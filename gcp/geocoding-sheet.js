!function(n){var e={};function t(l){if(e[l])return e[l].exports;var i=e[l]={i:l,l:!1,exports:{}};return n[l].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=n,t.c=e,t.d=function(n,e,l){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:l})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var l=Object.create(null);if(t.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)t.d(l,i,function(e){return n[e]}.bind(null,i));return l},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=149)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundingExtent", function() { return boundingExtent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buffer", function() { return buffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "closestSquaredDistanceXY", function() { return closestSquaredDistanceXY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsCoordinate", function() { return containsCoordinate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsExtent", function() { return containsExtent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "containsXY", function() { return containsXY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coordinateRelationship", function() { return coordinateRelationship; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEmpty", function() { return createEmpty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdate", function() { return createOrUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateEmpty", function() { return createOrUpdateEmpty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinate", function() { return createOrUpdateFromCoordinate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromCoordinates", function() { return createOrUpdateFromCoordinates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromFlatCoordinates", function() { return createOrUpdateFromFlatCoordinates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createOrUpdateFromRings", function() { return createOrUpdateFromRings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinate", function() { return extendCoordinate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendCoordinates", function() { return extendCoordinates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendFlatCoordinates", function() { return extendFlatCoordinates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendRings", function() { return extendRings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendXY", function() { return extendXY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEachCorner", function() { return forEachCorner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArea", function() { return getArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomLeft", function() { return getBottomLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBottomRight", function() { return getBottomRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCenter", function() { return getCenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCorner", function() { return getCorner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEnlargedArea", function() { return getEnlargedArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForViewAndSize", function() { return getForViewAndSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHeight", function() { return getHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersectionArea", function() { return getIntersectionArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIntersection", function() { return getIntersection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMargin", function() { return getMargin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSize", function() { return getSize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopLeft", function() { return getTopLeft; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopRight", function() { return getTopRight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWidth", function() { return getWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersects", function() { return intersects; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "returnOrUpdate", function() { return returnOrUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleFromCenter", function() { return scaleFromCenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersectsSegment", function() { return intersectsSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyTransform", function() { return applyTransform; });\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/* harmony import */ var _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);\n/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25);\n/**\n * @module ol/extent\n */\n\n\n\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\n\nfunction boundingExtent(coordinates) {\n  var extent = createEmpty();\n\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n\n  return extent;\n}\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent=} opt_extent Destination extent.\n * @private\n * @return {Extent} Extent.\n */\n\nfunction _boundingExtentXYs(xs, ys, opt_extent) {\n  var minX = Math.min.apply(null, xs);\n  var minY = Math.min.apply(null, ys);\n  var maxX = Math.max.apply(null, xs);\n  var maxY = Math.max.apply(null, ys);\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n}\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n * @api\n */\n\n\nfunction buffer(extent, value, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0] - value;\n    opt_extent[1] = extent[1] - value;\n    opt_extent[2] = extent[2] + value;\n    opt_extent[3] = extent[3] + value;\n    return opt_extent;\n  } else {\n    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];\n  }\n}\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} The clone.\n */\n\nfunction clone(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent.slice();\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\n\nfunction closestSquaredDistanceXY(extent, x, y) {\n  var dx, dy;\n\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n\n  return dx * dx + dy * dy;\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\n\nfunction containsCoordinate(extent, coordinate) {\n  return containsXY(extent, coordinate[0], coordinate[1]);\n}\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\n\nfunction containsExtent(extent1, extent2) {\n  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];\n}\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\n\nfunction containsXY(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.\n * @return {Relationship} The relationship (bitwise compare with\n *     import("./extent/Relationship.js").Relationship).\n */\n\nfunction coordinateRelationship(extent, coordinate) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var x = coordinate[0];\n  var y = coordinate[1];\n  var relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].UNKNOWN;\n\n  if (x < minX) {\n    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].RIGHT;\n  }\n\n  if (y < minY) {\n    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ABOVE;\n  }\n\n  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].UNKNOWN) {\n    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].INTERSECTING;\n  }\n\n  return relationship;\n}\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\n\nfunction createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent=} opt_extent Destination extent.\n * @return {Extent} Extent.\n */\n\nfunction createOrUpdate(minX, minY, maxX, maxY, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = minX;\n    opt_extent[1] = minY;\n    opt_extent[2] = maxX;\n    opt_extent[3] = maxY;\n    return opt_extent;\n  } else {\n    return [minX, minY, maxX, maxY];\n  }\n}\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\n\nfunction createOrUpdateEmpty(opt_extent) {\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);\n}\n/**\n * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\n\nfunction createOrUpdateFromCoordinate(coordinate, opt_extent) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  return createOrUpdate(x, y, x, y, opt_extent);\n}\n/**\n * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\n\nfunction createOrUpdateFromCoordinates(coordinates, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendCoordinates(extent, coordinates);\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\n\nfunction createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n/**\n * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\n\nfunction createOrUpdateFromRings(rings, opt_extent) {\n  var extent = createOrUpdateEmpty(opt_extent);\n  return extendRings(extent, rings);\n}\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\n\nfunction equals(extent1, extent2) {\n  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];\n}\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\n\nfunction extend(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n\n  return extent1;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.\n */\n\nfunction extendCoordinate(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\n\nfunction extendCoordinates(extent, coordinates) {\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\n\nfunction extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {\n  for (; offset < end; offset += stride) {\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\n\nfunction extendRings(extent, rings) {\n  for (var i = 0, ii = rings.length; i < ii; ++i) {\n    extendCoordinates(extent, rings[i]);\n  }\n\n  return extent;\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\n\nfunction extendXY(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n}\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(this:T, import("./coordinate.js").Coordinate): S} callback Callback.\n * @param {T=} opt_this Value to use as `this` when executing `callback`.\n * @return {S|boolean} Value.\n * @template S, T\n */\n\nfunction forEachCorner(extent, callback, opt_this) {\n  var val;\n  val = callback.call(opt_this, getBottomLeft(extent));\n\n  if (val) {\n    return val;\n  }\n\n  val = callback.call(opt_this, getBottomRight(extent));\n\n  if (val) {\n    return val;\n  }\n\n  val = callback.call(opt_this, getTopRight(extent));\n\n  if (val) {\n    return val;\n  }\n\n  val = callback.call(opt_this, getTopLeft(extent));\n\n  if (val) {\n    return val;\n  }\n\n  return false;\n}\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\n\nfunction getArea(extent) {\n  var area = 0;\n\n  if (!isEmpty(extent)) {\n    area = getWidth(extent) * getHeight(extent);\n  }\n\n  return area;\n}\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.\n * @api\n */\n\nfunction getBottomLeft(extent) {\n  return [extent[0], extent[1]];\n}\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.\n * @api\n */\n\nfunction getBottomRight(extent) {\n  return [extent[2], extent[1]];\n}\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import("./coordinate.js").Coordinate} Center.\n * @api\n */\n\nfunction getCenter(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import("./coordinate.js").Coordinate} Corner coordinate.\n */\n\nfunction getCorner(extent, corner) {\n  var coordinate;\n\n  if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].BOTTOM_LEFT) {\n    coordinate = getBottomLeft(extent);\n  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].BOTTOM_RIGHT) {\n    coordinate = getBottomRight(extent);\n  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].TOP_LEFT) {\n    coordinate = getTopLeft(extent);\n  } else if (corner === _extent_Corner_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].TOP_RIGHT) {\n    coordinate = getTopRight(extent);\n  } else {\n    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(false, 13); // Invalid corner\n  }\n\n  return coordinate;\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\n\nfunction getEnlargedArea(extent1, extent2) {\n  var minX = Math.min(extent1[0], extent2[0]);\n  var minY = Math.min(extent1[1], extent2[1]);\n  var maxX = Math.max(extent1[2], extent2[2]);\n  var maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\n/**\n * @param {import("./coordinate.js").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import("./size.js").Size} size Size.\n * @param {Extent=} opt_extent Destination extent.\n * @return {Extent} Extent.\n */\n\nfunction getForViewAndSize(center, resolution, rotation, size, opt_extent) {\n  var dx = resolution * size[0] / 2;\n  var dy = resolution * size[1] / 2;\n  var cosRotation = Math.cos(rotation);\n  var sinRotation = Math.sin(rotation);\n  var xCos = dx * cosRotation;\n  var xSin = dx * sinRotation;\n  var yCos = dy * cosRotation;\n  var ySin = dy * sinRotation;\n  var x = center[0];\n  var y = center[1];\n  var x0 = x - xCos + ySin;\n  var x1 = x - xCos - ySin;\n  var x2 = x + xCos - ySin;\n  var x3 = x + xCos + ySin;\n  var y0 = y - xSin - yCos;\n  var y1 = y - xSin + yCos;\n  var y2 = y + xSin + yCos;\n  var y3 = y + xSin - yCos;\n  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);\n}\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\n\nfunction getHeight(extent) {\n  return extent[3] - extent[1];\n}\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\n\nfunction getIntersectionArea(extent1, extent2) {\n  var intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent=} opt_extent Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\n\nfunction getIntersection(extent1, extent2, opt_extent) {\n  var intersection = opt_extent ? opt_extent : createEmpty();\n\n  if (intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n\n  return intersection;\n}\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\n\nfunction getMargin(extent) {\n  return getWidth(extent) + getHeight(extent);\n}\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import("./size.js").Size} The extent size.\n * @api\n */\n\nfunction getSize(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import("./coordinate.js").Coordinate} Top left coordinate.\n * @api\n */\n\nfunction getTopLeft(extent) {\n  return [extent[0], extent[3]];\n}\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import("./coordinate.js").Coordinate} Top right coordinate.\n * @api\n */\n\nfunction getTopRight(extent) {\n  return [extent[2], extent[3]];\n}\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\n\nfunction getWidth(extent) {\n  return extent[2] - extent[0];\n}\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\n\nfunction intersects(extent1, extent2) {\n  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];\n}\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\n\nfunction isEmpty(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n}\n/**\n * @param {Extent} extent Extent.\n * @param {Extent=} opt_extent Extent.\n * @return {Extent} Extent.\n */\n\nfunction returnOrUpdate(extent, opt_extent) {\n  if (opt_extent) {\n    opt_extent[0] = extent[0];\n    opt_extent[1] = extent[1];\n    opt_extent[2] = extent[2];\n    opt_extent[3] = extent[3];\n    return opt_extent;\n  } else {\n    return extent;\n  }\n}\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\n\nfunction scaleFromCenter(extent, value) {\n  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);\n  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n}\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.\n * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\n\nfunction intersectsSegment(extent, start, end) {\n  var intersects = false;\n  var startRel = coordinateRelationship(extent, start);\n  var endRel = coordinateRelationship(extent, end);\n\n  if (startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].INTERSECTING || endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].INTERSECTING) {\n    intersects = true;\n  } else {\n    var minX = extent[0];\n    var minY = extent[1];\n    var maxX = extent[2];\n    var maxY = extent[3];\n    var startX = start[0];\n    var startY = start[1];\n    var endX = end[0];\n    var endY = end[1];\n    var slope = (endY - startY) / (endX - startX);\n    var x, y;\n\n    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ABOVE) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ABOVE)) {\n      // potentially intersects top\n      x = endX - (endY - maxY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n\n    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].RIGHT) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].RIGHT)) {\n      // potentially intersects right\n      y = endY - (endX - maxX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n\n    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].BELOW) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].BELOW)) {\n      // potentially intersects bottom\n      x = endX - (endY - minY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n\n    if (!intersects && !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LEFT) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LEFT)) {\n      // potentially intersects left\n      y = endY - (endX - minX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n  }\n\n  return intersects;\n}\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import("./proj.js").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent=} opt_extent Destination extent.\n * @return {Extent} Extent.\n * @api\n */\n\nfunction applyTransform(extent, transformFn, opt_extent) {\n  var coordinates = [extent[0], extent[1], extent[0], extent[3], extent[2], extent[1], extent[2], extent[3]];\n  transformFn(coordinates, coordinates, 2);\n  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];\n  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];\n  return _boundingExtentXYs(xs, ys, opt_extent);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9zcmMvb2wvZXh0ZW50LmpzPzIyMTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2V4dGVudFxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCBDb3JuZXIgZnJvbSAnLi9leHRlbnQvQ29ybmVyLmpzJztcbmltcG9ydCBSZWxhdGlvbnNoaXAgZnJvbSAnLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcblxuXG4vKipcbiAqIEFuIGFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGFuIGV4dGVudDogYFttaW54LCBtaW55LCBtYXh4LCBtYXh5XWAuXG4gKiBAdHlwZWRlZiB7QXJyYXk8bnVtYmVyPn0gRXh0ZW50XG4gKiBAYXBpXG4gKi9cblxuLyoqXG4gKiBCdWlsZCBhbiBleHRlbnQgdGhhdCBpbmNsdWRlcyBhbGwgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICogQHJldHVybiB7RXh0ZW50fSBCb3VuZGluZyBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuZGluZ0V4dGVudChjb29yZGluYXRlcykge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSB4cyBYcy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0geXMgWXMuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5mdW5jdGlvbiBfYm91bmRpbmdFeHRlbnRYWXMoeHMsIHlzLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IG1pblggPSBNYXRoLm1pbi5hcHBseShudWxsLCB4cyk7XG4gIGNvbnN0IG1pblkgPSBNYXRoLm1pbi5hcHBseShudWxsLCB5cyk7XG4gIGNvbnN0IG1heFggPSBNYXRoLm1heC5hcHBseShudWxsLCB4cyk7XG4gIGNvbnN0IG1heFkgPSBNYXRoLm1heC5hcHBseShudWxsLCB5cyk7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIFJldHVybiBleHRlbnQgaW5jcmVhc2VkIGJ5IHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBhbW91bnQgYnkgd2hpY2ggdGhlIGV4dGVudCBzaG91bGQgYmUgYnVmZmVyZWQuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoZXh0ZW50LCB2YWx1ZSwgb3B0X2V4dGVudCkge1xuICBpZiAob3B0X2V4dGVudCkge1xuICAgIG9wdF9leHRlbnRbMF0gPSBleHRlbnRbMF0gLSB2YWx1ZTtcbiAgICBvcHRfZXh0ZW50WzFdID0gZXh0ZW50WzFdIC0gdmFsdWU7XG4gICAgb3B0X2V4dGVudFsyXSA9IGV4dGVudFsyXSArIHZhbHVlO1xuICAgIG9wdF9leHRlbnRbM10gPSBleHRlbnRbM10gKyB2YWx1ZTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW1xuICAgICAgZXh0ZW50WzBdIC0gdmFsdWUsXG4gICAgICBleHRlbnRbMV0gLSB2YWx1ZSxcbiAgICAgIGV4dGVudFsyXSArIHZhbHVlLFxuICAgICAgZXh0ZW50WzNdICsgdmFsdWVcbiAgICBdO1xuICB9XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYW4gZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50IHRvIGNsb25lLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gVGhlIGNsb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoZXh0ZW50LCBvcHRfZXh0ZW50KSB7XG4gIGlmIChvcHRfZXh0ZW50KSB7XG4gICAgb3B0X2V4dGVudFswXSA9IGV4dGVudFswXTtcbiAgICBvcHRfZXh0ZW50WzFdID0gZXh0ZW50WzFdO1xuICAgIG9wdF9leHRlbnRbMl0gPSBleHRlbnRbMl07XG4gICAgb3B0X2V4dGVudFszXSA9IGV4dGVudFszXTtcbiAgICByZXR1cm4gb3B0X2V4dGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXh0ZW50LnNsaWNlKCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IENsb3Nlc3Qgc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWShleHRlbnQsIHgsIHkpIHtcbiAgbGV0IGR4LCBkeTtcbiAgaWYgKHggPCBleHRlbnRbMF0pIHtcbiAgICBkeCA9IGV4dGVudFswXSAtIHg7XG4gIH0gZWxzZSBpZiAoZXh0ZW50WzJdIDwgeCkge1xuICAgIGR4ID0geCAtIGV4dGVudFsyXTtcbiAgfSBlbHNlIHtcbiAgICBkeCA9IDA7XG4gIH1cbiAgaWYgKHkgPCBleHRlbnRbMV0pIHtcbiAgICBkeSA9IGV4dGVudFsxXSAtIHk7XG4gIH0gZWxzZSBpZiAoZXh0ZW50WzNdIDwgeSkge1xuICAgIGR5ID0geSAtIGV4dGVudFszXTtcbiAgfSBlbHNlIHtcbiAgICBkeSA9IDA7XG4gIH1cbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBhc3NlZCBjb29yZGluYXRlIGlzIGNvbnRhaW5lZCBvciBvbiB0aGUgZWRnZSBvZiB0aGUgZXh0ZW50LlxuICpcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIGluIHRoZSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc0Nvb3JkaW5hdGUoZXh0ZW50LCBjb29yZGluYXRlKSB7XG4gIHJldHVybiBjb250YWluc1hZKGV4dGVudCwgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiBvbmUgZXh0ZW50IGNvbnRhaW5zIGFub3RoZXIuXG4gKlxuICogQW4gZXh0ZW50IGlzIGRlZW1lZCBjb250YWluZWQgaWYgaXQgbGllcyBjb21wbGV0ZWx5IHdpdGhpbiB0aGUgb3RoZXIgZXh0ZW50LFxuICogaW5jbHVkaW5nIGlmIHRoZXkgc2hhcmUgb25lIG9yIG1vcmUgZWRnZXMuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDEgRXh0ZW50IDEuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MiBFeHRlbnQgMi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWNvbmQgZXh0ZW50IGlzIGNvbnRhaW5lZCBieSBvciBvbiB0aGUgZWRnZSBvZiB0aGVcbiAqICAgICBmaXJzdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zRXh0ZW50KGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIGV4dGVudDFbMF0gPD0gZXh0ZW50MlswXSAmJiBleHRlbnQyWzJdIDw9IGV4dGVudDFbMl0gJiZcbiAgICAgIGV4dGVudDFbMV0gPD0gZXh0ZW50MlsxXSAmJiBleHRlbnQyWzNdIDw9IGV4dGVudDFbM107XG59XG5cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgaXMgY29udGFpbmVkIG9yIG9uIHRoZSBlZGdlIG9mIHRoZSBleHRlbnQuXG4gKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSBZIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgeCwgeSB2YWx1ZXMgYXJlIGNvbnRhaW5lZCBpbiB0aGUgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNYWShleHRlbnQsIHgsIHkpIHtcbiAgcmV0dXJuIGV4dGVudFswXSA8PSB4ICYmIHggPD0gZXh0ZW50WzJdICYmIGV4dGVudFsxXSA8PSB5ICYmIHkgPD0gZXh0ZW50WzNdO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBhIGNvb3JkaW5hdGUgYW5kIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtSZWxhdGlvbnNoaXB9IFRoZSByZWxhdGlvbnNoaXAgKGJpdHdpc2UgY29tcGFyZSB3aXRoXG4gKiAgICAgaW1wb3J0KFwiLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzXCIpLlJlbGF0aW9uc2hpcCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgY29vcmRpbmF0ZSkge1xuICBjb25zdCBtaW5YID0gZXh0ZW50WzBdO1xuICBjb25zdCBtaW5ZID0gZXh0ZW50WzFdO1xuICBjb25zdCBtYXhYID0gZXh0ZW50WzJdO1xuICBjb25zdCBtYXhZID0gZXh0ZW50WzNdO1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIGxldCByZWxhdGlvbnNoaXAgPSBSZWxhdGlvbnNoaXAuVU5LTk9XTjtcbiAgaWYgKHggPCBtaW5YKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkxFRlQ7XG4gIH0gZWxzZSBpZiAoeCA+IG1heFgpIHtcbiAgICByZWxhdGlvbnNoaXAgPSByZWxhdGlvbnNoaXAgfCBSZWxhdGlvbnNoaXAuUklHSFQ7XG4gIH1cbiAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkJFTE9XO1xuICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgcmVsYXRpb25zaGlwID0gcmVsYXRpb25zaGlwIHwgUmVsYXRpb25zaGlwLkFCT1ZFO1xuICB9XG4gIGlmIChyZWxhdGlvbnNoaXAgPT09IFJlbGF0aW9uc2hpcC5VTktOT1dOKSB7XG4gICAgcmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORztcbiAgfVxuICByZXR1cm4gcmVsYXRpb25zaGlwO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGVtcHR5IGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRW1wdHkgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRW1wdHkoKSB7XG4gIHJldHVybiBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXh0ZW50IG9yIHVwZGF0ZSB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblggTWluaW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFggTWF4aW11bSBYLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFkgTWF4aW11bSBZLlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IERlc3RpbmF0aW9uIGV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgb3B0X2V4dGVudCkge1xuICBpZiAob3B0X2V4dGVudCkge1xuICAgIG9wdF9leHRlbnRbMF0gPSBtaW5YO1xuICAgIG9wdF9leHRlbnRbMV0gPSBtaW5ZO1xuICAgIG9wdF9leHRlbnRbMl0gPSBtYXhYO1xuICAgIG9wdF9leHRlbnRbM10gPSBtYXhZO1xuICAgIHJldHVybiBvcHRfZXh0ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV07XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBlbXB0eSBleHRlbnQgb3IgbWFrZSB0aGUgcHJvdmlkZWQgb25lIGVtcHR5LlxuICogQHBhcmFtIHtFeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVFbXB0eShvcHRfZXh0ZW50KSB7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5LCBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUoY29vcmRpbmF0ZSwgb3B0X2V4dGVudCkge1xuICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgY29uc3QgeSA9IGNvb3JkaW5hdGVbMV07XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZSh4LCB5LCB4LCB5LCBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRDb29yZGluYXRlcyhleHRlbnQsIGNvb3JkaW5hdGVzKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IGV4dGVudCA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkob3B0X2V4dGVudCk7XG4gIHJldHVybiBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gcmluZ3MgUmluZ3MuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZUZyb21SaW5ncyhyaW5ncywgb3B0X2V4dGVudCkge1xuICBjb25zdCBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUVtcHR5KG9wdF9leHRlbnQpO1xuICByZXR1cm4gZXh0ZW5kUmluZ3MoZXh0ZW50LCByaW5ncyk7XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdHdvIGV4dGVudHMgYXJlIGVxdWl2YWxlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHR3byBleHRlbnRzIGFyZSBlcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIGV4dGVudDFbMF0gPT0gZXh0ZW50MlswXSAmJiBleHRlbnQxWzJdID09IGV4dGVudDJbMl0gJiZcbiAgICAgIGV4dGVudDFbMV0gPT0gZXh0ZW50MlsxXSAmJiBleHRlbnQxWzNdID09IGV4dGVudDJbM107XG59XG5cblxuLyoqXG4gKiBNb2RpZnkgYW4gZXh0ZW50IHRvIGluY2x1ZGUgYW5vdGhlciBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBUaGUgZXh0ZW50IHRvIGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgVGhlIGV4dGVudCB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGZpcnN0LlxuICogQHJldHVybiB7RXh0ZW50fSBBIHJlZmVyZW5jZSB0byB0aGUgZmlyc3QgKGV4dGVuZGVkKSBleHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoZXh0ZW50MSwgZXh0ZW50Mikge1xuICBpZiAoZXh0ZW50MlswXSA8IGV4dGVudDFbMF0pIHtcbiAgICBleHRlbnQxWzBdID0gZXh0ZW50MlswXTtcbiAgfVxuICBpZiAoZXh0ZW50MlsyXSA+IGV4dGVudDFbMl0pIHtcbiAgICBleHRlbnQxWzJdID0gZXh0ZW50MlsyXTtcbiAgfVxuICBpZiAoZXh0ZW50MlsxXSA8IGV4dGVudDFbMV0pIHtcbiAgICBleHRlbnQxWzFdID0gZXh0ZW50MlsxXTtcbiAgfVxuICBpZiAoZXh0ZW50MlszXSA+IGV4dGVudDFbM10pIHtcbiAgICBleHRlbnQxWzNdID0gZXh0ZW50MlszXTtcbiAgfVxuICByZXR1cm4gZXh0ZW50MTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGUpIHtcbiAgaWYgKGNvb3JkaW5hdGVbMF0gPCBleHRlbnRbMF0pIHtcbiAgICBleHRlbnRbMF0gPSBjb29yZGluYXRlWzBdO1xuICB9XG4gIGlmIChjb29yZGluYXRlWzBdID4gZXh0ZW50WzJdKSB7XG4gICAgZXh0ZW50WzJdID0gY29vcmRpbmF0ZVswXTtcbiAgfVxuICBpZiAoY29vcmRpbmF0ZVsxXSA8IGV4dGVudFsxXSkge1xuICAgIGV4dGVudFsxXSA9IGNvb3JkaW5hdGVbMV07XG4gIH1cbiAgaWYgKGNvb3JkaW5hdGVbMV0gPiBleHRlbnRbM10pIHtcbiAgICBleHRlbnRbM10gPSBjb29yZGluYXRlWzFdO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCBjb29yZGluYXRlcykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoZXh0ZW50LCBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGV4dGVuZFhZKGV4dGVudCwgZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSByaW5ncyBSaW5ncy5cbiAqIEByZXR1cm4ge0V4dGVudH0gRXh0ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kUmluZ3MoZXh0ZW50LCByaW5ncykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSByaW5ncy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZXh0ZW5kQ29vcmRpbmF0ZXMoZXh0ZW50LCByaW5nc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGV4dGVudDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRYWShleHRlbnQsIHgsIHkpIHtcbiAgZXh0ZW50WzBdID0gTWF0aC5taW4oZXh0ZW50WzBdLCB4KTtcbiAgZXh0ZW50WzFdID0gTWF0aC5taW4oZXh0ZW50WzFdLCB5KTtcbiAgZXh0ZW50WzJdID0gTWF0aC5tYXgoZXh0ZW50WzJdLCB4KTtcbiAgZXh0ZW50WzNdID0gTWF0aC5tYXgoZXh0ZW50WzNdLCB5KTtcbn1cblxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgYGNhbGxiYWNrYCBmb3IgZWFjaCBjb3JuZXIgb2YgdGhlIGV4dGVudC4gSWYgdGhlXG4gKiBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoYXQgdmFsdWVcbiAqIGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlQsIGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogU30gY2FsbGJhY2sgQ2FsbGJhY2suXG4gKiBAcGFyYW0ge1Q9fSBvcHRfdGhpcyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gKiBAcmV0dXJuIHtTfGJvb2xlYW59IFZhbHVlLlxuICogQHRlbXBsYXRlIFMsIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hDb3JuZXIoZXh0ZW50LCBjYWxsYmFjaywgb3B0X3RoaXMpIHtcbiAgbGV0IHZhbDtcbiAgdmFsID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgZ2V0Qm90dG9tTGVmdChleHRlbnQpKTtcbiAgaWYgKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdmFsID0gY2FsbGJhY2suY2FsbChvcHRfdGhpcywgZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KSk7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHZhbCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIGdldFRvcFJpZ2h0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB2YWwgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBnZXRUb3BMZWZ0KGV4dGVudCkpO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmVhKGV4dGVudCkge1xuICBsZXQgYXJlYSA9IDA7XG4gIGlmICghaXNFbXB0eShleHRlbnQpKSB7XG4gICAgYXJlYSA9IGdldFdpZHRoKGV4dGVudCkgKiBnZXRIZWlnaHQoZXh0ZW50KTtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgYm90dG9tIGxlZnQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBCb3R0b20gbGVmdCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90dG9tTGVmdChleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMF0sIGV4dGVudFsxXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGJvdHRvbSByaWdodCBjb29yZGluYXRlIG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEJvdHRvbSByaWdodCBjb29yZGluYXRlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzJdLCBleHRlbnRbMV1dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjZW50ZXIgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDZW50ZXIuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDZW50ZXIoZXh0ZW50KSB7XG4gIHJldHVybiBbKGV4dGVudFswXSArIGV4dGVudFsyXSkgLyAyLCAoZXh0ZW50WzFdICsgZXh0ZW50WzNdKSAvIDJdO1xufVxuXG5cbi8qKlxuICogR2V0IGEgY29ybmVyIGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIENvcm5lci5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb3JuZXIgY29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvcm5lcihleHRlbnQsIGNvcm5lcikge1xuICBsZXQgY29vcmRpbmF0ZTtcbiAgaWYgKGNvcm5lciA9PT0gQ29ybmVyLkJPVFRPTV9MRUZUKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldEJvdHRvbUxlZnQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09IENvcm5lci5CT1RUT01fUklHSFQpIHtcbiAgICBjb29yZGluYXRlID0gZ2V0Qm90dG9tUmlnaHQoZXh0ZW50KTtcbiAgfSBlbHNlIGlmIChjb3JuZXIgPT09IENvcm5lci5UT1BfTEVGVCkge1xuICAgIGNvb3JkaW5hdGUgPSBnZXRUb3BMZWZ0KGV4dGVudCk7XG4gIH0gZWxzZSBpZiAoY29ybmVyID09PSBDb3JuZXIuVE9QX1JJR0hUKSB7XG4gICAgY29vcmRpbmF0ZSA9IGdldFRvcFJpZ2h0KGV4dGVudCk7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAxMyk7IC8vIEludmFsaWQgY29ybmVyXG4gIH1cbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7bnVtYmVyfSBFbmxhcmdlZCBhcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5sYXJnZWRBcmVhKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgY29uc3QgbWluWCA9IE1hdGgubWluKGV4dGVudDFbMF0sIGV4dGVudDJbMF0pO1xuICBjb25zdCBtaW5ZID0gTWF0aC5taW4oZXh0ZW50MVsxXSwgZXh0ZW50MlsxXSk7XG4gIGNvbnN0IG1heFggPSBNYXRoLm1heChleHRlbnQxWzJdLCBleHRlbnQyWzJdKTtcbiAgY29uc3QgbWF4WSA9IE1hdGgubWF4KGV4dGVudDFbM10sIGV4dGVudDJbM10pO1xuICByZXR1cm4gKG1heFggLSBtaW5YKSAqIChtYXhZIC0gbWluWSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjZW50ZXIgQ2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBEZXN0aW5hdGlvbiBleHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZvclZpZXdBbmRTaXplKGNlbnRlciwgcmVzb2x1dGlvbiwgcm90YXRpb24sIHNpemUsIG9wdF9leHRlbnQpIHtcbiAgY29uc3QgZHggPSByZXNvbHV0aW9uICogc2l6ZVswXSAvIDI7XG4gIGNvbnN0IGR5ID0gcmVzb2x1dGlvbiAqIHNpemVbMV0gLyAyO1xuICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gIGNvbnN0IHhDb3MgPSBkeCAqIGNvc1JvdGF0aW9uO1xuICBjb25zdCB4U2luID0gZHggKiBzaW5Sb3RhdGlvbjtcbiAgY29uc3QgeUNvcyA9IGR5ICogY29zUm90YXRpb247XG4gIGNvbnN0IHlTaW4gPSBkeSAqIHNpblJvdGF0aW9uO1xuICBjb25zdCB4ID0gY2VudGVyWzBdO1xuICBjb25zdCB5ID0gY2VudGVyWzFdO1xuICBjb25zdCB4MCA9IHggLSB4Q29zICsgeVNpbjtcbiAgY29uc3QgeDEgPSB4IC0geENvcyAtIHlTaW47XG4gIGNvbnN0IHgyID0geCArIHhDb3MgLSB5U2luO1xuICBjb25zdCB4MyA9IHggKyB4Q29zICsgeVNpbjtcbiAgY29uc3QgeTAgPSB5IC0geFNpbiAtIHlDb3M7XG4gIGNvbnN0IHkxID0geSAtIHhTaW4gKyB5Q29zO1xuICBjb25zdCB5MiA9IHkgKyB4U2luICsgeUNvcztcbiAgY29uc3QgeTMgPSB5ICsgeFNpbiAtIHlDb3M7XG4gIHJldHVybiBjcmVhdGVPclVwZGF0ZShcbiAgICBNYXRoLm1pbih4MCwgeDEsIHgyLCB4MyksIE1hdGgubWluKHkwLCB5MSwgeTIsIHkzKSxcbiAgICBNYXRoLm1heCh4MCwgeDEsIHgyLCB4MyksIE1hdGgubWF4KHkwLCB5MSwgeTIsIHkzKSxcbiAgICBvcHRfZXh0ZW50KTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgaGVpZ2h0IG9mIGFuIGV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWlnaHQoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbM10gLSBleHRlbnRbMV07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudCAyLlxuICogQHJldHVybiB7bnVtYmVyfSBJbnRlcnNlY3Rpb24gYXJlYS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbkFyZWEoZXh0ZW50MSwgZXh0ZW50Mikge1xuICBjb25zdCBpbnRlcnNlY3Rpb24gPSBnZXRJbnRlcnNlY3Rpb24oZXh0ZW50MSwgZXh0ZW50Mik7XG4gIHJldHVybiBnZXRBcmVhKGludGVyc2VjdGlvbik7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gZXh0ZW50cy5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQxIEV4dGVudCAxLlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudDIgRXh0ZW50IDIuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgT3B0aW9uYWwgZXh0ZW50IHRvIHBvcHVsYXRlIHdpdGggaW50ZXJzZWN0aW9uLlxuICogQHJldHVybiB7RXh0ZW50fSBJbnRlcnNlY3RpbmcgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudDEsIGV4dGVudDIsIG9wdF9leHRlbnQpIHtcbiAgY29uc3QgaW50ZXJzZWN0aW9uID0gb3B0X2V4dGVudCA/IG9wdF9leHRlbnQgOiBjcmVhdGVFbXB0eSgpO1xuICBpZiAoaW50ZXJzZWN0cyhleHRlbnQxLCBleHRlbnQyKSkge1xuICAgIGlmIChleHRlbnQxWzBdID4gZXh0ZW50MlswXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzBdID0gZXh0ZW50MVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzBdID0gZXh0ZW50MlswXTtcbiAgICB9XG4gICAgaWYgKGV4dGVudDFbMV0gPiBleHRlbnQyWzFdKSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMV0gPSBleHRlbnQxWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3Rpb25bMV0gPSBleHRlbnQyWzFdO1xuICAgIH1cbiAgICBpZiAoZXh0ZW50MVsyXSA8IGV4dGVudDJbMl0pIHtcbiAgICAgIGludGVyc2VjdGlvblsyXSA9IGV4dGVudDFbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVyc2VjdGlvblsyXSA9IGV4dGVudDJbMl07XG4gICAgfVxuICAgIGlmIChleHRlbnQxWzNdIDwgZXh0ZW50MlszXSkge1xuICAgICAgaW50ZXJzZWN0aW9uWzNdID0gZXh0ZW50MVszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0aW9uWzNdID0gZXh0ZW50MlszXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlT3JVcGRhdGVFbXB0eShpbnRlcnNlY3Rpb24pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb247XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTWFyZ2luLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFyZ2luKGV4dGVudCkge1xuICByZXR1cm4gZ2V0V2lkdGgoZXh0ZW50KSArIGdldEhlaWdodChleHRlbnQpO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzaXplICh3aWR0aCwgaGVpZ2h0KSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gVGhlIGV4dGVudCBzaXplLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZShleHRlbnQpIHtcbiAgcmV0dXJuIFtleHRlbnRbMl0gLSBleHRlbnRbMF0sIGV4dGVudFszXSAtIGV4dGVudFsxXV07XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHRvcCBsZWZ0IGNvb3JkaW5hdGUgb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVG9wIGxlZnQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcExlZnQoZXh0ZW50KSB7XG4gIHJldHVybiBbZXh0ZW50WzBdLCBleHRlbnRbM11dO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSB0b3AgcmlnaHQgY29vcmRpbmF0ZSBvZiBhbiBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUb3AgcmlnaHQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcFJpZ2h0KGV4dGVudCkge1xuICByZXR1cm4gW2V4dGVudFsyXSwgZXh0ZW50WzNdXTtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgYW4gZXh0ZW50LlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2lkdGgoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMl0gLSBleHRlbnRbMF07XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgb25lIGV4dGVudCBpbnRlcnNlY3RzIGFub3RoZXIuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50MSBFeHRlbnQgMS5cbiAqIEBwYXJhbSB7RXh0ZW50fSBleHRlbnQyIEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gZXh0ZW50cyBpbnRlcnNlY3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzKGV4dGVudDEsIGV4dGVudDIpIHtcbiAgcmV0dXJuIGV4dGVudDFbMF0gPD0gZXh0ZW50MlsyXSAmJlxuICAgICAgZXh0ZW50MVsyXSA+PSBleHRlbnQyWzBdICYmXG4gICAgICBleHRlbnQxWzFdIDw9IGV4dGVudDJbM10gJiZcbiAgICAgIGV4dGVudDFbM10gPj0gZXh0ZW50MlsxXTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZSBpZiBhbiBleHRlbnQgaXMgZW1wdHkuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFsyXSA8IGV4dGVudFswXSB8fCBleHRlbnRbM10gPCBleHRlbnRbMV07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7RXh0ZW50PX0gb3B0X2V4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtFeHRlbnR9IEV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk9yVXBkYXRlKGV4dGVudCwgb3B0X2V4dGVudCkge1xuICBpZiAob3B0X2V4dGVudCkge1xuICAgIG9wdF9leHRlbnRbMF0gPSBleHRlbnRbMF07XG4gICAgb3B0X2V4dGVudFsxXSA9IGV4dGVudFsxXTtcbiAgICBvcHRfZXh0ZW50WzJdID0gZXh0ZW50WzJdO1xuICAgIG9wdF9leHRlbnRbM10gPSBleHRlbnRbM107XG4gICAgcmV0dXJuIG9wdF9leHRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4dGVudDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtFeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUZyb21DZW50ZXIoZXh0ZW50LCB2YWx1ZSkge1xuICBjb25zdCBkZWx0YVggPSAoKGV4dGVudFsyXSAtIGV4dGVudFswXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBjb25zdCBkZWx0YVkgPSAoKGV4dGVudFszXSAtIGV4dGVudFsxXSkgLyAyKSAqICh2YWx1ZSAtIDEpO1xuICBleHRlbnRbMF0gLT0gZGVsdGFYO1xuICBleHRlbnRbMl0gKz0gZGVsdGFYO1xuICBleHRlbnRbMV0gLT0gZGVsdGFZO1xuICBleHRlbnRbM10gKz0gZGVsdGFZO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBzZWdtZW50IGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzIGludGVyc2VjdHMgKGNyb3NzZXMsXG4gKiB0b3VjaGVzLCBvciBpcyBjb250YWluZWQgYnkpIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IFRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBzdGFydCBTZWdtZW50IHN0YXJ0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBlbmQgU2VnbWVudCBlbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzZWdtZW50IGludGVyc2VjdHMgdGhlIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgc3RhcnQsIGVuZCkge1xuICBsZXQgaW50ZXJzZWN0cyA9IGZhbHNlO1xuICBjb25zdCBzdGFydFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBzdGFydCk7XG4gIGNvbnN0IGVuZFJlbCA9IGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAoZXh0ZW50LCBlbmQpO1xuICBpZiAoc3RhcnRSZWwgPT09IFJlbGF0aW9uc2hpcC5JTlRFUlNFQ1RJTkcgfHxcbiAgICAgIGVuZFJlbCA9PT0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORykge1xuICAgIGludGVyc2VjdHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1pblggPSBleHRlbnRbMF07XG4gICAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgICBjb25zdCBtYXhYID0gZXh0ZW50WzJdO1xuICAgIGNvbnN0IG1heFkgPSBleHRlbnRbM107XG4gICAgY29uc3Qgc3RhcnRYID0gc3RhcnRbMF07XG4gICAgY29uc3Qgc3RhcnRZID0gc3RhcnRbMV07XG4gICAgY29uc3QgZW5kWCA9IGVuZFswXTtcbiAgICBjb25zdCBlbmRZID0gZW5kWzFdO1xuICAgIGNvbnN0IHNsb3BlID0gKGVuZFkgLSBzdGFydFkpIC8gKGVuZFggLSBzdGFydFgpO1xuICAgIGxldCB4LCB5O1xuICAgIGlmICghIShlbmRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpICYmXG4gICAgICAgICEoc3RhcnRSZWwgJiBSZWxhdGlvbnNoaXAuQUJPVkUpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIHRvcFxuICAgICAgeCA9IGVuZFggLSAoKGVuZFkgLSBtYXhZKSAvIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB4ID49IG1pblggJiYgeCA8PSBtYXhYO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLlJJR0hUKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLlJJR0hUKSkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgaW50ZXJzZWN0cyByaWdodFxuICAgICAgeSA9IGVuZFkgLSAoKGVuZFggLSBtYXhYKSAqIHNsb3BlKTtcbiAgICAgIGludGVyc2VjdHMgPSB5ID49IG1pblkgJiYgeSA8PSBtYXhZO1xuICAgIH1cbiAgICBpZiAoIWludGVyc2VjdHMgJiYgISEoZW5kUmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkJFTE9XKSkge1xuICAgICAgLy8gcG90ZW50aWFsbHkgaW50ZXJzZWN0cyBib3R0b21cbiAgICAgIHggPSBlbmRYIC0gKChlbmRZIC0gbWluWSkgLyBzbG9wZSk7XG4gICAgICBpbnRlcnNlY3RzID0geCA+PSBtaW5YICYmIHggPD0gbWF4WDtcbiAgICB9XG4gICAgaWYgKCFpbnRlcnNlY3RzICYmICEhKGVuZFJlbCAmIFJlbGF0aW9uc2hpcC5MRUZUKSAmJlxuICAgICAgICAhKHN0YXJ0UmVsICYgUmVsYXRpb25zaGlwLkxFRlQpKSB7XG4gICAgICAvLyBwb3RlbnRpYWxseSBpbnRlcnNlY3RzIGxlZnRcbiAgICAgIHkgPSBlbmRZIC0gKChlbmRYIC0gbWluWCkgKiBzbG9wZSk7XG4gICAgICBpbnRlcnNlY3RzID0geSA+PSBtaW5ZICYmIHkgPD0gbWF4WTtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4gaW50ZXJzZWN0cztcbn1cblxuXG4vKipcbiAqIEFwcGx5IGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHRvIHRoZSBleHRlbnQuXG4gKiBAcGFyYW0ge0V4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBDYWxsZWQgd2l0aCBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBleHRlbnQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0V4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LlxuICogQHJldHVybiB7RXh0ZW50fSBFeHRlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShleHRlbnQsIHRyYW5zZm9ybUZuLCBvcHRfZXh0ZW50KSB7XG4gIGNvbnN0IGNvb3JkaW5hdGVzID0gW1xuICAgIGV4dGVudFswXSwgZXh0ZW50WzFdLFxuICAgIGV4dGVudFswXSwgZXh0ZW50WzNdLFxuICAgIGV4dGVudFsyXSwgZXh0ZW50WzFdLFxuICAgIGV4dGVudFsyXSwgZXh0ZW50WzNdXG4gIF07XG4gIHRyYW5zZm9ybUZuKGNvb3JkaW5hdGVzLCBjb29yZGluYXRlcywgMik7XG4gIGNvbnN0IHhzID0gW2Nvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1syXSwgY29vcmRpbmF0ZXNbNF0sIGNvb3JkaW5hdGVzWzZdXTtcbiAgY29uc3QgeXMgPSBbY29vcmRpbmF0ZXNbMV0sIGNvb3JkaW5hdGVzWzNdLCBjb29yZGluYXRlc1s1XSwgY29vcmRpbmF0ZXNbN11dO1xuICByZXR1cm4gX2JvdW5kaW5nRXh0ZW50WFlzKHhzLCB5cywgb3B0X2V4dGVudCk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUVBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUlBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export bindListener */\n/* unused harmony export findListener */\n/* unused harmony export getListeners */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return listen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return listenOnce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return unlisten; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return unlistenByKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return unlistenAll; });\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/**\n * @module ol/events\n */\n\n/**\n * Key to use with {@link module:ol/Observable~Observable#unByKey}.\n * @typedef {Object} EventsKey\n * @property {Object} [bindTo]\n * @property {ListenerFunction} [boundListener]\n * @property {boolean} callOnce\n * @property {number} [deleteIndex]\n * @property {ListenerFunction} listener\n * @property {import("./events/Target.js").EventTargetLike} target\n * @property {string} type\n * @api\n */\n\n/**\n * Listener function. This function is called with an event object as argument.\n * When the function returns `false`, event propagation will stop.\n *\n * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction\n * @api\n */\n\n/**\n * @param {EventsKey} listenerObj Listener object.\n * @return {ListenerFunction} Bound listener.\n */\n\nfunction bindListener(listenerObj) {\n  var boundListener = function boundListener(evt) {\n    var listener = listenerObj.listener;\n    var bindTo = listenerObj.bindTo || listenerObj.target;\n\n    if (listenerObj.callOnce) {\n      unlistenByKey(listenerObj);\n    }\n\n    return listener.call(bindTo, evt);\n  };\n\n  listenerObj.boundListener = boundListener;\n  return boundListener;\n}\n/**\n * Finds the matching {@link module:ol/events~EventsKey} in the given listener\n * array.\n *\n * @param {!Array<!EventsKey>} listeners Array of listeners.\n * @param {!Function} listener The listener function.\n * @param {Object=} opt_this The `this` value inside the listener.\n * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching\n *     listener, for {@link module:ol/events~unlistenByKey}.\n * @return {EventsKey|undefined} The matching listener object.\n */\n\nfunction findListener(listeners, listener, opt_this, opt_setDeleteIndex) {\n  var listenerObj;\n\n  for (var i = 0, ii = listeners.length; i < ii; ++i) {\n    listenerObj = listeners[i];\n\n    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {\n      if (opt_setDeleteIndex) {\n        listenerObj.deleteIndex = i;\n      }\n\n      return listenerObj;\n    }\n  }\n\n  return undefined;\n}\n/**\n * @param {import("./events/Target.js").EventTargetLike} target Target.\n * @param {string} type Type.\n * @return {Array<EventsKey>|undefined} Listeners.\n */\n\nfunction getListeners(target, type) {\n  var listenerMap = getListenerMap(target);\n  return listenerMap ? listenerMap[type] : undefined;\n}\n/**\n * Get the lookup of listeners.\n * @param {Object} target Target.\n * @param {boolean=} opt_create If a map should be created if it doesn\'t exist.\n * @return {!Object<string, Array<EventsKey>>} Map of\n *     listeners by event type.\n */\n\nfunction getListenerMap(target, opt_create) {\n  var listenerMap = target.ol_lm;\n\n  if (!listenerMap && opt_create) {\n    listenerMap = target.ol_lm = {};\n  }\n\n  return listenerMap;\n}\n/**\n * Remove the listener map from a target.\n * @param {Object} target Target.\n */\n\n\nfunction removeListenerMap(target) {\n  delete target.ol_lm;\n}\n/**\n * Clean up all listener objects of the given type.  All properties on the\n * listener objects will be removed, and if no listeners remain in the listener\n * map, it will be removed from the target.\n * @param {import("./events/Target.js").EventTargetLike} target Target.\n * @param {string} type Type.\n */\n\n\nfunction removeListeners(target, type) {\n  var listeners = getListeners(target, type);\n\n  if (listeners) {\n    for (var i = 0, ii = listeners.length; i < ii; ++i) {\n      /** @type {import("./events/Target.js").default} */\n      target.removeEventListener(type, listeners[i].boundListener);\n      Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__[/* clear */ "b"])(listeners[i]);\n    }\n\n    listeners.length = 0;\n    var listenerMap = getListenerMap(target);\n\n    if (listenerMap) {\n      delete listenerMap[type];\n\n      if (Object.keys(listenerMap).length === 0) {\n        removeListenerMap(target);\n      }\n    }\n  }\n}\n/**\n * Registers an event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * This function efficiently binds a `listener` to a `this` object, and returns\n * a key for use with {@link module:ol/events~unlistenByKey}.\n *\n * @param {import("./events/Target.js").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @param {boolean=} opt_once If true, add the listener as one-off listener.\n * @return {EventsKey} Unique key for the listener.\n */\n\n\nfunction listen(target, type, listener, opt_this, opt_once) {\n  var listenerMap = getListenerMap(target, true);\n  var listeners = listenerMap[type];\n\n  if (!listeners) {\n    listeners = listenerMap[type] = [];\n  }\n\n  var listenerObj = findListener(listeners, listener, opt_this, false);\n\n  if (listenerObj) {\n    if (!opt_once) {\n      // Turn one-off listener into a permanent one.\n      listenerObj.callOnce = false;\n    }\n  } else {\n    listenerObj =\n    /** @type {EventsKey} */\n    {\n      bindTo: opt_this,\n      callOnce: !!opt_once,\n      listener: listener,\n      target: target,\n      type: type\n    };\n    /** @type {import("./events/Target.js").default} */\n\n    target.addEventListener(type, bindListener(listenerObj));\n    listeners.push(listenerObj);\n  }\n\n  return listenerObj;\n}\n/**\n * Registers a one-off event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * This function efficiently binds a `listener` as self-unregistering listener\n * to a `this` object, and returns a key for use with\n * {@link module:ol/events~unlistenByKey} in case the listener needs to be\n * unregistered before it is called.\n *\n * When {@link module:ol/events~listen} is called with the same arguments after this\n * function, the self-unregistering listener will be turned into a permanent\n * listener.\n *\n * @param {import("./events/Target.js").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n * @return {EventsKey} Key for unlistenByKey.\n */\n\nfunction listenOnce(target, type, listener, opt_this) {\n  return listen(target, type, listener, opt_this, true);\n}\n/**\n * Unregisters an event listener on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * To return a listener, this function needs to be called with the exact same\n * arguments that were used for a previous {@link module:ol/events~listen} call.\n *\n * @param {import("./events/Target.js").EventTargetLike} target Event target.\n * @param {string} type Event type.\n * @param {ListenerFunction} listener Listener.\n * @param {Object=} opt_this Object referenced by the `this` keyword in the\n *     listener. Default is the `target`.\n */\n\nfunction unlisten(target, type, listener, opt_this) {\n  var listeners = getListeners(target, type);\n\n  if (listeners) {\n    var listenerObj = findListener(listeners, listener, opt_this, true);\n\n    if (listenerObj) {\n      unlistenByKey(listenerObj);\n    }\n  }\n}\n/**\n * Unregisters event listeners on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * The argument passed to this function is the key returned from\n * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.\n *\n * @param {EventsKey} key The key.\n */\n\nfunction unlistenByKey(key) {\n  if (key && key.target) {\n    /** @type {import("./events/Target.js").default} */\n    key.target.removeEventListener(key.type, key.boundListener);\n    var listeners = getListeners(key.target, key.type);\n\n    if (listeners) {\n      var i = \'deleteIndex\' in key ? key.deleteIndex : listeners.indexOf(key);\n\n      if (i !== -1) {\n        listeners.splice(i, 1);\n      }\n\n      if (listeners.length === 0) {\n        removeListeners(key.target, key.type);\n      }\n    }\n\n    Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__[/* clear */ "b"])(key);\n  }\n}\n/**\n * Unregisters all event listeners on an event target. Inspired by\n * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html\n *\n * @param {import("./events/Target.js").EventTargetLike} target Target.\n */\n\nfunction unlistenAll(target) {\n  var listenerMap = getListenerMap(target);\n\n  if (listenerMap) {\n    for (var type in listenerMap) {\n      removeListeners(target, type);\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9zcmMvb2wvZXZlbnRzLmpzPzZhMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2V2ZW50c1xuICovXG5pbXBvcnQge2NsZWFyfSBmcm9tICcuL29iai5qcyc7XG5cblxuLyoqXG4gKiBLZXkgdG8gdXNlIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlfk9ic2VydmFibGUjdW5CeUtleX0uXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFdmVudHNLZXlcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYmluZFRvXVxuICogQHByb3BlcnR5IHtMaXN0ZW5lckZ1bmN0aW9ufSBbYm91bmRMaXN0ZW5lcl1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY2FsbE9uY2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVsZXRlSW5kZXhdXG4gKiBAcHJvcGVydHkge0xpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGVcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogTGlzdGVuZXIgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYW4gZXZlbnQgb2JqZWN0IGFzIGFyZ3VtZW50LlxuICogV2hlbiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLCBldmVudCBwcm9wYWdhdGlvbiB3aWxsIHN0b3AuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChFdmVudHxpbXBvcnQoXCIuL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0KSk6ICh2b2lkfGJvb2xlYW4pfSBMaXN0ZW5lckZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRzS2V5fSBsaXN0ZW5lck9iaiBMaXN0ZW5lciBvYmplY3QuXG4gKiBAcmV0dXJuIHtMaXN0ZW5lckZ1bmN0aW9ufSBCb3VuZCBsaXN0ZW5lci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRMaXN0ZW5lcihsaXN0ZW5lck9iaikge1xuICBjb25zdCBib3VuZExpc3RlbmVyID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgY29uc3QgbGlzdGVuZXIgPSBsaXN0ZW5lck9iai5saXN0ZW5lcjtcbiAgICBjb25zdCBiaW5kVG8gPSBsaXN0ZW5lck9iai5iaW5kVG8gfHwgbGlzdGVuZXJPYmoudGFyZ2V0O1xuICAgIGlmIChsaXN0ZW5lck9iai5jYWxsT25jZSkge1xuICAgICAgdW5saXN0ZW5CeUtleShsaXN0ZW5lck9iaik7XG4gICAgfVxuICAgIHJldHVybiBsaXN0ZW5lci5jYWxsKGJpbmRUbywgZXZ0KTtcbiAgfTtcbiAgbGlzdGVuZXJPYmouYm91bmRMaXN0ZW5lciA9IGJvdW5kTGlzdGVuZXI7XG4gIHJldHVybiBib3VuZExpc3RlbmVyO1xufVxuXG5cbi8qKlxuICogRmluZHMgdGhlIG1hdGNoaW5nIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfkV2ZW50c0tleX0gaW4gdGhlIGdpdmVuIGxpc3RlbmVyXG4gKiBhcnJheS5cbiAqXG4gKiBAcGFyYW0geyFBcnJheTwhRXZlbnRzS2V5Pn0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF90aGlzIFRoZSBgdGhpc2AgdmFsdWUgaW5zaWRlIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zZXREZWxldGVJbmRleCBTZXQgdGhlIGRlbGV0ZUluZGV4IG9uIHRoZSBtYXRjaGluZ1xuICogICAgIGxpc3RlbmVyLCBmb3Ige0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+dW5saXN0ZW5CeUtleX0uXG4gKiBAcmV0dXJuIHtFdmVudHNLZXl8dW5kZWZpbmVkfSBUaGUgbWF0Y2hpbmcgbGlzdGVuZXIgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExpc3RlbmVyKGxpc3RlbmVycywgbGlzdGVuZXIsIG9wdF90aGlzLCBvcHRfc2V0RGVsZXRlSW5kZXgpIHtcbiAgbGV0IGxpc3RlbmVyT2JqO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGxpc3RlbmVyT2JqID0gbGlzdGVuZXJzW2ldO1xuICAgIGlmIChsaXN0ZW5lck9iai5saXN0ZW5lciA9PT0gbGlzdGVuZXIgJiZcbiAgICAgICAgbGlzdGVuZXJPYmouYmluZFRvID09PSBvcHRfdGhpcykge1xuICAgICAgaWYgKG9wdF9zZXREZWxldGVJbmRleCkge1xuICAgICAgICBsaXN0ZW5lck9iai5kZWxldGVJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXJPYmo7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICogQHJldHVybiB7QXJyYXk8RXZlbnRzS2V5Pnx1bmRlZmluZWR9IExpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExpc3RlbmVycyh0YXJnZXQsIHR5cGUpIHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSBnZXRMaXN0ZW5lck1hcCh0YXJnZXQpO1xuICByZXR1cm4gbGlzdGVuZXJNYXAgPyBsaXN0ZW5lck1hcFt0eXBlXSA6IHVuZGVmaW5lZDtcbn1cblxuXG4vKipcbiAqIEdldCB0aGUgbG9va3VwIG9mIGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0LlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2NyZWF0ZSBJZiBhIG1hcCBzaG91bGQgYmUgY3JlYXRlZCBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsIEFycmF5PEV2ZW50c0tleT4+fSBNYXAgb2ZcbiAqICAgICBsaXN0ZW5lcnMgYnkgZXZlbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXJNYXAodGFyZ2V0LCBvcHRfY3JlYXRlKSB7XG4gIGxldCBsaXN0ZW5lck1hcCA9IHRhcmdldC5vbF9sbTtcbiAgaWYgKCFsaXN0ZW5lck1hcCAmJiBvcHRfY3JlYXRlKSB7XG4gICAgbGlzdGVuZXJNYXAgPSB0YXJnZXQub2xfbG0gPSB7fTtcbiAgfVxuICByZXR1cm4gbGlzdGVuZXJNYXA7XG59XG5cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVyIG1hcCBmcm9tIGEgdGFyZ2V0LlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyTWFwKHRhcmdldCkge1xuICBkZWxldGUgdGFyZ2V0Lm9sX2xtO1xufVxuXG5cbi8qKlxuICogQ2xlYW4gdXAgYWxsIGxpc3RlbmVyIG9iamVjdHMgb2YgdGhlIGdpdmVuIHR5cGUuICBBbGwgcHJvcGVydGllcyBvbiB0aGVcbiAqIGxpc3RlbmVyIG9iamVjdHMgd2lsbCBiZSByZW1vdmVkLCBhbmQgaWYgbm8gbGlzdGVuZXJzIHJlbWFpbiBpbiB0aGUgbGlzdGVuZXJcbiAqIG1hcCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIHRhcmdldC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyh0YXJnZXQsIHR5cGUpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gZ2V0TGlzdGVuZXJzKHRhcmdldCwgdHlwZSk7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuZGVmYXVsdH0gKi8gKHRhcmdldCkuXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldLmJvdW5kTGlzdGVuZXIpO1xuICAgICAgY2xlYXIobGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmxlbmd0aCA9IDA7XG4gICAgY29uc3QgbGlzdGVuZXJNYXAgPSBnZXRMaXN0ZW5lck1hcCh0YXJnZXQpO1xuICAgIGlmIChsaXN0ZW5lck1hcCkge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyTWFwW3R5cGVdO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGxpc3RlbmVyTWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJNYXAodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGVmZmljaWVudGx5IGJpbmRzIGEgYGxpc3RlbmVyYCB0byBhIGB0aGlzYCBvYmplY3QsIGFuZCByZXR1cm5zXG4gKiBhIGtleSBmb3IgdXNlIHdpdGgge0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+dW5saXN0ZW5CeUtleX0uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF90aGlzIE9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBgdGhpc2Aga2V5d29yZCBpbiB0aGVcbiAqICAgICBsaXN0ZW5lci4gRGVmYXVsdCBpcyB0aGUgYHRhcmdldGAuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfb25jZSBJZiB0cnVlLCBhZGQgdGhlIGxpc3RlbmVyIGFzIG9uZS1vZmYgbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHtFdmVudHNLZXl9IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRfdGhpcywgb3B0X29uY2UpIHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSBnZXRMaXN0ZW5lck1hcCh0YXJnZXQsIHRydWUpO1xuICBsZXQgbGlzdGVuZXJzID0gbGlzdGVuZXJNYXBbdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgbGlzdGVuZXJzID0gbGlzdGVuZXJNYXBbdHlwZV0gPSBbXTtcbiAgfVxuICBsZXQgbGlzdGVuZXJPYmogPSBmaW5kTGlzdGVuZXIobGlzdGVuZXJzLCBsaXN0ZW5lciwgb3B0X3RoaXMsIGZhbHNlKTtcbiAgaWYgKGxpc3RlbmVyT2JqKSB7XG4gICAgaWYgKCFvcHRfb25jZSkge1xuICAgICAgLy8gVHVybiBvbmUtb2ZmIGxpc3RlbmVyIGludG8gYSBwZXJtYW5lbnQgb25lLlxuICAgICAgbGlzdGVuZXJPYmouY2FsbE9uY2UgPSBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXJPYmogPSAvKiogQHR5cGUge0V2ZW50c0tleX0gKi8gKHtcbiAgICAgIGJpbmRUbzogb3B0X3RoaXMsXG4gICAgICBjYWxsT25jZTogISFvcHRfb25jZSxcbiAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgdHlwZTogdHlwZVxuICAgIH0pO1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLmRlZmF1bHR9ICovICh0YXJnZXQpLlxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kTGlzdGVuZXIobGlzdGVuZXJPYmopKTtcbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lck9iaik7XG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJPYmo7XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBvbmUtb2ZmIGV2ZW50IGxpc3RlbmVyIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZWZmaWNpZW50bHkgYmluZHMgYSBgbGlzdGVuZXJgIGFzIHNlbGYtdW5yZWdpc3RlcmluZyBsaXN0ZW5lclxuICogdG8gYSBgdGhpc2Agb2JqZWN0LCBhbmQgcmV0dXJucyBhIGtleSBmb3IgdXNlIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfnVubGlzdGVuQnlLZXl9IGluIGNhc2UgdGhlIGxpc3RlbmVyIG5lZWRzIHRvIGJlXG4gKiB1bnJlZ2lzdGVyZWQgYmVmb3JlIGl0IGlzIGNhbGxlZC5cbiAqXG4gKiBXaGVuIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFmdGVyIHRoaXNcbiAqIGZ1bmN0aW9uLCB0aGUgc2VsZi11bnJlZ2lzdGVyaW5nIGxpc3RlbmVyIHdpbGwgYmUgdHVybmVkIGludG8gYSBwZXJtYW5lbnRcbiAqIGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvVGFyZ2V0LmpzXCIpLkV2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IEV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge0xpc3RlbmVyRnVuY3Rpb259IGxpc3RlbmVyIExpc3RlbmVyLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfdGhpcyBPYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgYHRoaXNgIGtleXdvcmQgaW4gdGhlXG4gKiAgICAgbGlzdGVuZXIuIERlZmF1bHQgaXMgdGhlIGB0YXJnZXRgLlxuICogQHJldHVybiB7RXZlbnRzS2V5fSBLZXkgZm9yIHVubGlzdGVuQnlLZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5PbmNlKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIG9wdF90aGlzKSB7XG4gIHJldHVybiBsaXN0ZW4odGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0X3RoaXMsIHRydWUpO1xufVxuXG5cbi8qKlxuICogVW5yZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gYW4gZXZlbnQgdGFyZ2V0LiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL2Nsb3N1cmUtbGlicmFyeS9hcGkvc291cmNlL2Nsb3N1cmUvZ29vZy9ldmVudHMvZXZlbnRzLmpzLnNyYy5odG1sXG4gKlxuICogVG8gcmV0dXJuIGEgbGlzdGVuZXIsIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIGV4YWN0IHNhbWVcbiAqIGFyZ3VtZW50cyB0aGF0IHdlcmUgdXNlZCBmb3IgYSBwcmV2aW91cyB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50c35saXN0ZW59IGNhbGwuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuRXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgRXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7TGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF90aGlzIE9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBgdGhpc2Aga2V5d29yZCBpbiB0aGVcbiAqICAgICBsaXN0ZW5lci4gRGVmYXVsdCBpcyB0aGUgYHRhcmdldGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3Rlbih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBvcHRfdGhpcykge1xuICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlKTtcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIGNvbnN0IGxpc3RlbmVyT2JqID0gZmluZExpc3RlbmVyKGxpc3RlbmVycywgbGlzdGVuZXIsIG9wdF90aGlzLCB0cnVlKTtcbiAgICBpZiAobGlzdGVuZXJPYmopIHtcbiAgICAgIHVubGlzdGVuQnlLZXkobGlzdGVuZXJPYmopO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogVW5yZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGV2ZW50IHRhcmdldC4gSW5zcGlyZWQgYnlcbiAqIGh0dHBzOi8vZ29vZ2xlLmdpdGh1Yi5pby9jbG9zdXJlLWxpYnJhcnkvYXBpL3NvdXJjZS9jbG9zdXJlL2dvb2cvZXZlbnRzL2V2ZW50cy5qcy5zcmMuaHRtbFxuICpcbiAqIFRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBpcyB0aGUga2V5IHJldHVybmVkIGZyb21cbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzfmxpc3Rlbn0gb3Ige0BsaW5rIG1vZHVsZTpvbC9ldmVudHN+bGlzdGVuT25jZX0uXG4gKlxuICogQHBhcmFtIHtFdmVudHNLZXl9IGtleSBUaGUga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5CeUtleShrZXkpIHtcbiAgaWYgKGtleSAmJiBrZXkudGFyZ2V0KSB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2V2ZW50cy9UYXJnZXQuanNcIikuZGVmYXVsdH0gKi8gKGtleS50YXJnZXQpLlxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihrZXkudHlwZSwga2V5LmJvdW5kTGlzdGVuZXIpO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IGdldExpc3RlbmVycyhrZXkudGFyZ2V0LCBrZXkudHlwZSk7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgY29uc3QgaSA9ICdkZWxldGVJbmRleCcgaW4ga2V5ID8ga2V5LmRlbGV0ZUluZGV4IDogbGlzdGVuZXJzLmluZGV4T2Yoa2V5KTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKGtleS50YXJnZXQsIGtleS50eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoa2V5KTtcbiAgfVxufVxuXG5cbi8qKlxuICogVW5yZWdpc3RlcnMgYWxsIGV2ZW50IGxpc3RlbmVycyBvbiBhbiBldmVudCB0YXJnZXQuIEluc3BpcmVkIGJ5XG4gKiBodHRwczovL2dvb2dsZS5naXRodWIuaW8vY2xvc3VyZS1saWJyYXJ5L2FwaS9zb3VyY2UvY2xvc3VyZS9nb29nL2V2ZW50cy9ldmVudHMuanMuc3JjLmh0bWxcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXZlbnRzL1RhcmdldC5qc1wiKS5FdmVudFRhcmdldExpa2V9IHRhcmdldCBUYXJnZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpc3RlbkFsbCh0YXJnZXQpIHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSBnZXRMaXN0ZW5lck1hcCh0YXJnZXQpO1xuICBpZiAobGlzdGVuZXJNYXApIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gbGlzdGVuZXJNYXApIHtcbiAgICAgIHJlbW92ZUxpc3RlbmVycyh0YXJnZXQsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOzs7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return _abstract; });\n/* unused harmony export inherits */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return getUid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return VERSION; });\n/**\n * @module ol/util\n */\n\n/**\n * @return {?} Any return.\n */\nfunction _abstract() {\n  return (\n    /** @type {?} */\n    function () {\n      throw new Error('Unimplemented abstract method.');\n    }()\n  );\n}\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n *\n *     function ParentClass(a, b) { }\n *     ParentClass.prototype.foo = function(a) { }\n *\n *     function ChildClass(a, b, c) {\n *       // Call parent constructor\n *       ParentClass.call(this, a, b);\n *     }\n *     inherits(ChildClass, ParentClass);\n *\n *     var child = new ChildClass('a', 'b', 'see');\n *     child.foo(); // This works.\n *\n * @param {!Function} childCtor Child constructor.\n * @param {!Function} parentCtor Parent constructor.\n * @function module:ol.inherits\n * @deprecated\n * @api\n */\n\n\n\nfunction inherits(childCtor, parentCtor) {\n  childCtor.prototype = Object.create(parentCtor.prototype);\n  childCtor.prototype.constructor = childCtor;\n}\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\n\nvar uidCounter_ = 0;\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @function module:ol.getUid\n * @api\n */\n\nfunction getUid(obj) {\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n/**\n * OpenLayers version.\n * @type {string}\n */\n\nvar VERSION = '5.3.3';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9zcmMvb2wvdXRpbC5qcz8wMWY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC91dGlsXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHs/fSBBbnkgcmV0dXJuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHJldHVybiAvKiogQHR5cGUgez99ICovICgoZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZC4nKTtcbiAgfSkoKSk7XG59XG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgICBmdW5jdGlvbiBQYXJlbnRDbGFzcyhhLCBiKSB7IH1cbiAqICAgICBQYXJlbnRDbGFzcy5wcm90b3R5cGUuZm9vID0gZnVuY3Rpb24oYSkgeyB9XG4gKlxuICogICAgIGZ1bmN0aW9uIENoaWxkQ2xhc3MoYSwgYiwgYykge1xuICogICAgICAgLy8gQ2FsbCBwYXJlbnQgY29uc3RydWN0b3JcbiAqICAgICAgIFBhcmVudENsYXNzLmNhbGwodGhpcywgYSwgYik7XG4gKiAgICAgfVxuICogICAgIGluaGVyaXRzKENoaWxkQ2xhc3MsIFBhcmVudENsYXNzKTtcbiAqXG4gKiAgICAgdmFyIGNoaWxkID0gbmV3IENoaWxkQ2xhc3MoJ2EnLCAnYicsICdzZWUnKTtcbiAqICAgICBjaGlsZC5mb28oKTsgLy8gVGhpcyB3b3Jrcy5cbiAqXG4gKiBAcGFyYW0geyFGdW5jdGlvbn0gY2hpbGRDdG9yIENoaWxkIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHshRnVuY3Rpb259IHBhcmVudEN0b3IgUGFyZW50IGNvbnN0cnVjdG9yLlxuICogQGZ1bmN0aW9uIG1vZHVsZTpvbC5pbmhlcml0c1xuICogQGRlcHJlY2F0ZWRcbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaGVyaXRzKGNoaWxkQ3RvciwgcGFyZW50Q3Rvcikge1xuICBjaGlsZEN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRDdG9yLnByb3RvdHlwZSk7XG4gIGNoaWxkQ3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZEN0b3I7XG59XG5cbi8qKlxuICogQ291bnRlciBmb3IgZ2V0VWlkLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCB1aWRDb3VudGVyXyA9IDA7XG5cbi8qKlxuICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAqIHdpdGggdGhlIHNhbWUgb2JqZWN0IGFzIGEgcGFyYW1ldGVyIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuIFVuaXF1ZSBJRHMgYXJlIGdlbmVyYXRlZFxuICogYXMgYSBzdHJpY3RseSBpbmNyZWFzaW5nIHNlcXVlbmNlLiBBZGFwdGVkIGZyb20gZ29vZy5nZXRVaWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdW5pcXVlIElEIGZvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIG9iamVjdC5cbiAqIEBmdW5jdGlvbiBtb2R1bGU6b2wuZ2V0VWlkXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaWQob2JqKSB7XG4gIHJldHVybiBvYmoub2xfdWlkIHx8IChvYmoub2xfdWlkID0gU3RyaW5nKCsrdWlkQ291bnRlcl8pKTtcbn1cblxuLyoqXG4gKiBPcGVuTGF5ZXJzIHZlcnNpb24uXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9ICdsYXRlc3QnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTs7Ozs7O0FBTUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/geom/GeometryType\n */\n\n/**\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, `'Circle'`.\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  LINEAR_RING: 'LinearRing',\n  POLYGON: 'Polygon',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon',\n  GEOMETRY_COLLECTION: 'GeometryCollection',\n  CIRCLE: 'Circle'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvZ2VvbS9HZW9tZXRyeVR5cGUuanM/MjZmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9HZW9tZXRyeVR5cGVcbiAqL1xuXG4vKipcbiAqIFRoZSBnZW9tZXRyeSB0eXBlLiBPbmUgb2YgYCdQb2ludCdgLCBgJ0xpbmVTdHJpbmcnYCwgYCdMaW5lYXJSaW5nJ2AsXG4gKiBgJ1BvbHlnb24nYCwgYCdNdWx0aVBvaW50J2AsIGAnTXVsdGlMaW5lU3RyaW5nJ2AsIGAnTXVsdGlQb2x5Z29uJ2AsXG4gKiBgJ0dlb21ldHJ5Q29sbGVjdGlvbidgLCBgJ0NpcmNsZSdgLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQT0lOVDogJ1BvaW50JyxcbiAgTElORV9TVFJJTkc6ICdMaW5lU3RyaW5nJyxcbiAgTElORUFSX1JJTkc6ICdMaW5lYXJSaW5nJyxcbiAgUE9MWUdPTjogJ1BvbHlnb24nLFxuICBNVUxUSV9QT0lOVDogJ011bHRpUG9pbnQnLFxuICBNVUxUSV9MSU5FX1NUUklORzogJ011bHRpTGluZVN0cmluZycsXG4gIE1VTFRJX1BPTFlHT046ICdNdWx0aVBvbHlnb24nLFxuICBHRU9NRVRSWV9DT0xMRUNUSU9OOiAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcbiAgQ0lSQ0xFOiAnQ2lyY2xlJ1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return defaultFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return defaultFillStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return defaultLineCap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return defaultLineDash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return defaultLineDashOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return defaultLineJoin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return defaultMiterLimit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return defaultStrokeStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return defaultTextAlign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return defaultTextBaseline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return defaultPadding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return defaultLineWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return labelCache; });\n/* unused harmony export checkedFonts */\n/* unused harmony export textHeights */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return checkFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return measureTextHeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return measureTextWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return rotateAtOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return resetTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return drawImage; });\n/* harmony import */ var _css_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);\n/* harmony import */ var _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90);\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);\n/**\n * @module ol/render/canvas\n */\n\n\n\n\n\n/**\n * @typedef {Object} FillState\n * @property {import("../colorlike.js").ColorLike} fillStyle\n */\n\n/**\n * @typedef {Object} FillStrokeState\n * @property {import("../colorlike.js").ColorLike} [currentFillStyle]\n * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]\n * @property {string} [currentLineCap]\n * @property {Array<number>} currentLineDash\n * @property {number} [currentLineDashOffset]\n * @property {string} [currentLineJoin]\n * @property {number} [currentLineWidth]\n * @property {number} [currentMiterLimit]\n * @property {number} [lastStroke]\n * @property {import("../colorlike.js").ColorLike} [fillStyle]\n * @property {import("../colorlike.js").ColorLike} [strokeStyle]\n * @property {string} [lineCap]\n * @property {Array<number>} lineDash\n * @property {number} [lineDashOffset]\n * @property {string} [lineJoin]\n * @property {number} [lineWidth]\n * @property {number} [miterLimit]\n */\n\n/**\n * @typedef {Object} StrokeState\n * @property {string} lineCap\n * @property {Array<number>} lineDash\n * @property {number} lineDashOffset\n * @property {string} lineJoin\n * @property {number} lineWidth\n * @property {number} miterLimit\n * @property {import("../colorlike.js").ColorLike} strokeStyle\n */\n\n/**\n * @typedef {Object} TextState\n * @property {string} font\n * @property {string} [textAlign]\n * @property {string} textBaseline\n * @property {string} [placement]\n * @property {number} [maxAngle]\n * @property {boolean} [overflow]\n * @property {import("../style/Fill.js").default} [backgroundFill]\n * @property {import("../style/Stroke.js").default} [backgroundStroke]\n * @property {number} [scale]\n * @property {Array<number>} [padding]\n */\n\n/**\n * Container for decluttered replay instructions that need to be rendered or\n * omitted together, i.e. when styles render both an image and text, or for the\n * characters that form text along lines. The basic elements of this array are\n * `[minX, minY, maxX, maxY, count]`, where the first four entries are the\n * rendered extent of the group in pixel space. `count` is the number of styles\n * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.\n * In addition to these four elements, declutter instruction arrays (i.e. the\n * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.\n * @typedef {Array<*>} DeclutterGroup\n */\n\n/**\n * @const\n * @type {string}\n */\n\nvar defaultFont = \'10px sans-serif\';\n/**\n * @const\n * @type {import("../color.js").Color}\n */\n\nvar defaultFillStyle = [0, 0, 0, 1];\n/**\n * @const\n * @type {string}\n */\n\nvar defaultLineCap = \'round\';\n/**\n * @const\n * @type {Array<number>}\n */\n\nvar defaultLineDash = [];\n/**\n * @const\n * @type {number}\n */\n\nvar defaultLineDashOffset = 0;\n/**\n * @const\n * @type {string}\n */\n\nvar defaultLineJoin = \'round\';\n/**\n * @const\n * @type {number}\n */\n\nvar defaultMiterLimit = 10;\n/**\n * @const\n * @type {import("../color.js").Color}\n */\n\nvar defaultStrokeStyle = [0, 0, 0, 1];\n/**\n * @const\n * @type {string}\n */\n\nvar defaultTextAlign = \'center\';\n/**\n * @const\n * @type {string}\n */\n\nvar defaultTextBaseline = \'middle\';\n/**\n * @const\n * @type {Array<number>}\n */\n\nvar defaultPadding = [0, 0, 0, 0];\n/**\n * @const\n * @type {number}\n */\n\nvar defaultLineWidth = 1;\n/**\n * The label cache for text rendering. To change the default cache size of 2048\n * entries, use {@link module:ol/structs/LRUCache#setSize}.\n * @type {LRUCache<HTMLCanvasElement>}\n * @api\n */\n\nvar labelCache = new _structs_LRUCache_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]();\n/**\n * @type {!Object<string, number>}\n */\n\nvar checkedFonts = {};\n/**\n * @type {CanvasRenderingContext2D}\n */\n\nvar measureContext = null;\n/**\n * @type {!Object<string, number>}\n */\n\nvar textHeights = {};\n/**\n * Clears the label cache when a font becomes available.\n * @param {string} fontSpec CSS font spec.\n */\n\nvar checkFont = function () {\n  var retries = 60;\n  var checked = checkedFonts;\n  var size = \'32px \';\n  var referenceFonts = [\'monospace\', \'serif\'];\n  var len = referenceFonts.length;\n  var text = "wmytzilWMYTZIL@#/&?$%10\\uF013";\n  var interval, referenceWidth;\n\n  function isAvailable(font) {\n    var context = getMeasureContext(); // Check weight ranges according to\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights\n\n    for (var weight = 100; weight <= 700; weight += 300) {\n      var fontWeight = weight + \' \';\n      var available = true;\n\n      for (var i = 0; i < len; ++i) {\n        var referenceFont = referenceFonts[i];\n        context.font = fontWeight + size + referenceFont;\n        referenceWidth = context.measureText(text).width;\n\n        if (font != referenceFont) {\n          context.font = fontWeight + size + font + \',\' + referenceFont;\n          var width = context.measureText(text).width; // If width and referenceWidth are the same, then the fallback was used\n          // instead of the font we wanted, so the font is not available.\n\n          available = available && width != referenceWidth;\n        }\n      }\n\n      if (available) {\n        // Consider font available when it is available in one weight range.\n        //FIXME With this we miss rare corner cases, so we should consider\n        //FIXME checking availability for each requested weight range.\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function check() {\n    var done = true;\n\n    for (var font in checked) {\n      if (checked[font] < retries) {\n        if (isAvailable(font)) {\n          checked[font] = retries;\n          Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__[/* clear */ "b"])(textHeights); // Make sure that loaded fonts are picked up by Safari\n\n          measureContext = null;\n          labelCache.clear();\n        } else {\n          ++checked[font];\n          done = false;\n        }\n      }\n    }\n\n    if (done) {\n      clearInterval(interval);\n      interval = undefined;\n    }\n  }\n\n  return function (fontSpec) {\n    var fontFamilies = Object(_css_js__WEBPACK_IMPORTED_MODULE_0__[/* getFontFamilies */ "c"])(fontSpec);\n\n    if (!fontFamilies) {\n      return;\n    }\n\n    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {\n      var fontFamily = fontFamilies[i];\n\n      if (!(fontFamily in checked)) {\n        checked[fontFamily] = retries;\n\n        if (!isAvailable(fontFamily)) {\n          checked[fontFamily] = 0;\n\n          if (interval === undefined) {\n            interval = setInterval(check, 32);\n          }\n        }\n      }\n    }\n  };\n}();\n/**\n * @return {CanvasRenderingContext2D} Measure context.\n */\n\nfunction getMeasureContext() {\n  if (!measureContext) {\n    measureContext = Object(_dom_js__WEBPACK_IMPORTED_MODULE_1__[/* createCanvasContext2D */ "a"])(1, 1);\n  }\n\n  return measureContext;\n}\n/**\n * @param {string} font Font to use for measuring.\n * @return {import("../size.js").Size} Measurement.\n */\n\n\nvar measureTextHeight = function () {\n  var span;\n  var heights = textHeights;\n  return function (font) {\n    var height = heights[font];\n\n    if (height == undefined) {\n      if (!span) {\n        span = document.createElement(\'span\');\n        span.textContent = \'M\';\n        span.style.margin = span.style.padding = \'0 !important\';\n        span.style.position = \'absolute !important\';\n        span.style.left = \'-99999px !important\';\n      }\n\n      span.style.font = font;\n      document.body.appendChild(span);\n      height = heights[font] = span.offsetHeight;\n      document.body.removeChild(span);\n    }\n\n    return height;\n  };\n}();\n/**\n * @param {string} font Font.\n * @param {string} text Text.\n * @return {number} Width.\n */\n\nfunction measureTextWidth(font, text) {\n  var measureContext = getMeasureContext();\n\n  if (font != measureContext.font) {\n    measureContext.font = font;\n  }\n\n  return measureContext.measureText(text).width;\n}\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {number} offsetX X offset.\n * @param {number} offsetY Y offset.\n */\n\nfunction rotateAtOffset(context, rotation, offsetX, offsetY) {\n  if (rotation !== 0) {\n    context.translate(offsetX, offsetY);\n    context.rotate(rotation);\n    context.translate(-offsetX, -offsetY);\n  }\n}\nvar resetTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* create */ "c"])();\n/**\n * @param {CanvasRenderingContext2D} context Context.\n * @param {import("../transform.js").Transform|null} transform Transform.\n * @param {number} opacity Opacity.\n * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n * @param {number} originX Origin X.\n * @param {number} originY Origin Y.\n * @param {number} w Width.\n * @param {number} h Height.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} scale Scale.\n */\n\nfunction drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale) {\n  var alpha;\n\n  if (opacity != 1) {\n    alpha = context.globalAlpha;\n    context.globalAlpha = alpha * opacity;\n  }\n\n  if (transform) {\n    context.setTransform.apply(context, transform);\n  }\n\n  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);\n\n  if (alpha) {\n    context.globalAlpha = alpha;\n  }\n\n  if (transform) {\n    context.setTransform.apply(context, resetTransform);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvcmVuZGVyL2NhbnZhcy5qcz9mOTkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzXG4gKi9cbmltcG9ydCB7Z2V0Rm9udEZhbWlsaWVzfSBmcm9tICcuLi9jc3MuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uL2RvbS5qcyc7XG5pbXBvcnQge2NsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IExSVUNhY2hlIGZyb20gJy4uL3N0cnVjdHMvTFJVQ2FjaGUuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtfSBmcm9tICcuLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRmlsbFN0YXRlXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IGZpbGxTdHlsZVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxsU3Ryb2tlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX0gW2N1cnJlbnRGaWxsU3R5bGVdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjdXJyZW50U3Ryb2tlU3R5bGVdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2N1cnJlbnRMaW5lQ2FwXVxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBjdXJyZW50TGluZURhc2hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY3VycmVudExpbmVEYXNoT2Zmc2V0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjdXJyZW50TGluZUpvaW5dXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRMaW5lV2lkdGhdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2N1cnJlbnRNaXRlckxpbWl0XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYXN0U3Ryb2tlXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbZmlsbFN0eWxlXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbc3Ryb2tlU3R5bGVdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVDYXBdXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGxpbmVEYXNoXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2xpbmVEYXNoT2Zmc2V0XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsaW5lSm9pbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGluZVdpZHRoXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaXRlckxpbWl0XVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdHJva2VTdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVDYXBcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gbGluZURhc2hcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lRGFzaE9mZnNldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGxpbmVKb2luXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWl0ZXJMaW1pdFxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBzdHJva2VTdHlsZVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0U3RhdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb250XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RleHRBbGlnbl1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0QmFzZWxpbmVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGxhY2VtZW50XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhBbmdsZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW292ZXJmbG93XVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9GaWxsLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kRmlsbF1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc3R5bGUvU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kU3Ryb2tlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzY2FsZV1cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW3BhZGRpbmddXG4gKi9cblxuXG4vKipcbiAqIENvbnRhaW5lciBmb3IgZGVjbHV0dGVyZWQgcmVwbGF5IGluc3RydWN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgcmVuZGVyZWQgb3JcbiAqIG9taXR0ZWQgdG9nZXRoZXIsIGkuZS4gd2hlbiBzdHlsZXMgcmVuZGVyIGJvdGggYW4gaW1hZ2UgYW5kIHRleHQsIG9yIGZvciB0aGVcbiAqIGNoYXJhY3RlcnMgdGhhdCBmb3JtIHRleHQgYWxvbmcgbGluZXMuIFRoZSBiYXNpYyBlbGVtZW50cyBvZiB0aGlzIGFycmF5IGFyZVxuICogYFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBjb3VudF1gLCB3aGVyZSB0aGUgZmlyc3QgZm91ciBlbnRyaWVzIGFyZSB0aGVcbiAqIHJlbmRlcmVkIGV4dGVudCBvZiB0aGUgZ3JvdXAgaW4gcGl4ZWwgc3BhY2UuIGBjb3VudGAgaXMgdGhlIG51bWJlciBvZiBzdHlsZXNcbiAqIGluIHRoZSBncm91cCwgaS5lLiAyIHdoZW4gYW4gaW1hZ2UgYW5kIGEgdGV4dCBhcmUgZ3JvdXBlZCwgb3IgMSBvdGhlcndpc2UuXG4gKiBJbiBhZGRpdGlvbiB0byB0aGVzZSBmb3VyIGVsZW1lbnRzLCBkZWNsdXR0ZXIgaW5zdHJ1Y3Rpb24gYXJyYXlzIChpLmUuIHRoZVxuICogYXJndW1lbnRzIHRvIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL2NhbnZhc35kcmF3SW1hZ2V9IGFyZSBhcHBlbmRlZCB0byB0aGUgYXJyYXkuXG4gKiBAdHlwZWRlZiB7QXJyYXk8Kj59IERlY2x1dHRlckdyb3VwXG4gKi9cblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRGb250ID0gJzEwcHggc2Fucy1zZXJpZic7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRGaWxsU3R5bGUgPSBbMCwgMCwgMCwgMV07XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZUNhcCA9ICdyb3VuZCc7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVEYXNoID0gW107XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TGluZURhc2hPZmZzZXQgPSAwO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdExpbmVKb2luID0gJ3JvdW5kJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRNaXRlckxpbWl0ID0gMTA7XG5cblxuLyoqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRTdHJva2VTdHlsZSA9IFswLCAwLCAwLCAxXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRUZXh0QWxpZ24gPSAnY2VudGVyJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRUZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFkZGluZyA9IFswLCAwLCAwLCAwXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRMaW5lV2lkdGggPSAxO1xuXG5cbi8qKlxuICogVGhlIGxhYmVsIGNhY2hlIGZvciB0ZXh0IHJlbmRlcmluZy4gVG8gY2hhbmdlIHRoZSBkZWZhdWx0IGNhY2hlIHNpemUgb2YgMjA0OFxuICogZW50cmllcywgdXNlIHtAbGluayBtb2R1bGU6b2wvc3RydWN0cy9MUlVDYWNoZSNzZXRTaXplfS5cbiAqIEB0eXBlIHtMUlVDYWNoZTxIVE1MQ2FudmFzRWxlbWVudD59XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBsYWJlbENhY2hlID0gbmV3IExSVUNhY2hlKCk7XG5cblxuLyoqXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja2VkRm9udHMgPSB7fTtcblxuXG4vKipcbiAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gKi9cbmxldCBtZWFzdXJlQ29udGV4dCA9IG51bGw7XG5cblxuLyoqXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCB0ZXh0SGVpZ2h0cyA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXJzIHRoZSBsYWJlbCBjYWNoZSB3aGVuIGEgZm9udCBiZWNvbWVzIGF2YWlsYWJsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250U3BlYyBDU1MgZm9udCBzcGVjLlxuICovXG5leHBvcnQgY29uc3QgY2hlY2tGb250ID0gKGZ1bmN0aW9uKCkge1xuICBjb25zdCByZXRyaWVzID0gNjA7XG4gIGNvbnN0IGNoZWNrZWQgPSBjaGVja2VkRm9udHM7XG4gIGNvbnN0IHNpemUgPSAnMzJweCAnO1xuICBjb25zdCByZWZlcmVuY2VGb250cyA9IFsnbW9ub3NwYWNlJywgJ3NlcmlmJ107XG4gIGNvbnN0IGxlbiA9IHJlZmVyZW5jZUZvbnRzLmxlbmd0aDtcbiAgY29uc3QgdGV4dCA9ICd3bXl0emlsV01ZVFpJTEAjLyY/JCUxMFxcdUYwMTMnO1xuICBsZXQgaW50ZXJ2YWwsIHJlZmVyZW5jZVdpZHRoO1xuXG4gIGZ1bmN0aW9uIGlzQXZhaWxhYmxlKGZvbnQpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gZ2V0TWVhc3VyZUNvbnRleHQoKTtcbiAgICAvLyBDaGVjayB3ZWlnaHQgcmFuZ2VzIGFjY29yZGluZyB0b1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXdlaWdodCNGYWxsYmFja193ZWlnaHRzXG4gICAgZm9yIChsZXQgd2VpZ2h0ID0gMTAwOyB3ZWlnaHQgPD0gNzAwOyB3ZWlnaHQgKz0gMzAwKSB7XG4gICAgICBjb25zdCBmb250V2VpZ2h0ID0gd2VpZ2h0ICsgJyAnO1xuICAgICAgbGV0IGF2YWlsYWJsZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUZvbnQgPSByZWZlcmVuY2VGb250c1tpXTtcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udFdlaWdodCArIHNpemUgKyByZWZlcmVuY2VGb250O1xuICAgICAgICByZWZlcmVuY2VXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICAgIGlmIChmb250ICE9IHJlZmVyZW5jZUZvbnQpIHtcbiAgICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250V2VpZ2h0ICsgc2l6ZSArIGZvbnQgKyAnLCcgKyByZWZlcmVuY2VGb250O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgICAgICAvLyBJZiB3aWR0aCBhbmQgcmVmZXJlbmNlV2lkdGggYXJlIHRoZSBzYW1lLCB0aGVuIHRoZSBmYWxsYmFjayB3YXMgdXNlZFxuICAgICAgICAgIC8vIGluc3RlYWQgb2YgdGhlIGZvbnQgd2Ugd2FudGVkLCBzbyB0aGUgZm9udCBpcyBub3QgYXZhaWxhYmxlLlxuICAgICAgICAgIGF2YWlsYWJsZSA9IGF2YWlsYWJsZSAmJiB3aWR0aCAhPSByZWZlcmVuY2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGF2YWlsYWJsZSkge1xuICAgICAgICAvLyBDb25zaWRlciBmb250IGF2YWlsYWJsZSB3aGVuIGl0IGlzIGF2YWlsYWJsZSBpbiBvbmUgd2VpZ2h0IHJhbmdlLlxuICAgICAgICAvL0ZJWE1FIFdpdGggdGhpcyB3ZSBtaXNzIHJhcmUgY29ybmVyIGNhc2VzLCBzbyB3ZSBzaG91bGQgY29uc2lkZXJcbiAgICAgICAgLy9GSVhNRSBjaGVja2luZyBhdmFpbGFiaWxpdHkgZm9yIGVhY2ggcmVxdWVzdGVkIHdlaWdodCByYW5nZS5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGZvbnQgaW4gY2hlY2tlZCkge1xuICAgICAgaWYgKGNoZWNrZWRbZm9udF0gPCByZXRyaWVzKSB7XG4gICAgICAgIGlmIChpc0F2YWlsYWJsZShmb250KSkge1xuICAgICAgICAgIGNoZWNrZWRbZm9udF0gPSByZXRyaWVzO1xuICAgICAgICAgIGNsZWFyKHRleHRIZWlnaHRzKTtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsb2FkZWQgZm9udHMgYXJlIHBpY2tlZCB1cCBieSBTYWZhcmlcbiAgICAgICAgICBtZWFzdXJlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgbGFiZWxDYWNoZS5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrY2hlY2tlZFtmb250XTtcbiAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgaW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZvbnRTcGVjKSB7XG4gICAgY29uc3QgZm9udEZhbWlsaWVzID0gZ2V0Rm9udEZhbWlsaWVzKGZvbnRTcGVjKTtcbiAgICBpZiAoIWZvbnRGYW1pbGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmb250RmFtaWxpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZm9udEZhbWlseSA9IGZvbnRGYW1pbGllc1tpXTtcbiAgICAgIGlmICghKGZvbnRGYW1pbHkgaW4gY2hlY2tlZCkpIHtcbiAgICAgICAgY2hlY2tlZFtmb250RmFtaWx5XSA9IHJldHJpZXM7XG4gICAgICAgIGlmICghaXNBdmFpbGFibGUoZm9udEZhbWlseSkpIHtcbiAgICAgICAgICBjaGVja2VkW2ZvbnRGYW1pbHldID0gMDtcbiAgICAgICAgICBpZiAoaW50ZXJ2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGVjaywgMzIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IE1lYXN1cmUgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWVhc3VyZUNvbnRleHQoKSB7XG4gIGlmICghbWVhc3VyZUNvbnRleHQpIHtcbiAgICBtZWFzdXJlQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRCgxLCAxKTtcbiAgfVxuICByZXR1cm4gbWVhc3VyZUNvbnRleHQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9udCBGb250IHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBNZWFzdXJlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IG1lYXN1cmVUZXh0SGVpZ2h0ID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgc3BhbjtcbiAgY29uc3QgaGVpZ2h0cyA9IHRleHRIZWlnaHRzO1xuICByZXR1cm4gZnVuY3Rpb24oZm9udCkge1xuICAgIGxldCBoZWlnaHQgPSBoZWlnaHRzW2ZvbnRdO1xuICAgIGlmIChoZWlnaHQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXNwYW4pIHtcbiAgICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9ICdNJztcbiAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW4gPSBzcGFuLnN0eWxlLnBhZGRpbmcgPSAnMCAhaW1wb3J0YW50JztcbiAgICAgICAgc3Bhbi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSAhaW1wb3J0YW50JztcbiAgICAgICAgc3Bhbi5zdHlsZS5sZWZ0ID0gJy05OTk5OXB4ICFpbXBvcnRhbnQnO1xuICAgICAgfVxuICAgICAgc3Bhbi5zdHlsZS5mb250ID0gZm9udDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICBoZWlnaHQgPSBoZWlnaHRzW2ZvbnRdID0gc3Bhbi5vZmZzZXRIZWlnaHQ7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNwYW4pO1xuICAgIH1cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICogQHJldHVybiB7bnVtYmVyfSBXaWR0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lYXN1cmVUZXh0V2lkdGgoZm9udCwgdGV4dCkge1xuICBjb25zdCBtZWFzdXJlQ29udGV4dCA9IGdldE1lYXN1cmVDb250ZXh0KCk7XG4gIGlmIChmb250ICE9IG1lYXN1cmVDb250ZXh0LmZvbnQpIHtcbiAgICBtZWFzdXJlQ29udGV4dC5mb250ID0gZm9udDtcbiAgfVxuICByZXR1cm4gbWVhc3VyZUNvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggWCBvZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSBZIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICB9XG59XG5cblxuZXhwb3J0IGNvbnN0IHJlc2V0VHJhbnNmb3JtID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfG51bGx9IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSBPcGFjaXR5LlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIEltYWdlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpblggT3JpZ2luIFguXG4gKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWSBPcmlnaW4gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3IFdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGggSGVpZ2h0LlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgU2NhbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3SW1hZ2UoY29udGV4dCxcbiAgdHJhbnNmb3JtLCBvcGFjaXR5LCBpbWFnZSwgb3JpZ2luWCwgb3JpZ2luWSwgdywgaCwgeCwgeSwgc2NhbGUpIHtcbiAgbGV0IGFscGhhO1xuICBpZiAob3BhY2l0eSAhPSAxKSB7XG4gICAgYWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIG9wYWNpdHk7XG4gIH1cbiAgaWYgKHRyYW5zZm9ybSkge1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtLmFwcGx5KGNvbnRleHQsIHRyYW5zZm9ybSk7XG4gIH1cblxuICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgb3JpZ2luWCwgb3JpZ2luWSwgdywgaCwgeCwgeSwgdyAqIHNjYWxlLCBoICogc2NhbGUpO1xuXG4gIGlmIChhbHBoYSkge1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgfVxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0uYXBwbHkoY29udGV4dCwgcmVzZXRUcmFuc2Zvcm0pO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkVBOzs7Ozs7QUFPQTs7Ozs7O0FBT0E7Ozs7OztBQU9BOzs7Ozs7QUFPQTs7Ozs7O0FBT0E7Ozs7OztBQU9BOzs7Ozs7QUFPQTs7Ozs7O0FBT0E7Ozs7OztBQU9BOzs7Ozs7QUFPQTs7Ozs7O0FBT0E7Ozs7Ozs7O0FBU0E7Ozs7O0FBTUE7Ozs7O0FBTUE7Ozs7O0FBTUE7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/events/EventType\n */\n\n/**\n * @enum {string}\n * @const\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  /**\n   * Generic change event. Triggered when the revision counter is increased.\n   * @event module:ol/events/Event~Event#change\n   * @api\n   */\n  CHANGE: 'change',\n  CLEAR: 'clear',\n  CONTEXTMENU: 'contextmenu',\n  CLICK: 'click',\n  DBLCLICK: 'dblclick',\n  DRAGENTER: 'dragenter',\n  DRAGOVER: 'dragover',\n  DROP: 'drop',\n  ERROR: 'error',\n  KEYDOWN: 'keydown',\n  KEYPRESS: 'keypress',\n  LOAD: 'load',\n  MOUSEDOWN: 'mousedown',\n  MOUSEMOVE: 'mousemove',\n  MOUSEOUT: 'mouseout',\n  MOUSEUP: 'mouseup',\n  MOUSEWHEEL: 'mousewheel',\n  MSPOINTERDOWN: 'MSPointerDown',\n  RESIZE: 'resize',\n  TOUCHSTART: 'touchstart',\n  TOUCHMOVE: 'touchmove',\n  TOUCHEND: 'touchend',\n  WHEEL: 'wheel'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvZXZlbnRzL0V2ZW50VHlwZS5qcz8zYjViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIEdlbmVyaWMgY2hhbmdlIGV2ZW50LiBUcmlnZ2VyZWQgd2hlbiB0aGUgcmV2aXNpb24gY291bnRlciBpcyBpbmNyZWFzZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50I2NoYW5nZVxuICAgKiBAYXBpXG4gICAqL1xuICBDSEFOR0U6ICdjaGFuZ2UnLFxuXG4gIENMRUFSOiAnY2xlYXInLFxuICBDT05URVhUTUVOVTogJ2NvbnRleHRtZW51JyxcbiAgQ0xJQ0s6ICdjbGljaycsXG4gIERCTENMSUNLOiAnZGJsY2xpY2snLFxuICBEUkFHRU5URVI6ICdkcmFnZW50ZXInLFxuICBEUkFHT1ZFUjogJ2RyYWdvdmVyJyxcbiAgRFJPUDogJ2Ryb3AnLFxuICBFUlJPUjogJ2Vycm9yJyxcbiAgS0VZRE9XTjogJ2tleWRvd24nLFxuICBLRVlQUkVTUzogJ2tleXByZXNzJyxcbiAgTE9BRDogJ2xvYWQnLFxuICBNT1VTRURPV046ICdtb3VzZWRvd24nLFxuICBNT1VTRU1PVkU6ICdtb3VzZW1vdmUnLFxuICBNT1VTRU9VVDogJ21vdXNlb3V0JyxcbiAgTU9VU0VVUDogJ21vdXNldXAnLFxuICBNT1VTRVdIRUVMOiAnbW91c2V3aGVlbCcsXG4gIE1TUE9JTlRFUkRPV046ICdNU1BvaW50ZXJEb3duJyxcbiAgUkVTSVpFOiAncmVzaXplJyxcbiAgVE9VQ0hTVEFSVDogJ3RvdWNoc3RhcnQnLFxuICBUT1VDSE1PVkU6ICd0b3VjaG1vdmUnLFxuICBUT1VDSEVORDogJ3RvdWNoZW5kJyxcbiAgV0hFRUw6ICd3aGVlbCdcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQVFBOzs7Ozs7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0JBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cosh; });\n/* unused harmony export roundUpToPowerOfTwo */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return squaredSegmentDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return solveLinearSystem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return toDegrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return toRadians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return modulo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return lerp; });\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/**\n * @module ol/math\n */\n\n/**\n * Takes a number and clamps it to within the provided bounds.\n * @param {number} value The input number.\n * @param {number} min The minimum value to return.\n * @param {number} max The maximum value to return.\n * @return {number} The input number if it is within bounds, or the nearest\n *     number within the bounds.\n */\n\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\n * Return the hyperbolic cosine of a given number. The method will use the\n * native `Math.cosh` function if it is available, otherwise the hyperbolic\n * cosine will be calculated via the reference implementation of the Mozilla\n * developer network.\n *\n * @param {number} x X.\n * @return {number} Hyperbolic cosine of x.\n */\n\nvar cosh = function () {\n  // Wrapped in a iife, to save the overhead of checking for the native\n  // implementation on every invocation.\n  var cosh;\n\n  if (\'cosh\' in Math) {\n    // The environment supports the native Math.cosh function, use it\n    cosh = Math.cosh;\n  } else {\n    //  else, use the reference implementation of MDN:\n    cosh = function cosh(x) {\n      var y =\n      /** @type {Math} */\n      Math.exp(x);\n      return (y + 1 / y) / 2;\n    };\n  }\n\n  return cosh;\n}();\n/**\n * @param {number} x X.\n * @return {number} The smallest power of two greater than or equal to x.\n */\n\nfunction roundUpToPowerOfTwo(x) {\n  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(0 < x, 29); // `x` must be greater than `0`\n\n  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));\n}\n/**\n * Returns the square of the closest distance between the point (x, y) and the\n * line segment (x1, y1) to (x2, y2).\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\n\nfunction squaredSegmentDistance(x, y, x1, y1, x2, y2) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x1 = x2;\n      y1 = y2;\n    } else if (t > 0) {\n      x1 += dx * t;\n      y1 += dy * t;\n    }\n  }\n\n  return squaredDistance(x, y, x1, y1);\n}\n/**\n * Returns the square of the distance between the points (x1, y1) and (x2, y2).\n * @param {number} x1 X1.\n * @param {number} y1 Y1.\n * @param {number} x2 X2.\n * @param {number} y2 Y2.\n * @return {number} Squared distance.\n */\n\nfunction squaredDistance(x1, y1, x2, y2) {\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  return dx * dx + dy * dy;\n}\n/**\n * Solves system of linear equations using Gaussian elimination method.\n *\n * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)\n *                                     in row-major order.\n * @return {Array<number>} The resulting vector.\n */\n\nfunction solveLinearSystem(mat) {\n  var n = mat.length;\n\n  for (var i = 0; i < n; i++) {\n    // Find max in the i-th column (ignoring i - 1 first rows)\n    var maxRow = i;\n    var maxEl = Math.abs(mat[i][i]);\n\n    for (var r = i + 1; r < n; r++) {\n      var absValue = Math.abs(mat[r][i]);\n\n      if (absValue > maxEl) {\n        maxEl = absValue;\n        maxRow = r;\n      }\n    }\n\n    if (maxEl === 0) {\n      return null; // matrix is singular\n    } // Swap max row with i-th (current) row\n\n\n    var tmp = mat[maxRow];\n    mat[maxRow] = mat[i];\n    mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column\n\n    for (var j = i + 1; j < n; j++) {\n      var coef = -mat[j][i] / mat[i][i];\n\n      for (var k = i; k < n + 1; k++) {\n        if (i == k) {\n          mat[j][k] = 0;\n        } else {\n          mat[j][k] += coef * mat[i][k];\n        }\n      }\n    }\n  } // Solve Ax=b for upper triangular matrix A (mat)\n\n\n  var x = new Array(n);\n\n  for (var l = n - 1; l >= 0; l--) {\n    x[l] = mat[l][n] / mat[l][l];\n\n    for (var m = l - 1; m >= 0; m--) {\n      mat[m][n] -= mat[m][l] * x[l];\n    }\n  }\n\n  return x;\n}\n/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\n\nfunction toDegrees(angleInRadians) {\n  return angleInRadians * 180 / Math.PI;\n}\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\n\nfunction toRadians(angleInDegrees) {\n  return angleInDegrees * Math.PI / 180;\n}\n/**\n * Returns the modulo of a / b, depending on the sign of b.\n *\n * @param {number} a Dividend.\n * @param {number} b Divisor.\n * @return {number} Modulo.\n */\n\nfunction modulo(a, b) {\n  var r = a % b;\n  return r * b < 0 ? r + b : r;\n}\n/**\n * Calculates the linearly interpolated value of x between a and b.\n *\n * @param {number} a Number\n * @param {number} b Number\n * @param {number} x Value to be interpolated.\n * @return {number} Interpolated value.\n */\n\nfunction lerp(a, b, x) {\n  return a + x * (b - a);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9zcmMvb2wvbWF0aC5qcz8zZDFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9tYXRoXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIGFuZCBjbGFtcHMgaXQgdG8gd2l0aGluIHRoZSBwcm92aWRlZCBib3VuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGlucHV0IG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gVGhlIG1pbmltdW0gdmFsdWUgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBUaGUgbWF4aW11bSB2YWx1ZSB0byByZXR1cm4uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbnB1dCBudW1iZXIgaWYgaXQgaXMgd2l0aGluIGJvdW5kcywgb3IgdGhlIG5lYXJlc3RcbiAqICAgICBudW1iZXIgd2l0aGluIHRoZSBib3VuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBhIGdpdmVuIG51bWJlci4gVGhlIG1ldGhvZCB3aWxsIHVzZSB0aGVcbiAqIG5hdGl2ZSBgTWF0aC5jb3NoYCBmdW5jdGlvbiBpZiBpdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSB0aGUgaHlwZXJib2xpY1xuICogY29zaW5lIHdpbGwgYmUgY2FsY3VsYXRlZCB2aWEgdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgTW96aWxsYVxuICogZGV2ZWxvcGVyIG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEByZXR1cm4ge251bWJlcn0gSHlwZXJib2xpYyBjb3NpbmUgb2YgeC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvc2ggPSAoZnVuY3Rpb24oKSB7XG4gIC8vIFdyYXBwZWQgaW4gYSBpaWZlLCB0byBzYXZlIHRoZSBvdmVyaGVhZCBvZiBjaGVja2luZyBmb3IgdGhlIG5hdGl2ZVxuICAvLyBpbXBsZW1lbnRhdGlvbiBvbiBldmVyeSBpbnZvY2F0aW9uLlxuICBsZXQgY29zaDtcbiAgaWYgKCdjb3NoJyBpbiBNYXRoKSB7XG4gICAgLy8gVGhlIGVudmlyb25tZW50IHN1cHBvcnRzIHRoZSBuYXRpdmUgTWF0aC5jb3NoIGZ1bmN0aW9uLCB1c2UgaXTigKZcbiAgICBjb3NoID0gTWF0aC5jb3NoO1xuICB9IGVsc2Uge1xuICAgIC8vIOKApiBlbHNlLCB1c2UgdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiBNRE46XG4gICAgY29zaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGNvbnN0IHkgPSAvKiogQHR5cGUge01hdGh9ICovIChNYXRoKS5leHAoeCk7XG4gICAgICByZXR1cm4gKHkgKyAxIC8geSkgLyAyO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNvc2g7XG59KCkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXN0IHBvd2VyIG9mIHR3byBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVXBUb1Bvd2VyT2ZUd28oeCkge1xuICBhc3NlcnQoMCA8IHgsIDI5KTsgLy8gYHhgIG11c3QgYmUgZ3JlYXRlciB0aGFuIGAwYFxuICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKHgpIC8gTWF0aC5MTjIpKTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgY2xvc2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb2ludCAoeCwgeSkgYW5kIHRoZVxuICogbGluZSBzZWdtZW50ICh4MSwgeTEpIHRvICh4MiwgeTIpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgWDEuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgWTEuXG4gKiBAcGFyYW0ge251bWJlcn0geDIgWDIuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgWTIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkU2VnbWVudERpc3RhbmNlKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcbiAgICBjb25zdCB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzcXVhcmVkRGlzdGFuY2UoeCwgeSwgeDEsIHkxKTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzICh4MSwgeTEpIGFuZCAoeDIsIHkyKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSBYMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MSBZMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiBYMi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MiBZMi5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZSh4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBkeCA9IHgyIC0geDE7XG4gIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5cbi8qKlxuICogU29sdmVzIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIHVzaW5nIEdhdXNzaWFuIGVsaW1pbmF0aW9uIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBtYXQgQXVnbWVudGVkIG1hdHJpeCAobiB4IG4gKyAxIGNvbHVtbilcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHJvdy1tYWpvciBvcmRlci5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSByZXN1bHRpbmcgdmVjdG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29sdmVMaW5lYXJTeXN0ZW0obWF0KSB7XG4gIGNvbnN0IG4gPSBtYXQubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgLy8gRmluZCBtYXggaW4gdGhlIGktdGggY29sdW1uIChpZ25vcmluZyBpIC0gMSBmaXJzdCByb3dzKVxuICAgIGxldCBtYXhSb3cgPSBpO1xuICAgIGxldCBtYXhFbCA9IE1hdGguYWJzKG1hdFtpXVtpXSk7XG4gICAgZm9yIChsZXQgciA9IGkgKyAxOyByIDwgbjsgcisrKSB7XG4gICAgICBjb25zdCBhYnNWYWx1ZSA9IE1hdGguYWJzKG1hdFtyXVtpXSk7XG4gICAgICBpZiAoYWJzVmFsdWUgPiBtYXhFbCkge1xuICAgICAgICBtYXhFbCA9IGFic1ZhbHVlO1xuICAgICAgICBtYXhSb3cgPSByO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhFbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIG1hdHJpeCBpcyBzaW5ndWxhclxuICAgIH1cblxuICAgIC8vIFN3YXAgbWF4IHJvdyB3aXRoIGktdGggKGN1cnJlbnQpIHJvd1xuICAgIGNvbnN0IHRtcCA9IG1hdFttYXhSb3ddO1xuICAgIG1hdFttYXhSb3ddID0gbWF0W2ldO1xuICAgIG1hdFtpXSA9IHRtcDtcblxuICAgIC8vIFN1YnRyYWN0IHRoZSBpLXRoIHJvdyB0byBtYWtlIGFsbCB0aGUgcmVtYWluaW5nIHJvd3MgMCBpbiB0aGUgaS10aCBjb2x1bW5cbiAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgIGNvbnN0IGNvZWYgPSAtbWF0W2pdW2ldIC8gbWF0W2ldW2ldO1xuICAgICAgZm9yIChsZXQgayA9IGk7IGsgPCBuICsgMTsgaysrKSB7XG4gICAgICAgIGlmIChpID09IGspIHtcbiAgICAgICAgICBtYXRbal1ba10gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdFtqXVtrXSArPSBjb2VmICogbWF0W2ldW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU29sdmUgQXg9YiBmb3IgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggQSAobWF0KVxuICBjb25zdCB4ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKGxldCBsID0gbiAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgeFtsXSA9IG1hdFtsXVtuXSAvIG1hdFtsXVtsXTtcbiAgICBmb3IgKGxldCBtID0gbCAtIDE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICBtYXRbbV1bbl0gLT0gbWF0W21dW2xdICogeFtsXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0cyByYWRpYW5zIHRvIHRvIGRlZ3JlZXMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlSW5SYWRpYW5zIEFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuZ2xlIGluIGRlZ3JlZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlZ3JlZXMoYW5nbGVJblJhZGlhbnMpIHtcbiAgcmV0dXJuIGFuZ2xlSW5SYWRpYW5zICogMTgwIC8gTWF0aC5QSTtcbn1cblxuXG4vKipcbiAqIENvbnZlcnRzIGRlZ3JlZXMgdG8gcmFkaWFucy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGVJbkRlZ3JlZXMgQW5nbGUgaW4gZGVncmVlcy5cbiAqIEByZXR1cm4ge251bWJlcn0gQW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhhbmdsZUluRGVncmVlcykge1xuICByZXR1cm4gYW5nbGVJbkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vZHVsbyBvZiBhIC8gYiwgZGVwZW5kaW5nIG9uIHRoZSBzaWduIG9mIGIuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgRGl2aWRlbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gYiBEaXZpc29yLlxuICogQHJldHVybiB7bnVtYmVyfSBNb2R1bG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb2R1bG8oYSwgYikge1xuICBjb25zdCByID0gYSAlIGI7XG4gIHJldHVybiByICogYiA8IDAgPyByICsgYiA6IHI7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGluZWFybHkgaW50ZXJwb2xhdGVkIHZhbHVlIG9mIHggYmV0d2VlbiBhIGFuZCBiLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBhIE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IGIgTnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0geCBWYWx1ZSB0byBiZSBpbnRlcnBvbGF0ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEludGVycG9sYXRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlcnAoYSwgYiwgeCkge1xuICByZXR1cm4gYSArIHggKiAoYiAtIGEpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVlBOzs7QUFHQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/**\n * @module ol/TileState\n */\n\n/**\n * @enum {number}\n */\n/* harmony default export */ __webpack_exports__["a"] = ({\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n\n  /**\n   * Indicates that tile loading failed\n   * @type {number}\n   */\n  ERROR: 3,\n  EMPTY: 4,\n  ABORT: 5\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9zcmMvb2wvVGlsZVN0YXRlLmpzPzhiNjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aWxlIGxvYWRpbmcgZmFpbGVkXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBFUlJPUjogMyxcbiAgRU1QVFk6IDQsXG4gIEFCT1JUOiA1XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBVkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n')},function(module,exports){eval("module.exports = jQuery;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImpRdWVyeVwiP2NkMGMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return reset; });\n/* unused harmony export multiply */\n/* unused harmony export set */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return setFromArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return apply; });\n/* unused harmony export rotate */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return compose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return invert; });\n/* unused harmony export determinant */\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/**\n * @module ol/transform\n */\n\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n */\n\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 33 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n/**\n * @private\n * @type {Transform}\n */\n\nvar tmp_ = new Array(6);\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\n\nfunction create() {\n  return [1, 0, 0, 1, 0, 0];\n}\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\n\nfunction reset(transform) {\n  return set(transform, 1, 0, 0, 1, 0, 0);\n}\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\n\nfunction multiply(transform1, transform2) {\n  var a1 = transform1[0];\n  var b1 = transform1[1];\n  var c1 = transform1[2];\n  var d1 = transform1[3];\n  var e1 = transform1[4];\n  var f1 = transform1[5];\n  var a2 = transform2[0];\n  var b2 = transform2[1];\n  var c2 = transform2[2];\n  var d2 = transform2[3];\n  var e2 = transform2[4];\n  var f2 = transform2[5];\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n  return transform1;\n}\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\n\nfunction set(transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n}\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\n\nfunction setFromArray(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n}\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.\n * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be\n *     chained together.\n */\n\nfunction apply(transform, coordinate) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n}\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\n\nfunction rotate(transform, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\n\nfunction scale(transform, x, y) {\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\n\nfunction translate(transform, dx, dy) {\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\n\nfunction compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  var sin = Math.sin(angle);\n  var cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n}\n/**\n * Invert the given transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Inverse of the transform.\n */\n\nfunction invert(transform) {\n  var det = determinant(transform);\n  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(det !== 0, 32); // Transformation matrix cannot be inverted\n\n  var a = transform[0];\n  var b = transform[1];\n  var c = transform[2];\n  var d = transform[3];\n  var e = transform[4];\n  var f = transform[5];\n  transform[0] = d / det;\n  transform[1] = -b / det;\n  transform[2] = -c / det;\n  transform[3] = a / det;\n  transform[4] = (c * f - d * e) / det;\n  transform[5] = -(a * f - b * e) / det;\n  return transform;\n}\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\n\nfunction determinant(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9zcmMvb2wvdHJhbnNmb3JtLmpzPzlmNzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3RyYW5zZm9ybVxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcblxuXG4vKipcbiAqIEFuIGFycmF5IHJlcHJlc2VudGluZyBhbiBhZmZpbmUgMmQgdHJhbnNmb3JtYXRpb24gZm9yIHVzZSB3aXRoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3RyYW5zZm9ybX0gZnVuY3Rpb25zLiBUaGUgYXJyYXkgaGFzIDYgZWxlbWVudHMuXG4gKiBAdHlwZWRlZiB7IUFycmF5PG51bWJlcj59IFRyYW5zZm9ybVxuICovXG5cblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFmZmluZSAyZCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMuIFRoZSBmdW5jdGlvbnMgd29yayBvbiBhblxuICogYXJyYXkgb2YgNiBlbGVtZW50cy4gVGhlIGVsZW1lbnQgb3JkZXIgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBbU1ZHTWF0cml4XG4gKiBpbnRlcmZhY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdNYXRyaXgpIGFuZCBpc1xuICogYSBzdWJzZXQgKGVsZW1lbnRzIGEgdG8gZikgb2YgYSAzw5czIG1hdHJpeDpcbiAqIGBgYFxuICogWyBhIGMgZSBdXG4gKiBbIGIgZCBmIF1cbiAqIFsgMCAwIDEgXVxuICogYGBgXG4gKi9cblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7VHJhbnNmb3JtfVxuICovXG5jb25zdCB0bXBfID0gbmV3IEFycmF5KDYpO1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IElkZW50aXR5IHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgcmV0dXJuIFsxLCAwLCAwLCAxLCAwLCAwXTtcbn1cblxuXG4vKipcbiAqIFJlc2V0cyB0aGUgZ2l2ZW4gdHJhbnNmb3JtIHRvIGFuIGlkZW50aXR5IHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHRyYW5zZm9ybSkge1xuICByZXR1cm4gc2V0KHRyYW5zZm9ybSwgMSwgMCwgMCwgMSwgMCwgMCk7XG59XG5cblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgdW5kZXJseWluZyBtYXRyaWNlcyBvZiB0d28gdHJhbnNmb3JtcyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgaW5cbiAqIHRoZSBmaXJzdCB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTEgVHJhbnNmb3JtIHBhcmFtZXRlcnMgb2YgbWF0cml4IDEuXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybTIgVHJhbnNmb3JtIHBhcmFtZXRlcnMgb2YgbWF0cml4IDIuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0xIG11bHRpcGxpZWQgd2l0aCB0cmFuc2Zvcm0yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkodHJhbnNmb3JtMSwgdHJhbnNmb3JtMikge1xuICBjb25zdCBhMSA9IHRyYW5zZm9ybTFbMF07XG4gIGNvbnN0IGIxID0gdHJhbnNmb3JtMVsxXTtcbiAgY29uc3QgYzEgPSB0cmFuc2Zvcm0xWzJdO1xuICBjb25zdCBkMSA9IHRyYW5zZm9ybTFbM107XG4gIGNvbnN0IGUxID0gdHJhbnNmb3JtMVs0XTtcbiAgY29uc3QgZjEgPSB0cmFuc2Zvcm0xWzVdO1xuICBjb25zdCBhMiA9IHRyYW5zZm9ybTJbMF07XG4gIGNvbnN0IGIyID0gdHJhbnNmb3JtMlsxXTtcbiAgY29uc3QgYzIgPSB0cmFuc2Zvcm0yWzJdO1xuICBjb25zdCBkMiA9IHRyYW5zZm9ybTJbM107XG4gIGNvbnN0IGUyID0gdHJhbnNmb3JtMls0XTtcbiAgY29uc3QgZjIgPSB0cmFuc2Zvcm0yWzVdO1xuXG4gIHRyYW5zZm9ybTFbMF0gPSBhMSAqIGEyICsgYzEgKiBiMjtcbiAgdHJhbnNmb3JtMVsxXSA9IGIxICogYTIgKyBkMSAqIGIyO1xuICB0cmFuc2Zvcm0xWzJdID0gYTEgKiBjMiArIGMxICogZDI7XG4gIHRyYW5zZm9ybTFbM10gPSBiMSAqIGMyICsgZDEgKiBkMjtcbiAgdHJhbnNmb3JtMVs0XSA9IGExICogZTIgKyBjMSAqIGYyICsgZTE7XG4gIHRyYW5zZm9ybTFbNV0gPSBiMSAqIGUyICsgZDEgKiBmMiArIGYxO1xuXG4gIHJldHVybiB0cmFuc2Zvcm0xO1xufVxuXG4vKipcbiAqIFNldCB0aGUgdHJhbnNmb3JtIGNvbXBvbmVudHMgYS1mIG9uIGEgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIGEgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gYiBUaGUgYiBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjIFRoZSBjIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGQgVGhlIGQgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0gZSBUaGUgZSBjb21wb25lbnQgb2YgdGhlIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmIFRoZSBmIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gTWF0cml4IHdpdGggdHJhbnNmb3JtIGFwcGxpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQodHJhbnNmb3JtLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHRyYW5zZm9ybVswXSA9IGE7XG4gIHRyYW5zZm9ybVsxXSA9IGI7XG4gIHRyYW5zZm9ybVsyXSA9IGM7XG4gIHRyYW5zZm9ybVszXSA9IGQ7XG4gIHRyYW5zZm9ybVs0XSA9IGU7XG4gIHRyYW5zZm9ybVs1XSA9IGY7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuLyoqXG4gKiBTZXQgdHJhbnNmb3JtIG9uIG9uZSBtYXRyaXggZnJvbSBhbm90aGVyIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSBNYXRyaXggdG8gc2V0IHRyYW5zZm9ybSB0by5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMiBNYXRyaXggdG8gc2V0IHRyYW5zZm9ybSBmcm9tLlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtMSB3aXRoIHRyYW5zZm9ybSBmcm9tIHRyYW5zZm9ybTIgYXBwbGllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZyb21BcnJheSh0cmFuc2Zvcm0xLCB0cmFuc2Zvcm0yKSB7XG4gIHRyYW5zZm9ybTFbMF0gPSB0cmFuc2Zvcm0yWzBdO1xuICB0cmFuc2Zvcm0xWzFdID0gdHJhbnNmb3JtMlsxXTtcbiAgdHJhbnNmb3JtMVsyXSA9IHRyYW5zZm9ybTJbMl07XG4gIHRyYW5zZm9ybTFbM10gPSB0cmFuc2Zvcm0yWzNdO1xuICB0cmFuc2Zvcm0xWzRdID0gdHJhbnNmb3JtMls0XTtcbiAgdHJhbnNmb3JtMVs1XSA9IHRyYW5zZm9ybTJbNV07XG4gIHJldHVybiB0cmFuc2Zvcm0xO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gY29vcmRpbmF0ZSB3aXRoIHRoZSBnaXZlbiB0cmFuc2Zvcm0gcmV0dXJuaW5nIHRoZVxuICogcmVzdWx0aW5nLCB0cmFuc2Zvcm1lZCBjb29yZGluYXRlLiBUaGUgY29vcmRpbmF0ZSB3aWxsIGJlIG1vZGlmaWVkIGluLXBsYWNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybWF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXxpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlIHRvIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfGltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHJldHVybiBjb29yZGluYXRlIHNvIHRoYXQgb3BlcmF0aW9ucyBjYW4gYmVcbiAqICAgICBjaGFpbmVkIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkodHJhbnNmb3JtLCBjb29yZGluYXRlKSB7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgY29vcmRpbmF0ZVswXSA9IHRyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdO1xuICBjb29yZGluYXRlWzFdID0gdHJhbnNmb3JtWzFdICogeCArIHRyYW5zZm9ybVszXSAqIHkgKyB0cmFuc2Zvcm1bNV07XG4gIHJldHVybiBjb29yZGluYXRlO1xufVxuXG5cbi8qKlxuICogQXBwbGllcyByb3RhdGlvbiB0byB0aGUgZ2l2ZW4gdHJhbnNmb3JtLlxuICogQHBhcmFtIHshVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIEFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgcm90YXRlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUodHJhbnNmb3JtLCBhbmdsZSkge1xuICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIGNvcywgc2luLCAtc2luLCBjb3MsIDAsIDApKTtcbn1cblxuXG4vKipcbiAqIEFwcGxpZXMgc2NhbGUgdG8gYSBnaXZlbiB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gKiBAcGFyYW0ge251bWJlcn0geCBTY2FsZSBmYWN0b3IgeC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFNjYWxlIGZhY3RvciB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIHNjYWxlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIHgsIHkpIHtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIHgsIDAsIDAsIHksIDAsIDApKTtcbn1cblxuXG4vKipcbiAqIEFwcGxpZXMgdHJhbnNsYXRpb24gdG8gdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeCBUcmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5IFRyYW5zbGF0aW9uIHkuXG4gKiBAcmV0dXJuIHshVHJhbnNmb3JtfSBUaGUgdHJhbnNsYXRlZCB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBkeCwgZHkpIHtcbiAgcmV0dXJuIG11bHRpcGx5KHRyYW5zZm9ybSwgc2V0KHRtcF8sIDEsIDAsIDAsIDEsIGR4LCBkeSkpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSB0cmFuc2Zvcm0gZ2l2ZW4gYW4gaW5pdGlhbCB0cmFuc2xhdGlvbiwgc2NhbGUsIHJvdGF0aW9uLCBhbmRcbiAqIGZpbmFsIHRyYW5zbGF0aW9uIChpbiB0aGF0IG9yZGVyIG9ubHksIG5vdCBjb21tdXRhdGl2ZSkuXG4gKiBAcGFyYW0geyFUcmFuc2Zvcm19IHRyYW5zZm9ybSBUaGUgdHJhbnNmb3JtICh3aWxsIGJlIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkeDEgSW5pdGlhbCB0cmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5MSBJbml0aWFsIHRyYW5zbGF0aW9uIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gc3ggU2NhbGUgZmFjdG9yIHguXG4gKiBAcGFyYW0ge251bWJlcn0gc3kgU2NhbGUgZmFjdG9yIHkuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gKGluIGNvdW50ZXItY2xvY2t3aXNlIHJhZGlhbnMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGR4MiBGaW5hbCB0cmFuc2xhdGlvbiB4LlxuICogQHBhcmFtIHtudW1iZXJ9IGR5MiBGaW5hbCB0cmFuc2xhdGlvbiB5LlxuICogQHJldHVybiB7IVRyYW5zZm9ybX0gVGhlIGNvbXBvc2l0ZSB0cmFuc2Zvcm0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wb3NlKHRyYW5zZm9ybSwgZHgxLCBkeTEsIHN4LCBzeSwgYW5nbGUsIGR4MiwgZHkyKSB7XG4gIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICB0cmFuc2Zvcm1bMF0gPSBzeCAqIGNvcztcbiAgdHJhbnNmb3JtWzFdID0gc3kgKiBzaW47XG4gIHRyYW5zZm9ybVsyXSA9IC1zeCAqIHNpbjtcbiAgdHJhbnNmb3JtWzNdID0gc3kgKiBjb3M7XG4gIHRyYW5zZm9ybVs0XSA9IGR4MiAqIHN4ICogY29zIC0gZHkyICogc3ggKiBzaW4gKyBkeDE7XG4gIHRyYW5zZm9ybVs1XSA9IGR4MiAqIHN5ICogc2luICsgZHkyICogc3kgKiBjb3MgKyBkeTE7XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cblxuLyoqXG4gKiBJbnZlcnQgdGhlIGdpdmVuIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEByZXR1cm4geyFUcmFuc2Zvcm19IEludmVyc2Ugb2YgdGhlIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydCh0cmFuc2Zvcm0pIHtcbiAgY29uc3QgZGV0ID0gZGV0ZXJtaW5hbnQodHJhbnNmb3JtKTtcbiAgYXNzZXJ0KGRldCAhPT0gMCwgMzIpOyAvLyBUcmFuc2Zvcm1hdGlvbiBtYXRyaXggY2Fubm90IGJlIGludmVydGVkXG5cbiAgY29uc3QgYSA9IHRyYW5zZm9ybVswXTtcbiAgY29uc3QgYiA9IHRyYW5zZm9ybVsxXTtcbiAgY29uc3QgYyA9IHRyYW5zZm9ybVsyXTtcbiAgY29uc3QgZCA9IHRyYW5zZm9ybVszXTtcbiAgY29uc3QgZSA9IHRyYW5zZm9ybVs0XTtcbiAgY29uc3QgZiA9IHRyYW5zZm9ybVs1XTtcblxuICB0cmFuc2Zvcm1bMF0gPSBkIC8gZGV0O1xuICB0cmFuc2Zvcm1bMV0gPSAtYiAvIGRldDtcbiAgdHJhbnNmb3JtWzJdID0gLWMgLyBkZXQ7XG4gIHRyYW5zZm9ybVszXSA9IGEgLyBkZXQ7XG4gIHRyYW5zZm9ybVs0XSA9IChjICogZiAtIGQgKiBlKSAvIGRldDtcbiAgdHJhbnNmb3JtWzVdID0gLShhICogZiAtIGIgKiBlKSAvIGRldDtcblxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgb2YgdGhlIGdpdmVuIG1hdHJpeC5cbiAqIEBwYXJhbSB7IVRyYW5zZm9ybX0gbWF0IE1hdHJpeC5cbiAqIEByZXR1cm4ge251bWJlcn0gRGV0ZXJtaW5hbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChtYXQpIHtcbiAgcmV0dXJuIG1hdFswXSAqIG1hdFszXSAtIG1hdFsxXSAqIG1hdFsyXTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCQTs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/sphere.js\nvar sphere = __webpack_require__(79);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./node_modules/ol/proj/Projection.js\nvar proj_Projection = __webpack_require__(60);\n\n// EXTERNAL MODULE: ./node_modules/ol/proj/Units.js\nvar Units = __webpack_require__(26);\n\n// CONCATENATED MODULE: ./node_modules/ol/proj/epsg3857.js\n/**\n * @module ol/proj/epsg3857\n */\n\n\n\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\n\nvar RADIUS = 6378137;\n/**\n * @const\n * @type {number}\n */\n\nvar HALF_SIZE = Math.PI * RADIUS;\n/**\n * @const\n * @type {import("../extent.js").Extent}\n */\n\nvar EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n/**\n * @const\n * @type {import("../extent.js").Extent}\n */\n\nvar WORLD_EXTENT = [-180, -85, 180, 85];\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\n\nvar epsg3857_EPSG3857Projection =\n/*@__PURE__*/\nfunction (Projection) {\n  function EPSG3857Projection(code) {\n    Projection.call(this, {\n      code: code,\n      units: Units["b" /* default */].METERS,\n      extent: EXTENT,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function getPointResolution(resolution, point) {\n        return resolution / Object(math["b" /* cosh */])(point[1] / RADIUS);\n      }\n    });\n  }\n\n  if (Projection) EPSG3857Projection.__proto__ = Projection;\n  EPSG3857Projection.prototype = Object.create(Projection && Projection.prototype);\n  EPSG3857Projection.prototype.constructor = EPSG3857Projection;\n  return EPSG3857Projection;\n}(proj_Projection["a" /* default */]);\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import("./Projection.js").default>}\n */\n\n\nvar PROJECTIONS = [new epsg3857_EPSG3857Projection(\'EPSG:3857\'), new epsg3857_EPSG3857Projection(\'EPSG:102100\'), new epsg3857_EPSG3857Projection(\'EPSG:102113\'), new epsg3857_EPSG3857Projection(\'EPSG:900913\'), new epsg3857_EPSG3857Projection(\'urn:ogc:def:crs:EPSG:6.18:3:3857\'), new epsg3857_EPSG3857Projection(\'urn:ogc:def:crs:EPSG::3857\'), new epsg3857_EPSG3857Projection(\'http://www.opengis.net/gml/srs/epsg.xml#3857\')];\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\n\nfunction fromEPSG4326(input, opt_output, opt_dimension) {\n  var length = input.length;\n  var dimension = opt_dimension > 1 ? opt_dimension : 2;\n  var output = opt_output;\n\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n\n  var halfSize = HALF_SIZE;\n\n  for (var i = 0; i < length; i += dimension) {\n    output[i] = halfSize * input[i] / 180;\n    var y = RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));\n\n    if (y > halfSize) {\n      y = halfSize;\n    } else if (y < -halfSize) {\n      y = -halfSize;\n    }\n\n    output[i + 1] = y;\n  }\n\n  return output;\n}\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\n\nfunction epsg3857_toEPSG4326(input, opt_output, opt_dimension) {\n  var length = input.length;\n  var dimension = opt_dimension > 1 ? opt_dimension : 2;\n  var output = opt_output;\n\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n\n  for (var i = 0; i < length; i += dimension) {\n    output[i] = 180 * input[i] / HALF_SIZE;\n    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;\n  }\n\n  return output;\n}\n// CONCATENATED MODULE: ./node_modules/ol/proj/epsg4326.js\n/**\n * @module ol/proj/epsg4326\n */\n\n\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\n\nvar epsg4326_RADIUS = 6378137;\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import("../extent.js").Extent}\n */\n\nvar epsg4326_EXTENT = [-180, -90, 180, 90];\n/**\n * @const\n * @type {number}\n */\n\nvar METERS_PER_UNIT = Math.PI * epsg4326_RADIUS / 180;\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\n\nvar epsg4326_EPSG4326Projection =\n/*@__PURE__*/\nfunction (Projection) {\n  function EPSG4326Projection(code, opt_axisOrientation) {\n    Projection.call(this, {\n      code: code,\n      units: Units["b" /* default */].DEGREES,\n      extent: epsg4326_EXTENT,\n      axisOrientation: opt_axisOrientation,\n      global: true,\n      metersPerUnit: METERS_PER_UNIT,\n      worldExtent: epsg4326_EXTENT\n    });\n  }\n\n  if (Projection) EPSG4326Projection.__proto__ = Projection;\n  EPSG4326Projection.prototype = Object.create(Projection && Projection.prototype);\n  EPSG4326Projection.prototype.constructor = EPSG4326Projection;\n  return EPSG4326Projection;\n}(proj_Projection["a" /* default */]);\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import("./Projection.js").default>}\n */\n\n\nvar epsg4326_PROJECTIONS = [new epsg4326_EPSG4326Projection(\'CRS:84\'), new epsg4326_EPSG4326Projection(\'EPSG:4326\', \'neu\'), new epsg4326_EPSG4326Projection(\'urn:ogc:def:crs:EPSG::4326\', \'neu\'), new epsg4326_EPSG4326Projection(\'urn:ogc:def:crs:EPSG:6.6:4326\', \'neu\'), new epsg4326_EPSG4326Projection(\'urn:ogc:def:crs:OGC:1.3:CRS84\'), new epsg4326_EPSG4326Projection(\'urn:ogc:def:crs:OGC:2:84\'), new epsg4326_EPSG4326Projection(\'http://www.opengis.net/gml/srs/epsg.xml#4326\', \'neu\'), new epsg4326_EPSG4326Projection(\'urn:x-ogc:def:crs:EPSG:4326\', \'neu\')];\n// CONCATENATED MODULE: ./node_modules/ol/proj/projections.js\n/**\n * @module ol/proj/projections\n */\n\n/**\n * @type {Object<string, import("./Projection.js").default>}\n */\nvar cache = {};\n/**\n * Clear the projections cache.\n */\n\nfunction clear() {\n  cache = {};\n}\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import("./Projection.js").default} The projection (if cached).\n */\n\nfunction get(code) {\n  return cache[code] || null;\n}\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import("./Projection.js").default} projection The projection to cache.\n */\n\nfunction add(code, projection) {\n  cache[code] = projection;\n}\n// EXTERNAL MODULE: ./node_modules/ol/proj/transforms.js\nvar transforms = __webpack_require__(50);\n\n// CONCATENATED MODULE: ./node_modules/ol/proj.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneTransform", function() { return cloneTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identityTransform", function() { return identityTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjection", function() { return addProjection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addProjections", function() { return addProjections; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return proj_get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointResolution", function() { return proj_getPointResolution; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentProjections", function() { return addEquivalentProjections; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEquivalentTransforms", function() { return addEquivalentTransforms; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearAllProjections", function() { return clearAllProjections; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createProjection", function() { return createProjection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createTransformFromCoordinateTransform", function() { return createTransformFromCoordinateTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCoordinateTransforms", function() { return addCoordinateTransforms; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromLonLat", function() { return fromLonLat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toLonLat", function() { return toLonLat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equivalent", function() { return equivalent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransformFromProjections", function() { return getTransformFromProjections; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransform", function() { return getTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformExtent", function() { return transformExtent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformWithProjections", function() { return transformWithProjections; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addCommon", function() { return addCommon; });\n/* concated harmony reexport METERS_PER_UNIT */__webpack_require__.d(__webpack_exports__, "METERS_PER_UNIT", function() { return Units["a" /* METERS_PER_UNIT */]; });\n/* concated harmony reexport Projection */__webpack_require__.d(__webpack_exports__, "Projection", function() { return proj_Projection["a" /* default */]; });\n/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4\'s registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don\'t\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get(\'EPSG:1234\').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection} object for the new projection and add it with\n * {@link module:ol/proj~addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj~addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection} with\n * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\n\n\n\n\n\n\n\n\n\n/**\n * A projection as {@link module:ol/proj/Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\n\n\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\n\nfunction cloneTransform(input, opt_output, opt_dimension) {\n  var output;\n\n  if (opt_output !== undefined) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n\n    output = opt_output;\n  } else {\n    output = input.slice();\n  }\n\n  return output;\n}\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\n\nfunction identityTransform(input, opt_output, opt_dimension) {\n  if (opt_output !== undefined && input !== opt_output) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n\n    input = opt_output;\n  }\n\n  return input;\n}\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\n\nfunction addProjection(projection) {\n  add(projection.getCode(), projection);\n  Object(transforms["a" /* add */])(projection, projection, cloneTransform);\n}\n/**\n * @param {Array<Projection>} projections Projections.\n */\n\nfunction addProjections(projections) {\n  projections.forEach(addProjection);\n}\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as "EPSG:4326", or an\n *     existing projection object, or undefined.\n * @return {Projection} Projection object, or null if not in list.\n * @api\n */\n\nfunction proj_get(projectionLike) {\n  return typeof projectionLike === \'string\' ? get(\n  /** @type {string} */\n  projectionLike) :\n  /** @type {Projection} */\n  projectionLike || null;\n}\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the \'point\' pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.\n * @param {Units=} opt_units Units to get the point resolution in.\n * Default is the projection\'s units.\n * @return {number} Point resolution.\n * @api\n */\n\nfunction proj_getPointResolution(projection, resolution, point, opt_units) {\n  projection = proj_get(projection);\n  var pointResolution;\n  var getter = projection.getPointResolutionFunc();\n\n  if (getter) {\n    pointResolution = getter(resolution, point);\n  } else {\n    var units = projection.getUnits();\n\n    if (units == Units["b" /* default */].DEGREES && !opt_units || opt_units == Units["b" /* default */].DEGREES) {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      var toEPSG4326 = getTransformFromProjections(projection, proj_get(\'EPSG:4326\'));\n      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];\n      vertices = toEPSG4326(vertices, vertices, 2);\n      var width = Object(sphere["a" /* getDistance */])(vertices.slice(0, 2), vertices.slice(2, 4));\n      var height = Object(sphere["a" /* getDistance */])(vertices.slice(4, 6), vertices.slice(6, 8));\n      pointResolution = (width + height) / 2;\n      var metersPerUnit = opt_units ? Units["a" /* METERS_PER_UNIT */][opt_units] : projection.getMetersPerUnit();\n\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n\n  return pointResolution;\n}\n/**\n * Registers transformation functions that don\'t alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\n\nfunction addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        Object(transforms["a" /* add */])(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\n\nfunction addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      Object(transforms["a" /* add */])(projection1, projection2, forwardTransform);\n      Object(transforms["a" /* add */])(projection2, projection1, inverseTransform);\n    });\n  });\n}\n/**\n * Clear all cached projections and transforms.\n */\n\nfunction clearAllProjections() {\n  clear();\n  Object(transforms["b" /* clear */])();\n}\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\n\nfunction createProjection(projection, defaultCode) {\n  if (!projection) {\n    return proj_get(defaultCode);\n  } else if (typeof projection === \'string\') {\n    return proj_get(projection);\n  } else {\n    return (\n      /** @type {Projection} */\n      projection\n    );\n  }\n}\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\n\nfunction createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>=} opt_output Output.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, opt_output, opt_dimension) {\n      var length = input.length;\n      var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n      var output = opt_output !== undefined ? opt_output : new Array(length);\n\n      for (var i = 0; i < length; i += dimension) {\n        var point = coordTransform([input[i], input[i + 1]]);\n        output[i] = point[0];\n        output[i + 1] = point[1];\n\n        for (var j = dimension - 1; j >= 2; --j) {\n          output[i + j] = input[i + j];\n        }\n      }\n\n      return output;\n    }\n  );\n}\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @api\n */\n\nfunction addCoordinateTransforms(source, destination, forward, inverse) {\n  var sourceProj = proj_get(source);\n  var destProj = proj_get(destination);\n  Object(transforms["a" /* add */])(sourceProj, destProj, createTransformFromCoordinateTransform(forward));\n  Object(transforms["a" /* add */])(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));\n}\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike=} opt_projection Target projection. The\n *     default is Web Mercator, i.e. \'EPSG:3857\'.\n * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.\n * @api\n */\n\nfunction fromLonLat(coordinate, opt_projection) {\n  return transform(coordinate, \'EPSG:4326\', opt_projection !== undefined ? opt_projection : \'EPSG:3857\');\n}\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike=} opt_projection Projection of the coordinate.\n *     The default is Web Mercator, i.e. \'EPSG:3857\'.\n * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\n\nfunction toLonLat(coordinate, opt_projection) {\n  var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : \'EPSG:3857\', \'EPSG:4326\');\n  var lon = lonLat[0];\n\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = Object(math["d" /* modulo */])(lon + 180, 360) - 180;\n  }\n\n  return lonLat;\n}\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\n\nfunction equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n\n  var equalUnits = projection1.getUnits() === projection2.getUnits();\n\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    var transformFunc = getTransformFromProjections(projection1, projection2);\n    return transformFunc === cloneTransform && equalUnits;\n  }\n}\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\n\nfunction getTransformFromProjections(sourceProjection, destinationProjection) {\n  var sourceCode = sourceProjection.getCode();\n  var destinationCode = destinationProjection.getCode();\n  var transformFunc = Object(transforms["c" /* get */])(sourceCode, destinationCode);\n\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n\n  return transformFunc;\n}\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\n\nfunction getTransform(source, destination) {\n  var sourceProjection = proj_get(source);\n  var destinationProjection = proj_get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj~transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import("./coordinate.js").Coordinate} Coordinate.\n * @api\n */\n\nfunction transform(coordinate, source, destination) {\n  var transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import("./extent.js").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import("./extent.js").Extent} The transformed extent.\n * @api\n */\n\nfunction transformExtent(extent, source, destination) {\n  var transformFunc = getTransform(source, destination);\n  return Object(ol_extent["applyTransform"])(extent, transformFunc);\n}\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import("./coordinate.js").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import("./coordinate.js").Coordinate} Point.\n */\n\nfunction transformWithProjections(point, sourceProjection, destinationProjection) {\n  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);\n  return transformFunc(point);\n}\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\n\nfunction addCommon() {\n  // Add transformations that don\'t alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(PROJECTIONS);\n  addEquivalentProjections(epsg4326_PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n\n  addEquivalentTransforms(epsg4326_PROJECTIONS, PROJECTIONS, fromEPSG4326, epsg3857_toEPSG4326);\n}\naddCommon();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3Byb2ovZXBzZzM4NTcuanM/YjlkNiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3Byb2ovZXBzZzQzMjYuanM/ZmNhZCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3Byb2ovcHJvamVjdGlvbnMuanM/MmVlOCIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL3Byb2ouanM/ZWM3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9lcHNnMzg1N1xuICovXG5pbXBvcnQge2Nvc2h9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuL1VuaXRzLmpzJztcblxuXG4vKipcbiAqIFJhZGl1cyBvZiBXR1M4NCBzcGhlcmVcbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBSQURJVVMgPSA2Mzc4MTM3O1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgSEFMRl9TSVpFID0gTWF0aC5QSSAqIFJBRElVUztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFTlQgPSBbXG4gIC1IQUxGX1NJWkUsIC1IQUxGX1NJWkUsXG4gIEhBTEZfU0laRSwgSEFMRl9TSVpFXG5dO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IFdPUkxEX0VYVEVOVCA9IFstMTgwLCAtODUsIDE4MCwgODVdO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvamVjdGlvbiBvYmplY3QgZm9yIHdlYi9zcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKi9cbmNsYXNzIEVQU0czODU3UHJvamVjdGlvbiBleHRlbmRzIFByb2plY3Rpb24ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBDb2RlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICB1bml0czogVW5pdHMuTUVURVJTLFxuICAgICAgZXh0ZW50OiBFWFRFTlQsXG4gICAgICBnbG9iYWw6IHRydWUsXG4gICAgICB3b3JsZEV4dGVudDogV09STERfRVhURU5ULFxuICAgICAgZ2V0UG9pbnRSZXNvbHV0aW9uOiBmdW5jdGlvbihyZXNvbHV0aW9uLCBwb2ludCkge1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbiAvIGNvc2gocG9pbnRbMV0gLyBSQURJVVMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH1cblxufVxuXG5cbi8qKlxuICogUHJvamVjdGlvbnMgZXF1YWwgdG8gRVBTRzozODU3LlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBST0pFQ1RJT05TID0gW1xuICBuZXcgRVBTRzM4NTdQcm9qZWN0aW9uKCdFUFNHOjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzoxMDIxMDAnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzoxMDIxMTMnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignRVBTRzo5MDA5MTMnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6Ni4xODozOjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjM4NTcnKSxcbiAgbmV3IEVQU0czODU3UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzM4NTcnKVxuXTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybWF0aW9uIGZyb20gRVBTRzo0MzI2IHRvIEVQU0c6Mzg1Ny5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IElucHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaW1lbnNpb24gRGltZW5zaW9uIChkZWZhdWx0IGlzIGAyYCkuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRVBTRzQzMjYoaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBkaW1lbnNpb24gPSBvcHRfZGltZW5zaW9uID4gMSA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICBsZXQgb3V0cHV0ID0gb3B0X291dHB1dDtcbiAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRpbWVuc2lvbiA+IDIpIHtcbiAgICAgIC8vIHByZXNlcnZlIHZhbHVlcyBiZXlvbmQgc2Vjb25kIGRpbWVuc2lvblxuICAgICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhbGZTaXplID0gSEFMRl9TSVpFO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBkaW1lbnNpb24pIHtcbiAgICBvdXRwdXRbaV0gPSBoYWxmU2l6ZSAqIGlucHV0W2ldIC8gMTgwO1xuICAgIGxldCB5ID0gUkFESVVTICpcbiAgICAgICAgTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAqIChpbnB1dFtpICsgMV0gKyA5MCkgLyAzNjApKTtcbiAgICBpZiAoeSA+IGhhbGZTaXplKSB7XG4gICAgICB5ID0gaGFsZlNpemU7XG4gICAgfSBlbHNlIGlmICh5IDwgLWhhbGZTaXplKSB7XG4gICAgICB5ID0gLWhhbGZTaXplO1xuICAgIH1cbiAgICBvdXRwdXRbaSArIDFdID0geTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtYXRpb24gZnJvbSBFUFNHOjM4NTcgdG8gRVBTRzo0MzI2LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgYXJyYXkgb2YgY29vcmRpbmF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfb3V0cHV0IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2RpbWVuc2lvbiBEaW1lbnNpb24gKGRlZmF1bHQgaXMgYDJgKS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dCBhcnJheSBvZiBjb29yZGluYXRlIHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRVBTRzQzMjYoaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICBjb25zdCBkaW1lbnNpb24gPSBvcHRfZGltZW5zaW9uID4gMSA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICBsZXQgb3V0cHV0ID0gb3B0X291dHB1dDtcbiAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRpbWVuc2lvbiA+IDIpIHtcbiAgICAgIC8vIHByZXNlcnZlIHZhbHVlcyBiZXlvbmQgc2Vjb25kIGRpbWVuc2lvblxuICAgICAgb3V0cHV0ID0gaW5wdXQuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGRpbWVuc2lvbikge1xuICAgIG91dHB1dFtpXSA9IDE4MCAqIGlucHV0W2ldIC8gSEFMRl9TSVpFO1xuICAgIG91dHB1dFtpICsgMV0gPSAzNjAgKiBNYXRoLmF0YW4oXG4gICAgICBNYXRoLmV4cChpbnB1dFtpICsgMV0gLyBSQURJVVMpKSAvIE1hdGguUEkgLSA5MDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovZXBzZzQzMjZcbiAqL1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuL1VuaXRzLmpzJztcblxuXG4vKipcbiAqIFNlbWktbWFqb3IgcmFkaXVzIG9mIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgUkFESVVTID0gNjM3ODEzNztcblxuXG4vKipcbiAqIEV4dGVudCBvZiB0aGUgRVBTRzo0MzI2IHByb2plY3Rpb24gd2hpY2ggaXMgdGhlIHdob2xlIHdvcmxkLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBFWFRFTlQgPSBbLTE4MCwgLTkwLCAxODAsIDkwXTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IE1FVEVSU19QRVJfVU5JVCA9IE1hdGguUEkgKiBSQURJVVMgLyAxODA7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIG9iamVjdCBmb3IgV0dTODQgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyAoRVBTRzo0MzI2KS5cbiAqXG4gKiBOb3RlIHRoYXQgT3BlbkxheWVycyBkb2VzIG5vdCBzdHJpY3RseSBjb21wbHkgd2l0aCB0aGUgRVBTRyBkZWZpbml0aW9uLlxuICogVGhlIEVQU0cgcmVnaXN0cnkgZGVmaW5lcyA0MzI2IGFzIGEgQ1JTIGZvciBMYXRpdHVkZSxMb25naXR1ZGUgKHkseCkuXG4gKiBPcGVuTGF5ZXJzIHRyZWF0cyBFUFNHOjQzMjYgYXMgYSBwc2V1ZG8tcHJvamVjdGlvbiwgd2l0aCB4LHkgY29vcmRpbmF0ZXMuXG4gKi9cbmNsYXNzIEVQU0c0MzI2UHJvamVjdGlvbiBleHRlbmRzIFByb2plY3Rpb24ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZSBDb2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9heGlzT3JpZW50YXRpb24gQXhpcyBvcmllbnRhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGUsIG9wdF9heGlzT3JpZW50YXRpb24pIHtcbiAgICBzdXBlcih7XG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgdW5pdHM6IFVuaXRzLkRFR1JFRVMsXG4gICAgICBleHRlbnQ6IEVYVEVOVCxcbiAgICAgIGF4aXNPcmllbnRhdGlvbjogb3B0X2F4aXNPcmllbnRhdGlvbixcbiAgICAgIGdsb2JhbDogdHJ1ZSxcbiAgICAgIG1ldGVyc1BlclVuaXQ6IE1FVEVSU19QRVJfVU5JVCxcbiAgICAgIHdvcmxkRXh0ZW50OiBFWFRFTlRcbiAgICB9KTtcblxuICB9XG5cbn1cblxuXG4vKipcbiAqIFByb2plY3Rpb25zIGVxdWFsIHRvIEVQU0c6NDMyNi5cbiAqXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmV4cG9ydCBjb25zdCBQUk9KRUNUSU9OUyA9IFtcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignQ1JTOjg0JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ0VQU0c6NDMyNicsICduZXUnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbigndXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3VybjpvZ2M6ZGVmOmNyczpFUFNHOjYuNjo0MzI2JywgJ25ldScpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6T0dDOjEuMzpDUlM4NCcpLFxuICBuZXcgRVBTRzQzMjZQcm9qZWN0aW9uKCd1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQnKSxcbiAgbmV3IEVQU0c0MzI2UHJvamVjdGlvbignaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYnLCAnbmV1JyksXG4gIG5ldyBFUFNHNDMyNlByb2plY3Rpb24oJ3Vybjp4LW9nYzpkZWY6Y3JzOkVQU0c6NDMyNicsICduZXUnKVxuXTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3Byb2plY3Rpb25zXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD59XG4gKi9cbmxldCBjYWNoZSA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXIgdGhlIHByb2plY3Rpb25zIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGNhY2hlID0ge307XG59XG5cblxuLyoqXG4gKiBHZXQgYSBjYWNoZWQgcHJvamVjdGlvbiBieSBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGUgVGhlIGNvZGUgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFRoZSBwcm9qZWN0aW9uIChpZiBjYWNoZWQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGNvZGUpIHtcbiAgcmV0dXJuIGNhY2hlW2NvZGVdIHx8IG51bGw7XG59XG5cblxuLyoqXG4gKiBBZGQgYSBwcm9qZWN0aW9uIHRvIHRoZSBjYWNoZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIFRoZSBwcm9qZWN0aW9uIGNvZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFRoZSBwcm9qZWN0aW9uIHRvIGNhY2hlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKGNvZGUsIHByb2plY3Rpb24pIHtcbiAgY2FjaGVbY29kZV0gPSBwcm9qZWN0aW9uO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2pcbiAqL1xuXG4vKipcbiAqIFRoZSBvbC9wcm9qIG1vZHVsZSBzdG9yZXM6XG4gKiAqIGEgbGlzdCBvZiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn1cbiAqIG9iamVjdHMsIG9uZSBmb3IgZWFjaCBwcm9qZWN0aW9uIHN1cHBvcnRlZCBieSB0aGUgYXBwbGljYXRpb25cbiAqICogYSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgbmVlZGVkIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgaW4gb25lIHByb2plY3Rpb25cbiAqIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgc3RhdGljIGZ1bmN0aW9ucyBhcmUgdGhlIG1ldGhvZHMgdXNlZCB0byBtYWludGFpbiB0aGVzZS5cbiAqIEVhY2ggdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbiBoYW5kbGUgbm90IG9ubHkgc2ltcGxlIGNvb3JkaW5hdGUgcGFpcnMsIGJ1dCBhbHNvXG4gKiBsYXJnZSBhcnJheXMgb2YgY29vcmRpbmF0ZXMgc3VjaCBhcyB2ZWN0b3IgZ2VvbWV0cmllcy5cbiAqXG4gKiBXaGVuIGxvYWRlZCwgdGhlIGxpYnJhcnkgYWRkcyBwcm9qZWN0aW9uIG9iamVjdHMgZm9yIEVQU0c6NDMyNiAoV0dTODRcbiAqIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMpIGFuZCBFUFNHOjM4NTcgKFdlYiBvciBTcGhlcmljYWwgTWVyY2F0b3IsIGFzIHVzZWRcbiAqIGZvciBleGFtcGxlIGJ5IEJpbmcgTWFwcyBvciBPcGVuU3RyZWV0TWFwKSwgdG9nZXRoZXIgd2l0aCB0aGUgcmVsZXZhbnRcbiAqIHRyYW5zZm9ybSBmdW5jdGlvbnMuXG4gKlxuICogQWRkaXRpb25hbCB0cmFuc2Zvcm1zIG1heSBiZSBhZGRlZCBieSB1c2luZyB0aGUgaHR0cDovL3Byb2o0anMub3JnL1xuICogbGlicmFyeSAodmVyc2lvbiAyLjIgb3IgbGF0ZXIpLiBZb3UgY2FuIHVzZSB0aGUgZnVsbCBidWlsZCBzdXBwbGllZCBieVxuICogUHJvajRqcywgb3IgY3JlYXRlIGEgY3VzdG9tIGJ1aWxkIHRvIHN1cHBvcnQgdGhvc2UgcHJvamVjdGlvbnMgeW91IG5lZWQ7IHNlZVxuICogdGhlIFByb2o0anMgd2Vic2l0ZSBmb3IgaG93IHRvIGRvIHRoaXMuIFlvdSBhbHNvIG5lZWQgdGhlIFByb2o0anMgZGVmaW5pdGlvbnNcbiAqIGZvciB0aGUgcmVxdWlyZWQgcHJvamVjdGlvbnMuIFRoZXNlIGRlZmluaXRpb25zIGNhbiBiZSBvYnRhaW5lZCBmcm9tXG4gKiBodHRwczovL2Vwc2cuaW8vLCBhbmQgYXJlIGEgSlMgZnVuY3Rpb24sIHNvIGNhbiBiZSBsb2FkZWQgaW4gYSBzY3JpcHRcbiAqIHRhZyAoYXMgaW4gdGhlIGV4YW1wbGVzKSBvciBwYXN0ZWQgaW50byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIEFmdGVyIGFsbCByZXF1aXJlZCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGFyZSBhZGRlZCB0byBwcm9qNCdzIHJlZ2lzdHJ5IChieVxuICogdXNpbmcgYHByb2o0LmRlZnMoKWApLCBzaW1wbHkgY2FsbCBgcmVnaXN0ZXIocHJvajQpYCBmcm9tIHRoZSBgb2wvcHJvai9wcm9qNGBcbiAqIHBhY2thZ2UuIEV4aXN0aW5nIHRyYW5zZm9ybXMgYXJlIG5vdCBjaGFuZ2VkIGJ5IHRoaXMgZnVuY3Rpb24uIFNlZVxuICogZXhhbXBsZXMvd21zLWltYWdlLWN1c3RvbS1wcm9qIGZvciBhbiBleGFtcGxlIG9mIHRoaXMuXG4gKlxuICogQWRkaXRpb25hbCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGNhbiBiZSByZWdpc3RlcmVkIHdpdGggYHByb2o0LmRlZnMoKWAgYW55XG4gKiB0aW1lLiBKdXN0IG1ha2Ugc3VyZSB0byBjYWxsIGByZWdpc3Rlcihwcm9qNClgIGFnYWluOyBmb3IgZXhhbXBsZSwgd2l0aCB1c2VyLXN1cHBsaWVkIGRhdGEgd2hlcmUgeW91IGRvbid0XG4gKiBrbm93IGluIGFkdmFuY2Ugd2hhdCBwcm9qZWN0aW9ucyBhcmUgbmVlZGVkLCB5b3UgY2FuIGluaXRpYWxseSBsb2FkIG1pbmltYWxcbiAqIHN1cHBvcnQgYW5kIHRoZW4gbG9hZCB3aGljaGV2ZXIgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBOb3RlIHRoYXQgUHJvajRqcyBkb2VzIG5vdCBzdXBwb3J0IHByb2plY3Rpb24gZXh0ZW50cy4gSWYgeW91IHdhbnQgdG8gYWRkXG4gKiBvbmUgZm9yIGNyZWF0aW5nIGRlZmF1bHQgdGlsZSBncmlkcywgeW91IGNhbiBhZGQgaXQgYWZ0ZXIgdGhlIFByb2plY3Rpb25cbiAqIG9iamVjdCBoYXMgYmVlbiBjcmVhdGVkIHdpdGggYHNldEV4dGVudGAsIGZvciBleGFtcGxlLFxuICogYGdldCgnRVBTRzoxMjM0Jykuc2V0RXh0ZW50KGV4dGVudClgLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIFByb2o0anMgc3VwcG9ydCwgYW55IHRyYW5zZm9ybSBmdW5jdGlvbnMgY2FuIGJlIGFkZGVkIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvan5hZGRDb29yZGluYXRlVHJhbnNmb3Jtc30uIFRvIHVzZSB0aGlzLCB5b3UgbXVzdCBmaXJzdCBjcmVhdGVcbiAqIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IG9iamVjdCBmb3IgdGhlIG5ldyBwcm9qZWN0aW9uIGFuZCBhZGQgaXQgd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZFByb2plY3Rpb259LiBZb3UgY2FuIHRoZW4gYWRkIHRoZSBmb3J3YXJkIGFuZCBpbnZlcnNlXG4gKiBmdW5jdGlvbnMgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL3Byb2p+YWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXN9LiBTZWVcbiAqIGV4YW1wbGVzL3dtcy1jdXN0b20tcHJvaiBmb3IgYW4gZXhhbXBsZSBvZiB0aGlzLlxuICpcbiAqIE5vdGUgdGhhdCBpZiBubyB0cmFuc2Zvcm1zIGFyZSBuZWVkZWQgYW5kIHlvdSBvbmx5IG5lZWQgdG8gZGVmaW5lIHRoZVxuICogcHJvamVjdGlvbiwganVzdCBhZGQgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gd2l0aFxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qfmFkZFByb2plY3Rpb259LiBTZWUgZXhhbXBsZXMvd21zLW5vLXByb2ogZm9yIGFuIGV4YW1wbGUgb2ZcbiAqIHRoaXMuXG4gKi9cbmltcG9ydCB7Z2V0RGlzdGFuY2V9IGZyb20gJy4vc3BoZXJlLmpzJztcbmltcG9ydCB7YXBwbHlUcmFuc2Zvcm19IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHt0b0VQU0c0MzI2LCBmcm9tRVBTRzQzMjYsIFBST0pFQ1RJT05TIGFzIEVQU0czODU3X1BST0pFQ1RJT05TfSBmcm9tICcuL3Byb2ovZXBzZzM4NTcuanMnO1xuaW1wb3J0IHtQUk9KRUNUSU9OUyBhcyBFUFNHNDMyNl9QUk9KRUNUSU9OU30gZnJvbSAnLi9wcm9qL2Vwc2c0MzI2LmpzJztcbmltcG9ydCBQcm9qZWN0aW9uIGZyb20gJy4vcHJvai9Qcm9qZWN0aW9uLmpzJztcbmltcG9ydCBVbml0cywge01FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9wcm9qL1VuaXRzLmpzJztcbmltcG9ydCAqIGFzIHByb2plY3Rpb25zIGZyb20gJy4vcHJvai9wcm9qZWN0aW9ucy5qcyc7XG5pbXBvcnQge2FkZCBhcyBhZGRUcmFuc2Zvcm1GdW5jLCBjbGVhciBhcyBjbGVhclRyYW5zZm9ybUZ1bmNzLCBnZXQgYXMgZ2V0VHJhbnNmb3JtRnVuY30gZnJvbSAnLi9wcm9qL3RyYW5zZm9ybXMuanMnO1xuXG5cbi8qKlxuICogQSBwcm9qZWN0aW9uIGFzIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSwgU1JTIGlkZW50aWZpZXJcbiAqIHN0cmluZyBvciB1bmRlZmluZWQuXG4gKiBAdHlwZWRlZiB7UHJvamVjdGlvbnxzdHJpbmd8dW5kZWZpbmVkfSBQcm9qZWN0aW9uTGlrZVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBBIHRyYW5zZm9ybSBmdW5jdGlvbiBhY2NlcHRzIGFuIGFycmF5IG9mIGlucHV0IGNvb3JkaW5hdGUgdmFsdWVzLCBhbiBvcHRpb25hbFxuICogb3V0cHV0IGFycmF5LCBhbmQgYW4gb3B0aW9uYWwgZGltZW5zaW9uIChkZWZhdWx0IHNob3VsZCBiZSAyKS4gIFRoZSBmdW5jdGlvblxuICogdHJhbnNmb3JtcyB0aGUgaW5wdXQgY29vcmRpbmF0ZSB2YWx1ZXMsIHBvcHVsYXRlcyB0aGUgb3V0cHV0IGFycmF5LCBhbmRcbiAqIHJldHVybnMgdGhlIG91dHB1dCBhcnJheS5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oQXJyYXk8bnVtYmVyPiwgQXJyYXk8bnVtYmVyPj0sIG51bWJlcj0pOiBBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1GdW5jdGlvblxuICogQGFwaVxuICovXG5cblxuZXhwb3J0IHtNRVRFUlNfUEVSX1VOSVR9O1xuXG5leHBvcnQge1Byb2plY3Rpb259O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9vdXRwdXQgT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGltZW5zaW9uIERpbWVuc2lvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IE91dHB1dCBjb29yZGluYXRlIGFycmF5IChuZXcgYXJyYXksIHNhbWUgY29vcmRpbmF0ZVxuICogICAgIHZhbHVlcykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVRyYW5zZm9ybShpbnB1dCwgb3B0X291dHB1dCwgb3B0X2RpbWVuc2lvbikge1xuICBsZXQgb3V0cHV0O1xuICBpZiAob3B0X291dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgb3B0X291dHB1dFtpXSA9IGlucHV0W2ldO1xuICAgIH1cbiAgICBvdXRwdXQgPSBvcHRfb3V0cHV0O1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGlucHV0LnNsaWNlKCk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQgY29vcmRpbmF0ZSBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9vdXRwdXQgT3V0cHV0IGFycmF5IG9mIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGltZW5zaW9uIERpbWVuc2lvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IElucHV0IGNvb3JkaW5hdGUgYXJyYXkgKHNhbWUgYXJyYXkgYXMgaW5wdXQpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHlUcmFuc2Zvcm0oaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgaWYgKG9wdF9vdXRwdXQgIT09IHVuZGVmaW5lZCAmJiBpbnB1dCAhPT0gb3B0X291dHB1dCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGlucHV0Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9wdF9vdXRwdXRbaV0gPSBpbnB1dFtpXTtcbiAgICB9XG4gICAgaW5wdXQgPSBvcHRfb3V0cHV0O1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cblxuXG4vKipcbiAqIEFkZCBhIFByb2plY3Rpb24gb2JqZWN0IHRvIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBwcm9qZWN0aW9ucyB0aGF0IGNhbiBiZVxuICogbG9va2VkIHVwIGJ5IHRoZWlyIGNvZGUuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBwcm9qZWN0aW9uIFByb2plY3Rpb24gaW5zdGFuY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgcHJvamVjdGlvbnMuYWRkKHByb2plY3Rpb24uZ2V0Q29kZSgpLCBwcm9qZWN0aW9uKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhwcm9qZWN0aW9uLCBwcm9qZWN0aW9uLCBjbG9uZVRyYW5zZm9ybSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFByb2plY3Rpb24+fSBwcm9qZWN0aW9ucyBQcm9qZWN0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFByb2plY3Rpb25zKHByb2plY3Rpb25zKSB7XG4gIHByb2plY3Rpb25zLmZvckVhY2goYWRkUHJvamVjdGlvbik7XG59XG5cblxuLyoqXG4gKiBGZXRjaGVzIGEgUHJvamVjdGlvbiBvYmplY3QgZm9yIHRoZSBjb2RlIHNwZWNpZmllZC5cbiAqXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBwcm9qZWN0aW9uTGlrZSBFaXRoZXIgYSBjb2RlIHN0cmluZyB3aGljaCBpc1xuICogICAgIGEgY29tYmluYXRpb24gb2YgYXV0aG9yaXR5IGFuZCBpZGVudGlmaWVyIHN1Y2ggYXMgXCJFUFNHOjQzMjZcIiwgb3IgYW5cbiAqICAgICBleGlzdGluZyBwcm9qZWN0aW9uIG9iamVjdCwgb3IgdW5kZWZpbmVkLlxuICogQHJldHVybiB7UHJvamVjdGlvbn0gUHJvamVjdGlvbiBvYmplY3QsIG9yIG51bGwgaWYgbm90IGluIGxpc3QuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQocHJvamVjdGlvbkxpa2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9qZWN0aW9uTGlrZSA9PT0gJ3N0cmluZycgP1xuICAgIHByb2plY3Rpb25zLmdldCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHByb2plY3Rpb25MaWtlKSkgOlxuICAgICgvKiogQHR5cGUge1Byb2plY3Rpb259ICovIChwcm9qZWN0aW9uTGlrZSkgfHwgbnVsbCk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHJlc29sdXRpb24gb2YgdGhlIHBvaW50IGluIGRlZ3JlZXMgb3IgZGlzdGFuY2UgdW5pdHMuXG4gKiBGb3IgcHJvamVjdGlvbnMgd2l0aCBkZWdyZWVzIGFzIHRoZSB1bml0IHRoaXMgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZVxuICogcHJvdmlkZWQgcmVzb2x1dGlvbi4gRm9yIG90aGVyIHByb2plY3Rpb25zIHRoZSBwb2ludCByZXNvbHV0aW9uIGlzXG4gKiBieSBkZWZhdWx0IGVzdGltYXRlZCBieSB0cmFuc2Zvcm1pbmcgdGhlICdwb2ludCcgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICogbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLFxuICogYW5kIHRha2luZyB0aGUgYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAqIEEgY3VzdG9tIGZ1bmN0aW9uIGNhbiBiZSBwcm92aWRlZCBmb3IgYSBzcGVjaWZpYyBwcm9qZWN0aW9uLCBlaXRoZXJcbiAqIGJ5IHNldHRpbmcgdGhlIGBnZXRQb2ludFJlc29sdXRpb25gIG9wdGlvbiBpbiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IGNvbnN0cnVjdG9yIG9yIGJ5IHVzaW5nXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9uI3NldEdldFBvaW50UmVzb2x1dGlvbn0gdG8gY2hhbmdlIGFuIGV4aXN0aW5nXG4gKiBwcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gVGhlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBOb21pbmFsIHJlc29sdXRpb24gaW4gcHJvamVjdGlvbiB1bml0cy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50IHRvIGZpbmQgYWRqdXN0ZWQgcmVzb2x1dGlvbiBhdC5cbiAqIEBwYXJhbSB7VW5pdHM9fSBvcHRfdW5pdHMgVW5pdHMgdG8gZ2V0IHRoZSBwb2ludCByZXNvbHV0aW9uIGluLlxuICogRGVmYXVsdCBpcyB0aGUgcHJvamVjdGlvbidzIHVuaXRzLlxuICogQHJldHVybiB7bnVtYmVyfSBQb2ludCByZXNvbHV0aW9uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9pbnRSZXNvbHV0aW9uKHByb2plY3Rpb24sIHJlc29sdXRpb24sIHBvaW50LCBvcHRfdW5pdHMpIHtcbiAgcHJvamVjdGlvbiA9IGdldChwcm9qZWN0aW9uKTtcbiAgbGV0IHBvaW50UmVzb2x1dGlvbjtcbiAgY29uc3QgZ2V0dGVyID0gcHJvamVjdGlvbi5nZXRQb2ludFJlc29sdXRpb25GdW5jKCk7XG4gIGlmIChnZXR0ZXIpIHtcbiAgICBwb2ludFJlc29sdXRpb24gPSBnZXR0ZXIocmVzb2x1dGlvbiwgcG9pbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHVuaXRzID0gcHJvamVjdGlvbi5nZXRVbml0cygpO1xuICAgIGlmICh1bml0cyA9PSBVbml0cy5ERUdSRUVTICYmICFvcHRfdW5pdHMgfHwgb3B0X3VuaXRzID09IFVuaXRzLkRFR1JFRVMpIHtcbiAgICAgIHBvaW50UmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVzdGltYXRlIHBvaW50IHJlc29sdXRpb24gYnkgdHJhbnNmb3JtaW5nIHRoZSBjZW50ZXIgcGl4ZWwgdG8gRVBTRzo0MzI2LFxuICAgICAgLy8gbWVhc3VyaW5nIGl0cyB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSBub3JtYWwgc3BoZXJlLCBhbmQgdGFraW5nIHRoZVxuICAgICAgLy8gYXZlcmFnZSBvZiB0aGUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgIGNvbnN0IHRvRVBTRzQzMjYgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMocHJvamVjdGlvbiwgZ2V0KCdFUFNHOjQzMjYnKSk7XG4gICAgICBsZXQgdmVydGljZXMgPSBbXG4gICAgICAgIHBvaW50WzBdIC0gcmVzb2x1dGlvbiAvIDIsIHBvaW50WzFdLFxuICAgICAgICBwb2ludFswXSArIHJlc29sdXRpb24gLyAyLCBwb2ludFsxXSxcbiAgICAgICAgcG9pbnRbMF0sIHBvaW50WzFdIC0gcmVzb2x1dGlvbiAvIDIsXG4gICAgICAgIHBvaW50WzBdLCBwb2ludFsxXSArIHJlc29sdXRpb24gLyAyXG4gICAgICBdO1xuICAgICAgdmVydGljZXMgPSB0b0VQU0c0MzI2KHZlcnRpY2VzLCB2ZXJ0aWNlcywgMik7XG4gICAgICBjb25zdCB3aWR0aCA9IGdldERpc3RhbmNlKHZlcnRpY2VzLnNsaWNlKDAsIDIpLCB2ZXJ0aWNlcy5zbGljZSgyLCA0KSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBnZXREaXN0YW5jZSh2ZXJ0aWNlcy5zbGljZSg0LCA2KSwgdmVydGljZXMuc2xpY2UoNiwgOCkpO1xuICAgICAgcG9pbnRSZXNvbHV0aW9uID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG4gICAgICBjb25zdCBtZXRlcnNQZXJVbml0ID0gb3B0X3VuaXRzID9cbiAgICAgICAgTUVURVJTX1BFUl9VTklUW29wdF91bml0c10gOlxuICAgICAgICBwcm9qZWN0aW9uLmdldE1ldGVyc1BlclVuaXQoKTtcbiAgICAgIGlmIChtZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9pbnRSZXNvbHV0aW9uIC89IG1ldGVyc1BlclVuaXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwb2ludFJlc29sdXRpb247XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRoYXQgZG9uJ3QgYWx0ZXIgY29vcmRpbmF0ZXMuIFRob3NlIGFsbG93XG4gKiB0byB0cmFuc2Zvcm0gYmV0d2VlbiBwcm9qZWN0aW9ucyB3aXRoIGVxdWFsIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMgUHJvamVjdGlvbnMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMocHJvamVjdGlvbnMpIHtcbiAgYWRkUHJvamVjdGlvbnMocHJvamVjdGlvbnMpO1xuICBwcm9qZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHByb2plY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oZGVzdGluYXRpb24pIHtcbiAgICAgIGlmIChzb3VyY2UgIT09IGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGFkZFRyYW5zZm9ybUZ1bmMoc291cmNlLCBkZXN0aW5hdGlvbiwgY2xvbmVUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gY29udmVydCBjb29yZGluYXRlcyBpbiBhbnkgcHJvamVjdGlvblxuICogaW4gcHJvamVjdGlvbjEgdG8gYW55IHByb2plY3Rpb24gaW4gcHJvamVjdGlvbjIuXG4gKlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMxIFByb2plY3Rpb25zIHdpdGggZXF1YWxcbiAqICAgICBtZWFuaW5nLlxuICogQHBhcmFtIHtBcnJheTxQcm9qZWN0aW9uPn0gcHJvamVjdGlvbnMyIFByb2plY3Rpb25zIHdpdGggZXF1YWxcbiAqICAgICBtZWFuaW5nLlxuICogQHBhcmFtIHtUcmFuc2Zvcm1GdW5jdGlvbn0gZm9yd2FyZFRyYW5zZm9ybSBUcmFuc2Zvcm1hdGlvbiBmcm9tIGFueVxuICogICBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24xIHRvIGFueSBwcm9qZWN0aW9uIGluIHByb2plY3Rpb24yLlxuICogQHBhcmFtIHtUcmFuc2Zvcm1GdW5jdGlvbn0gaW52ZXJzZVRyYW5zZm9ybSBUcmFuc2Zvcm0gZnJvbSBhbnkgcHJvamVjdGlvblxuICogICBpbiBwcm9qZWN0aW9uMiB0byBhbnkgcHJvamVjdGlvbiBpbiBwcm9qZWN0aW9uMS4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRFcXVpdmFsZW50VHJhbnNmb3Jtcyhwcm9qZWN0aW9uczEsIHByb2plY3Rpb25zMiwgZm9yd2FyZFRyYW5zZm9ybSwgaW52ZXJzZVRyYW5zZm9ybSkge1xuICBwcm9qZWN0aW9uczEuZm9yRWFjaChmdW5jdGlvbihwcm9qZWN0aW9uMSkge1xuICAgIHByb2plY3Rpb25zMi5mb3JFYWNoKGZ1bmN0aW9uKHByb2plY3Rpb24yKSB7XG4gICAgICBhZGRUcmFuc2Zvcm1GdW5jKHByb2plY3Rpb24xLCBwcm9qZWN0aW9uMiwgZm9yd2FyZFRyYW5zZm9ybSk7XG4gICAgICBhZGRUcmFuc2Zvcm1GdW5jKHByb2plY3Rpb24yLCBwcm9qZWN0aW9uMSwgaW52ZXJzZVRyYW5zZm9ybSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogQ2xlYXIgYWxsIGNhY2hlZCBwcm9qZWN0aW9ucyBhbmQgdHJhbnNmb3Jtcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQWxsUHJvamVjdGlvbnMoKSB7XG4gIHByb2plY3Rpb25zLmNsZWFyKCk7XG4gIGNsZWFyVHJhbnNmb3JtRnVuY3MoKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7UHJvamVjdGlvbnxzdHJpbmd8dW5kZWZpbmVkfSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdENvZGUgRGVmYXVsdCBjb2RlLlxuICogQHJldHVybiB7UHJvamVjdGlvbn0gUHJvamVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb2plY3Rpb24ocHJvamVjdGlvbiwgZGVmYXVsdENvZGUpIHtcbiAgaWYgKCFwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIGdldChkZWZhdWx0Q29kZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2plY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGdldChwcm9qZWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtQcm9qZWN0aW9ufSAqLyAocHJvamVjdGlvbilcbiAgICApO1xuICB9XG59XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIG1vZHVsZTpvbC9wcm9qflRyYW5zZm9ybUZ1bmN0aW9ufSBmcm9tIGEgc2ltcGxlIDJEIGNvb3JkaW5hdGUgdHJhbnNmb3JtXG4gKiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRUcmFuc2Zvcm0gQ29vcmRpbmF0ZVxuICogICAgIHRyYW5zZm9ybS5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShjb29yZFRyYW5zZm9ybSkge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5wdXQgSW5wdXQuXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X291dHB1dCBPdXRwdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGltZW5zaW9uIERpbWVuc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPdXRwdXQuXG4gICAgICovXG4gICAgZnVuY3Rpb24oaW5wdXQsIG9wdF9vdXRwdXQsIG9wdF9kaW1lbnNpb24pIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IG9wdF9kaW1lbnNpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9kaW1lbnNpb24gOiAyO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3B0X291dHB1dCAhPT0gdW5kZWZpbmVkID8gb3B0X291dHB1dCA6IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gZGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gY29vcmRUcmFuc2Zvcm0oW2lucHV0W2ldLCBpbnB1dFtpICsgMV1dKTtcbiAgICAgICAgb3V0cHV0W2ldID0gcG9pbnRbMF07XG4gICAgICAgIG91dHB1dFtpICsgMV0gPSBwb2ludFsxXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGRpbWVuc2lvbiAtIDE7IGogPj0gMjsgLS1qKSB7XG4gICAgICAgICAgb3V0cHV0W2kgKyBqXSA9IGlucHV0W2kgKyBqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbn1cblxuXG4vKipcbiAqIFJlZ2lzdGVycyBjb29yZGluYXRlIHRyYW5zZm9ybSBmdW5jdGlvbnMgdG8gY29udmVydCBjb29yZGluYXRlcyBiZXR3ZWVuIHRoZVxuICogc291cmNlIHByb2plY3Rpb24gYW5kIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICogVGhlIGZvcndhcmQgYW5kIGludmVyc2UgZnVuY3Rpb25zIGNvbnZlcnQgY29vcmRpbmF0ZSBwYWlyczsgdGhpcyBmdW5jdGlvblxuICogY29udmVydHMgdGhlc2UgaW50byB0aGUgZnVuY3Rpb25zIHVzZWQgaW50ZXJuYWxseSB3aGljaCBhbHNvIGhhbmRsZVxuICogZXh0ZW50cyBhbmQgY29vcmRpbmF0ZSBhcnJheXMuXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gc291cmNlIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOiBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZm9yd2FyZCBUaGUgZm9yd2FyZCB0cmFuc2Zvcm1cbiAqICAgICBmdW5jdGlvbiAodGhhdCBpcywgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uXG4gKiAgICAgcHJvamVjdGlvbikgdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhcyBhcmd1bWVudCBhbmQgcmV0dXJuc1xuICogICAgIHRoZSB0cmFuc2Zvcm1lZCB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogaW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGludmVyc2UgVGhlIGludmVyc2UgdHJhbnNmb3JtXG4gKiAgICAgZnVuY3Rpb24gKHRoYXQgaXMsIGZyb20gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24gdG8gdGhlIHNvdXJjZVxuICogICAgIHByb2plY3Rpb24pIHRoYXQgdGFrZXMgYSB7QGxpbmsgbW9kdWxlOm9sL2Nvb3JkaW5hdGV+Q29vcmRpbmF0ZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnNcbiAqICAgICB0aGUgdHJhbnNmb3JtZWQge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXMoc291cmNlLCBkZXN0aW5hdGlvbiwgZm9yd2FyZCwgaW52ZXJzZSkge1xuICBjb25zdCBzb3VyY2VQcm9qID0gZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IGRlc3RQcm9qID0gZ2V0KGRlc3RpbmF0aW9uKTtcbiAgYWRkVHJhbnNmb3JtRnVuYyhzb3VyY2VQcm9qLCBkZXN0UHJvaiwgY3JlYXRlVHJhbnNmb3JtRnJvbUNvb3JkaW5hdGVUcmFuc2Zvcm0oZm9yd2FyZCkpO1xuICBhZGRUcmFuc2Zvcm1GdW5jKGRlc3RQcm9qLCBzb3VyY2VQcm9qLCBjcmVhdGVUcmFuc2Zvcm1Gcm9tQ29vcmRpbmF0ZVRyYW5zZm9ybShpbnZlcnNlKSk7XG59XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGEgY29vcmRpbmF0ZSBmcm9tIGxvbmdpdHVkZS9sYXRpdHVkZSB0byBhIGRpZmZlcmVudCBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS5cbiAqICAgICBhbiBhcnJheSB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZT19IG9wdF9wcm9qZWN0aW9uIFRhcmdldCBwcm9qZWN0aW9uLiBUaGVcbiAqICAgICBkZWZhdWx0IGlzIFdlYiBNZXJjYXRvciwgaS5lLiAnRVBTRzozODU3Jy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIHByb2plY3RlZCB0byB0aGUgdGFyZ2V0IHByb2plY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTG9uTGF0KGNvb3JkaW5hdGUsIG9wdF9wcm9qZWN0aW9uKSB7XG4gIHJldHVybiB0cmFuc2Zvcm0oY29vcmRpbmF0ZSwgJ0VQU0c6NDMyNicsXG4gICAgb3B0X3Byb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9wcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIGNvb3JkaW5hdGUgdG8gbG9uZ2l0dWRlL2xhdGl0dWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBQcm9qZWN0ZWQgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2U9fSBvcHRfcHJvamVjdGlvbiBQcm9qZWN0aW9uIG9mIHRoZSBjb29yZGluYXRlLlxuICogICAgIFRoZSBkZWZhdWx0IGlzIFdlYiBNZXJjYXRvciwgaS5lLiAnRVBTRzozODU3Jy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIGFzIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUsIGkuZS4gYW4gYXJyYXlcbiAqICAgICB3aXRoIGxvbmdpdHVkZSBhcyAxc3QgYW5kIGxhdGl0dWRlIGFzIDJuZCBlbGVtZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Mb25MYXQoY29vcmRpbmF0ZSwgb3B0X3Byb2plY3Rpb24pIHtcbiAgY29uc3QgbG9uTGF0ID0gdHJhbnNmb3JtKGNvb3JkaW5hdGUsXG4gICAgb3B0X3Byb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/IG9wdF9wcm9qZWN0aW9uIDogJ0VQU0c6Mzg1NycsICdFUFNHOjQzMjYnKTtcbiAgY29uc3QgbG9uID0gbG9uTGF0WzBdO1xuICBpZiAobG9uIDwgLTE4MCB8fCBsb24gPiAxODApIHtcbiAgICBsb25MYXRbMF0gPSBtb2R1bG8obG9uICsgMTgwLCAzNjApIC0gMTgwO1xuICB9XG4gIHJldHVybiBsb25MYXQ7XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHByb2plY3Rpb25zIGFyZSB0aGUgc2FtZSwgdGhhdCBpcyBldmVyeSBjb29yZGluYXRlIGluIG9uZVxuICogcHJvamVjdGlvbiBkb2VzIHJlcHJlc2VudCB0aGUgc2FtZSBnZW9ncmFwaGljIHBvaW50IGFzIHRoZSBzYW1lIGNvb3JkaW5hdGUgaW5cbiAqIHRoZSBvdGhlciBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gcHJvamVjdGlvbjEgUHJvamVjdGlvbiAxLlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBwcm9qZWN0aW9uMiBQcm9qZWN0aW9uIDIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVpdmFsZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1aXZhbGVudChwcm9qZWN0aW9uMSwgcHJvamVjdGlvbjIpIHtcbiAgaWYgKHByb2plY3Rpb24xID09PSBwcm9qZWN0aW9uMikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGVxdWFsVW5pdHMgPSBwcm9qZWN0aW9uMS5nZXRVbml0cygpID09PSBwcm9qZWN0aW9uMi5nZXRVbml0cygpO1xuICBpZiAocHJvamVjdGlvbjEuZ2V0Q29kZSgpID09PSBwcm9qZWN0aW9uMi5nZXRDb2RlKCkpIHtcbiAgICByZXR1cm4gZXF1YWxVbml0cztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHByb2plY3Rpb24xLCBwcm9qZWN0aW9uMik7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMgPT09IGNsb25lVHJhbnNmb3JtICYmIGVxdWFsVW5pdHM7XG4gIH1cbn1cblxuXG4vKipcbiAqIFNlYXJjaGVzIGluIHRoZSBsaXN0IG9mIHRyYW5zZm9ybSBmdW5jdGlvbnMgZm9yIHRoZSBmdW5jdGlvbiBmb3IgY29udmVydGluZ1xuICogY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlIGRlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBQcm9qZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbn0gZGVzdGluYXRpb25Qcm9qZWN0aW9uIERlc3RpbmF0aW9uIFByb2plY3Rpb25cbiAqICAgICBvYmplY3QuXG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm1GdW5jdGlvbn0gVHJhbnNmb3JtIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtRnJvbVByb2plY3Rpb25zKHNvdXJjZVByb2plY3Rpb24sIGRlc3RpbmF0aW9uUHJvamVjdGlvbikge1xuICBjb25zdCBzb3VyY2VDb2RlID0gc291cmNlUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uQ29kZSA9IGRlc3RpbmF0aW9uUHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gIGxldCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtRnVuYyhzb3VyY2VDb2RlLCBkZXN0aW5hdGlvbkNvZGUpO1xuICBpZiAoIXRyYW5zZm9ybUZ1bmMpIHtcbiAgICB0cmFuc2Zvcm1GdW5jID0gaWRlbnRpdHlUcmFuc2Zvcm07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmM7XG59XG5cblxuLyoqXG4gKiBHaXZlbiB0aGUgcHJvamVjdGlvbi1saWtlIG9iamVjdHMsIHNlYXJjaGVzIGZvciBhIHRyYW5zZm9ybWF0aW9uXG4gKiBmdW5jdGlvbiB0byBjb252ZXJ0IGEgY29vcmRpbmF0ZXMgYXJyYXkgZnJvbSB0aGUgc291cmNlIHByb2plY3Rpb24gdG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UuXG4gKiBAcGFyYW0ge1Byb2plY3Rpb25MaWtlfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge1RyYW5zZm9ybUZ1bmN0aW9ufSBUcmFuc2Zvcm0gZnVuY3Rpb24uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCBzb3VyY2VQcm9qZWN0aW9uID0gZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uUHJvamVjdGlvbiA9IGdldChkZXN0aW5hdGlvbik7XG4gIHJldHVybiBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBjb29yZGluYXRlIGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIFRoaXMgcmV0dXJucyBhIG5ldyBjb29yZGluYXRlIChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvcHJvan50cmFuc2Zvcm1FeHRlbnR9IGZvciBleHRlbnQgdHJhbnNmb3JtYXRpb24uXG4gKiBTZWUgdGhlIHRyYW5zZm9ybSBtZXRob2Qgb2Yge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5fkdlb21ldHJ5fSBhbmQgaXRzXG4gKiBzdWJjbGFzc2VzIGZvciBnZW9tZXRyeSB0cmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oY29vcmRpbmF0ZSwgc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gdHJhbnNmb3JtRnVuYyhjb29yZGluYXRlLCB1bmRlZmluZWQsIGNvb3JkaW5hdGUubGVuZ3RoKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gZXh0ZW50IGZyb20gc291cmNlIHByb2plY3Rpb24gdG8gZGVzdGluYXRpb24gcHJvamVjdGlvbi4gIFRoaXNcbiAqIHJldHVybnMgYSBuZXcgZXh0ZW50IChhbmQgZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBUaGUgZXh0ZW50IHRvIHRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7UHJvamVjdGlvbkxpa2V9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi1saWtlLlxuICogQHBhcmFtIHtQcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi1saWtlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBUaGUgdHJhbnNmb3JtZWQgZXh0ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtRXh0ZW50KGV4dGVudCwgc291cmNlLCBkZXN0aW5hdGlvbikge1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jID0gZ2V0VHJhbnNmb3JtKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuICByZXR1cm4gYXBwbHlUcmFuc2Zvcm0oZXh0ZW50LCB0cmFuc2Zvcm1GdW5jKTtcbn1cblxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGdpdmVuIHBvaW50IHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50IFBvaW50LlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBzb3VyY2VQcm9qZWN0aW9uIFNvdXJjZSBwcm9qZWN0aW9uLlxuICogQHBhcmFtIHtQcm9qZWN0aW9ufSBkZXN0aW5hdGlvblByb2plY3Rpb24gRGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBQb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVdpdGhQcm9qZWN0aW9ucyhwb2ludCwgc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKSB7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmMgPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoc291cmNlUHJvamVjdGlvbiwgZGVzdGluYXRpb25Qcm9qZWN0aW9uKTtcbiAgcmV0dXJuIHRyYW5zZm9ybUZ1bmMocG9pbnQpO1xufVxuXG4vKipcbiAqIEFkZCB0cmFuc2Zvcm1zIHRvIGFuZCBmcm9tIEVQU0c6NDMyNiBhbmQgRVBTRzozODU3LiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcbiAqIGJ5IHdoZW4gdGhpcyBtb2R1bGUgaXMgZXhlY3V0ZWQgYW5kIHNob3VsZCBvbmx5IG5lZWQgdG8gYmUgY2FsbGVkIGFnYWluIGFmdGVyXG4gKiBgY2xlYXJBbGxQcm9qZWN0aW9ucygpYCBpcyBjYWxsZWQgKGUuZy4gaW4gdGVzdHMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29tbW9uKCkge1xuICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zIHRoYXQgZG9uJ3QgYWx0ZXIgY29vcmRpbmF0ZXMgdG8gY29udmVydCB3aXRoaW4gc2V0IG9mXG4gIC8vIHByb2plY3Rpb25zIHdpdGggZXF1YWwgbWVhbmluZy5cbiAgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKEVQU0czODU3X1BST0pFQ1RJT05TKTtcbiAgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zKEVQU0c0MzI2X1BST0pFQ1RJT05TKTtcbiAgLy8gQWRkIHRyYW5zZm9ybWF0aW9ucyB0byBjb252ZXJ0IEVQU0c6NDMyNiBsaWtlIGNvb3JkaW5hdGVzIHRvIEVQU0c6Mzg1NyBsaWtlXG4gIC8vIGNvb3JkaW5hdGVzIGFuZCBiYWNrLlxuICBhZGRFcXVpdmFsZW50VHJhbnNmb3JtcyhFUFNHNDMyNl9QUk9KRUNUSU9OUywgRVBTRzM4NTdfUFJPSkVDVElPTlMsIGZyb21FUFNHNDMyNiwgdG9FUFNHNDMyNik7XG59XG5cbmFkZENvbW1vbigpO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBOzs7Ozs7QUFPQTs7Ozs7O0FBT0E7Ozs7OztBQVVBOzs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBOzs7OztBQVdBOztBQWpCQTs7Ozs7Ozs7O0FBNEJBOzs7Ozs7Ozs7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUNsSkE7OztBQUdBO0FBQ0E7Ozs7Ozs7O0FBU0E7Ozs7Ozs7O0FBU0E7Ozs7OztBQU9BOzs7Ozs7Ozs7O0FBV0E7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7Ozs7O0FBVUE7O0FBakJBOzs7Ozs7Ozs7QUE0QkE7O0FDcEVBOzs7Ozs7O0FBUUE7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7OztBQ3BDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBcEJBO0FBcUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assert; });\n/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87);\n/**\n * @module ol/asserts\n */\n\n/**\n * @param {*} assertion Assertion we expected to be truthy.\n * @param {number} errorCode Error code.\n */\n\nfunction assert(assertion, errorCode) {\n  if (!assertion) {\n    throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](errorCode);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2Fzc2VydHMuanM/NmQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvYXNzZXJ0c1xuICovXG5pbXBvcnQgQXNzZXJ0aW9uRXJyb3IgZnJvbSAnLi9Bc3NlcnRpb25FcnJvci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBhc3NlcnRpb24gQXNzZXJ0aW9uIHdlIGV4cGVjdGVkIHRvIGJlIHRydXRoeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJvckNvZGUgRXJyb3IgY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChhc3NlcnRpb24sIGVycm9yQ29kZSkge1xuICBpZiAoIWFzc2VydGlvbikge1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihlcnJvckNvZGUpO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTs7O0FBR0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return clear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isEmpty; });\n/**\n * @module ol/obj\n */\n\n/**\n * Polyfill for Object.assign().  Assigns enumerable and own properties from\n * one or more source objects to a target object.\n * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.\n *\n * @param {!Object} target The target object.\n * @param {...Object} var_sources The source object(s).\n * @return {!Object} The modified target object.\n */\nvar assign = typeof Object.assign === \'function\' ? Object.assign : function (target, var_sources) {\n  var arguments$1 = arguments;\n\n  if (target === undefined || target === null) {\n    throw new TypeError(\'Cannot convert undefined or null to object\');\n  }\n\n  var output = Object(target);\n\n  for (var i = 1, ii = arguments.length; i < ii; ++i) {\n    var source = arguments$1[i];\n\n    if (source !== undefined && source !== null) {\n      for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n          output[key] = source[key];\n        }\n      }\n    }\n  }\n\n  return output;\n};\n/**\n * Removes all properties from an object.\n * @param {Object} object The object to clear.\n */\n\nfunction clear(object) {\n  for (var property in object) {\n    delete object[property];\n  }\n}\n/**\n * Get an array of property values from an object.\n * @param {Object<K,V>} object The object from which to get the values.\n * @return {!Array<V>} The property values.\n * @template K,V\n */\n\nfunction getValues(object) {\n  var values = [];\n\n  for (var property in object) {\n    values.push(object[property]);\n  }\n\n  return values;\n}\n/**\n * Determine if an object has any properties.\n * @param {Object} object The object to check.\n * @return {boolean} The object is empty.\n */\n\nfunction isEmpty(object) {\n  var property;\n\n  for (property in object) {\n    return false;\n  }\n\n  return !property;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL29iai5qcz9kZjgyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9vYmpcbiAqL1xuXG5cbi8qKlxuICogUG9seWZpbGwgZm9yIE9iamVjdC5hc3NpZ24oKS4gIEFzc2lnbnMgZW51bWVyYWJsZSBhbmQgb3duIHByb3BlcnRpZXMgZnJvbVxuICogb25lIG9yIG1vcmUgc291cmNlIG9iamVjdHMgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24uXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX3NvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3QocykuXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBUaGUgbW9kaWZpZWQgdGFyZ2V0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2lnbiA9ICh0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJykgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24odGFyZ2V0LCB2YXJfc291cmNlcykge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yIChsZXQgaSA9IDEsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsZWFyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIob2JqZWN0KSB7XG4gIGZvciAoY29uc3QgcHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgZGVsZXRlIG9iamVjdFtwcm9wZXJ0eV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEdldCBhbiBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMgZnJvbSBhbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxLLFY+fSBvYmplY3QgVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRvIGdldCB0aGUgdmFsdWVzLlxuICogQHJldHVybiB7IUFycmF5PFY+fSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVzKG9iamVjdCkge1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICB2YWx1ZXMucHVzaChvYmplY3RbcHJvcGVydHldKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBoYXMgYW55IHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgb2JqZWN0IGlzIGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShvYmplY3QpIHtcbiAgbGV0IHByb3BlcnR5O1xuICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gIXByb3BlcnR5O1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FBY0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return binarySearch; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return numberSafeCompareFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return includes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return linearFindNearest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return reverseSubArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return extend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return remove; });\n/* unused harmony export find */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return stableSort; });\n/* unused harmony export findIndex */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isSorted; });\n/**\n * @module ol/array\n */\n\n/**\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can\'t be found it\'ll return -1.\n * https://github.com/darkskyapp/binary-search\n *\n * @param {Array<*>} haystack Items to search through.\n * @param {*} needle The item to look for.\n * @param {Function=} opt_comparator Comparator function.\n * @return {number} The index of the item if found, -1 if not.\n */\nfunction binarySearch(haystack, needle, opt_comparator) {\n  var mid, cmp;\n  var comparator = opt_comparator || numberSafeCompareFunction;\n  var low = 0;\n  var high = haystack.length;\n  var found = false;\n\n  while (low < high) {\n    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast\n     * to double (which gives the wrong results). */\n    mid = low + (high - low >> 1);\n    cmp = +comparator(haystack[mid], needle);\n\n    if (cmp < 0.0) {\n      /* Too low. */\n      low = mid + 1;\n    } else {\n      /* Key found or too high */\n      high = mid;\n      found = !cmp;\n    }\n  }\n  /* Key not found. */\n\n\n  return found ? low : ~low;\n}\n/**\n * Compare function for array sort that is safe for numbers.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\n\nfunction numberSafeCompareFunction(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n/**\n * Whether the array contains the given object.\n * @param {Array<*>} arr The array to test for the presence of the element.\n * @param {*} obj The object for which to test.\n * @return {boolean} The object is in the array.\n */\n\nfunction includes(arr, obj) {\n  return arr.indexOf(obj) >= 0;\n}\n/**\n * @param {Array<number>} arr Array.\n * @param {number} target Target.\n * @param {number} direction 0 means return the nearest, > 0\n *    means return the largest nearest, < 0 means return the\n *    smallest nearest.\n * @return {number} Index.\n */\n\nfunction linearFindNearest(arr, target, direction) {\n  var n = arr.length;\n\n  if (arr[0] <= target) {\n    return 0;\n  } else if (target <= arr[n - 1]) {\n    return n - 1;\n  } else {\n    var i;\n\n    if (direction > 0) {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] < target) {\n          return i - 1;\n        }\n      }\n    } else if (direction < 0) {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] <= target) {\n          return i;\n        }\n      }\n    } else {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] == target) {\n          return i;\n        } else if (arr[i] < target) {\n          if (arr[i - 1] - target < target - arr[i]) {\n            return i - 1;\n          } else {\n            return i;\n          }\n        }\n      }\n    }\n\n    return n - 1;\n  }\n}\n/**\n * @param {Array<*>} arr Array.\n * @param {number} begin Begin index.\n * @param {number} end End index.\n */\n\nfunction reverseSubArray(arr, begin, end) {\n  while (begin < end) {\n    var tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n}\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\n * @template VALUE\n */\n\nfunction extend(arr, data) {\n  var extension = Array.isArray(data) ? data : [data];\n  var length = extension.length;\n\n  for (var i = 0; i < length; i++) {\n    arr[arr.length] = extension[i];\n  }\n}\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {VALUE} obj The element to remove.\n * @template VALUE\n * @return {boolean} If the element was removed.\n */\n\nfunction remove(arr, obj) {\n  var i = arr.indexOf(obj);\n  var found = i > -1;\n\n  if (found) {\n    arr.splice(i, 1);\n  }\n\n  return found;\n}\n/**\n * @param {Array<VALUE>} arr The array to search in.\n * @param {function(VALUE, number, ?) : boolean} func The function to compare.\n * @template VALUE\n * @return {VALUE|null} The element found or null.\n */\n\nfunction find(arr, func) {\n  var length = arr.length >>> 0;\n  var value;\n\n  for (var i = 0; i < length; i++) {\n    value = arr[i];\n\n    if (func(value, i, arr)) {\n      return value;\n    }\n  }\n\n  return null;\n}\n/**\n * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\n * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\n * @return {boolean} Whether the two arrays are equal.\n */\n\nfunction equals(arr1, arr2) {\n  var len1 = arr1.length;\n\n  if (len1 !== arr2.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Sort the passed array such that the relative order of equal elements is preverved.\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n * @param {Array<*>} arr The array to sort (modifies original).\n * @param {!function(*, *): number} compareFnc Comparison function.\n * @api\n */\n\nfunction stableSort(arr, compareFnc) {\n  var length = arr.length;\n  var tmp = Array(arr.length);\n  var i;\n\n  for (i = 0; i < length; i++) {\n    tmp[i] = {\n      index: i,\n      value: arr[i]\n    };\n  }\n\n  tmp.sort(function (a, b) {\n    return compareFnc(a.value, b.value) || a.index - b.index;\n  });\n\n  for (i = 0; i < arr.length; i++) {\n    arr[i] = tmp[i].value;\n  }\n}\n/**\n * @param {Array<*>} arr The array to search in.\n * @param {Function} func Comparison function.\n * @return {number} Return index.\n */\n\nfunction findIndex(arr, func) {\n  var index;\n  var found = !arr.every(function (el, idx) {\n    index = idx;\n    return !func(el, idx, arr);\n  });\n  return found ? index : -1;\n}\n/**\n * @param {Array<*>} arr The array to test.\n * @param {Function=} opt_func Comparison function.\n * @param {boolean=} opt_strict Strictly sorted (default false).\n * @return {boolean} Return index.\n */\n\nfunction isSorted(arr, opt_func, opt_strict) {\n  var compare = opt_func || numberSafeCompareFunction;\n  return arr.every(function (currentVal, index) {\n    if (index === 0) {\n      return true;\n    }\n\n    var res = compare(arr[index - 1], currentVal);\n    return !(res > 0 || opt_strict && res === 0);\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2FycmF5LmpzP2I3MDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2FycmF5XG4gKi9cblxuXG4vKipcbiAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcHJvdmlkZWQgc29ydGVkIGxpc3QgYW5kIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGlmIGZvdW5kLiBJZiBpdCBjYW4ndCBiZSBmb3VuZCBpdCdsbCByZXR1cm4gLTEuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9iaW5hcnktc2VhcmNoXG4gKlxuICogQHBhcmFtIHtBcnJheTwqPn0gaGF5c3RhY2sgSXRlbXMgdG8gc2VhcmNoIHRocm91Z2guXG4gKiBAcGFyYW0geyp9IG5lZWRsZSBUaGUgaXRlbSB0byBsb29rIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfY29tcGFyYXRvciBDb21wYXJhdG9yIGZ1bmN0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gaWYgZm91bmQsIC0xIGlmIG5vdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBvcHRfY29tcGFyYXRvcikge1xuICBsZXQgbWlkLCBjbXA7XG4gIGNvbnN0IGNvbXBhcmF0b3IgPSBvcHRfY29tcGFyYXRvciB8fCBudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9uO1xuICBsZXQgbG93ID0gMDtcbiAgbGV0IGhpZ2ggPSBoYXlzdGFjay5sZW5ndGg7XG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgLyogTm90ZSB0aGF0IFwiKGxvdyArIGhpZ2gpID4+PiAxXCIgbWF5IG92ZXJmbG93LCBhbmQgcmVzdWx0cyBpbiBhIHR5cGVjYXN0XG4gICAgICogdG8gZG91YmxlICh3aGljaCBnaXZlcyB0aGUgd3JvbmcgcmVzdWx0cykuICovXG4gICAgbWlkID0gbG93ICsgKGhpZ2ggLSBsb3cgPj4gMSk7XG4gICAgY21wID0gK2NvbXBhcmF0b3IoaGF5c3RhY2tbbWlkXSwgbmVlZGxlKTtcblxuICAgIGlmIChjbXAgPCAwLjApIHsgLyogVG9vIGxvdy4gKi9cbiAgICAgIGxvdyA9IG1pZCArIDE7XG5cbiAgICB9IGVsc2UgeyAvKiBLZXkgZm91bmQgb3IgdG9vIGhpZ2ggKi9cbiAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICBmb3VuZCA9ICFjbXA7XG4gICAgfVxuICB9XG5cbiAgLyogS2V5IG5vdCBmb3VuZC4gKi9cbiAgcmV0dXJuIGZvdW5kID8gbG93IDogfmxvdztcbn1cblxuXG4vKipcbiAqIENvbXBhcmUgZnVuY3Rpb24gZm9yIGFycmF5IHNvcnQgdGhhdCBpcyBzYWZlIGZvciBudW1iZXJzLlxuICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBvYmplY3QgdG8gYmUgY29tcGFyZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEEgbmVnYXRpdmUgbnVtYmVyLCB6ZXJvLCBvciBhIHBvc2l0aXZlIG51bWJlciBhcyB0aGUgZmlyc3RcbiAqICAgICBhcmd1bWVudCBpcyBsZXNzIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIHNlY29uZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclNhZmVDb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59XG5cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBhcnJheSBjb250YWlucyB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIFRoZSBhcnJheSB0byB0ZXN0IGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iaiBUaGUgb2JqZWN0IGZvciB3aGljaCB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIG9iamVjdCBpcyBpbiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmNsdWRlcyhhcnIsIG9iaikge1xuICByZXR1cm4gYXJyLmluZGV4T2Yob2JqKSA+PSAwO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhcnIgQXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gdGFyZ2V0IFRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gMCBtZWFucyByZXR1cm4gdGhlIG5lYXJlc3QsID4gMFxuICogICAgbWVhbnMgcmV0dXJuIHRoZSBsYXJnZXN0IG5lYXJlc3QsIDwgMCBtZWFucyByZXR1cm4gdGhlXG4gKiAgICBzbWFsbGVzdCBuZWFyZXN0LlxuICogQHJldHVybiB7bnVtYmVyfSBJbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhckZpbmROZWFyZXN0KGFyciwgdGFyZ2V0LCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgbiA9IGFyci5sZW5ndGg7XG4gIGlmIChhcnJbMF0gPD0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAodGFyZ2V0IDw9IGFycltuIC0gMV0pIHtcbiAgICByZXR1cm4gbiAtIDE7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA8IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uIDwgMCkge1xuICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoYXJyW2ldIDw9IHRhcmdldCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKGFycltpXSA9PSB0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnJbaV0gPCB0YXJnZXQpIHtcbiAgICAgICAgICBpZiAoYXJyW2kgLSAxXSAtIHRhcmdldCA8IHRhcmdldCAtIGFycltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGkgLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG4gLSAxO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgQXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gYmVnaW4gQmVnaW4gaW5kZXguXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBpbmRleC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTdWJBcnJheShhcnIsIGJlZ2luLCBlbmQpIHtcbiAgd2hpbGUgKGJlZ2luIDwgZW5kKSB7XG4gICAgY29uc3QgdG1wID0gYXJyW2JlZ2luXTtcbiAgICBhcnJbYmVnaW5dID0gYXJyW2VuZF07XG4gICAgYXJyW2VuZF0gPSB0bXA7XG4gICAgKytiZWdpbjtcbiAgICAtLWVuZDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHshQXJyYXk8VkFMVUU+fFZBTFVFfSBkYXRhIFRoZSBlbGVtZW50cyBvciBhcnJheXMgb2YgZWxlbWVudHMgdG8gYWRkIHRvIGFyci5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKGFyciwgZGF0YSkge1xuICBjb25zdCBleHRlbnNpb24gPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcbiAgY29uc3QgbGVuZ3RoID0gZXh0ZW5zaW9uLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGFyclthcnIubGVuZ3RoXSA9IGV4dGVuc2lvbltpXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxWQUxVRT59IGFyciBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtWQUxVRX0gb2JqIFRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEB0ZW1wbGF0ZSBWQUxVRVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcbiAgY29uc3QgaSA9IGFyci5pbmRleE9mKG9iaik7XG4gIGNvbnN0IGZvdW5kID0gaSA+IC0xO1xuICBpZiAoZm91bmQpIHtcbiAgICBhcnIuc3BsaWNlKGksIDEpO1xuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VkFMVUU+fSBhcnIgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVkFMVUUsIG51bWJlciwgPykgOiBib29sZWFufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb21wYXJlLlxuICogQHRlbXBsYXRlIFZBTFVFXG4gKiBAcmV0dXJuIHtWQUxVRXxudWxsfSBUaGUgZWxlbWVudCBmb3VuZCBvciBudWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZChhcnIsIGZ1bmMpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyLmxlbmd0aCA+Pj4gMDtcbiAgbGV0IHZhbHVlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycltpXTtcbiAgICBpZiAoZnVuYyh2YWx1ZSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl8VWludDhDbGFtcGVkQXJyYXl9IGFycjEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fSBhcnIyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHR3byBhcnJheXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGFycjEsIGFycjIpIHtcbiAgY29uc3QgbGVuMSA9IGFycjEubGVuZ3RoO1xuICBpZiAobGVuMSAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIFNvcnQgdGhlIHBhc3NlZCBhcnJheSBzdWNoIHRoYXQgdGhlIHJlbGF0aXZlIG9yZGVyIG9mIGVxdWFsIGVsZW1lbnRzIGlzIHByZXZlcnZlZC5cbiAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Tb3J0aW5nX2FsZ29yaXRobSNTdGFiaWxpdHkgZm9yIGRldGFpbHMuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHNvcnQgKG1vZGlmaWVzIG9yaWdpbmFsKS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCosICopOiBudW1iZXJ9IGNvbXBhcmVGbmMgQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YWJsZVNvcnQoYXJyLCBjb21wYXJlRm5jKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gIGNvbnN0IHRtcCA9IEFycmF5KGFyci5sZW5ndGgpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdG1wW2ldID0ge2luZGV4OiBpLCB2YWx1ZTogYXJyW2ldfTtcbiAgfVxuICB0bXAuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVGbmMoYS52YWx1ZSwgYi52YWx1ZSkgfHwgYS5pbmRleCAtIGIuaW5kZXg7XG4gIH0pO1xuICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyW2ldID0gdG1wW2ldLnZhbHVlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHNlYXJjaCBpbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgQ29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIGluZGV4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEluZGV4KGFyciwgZnVuYykge1xuICBsZXQgaW5kZXg7XG4gIGNvbnN0IGZvdW5kID0gIWFyci5ldmVyeShmdW5jdGlvbihlbCwgaWR4KSB7XG4gICAgaW5kZXggPSBpZHg7XG4gICAgcmV0dXJuICFmdW5jKGVsLCBpZHgsIGFycik7XG4gIH0pO1xuICByZXR1cm4gZm91bmQgPyBpbmRleCA6IC0xO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTwqPn0gYXJyIFRoZSBhcnJheSB0byB0ZXN0LlxuICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdF9mdW5jIENvbXBhcmlzb24gZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc3RyaWN0IFN0cmljdGx5IHNvcnRlZCAoZGVmYXVsdCBmYWxzZSkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm4gaW5kZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NvcnRlZChhcnIsIG9wdF9mdW5jLCBvcHRfc3RyaWN0KSB7XG4gIGNvbnN0IGNvbXBhcmUgPSBvcHRfZnVuYyB8fCBudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9uO1xuICByZXR1cm4gYXJyLmV2ZXJ5KGZ1bmN0aW9uKGN1cnJlbnRWYWwsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gY29tcGFyZShhcnJbaW5kZXggLSAxXSwgY3VycmVudFZhbCk7XG4gICAgcmV0dXJuICEocmVzID4gMCB8fCBvcHRfc3RyaWN0ICYmIHJlcyA9PT0gMCk7XG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/render/ReplayType\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  CIRCLE: 'Circle',\n  DEFAULT: 'Default',\n  IMAGE: 'Image',\n  LINE_STRING: 'LineString',\n  POLYGON: 'Polygon',\n  TEXT: 'Text'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3JlbmRlci9SZXBsYXlUeXBlLmpzPzA2Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9SZXBsYXlUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIENJUkNMRTogJ0NpcmNsZScsXG4gIERFRkFVTFQ6ICdEZWZhdWx0JyxcbiAgSU1BR0U6ICdJbWFnZScsXG4gIExJTkVfU1RSSU5HOiAnTGluZVN0cmluZycsXG4gIFBPTFlHT046ICdQb2x5Z29uJyxcbiAgVEVYVDogJ1RleHQnXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export ObjectEvent */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return getChangeEventType; });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);\n/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86);\n/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);\n/**\n * @module ol/Object\n */\n\n\n\n\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.\n */\n\nvar ObjectEvent =\n/*@__PURE__*/\nfunction (Event) {\n  function ObjectEvent(type, key, oldValue) {\n    Event.call(this, type);\n    /**\n     * The name of the property whose value is changing.\n     * @type {string}\n     * @api\n     */\n\n    this.key = key;\n    /**\n     * The old value. To get the new value use `e.target.get(e.key)` where\n     * `e` is the event object.\n     * @type {*}\n     * @api\n     */\n\n    this.oldValue = oldValue;\n  }\n\n  if (Event) ObjectEvent.__proto__ = Event;\n  ObjectEvent.prototype = Object.create(Event && Event.prototype);\n  ObjectEvent.prototype.constructor = ObjectEvent;\n  return ObjectEvent;\n}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"]);\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Most non-trivial classes inherit from this.\n *\n * This extends {@link module:ol/Observable} with observable\n * properties, where each property is observable as well as the object as a\n * whole.\n *\n * Classes that inherit from this have pre-defined properties, to which you can\n * add your owns. The pre-defined properties are listed in this documentation as\n * 'Observable Properties', and have their own accessors; for example,\n * {@link module:ol/Map~Map} has a `target` property, accessed with\n * `getTarget()` and changed with `setTarget()`. Not all properties are however\n * settable. There are also general-purpose accessors `get()` and `set()`. For\n * example, `get('target')` is equivalent to `getTarget()`.\n *\n * The `set` accessors trigger a change event, and you can monitor this by\n * registering a listener. For example, {@link module:ol/View~View} has a\n * `center` property, so `view.on('change:center', function(evt) {...});` would\n * call the function whenever the value of the center property changes. Within\n * the function, `evt.target` would be the view, so `evt.target.getCenter()`\n * would return the new center.\n *\n * You can add your own observable properties with\n * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.\n * You can listen for changes on that property value with\n * `object.on('change:prop', listener)`. You can get a list of all\n * properties with {@link module:ol/Object~BaseObject#getProperties}.\n *\n * Note that the observable properties are separate from standard JS properties.\n * You can, for example, give your map object a title with\n * `map.title='New title'` and with `map.set('title', 'Another title')`. The\n * first will be a `hasOwnProperty`; the second will appear in\n * `getProperties()`. Only the second is observable.\n *\n * Properties can be deleted by using the unset method. E.g.\n * object.unset('foo').\n *\n * @fires ObjectEvent\n * @api\n */\n\nvar BaseObject =\n/*@__PURE__*/\nfunction (Observable) {\n  function BaseObject(opt_values) {\n    Observable.call(this); // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is\n    // the same as the order in which they were created.  This also helps to\n    // ensure that object properties are always added in the same order, which\n    // helps many JavaScript engines generate faster code.\n\n    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* getUid */ \"c\"])(this);\n    /**\n     * @private\n     * @type {!Object<string, *>}\n     */\n\n    this.values_ = {};\n\n    if (opt_values !== undefined) {\n      this.setProperties(opt_values);\n    }\n  }\n\n  if (Observable) BaseObject.__proto__ = Observable;\n  BaseObject.prototype = Object.create(Observable && Observable.prototype);\n  BaseObject.prototype.constructor = BaseObject;\n  /**\n   * Gets a value.\n   * @param {string} key Key name.\n   * @return {*} Value.\n   * @api\n   */\n\n  BaseObject.prototype.get = function get(key) {\n    var value;\n\n    if (this.values_.hasOwnProperty(key)) {\n      value = this.values_[key];\n    }\n\n    return value;\n  };\n  /**\n   * Get a list of object property names.\n   * @return {Array<string>} List of property names.\n   * @api\n   */\n\n\n  BaseObject.prototype.getKeys = function getKeys() {\n    return Object.keys(this.values_);\n  };\n  /**\n   * Get an object of all property names and values.\n   * @return {Object<string, *>} Object.\n   * @api\n   */\n\n\n  BaseObject.prototype.getProperties = function getProperties() {\n    return Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__[/* assign */ \"a\"])({}, this.values_);\n  };\n  /**\n   * @param {string} key Key name.\n   * @param {*} oldValue Old value.\n   */\n\n\n  BaseObject.prototype.notify = function notify(key, oldValue) {\n    var eventType;\n    eventType = getChangeEventType(key);\n    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ \"a\"].PROPERTYCHANGE;\n    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));\n  };\n  /**\n   * Sets a value.\n   * @param {string} key Key name.\n   * @param {*} value Value.\n   * @param {boolean=} opt_silent Update without triggering an event.\n   * @api\n   */\n\n\n  BaseObject.prototype.set = function set(key, value, opt_silent) {\n    if (opt_silent) {\n      this.values_[key] = value;\n    } else {\n      var oldValue = this.values_[key];\n      this.values_[key] = value;\n\n      if (oldValue !== value) {\n        this.notify(key, oldValue);\n      }\n    }\n  };\n  /**\n   * Sets a collection of key-value pairs.  Note that this changes any existing\n   * properties and adds new ones (it does not remove any existing properties).\n   * @param {Object<string, *>} values Values.\n   * @param {boolean=} opt_silent Update without triggering an event.\n   * @api\n   */\n\n\n  BaseObject.prototype.setProperties = function setProperties(values, opt_silent) {\n    for (var key in values) {\n      this.set(key, values[key], opt_silent);\n    }\n  };\n  /**\n   * Unsets a property.\n   * @param {string} key Key name.\n   * @param {boolean=} opt_silent Unset without triggering an event.\n   * @api\n   */\n\n\n  BaseObject.prototype.unset = function unset(key, opt_silent) {\n    if (key in this.values_) {\n      var oldValue = this.values_[key];\n      delete this.values_[key];\n\n      if (!opt_silent) {\n        this.notify(key, oldValue);\n      }\n    }\n  };\n\n  return BaseObject;\n}(_Observable_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]);\n/**\n * @type {Object<string, string>}\n */\n\n\nvar changeEventTypeCache = {};\n/**\n * @param {string} key Key name.\n * @return {string} Change name.\n */\n\nfunction getChangeEventType(key) {\n  return changeEventTypeCache.hasOwnProperty(key) ? changeEventTypeCache[key] : changeEventTypeCache[key] = 'change:' + key;\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = (BaseObject);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL09iamVjdC5qcz8yOWIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9PYmplY3RcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQgT2JqZWN0RXZlbnRUeXBlIGZyb20gJy4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJy4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4vb2JqLmpzJztcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE9iamVjdEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcHJvcGVydHkgbmFtZS5cbiAgICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIGZvciBga2V5YC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIGtleSwgb2xkVmFsdWUpIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBjaGFuZ2luZy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IGtleTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvbGQgdmFsdWUuIFRvIGdldCB0aGUgbmV3IHZhbHVlIHVzZSBgZS50YXJnZXQuZ2V0KGUua2V5KWAgd2hlcmVcbiAgICAgKiBgZWAgaXMgdGhlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuXG4gIH1cblxufVxuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTW9zdCBub24tdHJpdmlhbCBjbGFzc2VzIGluaGVyaXQgZnJvbSB0aGlzLlxuICpcbiAqIFRoaXMgZXh0ZW5kcyB7QGxpbmsgbW9kdWxlOm9sL09ic2VydmFibGV9IHdpdGggb2JzZXJ2YWJsZVxuICogcHJvcGVydGllcywgd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBvYnNlcnZhYmxlIGFzIHdlbGwgYXMgdGhlIG9iamVjdCBhcyBhXG4gKiB3aG9sZS5cbiAqXG4gKiBDbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgaGF2ZSBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzLCB0byB3aGljaCB5b3UgY2FuXG4gKiBhZGQgeW91ciBvd25zLiBUaGUgcHJlLWRlZmluZWQgcHJvcGVydGllcyBhcmUgbGlzdGVkIGluIHRoaXMgZG9jdW1lbnRhdGlvbiBhc1xuICogJ09ic2VydmFibGUgUHJvcGVydGllcycsIGFuZCBoYXZlIHRoZWlyIG93biBhY2Nlc3NvcnM7IGZvciBleGFtcGxlLFxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfSBoYXMgYSBgdGFyZ2V0YCBwcm9wZXJ0eSwgYWNjZXNzZWQgd2l0aFxuICogYGdldFRhcmdldCgpYCBhbmQgY2hhbmdlZCB3aXRoIGBzZXRUYXJnZXQoKWAuIE5vdCBhbGwgcHJvcGVydGllcyBhcmUgaG93ZXZlclxuICogc2V0dGFibGUuIFRoZXJlIGFyZSBhbHNvIGdlbmVyYWwtcHVycG9zZSBhY2Nlc3NvcnMgYGdldCgpYCBhbmQgYHNldCgpYC4gRm9yXG4gKiBleGFtcGxlLCBgZ2V0KCd0YXJnZXQnKWAgaXMgZXF1aXZhbGVudCB0byBgZ2V0VGFyZ2V0KClgLlxuICpcbiAqIFRoZSBgc2V0YCBhY2Nlc3NvcnMgdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgYW5kIHlvdSBjYW4gbW9uaXRvciB0aGlzIGJ5XG4gKiByZWdpc3RlcmluZyBhIGxpc3RlbmVyLiBGb3IgZXhhbXBsZSwge0BsaW5rIG1vZHVsZTpvbC9WaWV3flZpZXd9IGhhcyBhXG4gKiBgY2VudGVyYCBwcm9wZXJ0eSwgc28gYHZpZXcub24oJ2NoYW5nZTpjZW50ZXInLCBmdW5jdGlvbihldnQpIHsuLi59KTtgIHdvdWxkXG4gKiBjYWxsIHRoZSBmdW5jdGlvbiB3aGVuZXZlciB0aGUgdmFsdWUgb2YgdGhlIGNlbnRlciBwcm9wZXJ0eSBjaGFuZ2VzLiBXaXRoaW5cbiAqIHRoZSBmdW5jdGlvbiwgYGV2dC50YXJnZXRgIHdvdWxkIGJlIHRoZSB2aWV3LCBzbyBgZXZ0LnRhcmdldC5nZXRDZW50ZXIoKWBcbiAqIHdvdWxkIHJldHVybiB0aGUgbmV3IGNlbnRlci5cbiAqXG4gKiBZb3UgY2FuIGFkZCB5b3VyIG93biBvYnNlcnZhYmxlIHByb3BlcnRpZXMgd2l0aFxuICogYG9iamVjdC5zZXQoJ3Byb3AnLCAndmFsdWUnKWAsIGFuZCByZXRyaWV2ZSB0aGF0IHdpdGggYG9iamVjdC5nZXQoJ3Byb3AnKWAuXG4gKiBZb3UgY2FuIGxpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGF0IHByb3BlcnR5IHZhbHVlIHdpdGhcbiAqIGBvYmplY3Qub24oJ2NoYW5nZTpwcm9wJywgbGlzdGVuZXIpYC4gWW91IGNhbiBnZXQgYSBsaXN0IG9mIGFsbFxuICogcHJvcGVydGllcyB3aXRoIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3QjZ2V0UHJvcGVydGllc30uXG4gKlxuICogTm90ZSB0aGF0IHRoZSBvYnNlcnZhYmxlIHByb3BlcnRpZXMgYXJlIHNlcGFyYXRlIGZyb20gc3RhbmRhcmQgSlMgcHJvcGVydGllcy5cbiAqIFlvdSBjYW4sIGZvciBleGFtcGxlLCBnaXZlIHlvdXIgbWFwIG9iamVjdCBhIHRpdGxlIHdpdGhcbiAqIGBtYXAudGl0bGU9J05ldyB0aXRsZSdgIGFuZCB3aXRoIGBtYXAuc2V0KCd0aXRsZScsICdBbm90aGVyIHRpdGxlJylgLiBUaGVcbiAqIGZpcnN0IHdpbGwgYmUgYSBgaGFzT3duUHJvcGVydHlgOyB0aGUgc2Vjb25kIHdpbGwgYXBwZWFyIGluXG4gKiBgZ2V0UHJvcGVydGllcygpYC4gT25seSB0aGUgc2Vjb25kIGlzIG9ic2VydmFibGUuXG4gKlxuICogUHJvcGVydGllcyBjYW4gYmUgZGVsZXRlZCBieSB1c2luZyB0aGUgdW5zZXQgbWV0aG9kLiBFLmcuXG4gKiBvYmplY3QudW5zZXQoJ2ZvbycpLlxuICpcbiAqIEBmaXJlcyBPYmplY3RFdmVudFxuICogQGFwaVxuICovXG5jbGFzcyBCYXNlT2JqZWN0IGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj49fSBvcHRfdmFsdWVzIEFuIG9iamVjdCB3aXRoIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF92YWx1ZXMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gQ2FsbCB7QGxpbmsgbW9kdWxlOm9sL3V0aWx+Z2V0VWlkfSB0byBlbnN1cmUgdGhhdCB0aGUgb3JkZXIgb2Ygb2JqZWN0cycgaWRzIGlzXG4gICAgLy8gdGhlIHNhbWUgYXMgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSBjcmVhdGVkLiAgVGhpcyBhbHNvIGhlbHBzIHRvXG4gICAgLy8gZW5zdXJlIHRoYXQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIGFsd2F5cyBhZGRlZCBpbiB0aGUgc2FtZSBvcmRlciwgd2hpY2hcbiAgICAvLyBoZWxwcyBtYW55IEphdmFTY3JpcHQgZW5naW5lcyBnZW5lcmF0ZSBmYXN0ZXIgY29kZS5cbiAgICBnZXRVaWQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgKj59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNfID0ge307XG5cbiAgICBpZiAob3B0X3ZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFByb3BlcnRpZXMob3B0X3ZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkgbmFtZS5cbiAgICogQHJldHVybiB7Kn0gVmFsdWUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKHRoaXMudmFsdWVzXy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzX1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBvYmplY3QgcHJvcGVydHkgbmFtZXMuXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IExpc3Qgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudmFsdWVzXyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBvZiBhbGwgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcy5cbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgKj59IE9iamVjdC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvcGVydGllcygpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCB0aGlzLnZhbHVlc18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gICAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgT2xkIHZhbHVlLlxuICAgKi9cbiAgbm90aWZ5KGtleSwgb2xkVmFsdWUpIHtcbiAgICBsZXQgZXZlbnRUeXBlO1xuICAgIGV2ZW50VHlwZSA9IGdldENoYW5nZUV2ZW50VHlwZShrZXkpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gICAgZXZlbnRUeXBlID0gT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgT2JqZWN0RXZlbnQoZXZlbnRUeXBlLCBrZXksIG9sZFZhbHVlKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2lsZW50IFVwZGF0ZSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXZlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldChrZXksIHZhbHVlLCBvcHRfc2lsZW50KSB7XG4gICAgaWYgKG9wdF9zaWxlbnQpIHtcbiAgICAgIHRoaXMudmFsdWVzX1trZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZXNfW2tleV07XG4gICAgICB0aGlzLnZhbHVlc19ba2V5XSA9IHZhbHVlO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLm5vdGlmeShrZXksIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGNvbGxlY3Rpb24gb2Yga2V5LXZhbHVlIHBhaXJzLiAgTm90ZSB0aGF0IHRoaXMgY2hhbmdlcyBhbnkgZXhpc3RpbmdcbiAgICogcHJvcGVydGllcyBhbmQgYWRkcyBuZXcgb25lcyAoaXQgZG9lcyBub3QgcmVtb3ZlIGFueSBleGlzdGluZyBwcm9wZXJ0aWVzKS5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPn0gdmFsdWVzIFZhbHVlcy5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3NpbGVudCBVcGRhdGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRQcm9wZXJ0aWVzKHZhbHVlcywgb3B0X3NpbGVudCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlcykge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZXNba2V5XSwgb3B0X3NpbGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuc2V0cyBhIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleSBuYW1lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfc2lsZW50IFVuc2V0IHdpdGhvdXQgdHJpZ2dlcmluZyBhbiBldmVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgdW5zZXQoa2V5LCBvcHRfc2lsZW50KSB7XG4gICAgaWYgKGtleSBpbiB0aGlzLnZhbHVlc18pIHtcbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZXNfW2tleV07XG4gICAgICBkZWxldGUgdGhpcy52YWx1ZXNfW2tleV07XG4gICAgICBpZiAoIW9wdF9zaWxlbnQpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoa2V5LCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAqL1xuY29uc3QgY2hhbmdlRXZlbnRUeXBlQ2FjaGUgPSB7fTtcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IG5hbWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENoYW5nZSBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbmdlRXZlbnRUeXBlKGtleSkge1xuICByZXR1cm4gY2hhbmdlRXZlbnRUeXBlQ2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSA/XG4gICAgY2hhbmdlRXZlbnRUeXBlQ2FjaGVba2V5XSA6XG4gICAgKGNoYW5nZUV2ZW50VHlwZUNhY2hlW2tleV0gPSAnY2hhbmdlOicgKyBrZXkpO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VPYmplY3Q7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQU9BO0FBQ0E7Ozs7Ozs7QUFPQTs7Ozs7Ozs7QUFRQTs7Ozs7QUFFQTs7QUF6QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlFQTtBQUFBO0FBQUE7QUFLQTtBQUNBOzs7OztBQU1BOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXBIQTs7Ozs7O0FBMEhBOzs7Ozs7QUFPQTtBQUNBO0FBR0E7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createCanvasContext2D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return outerWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return outerHeight; });\n/* unused harmony export replaceNode */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return removeNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return removeChildren; });\n/**\n * @module ol/dom\n */\n\n/**\n * Create an html canvas element and returns its 2d context.\n * @param {number=} opt_width Canvas width.\n * @param {number=} opt_height Canvas height.\n * @return {CanvasRenderingContext2D} The context.\n */\nfunction createCanvasContext2D(opt_width, opt_height) {\n  var canvas =\n  /** @type {HTMLCanvasElement} */\n  document.createElement(\'canvas\');\n\n  if (opt_width) {\n    canvas.width = opt_width;\n  }\n\n  if (opt_height) {\n    canvas.height = opt_height;\n  }\n\n  return (\n    /** @type {CanvasRenderingContext2D} */\n    canvas.getContext(\'2d\')\n  );\n}\n/**\n * Get the current computed width for the given element including margin,\n * padding and border.\n * Equivalent to jQuery\'s `$(el).outerWidth(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The width.\n */\n\nfunction outerWidth(element) {\n  var width = element.offsetWidth;\n  var style = getComputedStyle(element);\n  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);\n  return width;\n}\n/**\n * Get the current computed height for the given element including margin,\n * padding and border.\n * Equivalent to jQuery\'s `$(el).outerHeight(true)`.\n * @param {!HTMLElement} element Element.\n * @return {number} The height.\n */\n\nfunction outerHeight(element) {\n  var height = element.offsetHeight;\n  var style = getComputedStyle(element);\n  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);\n  return height;\n}\n/**\n * @param {Node} newNode Node to replace old node\n * @param {Node} oldNode The node to be replaced\n */\n\nfunction replaceNode(newNode, oldNode) {\n  var parent = oldNode.parentNode;\n\n  if (parent) {\n    parent.replaceChild(newNode, oldNode);\n  }\n}\n/**\n * @param {Node} node The node to remove.\n * @returns {Node} The node that was removed or null.\n */\n\nfunction removeNode(node) {\n  return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\n\nfunction removeChildren(node) {\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2RvbS5qcz9jNWY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9kb21cbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGh0bWwgY2FudmFzIGVsZW1lbnQgYW5kIHJldHVybnMgaXRzIDJkIGNvbnRleHQuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF93aWR0aCBDYW52YXMgd2lkdGguXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9oZWlnaHQgQ2FudmFzIGhlaWdodC5cbiAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gVGhlIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYW52YXNDb250ZXh0MkQob3B0X3dpZHRoLCBvcHRfaGVpZ2h0KSB7XG4gIGNvbnN0IGNhbnZhcyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XG4gIGlmIChvcHRfd2lkdGgpIHtcbiAgICBjYW52YXMud2lkdGggPSBvcHRfd2lkdGg7XG4gIH1cbiAgaWYgKG9wdF9oZWlnaHQpIHtcbiAgICBjYW52YXMuaGVpZ2h0ID0gb3B0X2hlaWdodDtcbiAgfVxuICByZXR1cm4gLyoqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICovIChjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgY29tcHV0ZWQgd2lkdGggZm9yIHRoZSBnaXZlbiBlbGVtZW50IGluY2x1ZGluZyBtYXJnaW4sXG4gKiBwYWRkaW5nIGFuZCBib3JkZXIuXG4gKiBFcXVpdmFsZW50IHRvIGpRdWVyeSdzIGAkKGVsKS5vdXRlcldpZHRoKHRydWUpYC5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG91dGVyV2lkdGgoZWxlbWVudCkge1xuICBsZXQgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHdpZHRoICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLm1hcmdpblJpZ2h0LCAxMCk7XG5cbiAgcmV0dXJuIHdpZHRoO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGNvbXB1dGVkIGhlaWdodCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgaW5jbHVkaW5nIG1hcmdpbixcbiAqIHBhZGRpbmcgYW5kIGJvcmRlci5cbiAqIEVxdWl2YWxlbnQgdG8galF1ZXJ5J3MgYCQoZWwpLm91dGVySGVpZ2h0KHRydWUpYC5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlckhlaWdodChlbGVtZW50KSB7XG4gIGxldCBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBoZWlnaHQgKz0gcGFyc2VJbnQoc3R5bGUubWFyZ2luVG9wLCAxMCkgKyBwYXJzZUludChzdHlsZS5tYXJnaW5Cb3R0b20sIDEwKTtcblxuICByZXR1cm4gaGVpZ2h0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZSBOb2RlIHRvIHJlcGxhY2Ugb2xkIG5vZGVcbiAqIEBwYXJhbSB7Tm9kZX0gb2xkTm9kZSBUaGUgbm9kZSB0byBiZSByZXBsYWNlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5vZGUobmV3Tm9kZSwgb2xkTm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBvbGROb2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkKG5ld05vZGUsIG9sZE5vZGUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtOb2RlfSBUaGUgbm9kZSB0aGF0IHdhcyByZW1vdmVkIG9yIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlID8gbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBmcm9tLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4obm9kZSkge1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\n/**\n * @module ol/MapBrowserEventType\n */\n\n/**\n * Constants for event names.\n * @enum {string}\n */\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  /**\n   * A true single click with no dragging and no double click. Note that this\n   * event is delayed by 250 ms to ensure that it is not a double click.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick\n   * @api\n   */\n  SINGLECLICK: 'singleclick',\n\n  /**\n   * A click with no dragging. A double click will fire two of this.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click\n   * @api\n   */\n  CLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].CLICK,\n\n  /**\n   * A true double click, with no dragging.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick\n   * @api\n   */\n  DBLCLICK: _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].DBLCLICK,\n\n  /**\n   * Triggered when a pointer is dragged.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag\n   * @api\n   */\n  POINTERDRAG: 'pointerdrag',\n\n  /**\n   * Triggered when a pointer is moved. Note that on touch devices this is\n   * triggered when the map is panned, so is not the same as mousemove.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove\n   * @api\n   */\n  POINTERMOVE: 'pointermove',\n  POINTERDOWN: 'pointerdown',\n  POINTERUP: 'pointerup',\n  POINTEROVER: 'pointerover',\n  POINTEROUT: 'pointerout',\n  POINTERENTER: 'pointerenter',\n  POINTERLEAVE: 'pointerleave',\n  POINTERCANCEL: 'pointercancel'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL01hcEJyb3dzZXJFdmVudFR5cGUuanM/NDczNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvTWFwQnJvd3NlckV2ZW50VHlwZVxuICovXG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciBldmVudCBuYW1lcy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcbiAgICogQSB0cnVlIHNpbmdsZSBjbGljayB3aXRoIG5vIGRyYWdnaW5nIGFuZCBubyBkb3VibGUgY2xpY2suIE5vdGUgdGhhdCB0aGlzXG4gICAqIGV2ZW50IGlzIGRlbGF5ZWQgYnkgMjUwIG1zIHRvIGVuc3VyZSB0aGF0IGl0IGlzIG5vdCBhIGRvdWJsZSBjbGljay5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I3NpbmdsZWNsaWNrXG4gICAqIEBhcGlcbiAgICovXG4gIFNJTkdMRUNMSUNLOiAnc2luZ2xlY2xpY2snLFxuXG4gIC8qKlxuICAgKiBBIGNsaWNrIHdpdGggbm8gZHJhZ2dpbmcuIEEgZG91YmxlIGNsaWNrIHdpbGwgZmlyZSB0d28gb2YgdGhpcy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I2NsaWNrXG4gICAqIEBhcGlcbiAgICovXG4gIENMSUNLOiBFdmVudFR5cGUuQ0xJQ0ssXG5cbiAgLyoqXG4gICAqIEEgdHJ1ZSBkb3VibGUgY2xpY2ssIHdpdGggbm8gZHJhZ2dpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNkYmxjbGlja1xuICAgKiBAYXBpXG4gICAqL1xuICBEQkxDTElDSzogRXZlbnRUeXBlLkRCTENMSUNLLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHBvaW50ZXIgaXMgZHJhZ2dlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50I3BvaW50ZXJkcmFnXG4gICAqIEBhcGlcbiAgICovXG4gIFBPSU5URVJEUkFHOiAncG9pbnRlcmRyYWcnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHBvaW50ZXIgaXMgbW92ZWQuIE5vdGUgdGhhdCBvbiB0b3VjaCBkZXZpY2VzIHRoaXMgaXNcbiAgICogdHJpZ2dlcmVkIHdoZW4gdGhlIG1hcCBpcyBwYW5uZWQsIHNvIGlzIG5vdCB0aGUgc2FtZSBhcyBtb3VzZW1vdmUuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudCNwb2ludGVybW92ZVxuICAgKiBAYXBpXG4gICAqL1xuICBQT0lOVEVSTU9WRTogJ3BvaW50ZXJtb3ZlJyxcblxuICBQT0lOVEVSRE9XTjogJ3BvaW50ZXJkb3duJyxcbiAgUE9JTlRFUlVQOiAncG9pbnRlcnVwJyxcbiAgUE9JTlRFUk9WRVI6ICdwb2ludGVyb3ZlcicsXG4gIFBPSU5URVJPVVQ6ICdwb2ludGVyb3V0JyxcbiAgUE9JTlRFUkVOVEVSOiAncG9pbnRlcmVudGVyJyxcbiAgUE9JTlRFUkxFQVZFOiAncG9pbnRlcmxlYXZlJyxcbiAgUE9JTlRFUkNBTkNFTDogJ3BvaW50ZXJjYW5jZWwnXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7QUFHQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7O0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/**\n * @module ol/ViewHint\n */\n\n/**\n * @enum {number}\n */\n/* harmony default export */ __webpack_exports__["a"] = ({\n  ANIMATING: 0,\n  INTERACTING: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL1ZpZXdIaW50LmpzPzE0ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdIaW50XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFOSU1BVElORzogMCxcbiAgSU5URVJBQ1RJTkc6IDFcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return FIREFOX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return SAFARI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return WEBKIT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return MAC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return DEVICE_PIXEL_RATIO; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CANVAS_LINE_DASH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return GEOLOCATION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return TOUCH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return POINTER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return MSPOINTER; });\n/**\n * @module ol/has\n */\nvar ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\n/**\n * User agent string says we are dealing with Firefox as browser.\n * @type {boolean}\n */\n\nvar FIREFOX = ua.indexOf('firefox') !== -1;\n/**\n * User agent string says we are dealing with Safari as browser.\n * @type {boolean}\n */\n\nvar SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;\n/**\n * User agent string says we are dealing with a WebKit engine.\n * @type {boolean}\n */\n\nvar WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;\n/**\n * User agent string says we are dealing with a Mac as platform.\n * @type {boolean}\n */\n\nvar MAC = ua.indexOf('macintosh') !== -1;\n/**\n * The ratio between physical pixels and device-independent pixels\n * (dips) on the device (`window.devicePixelRatio`).\n * @const\n * @type {number}\n * @api\n */\n\nvar DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;\n/**\n * True if the browser's Canvas implementation implements {get,set}LineDash.\n * @type {boolean}\n */\n\nvar CANVAS_LINE_DASH = function () {\n  var has = false;\n\n  try {\n    has = !!document.createElement('canvas').getContext('2d').setLineDash;\n  } catch (e) {// pass\n  }\n\n  return has;\n}();\n/**\n * Is HTML5 geolocation supported in the current browser?\n * @const\n * @type {boolean}\n * @api\n */\n\nvar GEOLOCATION = 'geolocation' in navigator;\n/**\n * True if browser supports touch events.\n * @const\n * @type {boolean}\n * @api\n */\n\nvar TOUCH = 'ontouchstart' in window;\n/**\n * True if browser supports pointer events.\n * @const\n * @type {boolean}\n */\n\nvar POINTER = 'PointerEvent' in window;\n/**\n * True if browser supports ms pointer events (IE 10).\n * @const\n * @type {boolean}\n */\n\nvar MSPOINTER = !!navigator.msPointerEnabled;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2hhcy5qcz85ZjBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9oYXNcbiAqL1xuXG5jb25zdCB1YSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID9cbiAgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogJyc7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIEZpcmVmb3ggYXMgYnJvd3Nlci5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgRklSRUZPWCA9IHVhLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG5cbi8qKlxuICogVXNlciBhZ2VudCBzdHJpbmcgc2F5cyB3ZSBhcmUgZGVhbGluZyB3aXRoIFNhZmFyaSBhcyBicm93c2VyLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBTQUZBUkkgPSB1YS5pbmRleE9mKCdzYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignY2hyb20nKSA9PSAtMTtcblxuLyoqXG4gKiBVc2VyIGFnZW50IHN0cmluZyBzYXlzIHdlIGFyZSBkZWFsaW5nIHdpdGggYSBXZWJLaXQgZW5naW5lLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBXRUJLSVQgPSB1YS5pbmRleE9mKCd3ZWJraXQnKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignZWRnZScpID09IC0xO1xuXG4vKipcbiAqIFVzZXIgYWdlbnQgc3RyaW5nIHNheXMgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIE1hYyBhcyBwbGF0Zm9ybS5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgTUFDID0gdWEuaW5kZXhPZignbWFjaW50b3NoJykgIT09IC0xO1xuXG5cbi8qKlxuICogVGhlIHJhdGlvIGJldHdlZW4gcGh5c2ljYWwgcGl4ZWxzIGFuZCBkZXZpY2UtaW5kZXBlbmRlbnQgcGl4ZWxzXG4gKiAoZGlwcykgb24gdGhlIGRldmljZSAoYHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvYCkuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBERVZJQ0VfUElYRUxfUkFUSU8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgYnJvd3NlcidzIENhbnZhcyBpbXBsZW1lbnRhdGlvbiBpbXBsZW1lbnRzIHtnZXQsc2V0fUxpbmVEYXNoLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBDQU5WQVNfTElORV9EQVNIID0gZnVuY3Rpb24oKSB7XG4gIGxldCBoYXMgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBoYXMgPSAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJykuc2V0TGluZURhc2g7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBwYXNzXG4gIH1cbiAgcmV0dXJuIGhhcztcbn0oKTtcblxuXG4vKipcbiAqIElzIEhUTUw1IGdlb2xvY2F0aW9uIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyP1xuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IEdFT0xPQ0FUSU9OID0gJ2dlb2xvY2F0aW9uJyBpbiBuYXZpZ2F0b3I7XG5cblxuLyoqXG4gKiBUcnVlIGlmIGJyb3dzZXIgc3VwcG9ydHMgdG91Y2ggZXZlbnRzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IFRPVUNIID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuXG5cbi8qKlxuICogVHJ1ZSBpZiBicm93c2VyIHN1cHBvcnRzIHBvaW50ZXIgZXZlbnRzLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IFBPSU5URVIgPSAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3c7XG5cblxuLyoqXG4gKiBUcnVlIGlmIGJyb3dzZXIgc3VwcG9ydHMgbXMgcG9pbnRlciBldmVudHMgKElFIDEwKS5cbiAqIEBjb25zdFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBNU1BPSU5URVIgPSAhIShuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCk7XG5cblxuZXhwb3J0IHtIQVMgYXMgV0VCR0x9IGZyb20gJy4vd2ViZ2wuanMnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFJQTs7Ozs7O0FBT0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7OztBQVVBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7QUFTQTs7Ozs7OztBQVFBOzs7Ozs7O0FBUUE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TRUE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FALSE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return VOID; });\n/**\n * @module ol/functions\n */\n\n/**\n * Always returns true.\n * @returns {boolean} true.\n */\nfunction TRUE() {\n  return true;\n}\n/**\n * Always returns false.\n * @returns {boolean} false.\n */\n\nfunction FALSE() {\n  return false;\n}\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\n\nfunction VOID() {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2Z1bmN0aW9ucy5qcz8zMWZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9mdW5jdGlvbnNcbiAqL1xuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRSVUUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm5zIGZhbHNlLlxuICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRkFMU0UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHJldXNhYmxlIGZ1bmN0aW9uLCB1c2VkIGUuZy4gYXMgYSBkZWZhdWx0IGZvciBjYWxsYmFja3MuXG4gKlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFZPSUQoKSB7fVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7OztBQU9BIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/geom/GeometryLayout\n */\n\n/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  XY: 'XY',\n  XYZ: 'XYZ',\n  XYM: 'XYM',\n  XYZM: 'XYZM'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2dlb20vR2VvbWV0cnlMYXlvdXQuanM/ZDliZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9HZW9tZXRyeUxheW91dFxuICovXG5cbi8qKlxuICogVGhlIGNvb3JkaW5hdGUgbGF5b3V0IGZvciBnZW9tZXRyaWVzLCBpbmRpY2F0aW5nIHdoZXRoZXIgYSAzcmQgb3IgNHRoIHogKCdaJylcbiAqIG9yIG1lYXN1cmUgKCdNJykgY29vcmRpbmF0ZSBpcyBhdmFpbGFibGUuIFN1cHBvcnRlZCB2YWx1ZXMgYXJlIGAnWFknYCxcbiAqIGAnWFlaJ2AsIGAnWFlNJ2AsIGAnWFlaTSdgLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBYWTogJ1hZJyxcbiAgWFlaOiAnWFlaJyxcbiAgWFlNOiAnWFlNJyxcbiAgWFlaTTogJ1hZWk0nXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///21\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/**\n * @module ol/ImageState\n */\n\n/**\n * @enum {number}\n */\n/* harmony default export */ __webpack_exports__["a"] = ({\n  IDLE: 0,\n  LOADING: 1,\n  LOADED: 2,\n  ERROR: 3\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL0ltYWdlU3RhdGUuanM/N2NlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvSW1hZ2VTdGF0ZVxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJRExFOiAwLFxuICBMT0FESU5HOiAxLFxuICBMT0FERUQ6IDIsXG4gIEVSUk9SOiAzXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return stopPropagation; });\n/* unused harmony export preventDefault */\n/**\n * @module ol/events/Event\n */\n\n/**\n * @classdesc\n * Stripped down implementation of the W3C DOM Level 2 Event interface.\n * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.\n *\n * This implementation only provides `type` and `target` properties, and\n * `stopPropagation` and `preventDefault` methods. It is meant as base class\n * for higher level events defined in the library, and works with\n * {@link module:ol/events/Target~Target}.\n */\nvar Event = function Event(type) {\n  /**\n   * @type {boolean}\n   */\n  this.propagationStopped;\n  /**\n   * The event type.\n   * @type {string}\n   * @api\n   */\n\n  this.type = type;\n  /**\n   * The event target.\n   * @type {Object}\n   * @api\n   */\n\n  this.target = null;\n};\n/**\n * Stop event propagation.\n * @api\n */\n\n\nEvent.prototype.preventDefault = function preventDefault() {\n  this.propagationStopped = true;\n};\n/**\n * Stop event propagation.\n * @api\n */\n\n\nEvent.prototype.stopPropagation = function stopPropagation() {\n  this.propagationStopped = true;\n};\n/**\n * @param {Event|import("./Event.js").default} evt Event\n */\n\n\nfunction stopPropagation(evt) {\n  evt.stopPropagation();\n}\n/**\n * @param {Event|import("./Event.js").default} evt Event\n */\n\nfunction preventDefault(evt) {\n  evt.preventDefault();\n}\n/* harmony default export */ __webpack_exports__["a"] = (Event);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2V2ZW50cy9FdmVudC5qcz9lOGFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9ldmVudHMvRXZlbnRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIFN0cmlwcGVkIGRvd24gaW1wbGVtZW50YXRpb24gb2YgdGhlIFczQyBET00gTGV2ZWwgMiBFdmVudCBpbnRlcmZhY2UuXG4gKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtaW50ZXJmYWNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gb25seSBwcm92aWRlcyBgdHlwZWAgYW5kIGB0YXJnZXRgIHByb3BlcnRpZXMsIGFuZFxuICogYHN0b3BQcm9wYWdhdGlvbmAgYW5kIGBwcmV2ZW50RGVmYXVsdGAgbWV0aG9kcy4gSXQgaXMgbWVhbnQgYXMgYmFzZSBjbGFzc1xuICogZm9yIGhpZ2hlciBsZXZlbCBldmVudHMgZGVmaW5lZCBpbiB0aGUgbGlicmFyeSwgYW5kIHdvcmtzIHdpdGhcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL1RhcmdldH5UYXJnZXR9LlxuICovXG5jbGFzcyBFdmVudCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXZlbnQgdGFyZ2V0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfVxuXG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fGltcG9ydChcIi4vRXZlbnQuanNcIikuZGVmYXVsdH0gZXZ0IEV2ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZXZ0KSB7XG4gIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnR8aW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fSBldnQgRXZlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2dCkge1xuICBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQU9BOzs7QUFHQTtBQUVBOzs7Ozs7QUFLQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///23\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/layer/Property\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  OPACITY: 'opacity',\n  VISIBLE: 'visible',\n  EXTENT: 'extent',\n  Z_INDEX: 'zIndex',\n  MAX_RESOLUTION: 'maxResolution',\n  MIN_RESOLUTION: 'minResolution',\n  SOURCE: 'source'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2xheWVyL1Byb3BlcnR5LmpzP2NmZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL1Byb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIE9QQUNJVFk6ICdvcGFjaXR5JyxcbiAgVklTSUJMRTogJ3Zpc2libGUnLFxuICBFWFRFTlQ6ICdleHRlbnQnLFxuICBaX0lOREVYOiAnekluZGV4JyxcbiAgTUFYX1JFU09MVVRJT046ICdtYXhSZXNvbHV0aW9uJyxcbiAgTUlOX1JFU09MVVRJT046ICdtaW5SZXNvbHV0aW9uJyxcbiAgU09VUkNFOiAnc291cmNlJ1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/**\n * @module ol/extent/Relationship\n */\n\n/**\n * Relationship to an extent.\n * @enum {number}\n */\n/* harmony default export */ __webpack_exports__["a"] = ({\n  UNKNOWN: 0,\n  INTERSECTING: 1,\n  ABOVE: 2,\n  RIGHT: 4,\n  BELOW: 8,\n  LEFT: 16\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2V4dGVudC9SZWxhdGlvbnNoaXAuanM/YjZkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50L1JlbGF0aW9uc2hpcFxuICovXG5cbi8qKlxuICogUmVsYXRpb25zaGlwIHRvIGFuIGV4dGVudC5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgVU5LTk9XTjogMCxcbiAgSU5URVJTRUNUSU5HOiAxLFxuICBBQk9WRTogMixcbiAgUklHSFQ6IDQsXG4gIEJFTE9XOiA4LFxuICBMRUZUOiAxNlxufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return METERS_PER_UNIT; });\n/**\n * @module ol/proj/Units\n */\n\n/**\n * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or\n * `'us-ft'`.\n * @enum {string}\n */\nvar Units = {\n  DEGREES: 'degrees',\n  FEET: 'ft',\n  METERS: 'm',\n  PIXELS: 'pixels',\n  TILE_PIXELS: 'tile-pixels',\n  USFEET: 'us-ft'\n};\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object<Units, number>}\n * @api\n */\n\nvar METERS_PER_UNIT = {}; // use the radius of the Normal sphere\n\nMETERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;\nMETERS_PER_UNIT[Units.FEET] = 0.3048;\nMETERS_PER_UNIT[Units.METERS] = 1;\nMETERS_PER_UNIT[Units.USFEET] = 1200 / 3937;\n/* harmony default export */ __webpack_exports__[\"b\"] = (Units);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3Byb2ovVW5pdHMuanM/M2MxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcHJvai9Vbml0c1xuICovXG5cbi8qKlxuICogUHJvamVjdGlvbiB1bml0czogYCdkZWdyZWVzJ2AsIGAnZnQnYCwgYCdtJ2AsIGAncGl4ZWxzJ2AsIGAndGlsZS1waXhlbHMnYCBvclxuICogYCd1cy1mdCdgLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVW5pdHMgPSB7XG4gIERFR1JFRVM6ICdkZWdyZWVzJyxcbiAgRkVFVDogJ2Z0JyxcbiAgTUVURVJTOiAnbScsXG4gIFBJWEVMUzogJ3BpeGVscycsXG4gIFRJTEVfUElYRUxTOiAndGlsZS1waXhlbHMnLFxuICBVU0ZFRVQ6ICd1cy1mdCdcbn07XG5cblxuLyoqXG4gKiBNZXRlcnMgcGVyIHVuaXQgbG9va3VwIHRhYmxlLlxuICogQGNvbnN0XG4gKiBAdHlwZSB7T2JqZWN0PFVuaXRzLCBudW1iZXI+fVxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgTUVURVJTX1BFUl9VTklUID0ge307XG4vLyB1c2UgdGhlIHJhZGl1cyBvZiB0aGUgTm9ybWFsIHNwaGVyZVxuTUVURVJTX1BFUl9VTklUW1VuaXRzLkRFR1JFRVNdID0gMiAqIE1hdGguUEkgKiA2MzcwOTk3IC8gMzYwO1xuTUVURVJTX1BFUl9VTklUW1VuaXRzLkZFRVRdID0gMC4zMDQ4O1xuTUVURVJTX1BFUl9VTklUW1VuaXRzLk1FVEVSU10gPSAxO1xuTUVURVJTX1BFUl9VTklUW1VuaXRzLlVTRkVFVF0gPSAxMjAwIC8gMzkzNztcblxuZXhwb3J0IGRlZmF1bHQgVW5pdHM7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/CollectionEventType\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  /**\n   * Triggered when an item is added to the collection.\n   * @event module:ol/Collection.CollectionEvent#add\n   * @api\n   */\n  ADD: 'add',\n\n  /**\n   * Triggered when an item is removed from the collection.\n   * @event module:ol/Collection.CollectionEvent#remove\n   * @api\n   */\n  REMOVE: 'remove'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL0NvbGxlY3Rpb25FdmVudFR5cGUuanM/MmNhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvQ29sbGVjdGlvbkV2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gYW4gaXRlbSBpcyBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9Db2xsZWN0aW9uLkNvbGxlY3Rpb25FdmVudCNhZGRcbiAgICogQGFwaVxuICAgKi9cbiAgQUREOiAnYWRkJyxcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL0NvbGxlY3Rpb24uQ29sbGVjdGlvbkV2ZW50I3JlbW92ZVxuICAgKiBAYXBpXG4gICAqL1xuICBSRU1PVkU6ICdyZW1vdmUnXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQU9BOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFLQTtBQVpBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeIn", function() { return easeIn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "easeOut", function() { return easeOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inAndOut", function() { return inAndOut; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "upAndDown", function() { return upAndDown; });\n/**\n * @module ol/easing\n */\n\n/**\n * Start slow and speed up.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\nfunction easeIn(t) {\n  return Math.pow(t, 3);\n}\n/**\n * Start fast and slow down.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\n\nfunction easeOut(t) {\n  return 1 - easeIn(1 - t);\n}\n/**\n * Start slow, speed up, and then slow down again.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\n\nfunction inAndOut(t) {\n  return 3 * t * t - 2 * t * t * t;\n}\n/**\n * Maintain a constant speed over time.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\n\nfunction linear(t) {\n  return t;\n}\n/**\n * Start slow, speed up, and at the very end slow down again.  This has the\n * same general behavior as {@link module:ol/easing~inAndOut}, but the final\n * slowdown is delayed.\n * @param {number} t Input between 0 and 1.\n * @return {number} Output between 0 and 1.\n * @api\n */\n\nfunction upAndDown(t) {\n  if (t < 0.5) {\n    return inAndOut(2 * t);\n  } else {\n    return 1 - inAndOut(2 * (t - 0.5));\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2Vhc2luZy5qcz9mMWY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9lYXNpbmdcbiAqL1xuXG5cbi8qKlxuICogU3RhcnQgc2xvdyBhbmQgc3BlZWQgdXAuXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYXNlSW4odCkge1xuICByZXR1cm4gTWF0aC5wb3codCwgMyk7XG59XG5cblxuLyoqXG4gKiBTdGFydCBmYXN0IGFuZCBzbG93IGRvd24uXG4gKiBAcGFyYW0ge251bWJlcn0gdCBJbnB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE91dHB1dCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYXNlT3V0KHQpIHtcbiAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHQpO1xufVxuXG5cbi8qKlxuICogU3RhcnQgc2xvdywgc3BlZWQgdXAsIGFuZCB0aGVuIHNsb3cgZG93biBhZ2Fpbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluQW5kT3V0KHQpIHtcbiAgcmV0dXJuIDMgKiB0ICogdCAtIDIgKiB0ICogdCAqIHQ7XG59XG5cblxuLyoqXG4gKiBNYWludGFpbiBhIGNvbnN0YW50IHNwZWVkIG92ZXIgdGltZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0IElucHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEByZXR1cm4ge251bWJlcn0gT3V0cHV0IGJldHdlZW4gMCBhbmQgMS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gIHJldHVybiB0O1xufVxuXG5cbi8qKlxuICogU3RhcnQgc2xvdywgc3BlZWQgdXAsIGFuZCBhdCB0aGUgdmVyeSBlbmQgc2xvdyBkb3duIGFnYWluLiAgVGhpcyBoYXMgdGhlXG4gKiBzYW1lIGdlbmVyYWwgYmVoYXZpb3IgYXMge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmd+aW5BbmRPdXR9LCBidXQgdGhlIGZpbmFsXG4gKiBzbG93ZG93biBpcyBkZWxheWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHQgSW5wdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHJldHVybiB7bnVtYmVyfSBPdXRwdXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBBbmREb3duKHQpIHtcbiAgaWYgKHQgPCAwLjUpIHtcbiAgICByZXR1cm4gaW5BbmRPdXQoMiAqIHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxIC0gaW5BbmRPdXQoMiAqICh0IC0gMC41KSk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export altKeyOnly */\n/* unused harmony export altShiftKeysOnly */\n/* unused harmony export focus */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return always; });\n/* unused harmony export click */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return mouseActionButton; });\n/* unused harmony export never */\n/* unused harmony export pointerMove */\n/* unused harmony export singleClick */\n/* unused harmony export doubleClick */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return noModifierKeys; });\n/* unused harmony export platformModifierKeyOnly */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return shiftKeyOnly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return targetNotEditable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return mouseOnly; });\n/* unused harmony export primaryAction */\n/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);\n/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);\n/**\n * @module ol/events/condition\n */\n\n\n\n\n/**\n * A function that takes an {@link module:ol/MapBrowserEvent} and returns a\n * `{boolean}`. If the condition is met, true should be returned.\n *\n * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition\n */\n\n/**\n * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\n * additionally the shift-key is pressed).\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the alt key is pressed.\n * @api\n */\n\nvar altKeyOnly = function altKeyOnly(mapBrowserEvent) {\n  var originalEvent =\n  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\n/**\n * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\n * (e.g. when additionally the platform-modifier-key is pressed).\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the alt and shift keys are pressed.\n * @api\n */\n\nvar altShiftKeysOnly = function altShiftKeysOnly(mapBrowserEvent) {\n  var originalEvent =\n  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;\n};\n/**\n * Return `true` if the map has the focus. This condition requires a map target\n * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.\n *\n * @param {import("../MapBrowserEvent.js").default} event Map browser event.\n * @return {boolean} The map has the focus.\n * @api\n */\n\nvar focus = function focus(event) {\n  return event.target.getTargetElement() === document.activeElement;\n};\n/**\n * Return always true.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True.\n * @api\n */\n\nvar always = _functions_js__WEBPACK_IMPORTED_MODULE_2__[/* TRUE */ "b"];\n/**\n * Return `true` if the event is a `click` event, `false` otherwise.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `click` event.\n * @api\n */\n\nvar click = function click(mapBrowserEvent) {\n  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].CLICK;\n};\n/**\n * Return `true` if the event has an "action"-producing mouse button.\n *\n * By definition, this includes left-click on windows/linux, and left-click\n * without the ctrl key on Macs.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} The result.\n */\n\nvar mouseActionButton = function mouseActionButton(mapBrowserEvent) {\n  var originalEvent =\n  /** @type {MouseEvent} */\n  mapBrowserEvent.originalEvent;\n  return originalEvent.button == 0 && !(_has_js__WEBPACK_IMPORTED_MODULE_3__[/* WEBKIT */ "j"] && _has_js__WEBPACK_IMPORTED_MODULE_3__[/* MAC */ "e"] && originalEvent.ctrlKey);\n};\n/**\n * Return always false.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} False.\n * @api\n */\n\nvar never = _functions_js__WEBPACK_IMPORTED_MODULE_2__[/* FALSE */ "a"];\n/**\n * Return `true` if the browser event is a `pointermove` event, `false`\n * otherwise.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the browser event is a `pointermove` event.\n * @api\n */\n\nvar pointerMove = function pointerMove(mapBrowserEvent) {\n  return mapBrowserEvent.type == \'pointermove\';\n};\n/**\n * Return `true` if the event is a map `singleclick` event, `false` otherwise.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `singleclick` event.\n * @api\n */\n\nvar singleClick = function singleClick(mapBrowserEvent) {\n  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].SINGLECLICK;\n};\n/**\n * Return `true` if the event is a map `dblclick` event, `false` otherwise.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `dblclick` event.\n * @api\n */\n\nvar doubleClick = function doubleClick(mapBrowserEvent) {\n  return mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].DBLCLICK;\n};\n/**\n * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\n * pressed.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True only if there no modifier keys are pressed.\n * @api\n */\n\nvar noModifierKeys = function noModifierKeys(mapBrowserEvent) {\n  var originalEvent =\n  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\n/**\n * Return `true` if only the platform-modifier-key (the meta-key on Mac,\n * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally\n * the shift-key is pressed).\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the platform modifier key is pressed.\n * @api\n */\n\nvar platformModifierKeyOnly = function platformModifierKeyOnly(mapBrowserEvent) {\n  var originalEvent =\n  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && (_has_js__WEBPACK_IMPORTED_MODULE_3__[/* MAC */ "e"] ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;\n};\n/**\n * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\n * additionally the alt-key is pressed).\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the shift key is pressed.\n * @api\n */\n\nvar shiftKeyOnly = function shiftKeyOnly(mapBrowserEvent) {\n  var originalEvent =\n  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */\n  mapBrowserEvent.originalEvent;\n  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;\n};\n/**\n * Return `true` if the target element is not editable, i.e. not a `<input>`-,\n * `<select>`- or `<textarea>`-element, `false` otherwise.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True only if the target element is not editable.\n * @api\n */\n\nvar targetNotEditable = function targetNotEditable(mapBrowserEvent) {\n  var target = mapBrowserEvent.originalEvent.target;\n  var tagName =\n  /** @type {Element} */\n  target.tagName;\n  return tagName !== \'INPUT\' && tagName !== \'SELECT\' && tagName !== \'TEXTAREA\';\n};\n/**\n * Return `true` if the event originates from a mouse device.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a mouse device.\n * @api\n */\n\nvar mouseOnly = function mouseOnly(mapBrowserEvent) {\n  var pointerEvent =\n  /** @type {import("../MapBrowserPointerEvent").default} */\n  mapBrowserEvent.pointerEvent;\n  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__[/* assert */ "a"])(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n\n  return pointerEvent.pointerType == \'mouse\';\n};\n/**\n * Return `true` if the event originates from a primary pointer in\n * contact with the surface or if the left mouse button is pressed.\n * See http://www.w3.org/TR/pointerevents/#button-states.\n *\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a primary pointer.\n * @api\n */\n\nvar primaryAction = function primaryAction(mapBrowserEvent) {\n  var pointerEvent =\n  /** @type {import("../MapBrowserPointerEvent").default} */\n  mapBrowserEvent.pointerEvent;\n  Object(_asserts_js__WEBPACK_IMPORTED_MODULE_1__[/* assert */ "a"])(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event\n\n  return pointerEvent.isPrimary && pointerEvent.button === 0;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2V2ZW50cy9jb25kaXRpb24uanM/MjE0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL2NvbmRpdGlvblxuICovXG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7VFJVRSwgRkFMU0V9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge1dFQktJVCwgTUFDfSBmcm9tICcuLi9oYXMuanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBge2Jvb2xlYW59YC4gSWYgdGhlIGNvbmRpdGlvbiBpcyBtZXQsIHRydWUgc2hvdWxkIGJlIHJldHVybmVkLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbih0aGlzOiA/LCBpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IENvbmRpdGlvblxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIGFsdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlblxuICogYWRkaXRpb25hbGx5IHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQga2V5IGlzIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBhbHRLZXlPbmx5ID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICByZXR1cm4gKFxuICAgIG9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiBvbmx5IHRoZSBhbHQta2V5IGFuZCBzaGlmdC1rZXkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIChlLmcuIHdoZW4gYWRkaXRpb25hbGx5IHRoZSBwbGF0Zm9ybS1tb2RpZmllci1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBhbHQgYW5kIHNoaWZ0IGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBhbHRTaGlmdEtleXNPbmx5ID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICByZXR1cm4gKFxuICAgIG9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgICAhKG9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBvcmlnaW5hbEV2ZW50LmN0cmxLZXkpICYmXG4gICAgICBvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBtYXAgaGFzIHRoZSBmb2N1cy4gVGhpcyBjb25kaXRpb24gcmVxdWlyZXMgYSBtYXAgdGFyZ2V0XG4gKiBlbGVtZW50IHdpdGggYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSwgZS5nLiBgPGRpdiBpZD1cIm1hcFwiIHRhYmluZGV4PVwiMVwiPmAuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgbWFwIGhhcyB0aGUgZm9jdXMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBmb2N1cyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50YXJnZXQuZ2V0VGFyZ2V0RWxlbWVudCgpID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xufTtcblxuXG4vKipcbiAqIFJldHVybiBhbHdheXMgdHJ1ZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgYWx3YXlzID0gVFJVRTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGlzIGEgYGNsaWNrYCBldmVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYGNsaWNrYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IGNsaWNrID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLkNMSUNLO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhcyBhbiBcImFjdGlvblwiLXByb2R1Y2luZyBtb3VzZSBidXR0b24uXG4gKlxuICogQnkgZGVmaW5pdGlvbiwgdGhpcyBpbmNsdWRlcyBsZWZ0LWNsaWNrIG9uIHdpbmRvd3MvbGludXgsIGFuZCBsZWZ0LWNsaWNrXG4gKiB3aXRob3V0IHRoZSBjdHJsIGtleSBvbiBNYWNzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZXN1bHQuXG4gKi9cbmV4cG9ydCBjb25zdCBtb3VzZUFjdGlvbkJ1dHRvbiA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICByZXR1cm4gb3JpZ2luYWxFdmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgIShXRUJLSVQgJiYgTUFDICYmIG9yaWdpbmFsRXZlbnQuY3RybEtleSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGFsd2F5cyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IG5ldmVyID0gRkFMU0U7XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBicm93c2VyIGV2ZW50IGlzIGEgYHBvaW50ZXJtb3ZlYCBldmVudCwgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGJyb3dzZXIgZXZlbnQgaXMgYSBgcG9pbnRlcm1vdmVgIGV2ZW50LlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgcG9pbnRlck1vdmUgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgcmV0dXJuIG1hcEJyb3dzZXJFdmVudC50eXBlID09ICdwb2ludGVybW92ZSc7XG59O1xuXG5cbi8qKlxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYHNpbmdsZWNsaWNrYCBldmVudCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgYSBtYXAgYHNpbmdsZWNsaWNrYCBldmVudC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHNpbmdsZUNsaWNrID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIHJldHVybiBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBkYmxjbGlja2AgZXZlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIGEgbWFwIGBkYmxjbGlja2AgZXZlbnQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBkb3VibGVDbGljayA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICByZXR1cm4gbWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5EQkxDTElDSztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG5vIG1vZGlmaWVyIGtleSAoYWx0LSwgc2hpZnQtIG9yIHBsYXRmb3JtLW1vZGlmaWVyLWtleSkgaXNcbiAqIHByZXNzZWQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBvbmx5IGlmIHRoZXJlIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBjb25zdCBub01vZGlmaWVyS2V5cyA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgcmV0dXJuIChcbiAgICAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAgICFvcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIHBsYXRmb3JtLW1vZGlmaWVyLWtleSAodGhlIG1ldGEta2V5IG9uIE1hYyxcbiAqIGN0cmwta2V5IG90aGVyd2lzZSkgaXMgcHJlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UgKGUuZy4gd2hlbiBhZGRpdGlvbmFsbHlcbiAqIHRoZSBzaGlmdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBwbGF0Zm9ybSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXRmb3JtTW9kaWZpZXJLZXlPbmx5ID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSAvKiogQHR5cGUge0tleWJvYXJkRXZlbnR8TW91c2VFdmVudHxUb3VjaEV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICByZXR1cm4gIW9yaWdpbmFsRXZlbnQuYWx0S2V5ICYmXG4gICAgKE1BQyA/IG9yaWdpbmFsRXZlbnQubWV0YUtleSA6IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAhb3JpZ2luYWxFdmVudC5zaGlmdEtleTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIG9ubHkgdGhlIHNoaWZ0LWtleSBpcyBwcmVzc2VkLCBgZmFsc2VgIG90aGVyd2lzZSAoZS5nLiB3aGVuXG4gKiBhZGRpdGlvbmFsbHkgdGhlIGFsdC1rZXkgaXMgcHJlc3NlZCkuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHNoaWZ0S2V5T25seSA9IGZ1bmN0aW9uKG1hcEJyb3dzZXJFdmVudCkge1xuICBjb25zdCBvcmlnaW5hbEV2ZW50ID0gLyoqIEB0eXBlIHtLZXlib2FyZEV2ZW50fE1vdXNlRXZlbnR8VG91Y2hFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgcmV0dXJuIChcbiAgICAhb3JpZ2luYWxFdmVudC5hbHRLZXkgJiZcbiAgICAgICEob3JpZ2luYWxFdmVudC5tZXRhS2V5IHx8IG9yaWdpbmFsRXZlbnQuY3RybEtleSkgJiZcbiAgICAgIG9yaWdpbmFsRXZlbnQuc2hpZnRLZXkpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIG5vdCBlZGl0YWJsZSwgaS5lLiBub3QgYSBgPGlucHV0PmAtLFxuICogYDxzZWxlY3Q+YC0gb3IgYDx0ZXh0YXJlYT5gLWVsZW1lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgb25seSBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgbm90IGVkaXRhYmxlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgdGFyZ2V0Tm90RWRpdGFibGUgPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gbWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQudGFyZ2V0O1xuICBjb25zdCB0YWdOYW1lID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAodGFyZ2V0KS50YWdOYW1lO1xuICByZXR1cm4gKFxuICAgIHRhZ05hbWUgIT09ICdJTlBVVCcgJiZcbiAgICAgIHRhZ05hbWUgIT09ICdTRUxFQ1QnICYmXG4gICAgICB0YWdOYW1lICE9PSAnVEVYVEFSRUEnKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBtb3VzZSBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tIGEgbW91c2UgZGV2aWNlLlxuICogQGFwaVxuICovXG5leHBvcnQgY29uc3QgbW91c2VPbmx5ID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHBvaW50ZXJFdmVudCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudFwiKS5kZWZhdWx0fSAqLyAobWFwQnJvd3NlckV2ZW50KS5wb2ludGVyRXZlbnQ7XG4gIGFzc2VydChwb2ludGVyRXZlbnQgIT09IHVuZGVmaW5lZCwgNTYpOyAvLyBtYXBCcm93c2VyRXZlbnQgbXVzdCBvcmlnaW5hdGUgZnJvbSBhIHBvaW50ZXIgZXZlbnRcbiAgLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvI3dpZGwtUG9pbnRlckV2ZW50LXBvaW50ZXJUeXBlXG4gIHJldHVybiBwb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT0gJ21vdXNlJztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBldmVudCBvcmlnaW5hdGVzIGZyb20gYSBwcmltYXJ5IHBvaW50ZXIgaW5cbiAqIGNvbnRhY3Qgd2l0aCB0aGUgc3VyZmFjZSBvciBpZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gaXMgcHJlc3NlZC5cbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IG9yaWdpbmF0ZXMgZnJvbSBhIHByaW1hcnkgcG9pbnRlci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW1hcnlBY3Rpb24gPSBmdW5jdGlvbihtYXBCcm93c2VyRXZlbnQpIHtcbiAgY29uc3QgcG9pbnRlckV2ZW50ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50XCIpLmRlZmF1bHR9ICovIChtYXBCcm93c2VyRXZlbnQpLnBvaW50ZXJFdmVudDtcbiAgYXNzZXJ0KHBvaW50ZXJFdmVudCAhPT0gdW5kZWZpbmVkLCA1Nik7IC8vIG1hcEJyb3dzZXJFdmVudCBtdXN0IG9yaWdpbmF0ZSBmcm9tIGEgcG9pbnRlciBldmVudFxuICByZXR1cm4gcG9pbnRlckV2ZW50LmlzUHJpbWFyeSAmJiBwb2ludGVyRXZlbnQuYnV0dG9uID09PSAwO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFVQTs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/ol/Object.js\nvar ol_Object = __webpack_require__(15);\n\n// EXTERNAL MODULE: ./node_modules/ol/easing.js\nvar easing = __webpack_require__(28);\n\n// CONCATENATED MODULE: ./node_modules/ol/interaction/Property.js\n/**\n * @module ol/interaction/Property\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ var Property = ({\n  ACTIVE: \'active\'\n});\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./node_modules/ol/interaction/Interaction.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return pan; });\n/* unused harmony export rotate */\n/* unused harmony export rotateWithoutConstraints */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return zoom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return zoomByDelta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return zoomWithoutConstraints; });\n/**\n * @module ol/interaction/Interaction\n */\n\n\n\n\n/**\n * Object literal with config options for interactions.\n * @typedef {Object} InteractionOptions\n * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. If the function returns a falsy value, propagation of\n * the event to other interactions in the map\'s interactions chain will be\n * prevented (this includes functions with no explicit return).\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * User actions that change the state of the map. Some are similar to controls,\n * but are not associated with a DOM element.\n * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\n * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\n * by a keyboard event not a button element event.\n * Although interactions do not have a DOM element, some of them do render\n * vectors and so are visible on the screen.\n * @api\n */\n\nvar Interaction_Interaction =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function Interaction(options) {\n    BaseObject.call(this);\n\n    if (options.handleEvent) {\n      this.handleEvent = options.handleEvent;\n    }\n    /**\n     * @private\n     * @type {import("../PluggableMap.js").default}\n     */\n\n\n    this.map_ = null;\n    this.setActive(true);\n  }\n\n  if (BaseObject) Interaction.__proto__ = BaseObject;\n  Interaction.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Interaction.prototype.constructor = Interaction;\n  /**\n   * Return whether the interaction is currently active.\n   * @return {boolean} `true` if the interaction is active, `false` otherwise.\n   * @observable\n   * @api\n   */\n\n  Interaction.prototype.getActive = function getActive() {\n    return (\n      /** @type {boolean} */\n      this.get(Property.ACTIVE)\n    );\n  };\n  /**\n   * Get the map associated with this interaction.\n   * @return {import("../PluggableMap.js").default} Map.\n   * @api\n   */\n\n\n  Interaction.prototype.getMap = function getMap() {\n    return this.map_;\n  };\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent map browser event}.\n   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n\n\n  Interaction.prototype.handleEvent = function handleEvent(mapBrowserEvent) {\n    return true;\n  };\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n\n\n  Interaction.prototype.setActive = function setActive(active) {\n    this.set(Property.ACTIVE, active);\n  };\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import("../PluggableMap.js").default} map Map.\n   */\n\n\n  Interaction.prototype.setMap = function setMap(map) {\n    this.map_ = map;\n  };\n\n  return Interaction;\n}(ol_Object["a" /* default */]);\n/**\n * @param {import("../View.js").default} view View.\n * @param {import("../coordinate.js").Coordinate} delta Delta.\n * @param {number=} opt_duration Duration.\n */\n\n\nfunction pan(view, delta, opt_duration) {\n  var currentCenter = view.getCenter();\n\n  if (currentCenter) {\n    var center = view.constrainCenter([currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);\n\n    if (opt_duration) {\n      view.animate({\n        duration: opt_duration,\n        easing: easing["linear"],\n        center: center\n      });\n    } else {\n      view.setCenter(center);\n    }\n  }\n}\n/**\n * @param {import("../View.js").default} view View.\n * @param {number|undefined} rotation Rotation.\n * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.\n * @param {number=} opt_duration Duration.\n */\n\nfunction rotate(view, rotation, opt_anchor, opt_duration) {\n  rotation = view.constrainRotation(rotation, 0);\n  rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);\n}\n/**\n * @param {import("../View.js").default} view View.\n * @param {number|undefined} rotation Rotation.\n * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.\n * @param {number=} opt_duration Duration.\n */\n\nfunction rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration) {\n  if (rotation !== undefined) {\n    var currentRotation = view.getRotation();\n    var currentCenter = view.getCenter();\n\n    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {\n      view.animate({\n        rotation: rotation,\n        anchor: opt_anchor,\n        duration: opt_duration,\n        easing: easing["easeOut"]\n      });\n    } else {\n      view.rotate(rotation, opt_anchor);\n    }\n  }\n}\n/**\n * @param {import("../View.js").default} view View.\n * @param {number|undefined} resolution Resolution to go to.\n * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.\n * @param {number=} opt_duration Duration.\n * @param {number=} opt_direction Zooming direction; > 0 indicates\n *     zooming out, in which case the constraints system will select\n *     the largest nearest resolution; < 0 indicates zooming in, in\n *     which case the constraints system will select the smallest\n *     nearest resolution; == 0 indicates that the zooming direction\n *     is unknown/not relevant, in which case the constraints system\n *     will select the nearest resolution. If not defined 0 is\n *     assumed.\n */\n\nfunction zoom(view, resolution, opt_anchor, opt_duration, opt_direction) {\n  resolution = view.constrainResolution(resolution, 0, opt_direction);\n  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);\n}\n/**\n * @param {import("../View.js").default} view View.\n * @param {number} delta Delta from previous zoom level.\n * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.\n * @param {number=} opt_duration Duration.\n */\n\nfunction zoomByDelta(view, delta, opt_anchor, opt_duration) {\n  var currentResolution = view.getResolution();\n  var resolution = view.constrainResolution(currentResolution, delta, 0);\n\n  if (resolution !== undefined) {\n    var resolutions = view.getResolutions();\n    resolution = Object(math["a" /* clamp */])(resolution, view.getMinResolution() || resolutions[resolutions.length - 1], view.getMaxResolution() || resolutions[0]);\n  } // If we have a constraint on center, we need to change the anchor so that the\n  // new center is within the extent. We first calculate the new center, apply\n  // the constraint to it, and then calculate back the anchor\n\n\n  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {\n    var currentCenter = view.getCenter();\n    var center = view.calculateCenterZoom(resolution, opt_anchor);\n    center = view.constrainCenter(center);\n    opt_anchor = [(resolution * currentCenter[0] - currentResolution * center[0]) / (resolution - currentResolution), (resolution * currentCenter[1] - currentResolution * center[1]) / (resolution - currentResolution)];\n  }\n\n  zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);\n}\n/**\n * @param {import("../View.js").default} view View.\n * @param {number|undefined} resolution Resolution to go to.\n * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate.\n * @param {number=} opt_duration Duration.\n */\n\nfunction zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration) {\n  if (resolution) {\n    var currentResolution = view.getResolution();\n    var currentCenter = view.getCenter();\n\n    if (currentResolution !== undefined && currentCenter && resolution !== currentResolution && opt_duration) {\n      view.animate({\n        resolution: resolution,\n        anchor: opt_anchor,\n        duration: opt_duration,\n        easing: easing["easeOut"]\n      });\n    } else {\n      if (opt_anchor) {\n        var center = view.calculateCenterZoom(resolution, opt_anchor);\n        view.setCenter(center);\n      }\n\n      view.setResolution(resolution);\n    }\n  }\n}\n/* harmony default export */ var interaction_Interaction = __webpack_exports__["a"] = (Interaction_Interaction);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2ludGVyYWN0aW9uL1Byb3BlcnR5LmpzPzllNjgiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qcz9jYWEyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9Qcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBBQ1RJVkU6ICdhY3RpdmUnXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uXG4gKi9cbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2Vhc2VPdXQsIGxpbmVhcn0gZnJvbSAnLi4vZWFzaW5nLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvblByb3BlcnR5IGZyb20gJy4vUHJvcGVydHkuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIGNvbmZpZyBvcHRpb25zIGZvciBpbnRlcmFjdGlvbnMuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJbnRlcmFjdGlvbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IGhhbmRsZUV2ZW50XG4gKiBNZXRob2QgY2FsbGVkIGJ5IHRoZSBtYXAgdG8gbm90aWZ5IHRoZSBpbnRlcmFjdGlvbiB0aGF0IGEgYnJvd3NlciBldmVudCB3YXNcbiAqIGRpc3BhdGNoZWQgdG8gdGhlIG1hcC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgcHJvcGFnYXRpb24gb2ZcbiAqIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9ucyBjaGFpbiB3aWxsIGJlXG4gKiBwcmV2ZW50ZWQgKHRoaXMgaW5jbHVkZXMgZnVuY3Rpb25zIHdpdGggbm8gZXhwbGljaXQgcmV0dXJuKS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogVXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgbWFwLiBTb21lIGFyZSBzaW1pbGFyIHRvIGNvbnRyb2xzLFxuICogYnV0IGFyZSBub3QgYXNzb2NpYXRlZCB3aXRoIGEgRE9NIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21+S2V5Ym9hcmRab29tfSBpc1xuICogZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9ab29tflpvb219LCBidXQgdHJpZ2dlcmVkXG4gKiBieSBhIGtleWJvYXJkIGV2ZW50IG5vdCBhIGJ1dHRvbiBlbGVtZW50IGV2ZW50LlxuICogQWx0aG91Z2ggaW50ZXJhY3Rpb25zIGRvIG5vdCBoYXZlIGEgRE9NIGVsZW1lbnQsIHNvbWUgb2YgdGhlbSBkbyByZW5kZXJcbiAqIHZlY3RvcnMgYW5kIHNvIGFyZSB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEludGVyYWN0aW9uIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVFdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IG9wdGlvbnMuaGFuZGxlRXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbnVsbDtcblxuICAgIHRoaXMuc2V0QWN0aXZlKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBpbnRlcmFjdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyYWN0aW9uIGlzIGFjdGl2ZSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFjdGl2ZSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodGhpcy5nZXQoSW50ZXJhY3Rpb25Qcm9wZXJ0eS5BQ1RJVkUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnRlcmFjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IE1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgTWFwIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSB0aGUgaW50ZXJhY3Rpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZlIEFjdGl2ZS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0QWN0aXZlKGFjdGl2ZSkge1xuICAgIHRoaXMuc2V0KEludGVyYWN0aW9uUHJvcGVydHkuQUNUSVZFLCBhY3RpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgaW50ZXJhY3Rpb24gZnJvbSBpdHMgY3VycmVudCBtYXAgYW5kIGF0dGFjaCBpdCB0byB0aGUgbmV3IG1hcC5cbiAgICogU3ViY2xhc3NlcyBtYXkgc2V0IHVwIGV2ZW50IGhhbmRsZXJzIHRvIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIHRvXG4gICAqIHRoZSBtYXAgaGVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIHNldE1hcChtYXApIHtcbiAgICB0aGlzLm1hcF8gPSBtYXA7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gZGVsdGEgRGVsdGEuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kdXJhdGlvbiBEdXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhbih2aWV3LCBkZWx0YSwgb3B0X2R1cmF0aW9uKSB7XG4gIGNvbnN0IGN1cnJlbnRDZW50ZXIgPSB2aWV3LmdldENlbnRlcigpO1xuICBpZiAoY3VycmVudENlbnRlcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHZpZXcuY29uc3RyYWluQ2VudGVyKFxuICAgICAgW2N1cnJlbnRDZW50ZXJbMF0gKyBkZWx0YVswXSwgY3VycmVudENlbnRlclsxXSArIGRlbHRhWzFdXSk7XG4gICAgaWYgKG9wdF9kdXJhdGlvbikge1xuICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgZHVyYXRpb246IG9wdF9kdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBsaW5lYXIsXG4gICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU9fSBvcHRfYW5jaG9yIEFuY2hvciBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZHVyYXRpb24gRHVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUodmlldywgcm90YXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbikge1xuICByb3RhdGlvbiA9IHZpZXcuY29uc3RyYWluUm90YXRpb24ocm90YXRpb24sIDApO1xuICByb3RhdGVXaXRob3V0Q29uc3RyYWludHModmlldywgcm90YXRpb24sIG9wdF9hbmNob3IsIG9wdF9kdXJhdGlvbik7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1ZpZXcuanNcIikuZGVmYXVsdH0gdmlldyBWaWV3LlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIHJvdGF0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pIHtcbiAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjdXJyZW50Um90YXRpb24gPSB2aWV3LmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3QgY3VycmVudENlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gICAgaWYgKGN1cnJlbnRSb3RhdGlvbiAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRDZW50ZXIgJiYgb3B0X2R1cmF0aW9uID4gMCkge1xuICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICBhbmNob3I6IG9wdF9hbmNob3IsXG4gICAgICAgIGR1cmF0aW9uOiBvcHRfZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogZWFzZU91dFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcucm90YXRlKHJvdGF0aW9uLCBvcHRfYW5jaG9yKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbiB0byBnbyB0by5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGlyZWN0aW9uIFpvb21pbmcgZGlyZWN0aW9uOyA+IDAgaW5kaWNhdGVzXG4gKiAgICAgem9vbWluZyBvdXQsIGluIHdoaWNoIGNhc2UgdGhlIGNvbnN0cmFpbnRzIHN5c3RlbSB3aWxsIHNlbGVjdFxuICogICAgIHRoZSBsYXJnZXN0IG5lYXJlc3QgcmVzb2x1dGlvbjsgPCAwIGluZGljYXRlcyB6b29taW5nIGluLCBpblxuICogICAgIHdoaWNoIGNhc2UgdGhlIGNvbnN0cmFpbnRzIHN5c3RlbSB3aWxsIHNlbGVjdCB0aGUgc21hbGxlc3RcbiAqICAgICBuZWFyZXN0IHJlc29sdXRpb247ID09IDAgaW5kaWNhdGVzIHRoYXQgdGhlIHpvb21pbmcgZGlyZWN0aW9uXG4gKiAgICAgaXMgdW5rbm93bi9ub3QgcmVsZXZhbnQsIGluIHdoaWNoIGNhc2UgdGhlIGNvbnN0cmFpbnRzIHN5c3RlbVxuICogICAgIHdpbGwgc2VsZWN0IHRoZSBuZWFyZXN0IHJlc29sdXRpb24uIElmIG5vdCBkZWZpbmVkIDAgaXNcbiAqICAgICBhc3N1bWVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gem9vbSh2aWV3LCByZXNvbHV0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24sIG9wdF9kaXJlY3Rpb24pIHtcbiAgcmVzb2x1dGlvbiA9IHZpZXcuY29uc3RyYWluUmVzb2x1dGlvbihyZXNvbHV0aW9uLCAwLCBvcHRfZGlyZWN0aW9uKTtcbiAgem9vbVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCByZXNvbHV0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9WaWV3LmpzXCIpLmRlZmF1bHR9IHZpZXcgVmlldy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YSBmcm9tIHByZXZpb3VzIHpvb20gbGV2ZWwuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9hbmNob3IgQW5jaG9yIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9kdXJhdGlvbiBEdXJhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pIHtcbiAgY29uc3QgY3VycmVudFJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgbGV0IHJlc29sdXRpb24gPSB2aWV3LmNvbnN0cmFpblJlc29sdXRpb24oY3VycmVudFJlc29sdXRpb24sIGRlbHRhLCAwKTtcblxuICBpZiAocmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcmVzb2x1dGlvbnMgPSB2aWV3LmdldFJlc29sdXRpb25zKCk7XG4gICAgcmVzb2x1dGlvbiA9IGNsYW1wKFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIHZpZXcuZ2V0TWluUmVzb2x1dGlvbigpIHx8IHJlc29sdXRpb25zW3Jlc29sdXRpb25zLmxlbmd0aCAtIDFdLFxuICAgICAgdmlldy5nZXRNYXhSZXNvbHV0aW9uKCkgfHwgcmVzb2x1dGlvbnNbMF0pO1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGNvbnN0cmFpbnQgb24gY2VudGVyLCB3ZSBuZWVkIHRvIGNoYW5nZSB0aGUgYW5jaG9yIHNvIHRoYXQgdGhlXG4gIC8vIG5ldyBjZW50ZXIgaXMgd2l0aGluIHRoZSBleHRlbnQuIFdlIGZpcnN0IGNhbGN1bGF0ZSB0aGUgbmV3IGNlbnRlciwgYXBwbHlcbiAgLy8gdGhlIGNvbnN0cmFpbnQgdG8gaXQsIGFuZCB0aGVuIGNhbGN1bGF0ZSBiYWNrIHRoZSBhbmNob3JcbiAgaWYgKG9wdF9hbmNob3IgJiYgcmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkICYmIHJlc29sdXRpb24gIT09IGN1cnJlbnRSZXNvbHV0aW9uKSB7XG4gICAgY29uc3QgY3VycmVudENlbnRlciA9IHZpZXcuZ2V0Q2VudGVyKCk7XG4gICAgbGV0IGNlbnRlciA9IHZpZXcuY2FsY3VsYXRlQ2VudGVyWm9vbShyZXNvbHV0aW9uLCBvcHRfYW5jaG9yKTtcbiAgICBjZW50ZXIgPSB2aWV3LmNvbnN0cmFpbkNlbnRlcihjZW50ZXIpO1xuXG4gICAgb3B0X2FuY2hvciA9IFtcbiAgICAgIChyZXNvbHV0aW9uICogY3VycmVudENlbnRlclswXSAtIGN1cnJlbnRSZXNvbHV0aW9uICogY2VudGVyWzBdKSAvXG4gICAgICAgICAgKHJlc29sdXRpb24gLSBjdXJyZW50UmVzb2x1dGlvbiksXG4gICAgICAocmVzb2x1dGlvbiAqIGN1cnJlbnRDZW50ZXJbMV0gLSBjdXJyZW50UmVzb2x1dGlvbiAqIGNlbnRlclsxXSkgL1xuICAgICAgICAgIChyZXNvbHV0aW9uIC0gY3VycmVudFJlc29sdXRpb24pXG4gICAgXTtcbiAgfVxuXG4gIHpvb21XaXRob3V0Q29uc3RyYWludHModmlldywgcmVzb2x1dGlvbiwgb3B0X2FuY2hvciwgb3B0X2R1cmF0aW9uKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSB2aWV3IFZpZXcuXG4gKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbiB0byBnbyB0by5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBBbmNob3IgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2R1cmF0aW9uIER1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gem9vbVdpdGhvdXRDb25zdHJhaW50cyh2aWV3LCByZXNvbHV0aW9uLCBvcHRfYW5jaG9yLCBvcHRfZHVyYXRpb24pIHtcbiAgaWYgKHJlc29sdXRpb24pIHtcbiAgICBjb25zdCBjdXJyZW50UmVzb2x1dGlvbiA9IHZpZXcuZ2V0UmVzb2x1dGlvbigpO1xuICAgIGNvbnN0IGN1cnJlbnRDZW50ZXIgPSB2aWV3LmdldENlbnRlcigpO1xuICAgIGlmIChjdXJyZW50UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRDZW50ZXIgJiZcbiAgICAgICAgcmVzb2x1dGlvbiAhPT0gY3VycmVudFJlc29sdXRpb24gJiYgb3B0X2R1cmF0aW9uKSB7XG4gICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxuICAgICAgICBhbmNob3I6IG9wdF9hbmNob3IsXG4gICAgICAgIGR1cmF0aW9uOiBvcHRfZHVyYXRpb24sXG4gICAgICAgIGVhc2luZzogZWFzZU91dFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRfYW5jaG9yKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHZpZXcuY2FsY3VsYXRlQ2VudGVyWm9vbShyZXNvbHV0aW9uLCBvcHRfYW5jaG9yKTtcbiAgICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIH1cbiAgICAgIHZpZXcuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW50ZXJhY3Rpb247XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBREE7Ozs7O0FDUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBRUE7Ozs7O0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQXBFQTs7Ozs7Ozs7QUE0RUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export getStrideForLayout */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return transformGeom2D; });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);\n/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88);\n/* harmony import */ var _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);\n/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34);\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(12);\n/**\n * @module ol/geom/SimpleGeometry\n */\n\n\n\n\n\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\n\nvar SimpleGeometry =\n/*@__PURE__*/\nfunction (Geometry) {\n  function SimpleGeometry() {\n    Geometry.call(this);\n    /**\n     * @protected\n     * @type {GeometryLayout}\n     */\n\n    this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XY;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.stride = 2;\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.flatCoordinates = null;\n  }\n\n  if (Geometry) SimpleGeometry.__proto__ = Geometry;\n  SimpleGeometry.prototype = Object.create(Geometry && Geometry.prototype);\n  SimpleGeometry.prototype.constructor = SimpleGeometry;\n  /**\n   * @inheritDoc\n   */\n\n  SimpleGeometry.prototype.computeExtent = function computeExtent(extent) {\n    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["createOrUpdateFromFlatCoordinates"])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n  };\n  /**\n   * @abstract\n   * @return {Array} Coordinates.\n   */\n\n\n  SimpleGeometry.prototype.getCoordinates = function getCoordinates() {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import("../coordinate.js").Coordinate} First coordinate.\n   * @api\n   */\n\n\n  SimpleGeometry.prototype.getFirstCoordinate = function getFirstCoordinate() {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n\n\n  SimpleGeometry.prototype.getFlatCoordinates = function getFlatCoordinates() {\n    return this.flatCoordinates;\n  };\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import("../coordinate.js").Coordinate} Last point.\n   * @api\n   */\n\n\n  SimpleGeometry.prototype.getLastCoordinate = function getLastCoordinate() {\n    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n  };\n  /**\n   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.\n   * @return {GeometryLayout} Layout.\n   * @api\n   */\n\n\n  SimpleGeometry.prototype.getLayout = function getLayout() {\n    return this.layout;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  SimpleGeometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision != this.getRevision()) {\n      Object(_obj_js__WEBPACK_IMPORTED_MODULE_5__[/* clear */ "b"])(this.simplifiedGeometryCache);\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    } // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n\n\n    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {\n      return this;\n    }\n\n    var key = squaredTolerance.toString();\n\n    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n      return this.simplifiedGeometryCache[key];\n    } else {\n      var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);\n      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n\n      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n        this.simplifiedGeometryCache[key] = simplifiedGeometry;\n        return simplifiedGeometry;\n      } else {\n        // Simplification did not actually remove any coordinates.  We now know\n        // that any calls to getSimplifiedGeometry with a squaredTolerance less\n        // than or equal to the current squaredTolerance will also not have any\n        // effect.  This allows us to short circuit simplification (saving CPU\n        // cycles) and prevents the cache of simplified geometries from filling\n        // up with useless identical copies of this geometry (saving memory).\n        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n        return this;\n      }\n    }\n  };\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n\n\n  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n    return this;\n  };\n  /**\n   * @return {number} Stride.\n   */\n\n\n  SimpleGeometry.prototype.getStride = function getStride() {\n    return this.stride;\n  };\n  /**\n   * @param {GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n\n\n  SimpleGeometry.prototype.setFlatCoordinates = function setFlatCoordinates(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  };\n  /**\n   * @abstract\n   * @param {!Array} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   */\n\n\n  SimpleGeometry.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * @param {GeometryLayout|undefined} layout Layout.\n   * @param {Array} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n\n\n  SimpleGeometry.prototype.setLayout = function setLayout(layout, coordinates, nesting) {\n    /** @type {number} */\n    var stride;\n\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (var i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XY;\n          this.stride = 2;\n          return;\n        } else {\n          coordinates =\n          /** @type {Array} */\n          coordinates[0];\n        }\n      }\n\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n\n    this.layout = layout;\n    this.stride = stride;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  SimpleGeometry.prototype.applyTransform = function applyTransform(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  SimpleGeometry.prototype.rotate = function rotate$1(angle, anchor) {\n    var flatCoordinates = this.getFlatCoordinates();\n\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* rotate */ "a"])(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  SimpleGeometry.prototype.scale = function scale$1(sx, opt_sy, opt_anchor) {\n    var sy = opt_sy;\n\n    if (sy === undefined) {\n      sy = sx;\n    }\n\n    var anchor = opt_anchor;\n\n    if (!anchor) {\n      anchor = Object(_extent_js__WEBPACK_IMPORTED_MODULE_1__["getCenter"])(this.getExtent());\n    }\n\n    var flatCoordinates = this.getFlatCoordinates();\n\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* scale */ "b"])(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  SimpleGeometry.prototype.translate = function translate$1(deltaX, deltaY) {\n    var flatCoordinates = this.getFlatCoordinates();\n\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* translate */ "d"])(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);\n      this.changed();\n    }\n  };\n\n  return SimpleGeometry;\n}(_Geometry_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);\n/**\n * @param {number} stride Stride.\n * @return {GeometryLayout} layout Layout.\n */\n\n\nfunction getLayoutForStride(stride) {\n  var layout;\n\n  if (stride == 2) {\n    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XY;\n  } else if (stride == 3) {\n    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XYZ;\n  } else if (stride == 4) {\n    layout = _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XYZM;\n  }\n\n  return (\n    /** @type {GeometryLayout} */\n    layout\n  );\n}\n/**\n * @param {GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\n\n\nfunction getStrideForLayout(layout) {\n  var stride;\n\n  if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XY) {\n    stride = 2;\n  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XYZ || layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XYM) {\n    stride = 3;\n  } else if (layout == _GeometryLayout_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].XYZM) {\n    stride = 4;\n  }\n\n  return (\n    /** @type {number} */\n    stride\n  );\n}\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import("../transform.js").Transform} transform Transform.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\n\nfunction transformGeom2D(simpleGeometry, transform, opt_dest) {\n  var flatCoordinates = simpleGeometry.getFlatCoordinates();\n\n  if (!flatCoordinates) {\n    return null;\n  } else {\n    var stride = simpleGeometry.getStride();\n    return Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_4__[/* transform2D */ "c"])(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);\n  }\n}\n/* harmony default export */ __webpack_exports__["a"] = (SimpleGeometry);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2dlb20vU2ltcGxlR2VvbWV0cnkuanM/YzJkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9TaW1wbGVHZW9tZXRyeVxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzLCBnZXRDZW50ZXJ9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnkgZnJvbSAnLi9HZW9tZXRyeS5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQge3JvdGF0ZSwgc2NhbGUsIHRyYW5zbGF0ZSwgdHJhbnNmb3JtMkR9IGZyb20gJy4vZmxhdC90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXM7IGRvIG5vdCBpbnN0YW50aWF0ZVxuICogaW4gYXBwcywgYXMgY2Fubm90IGJlIHJlbmRlcmVkLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG5jbGFzcyBTaW1wbGVHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtHZW9tZXRyeUxheW91dH1cbiAgICAgKi9cbiAgICB0aGlzLmxheW91dCA9IEdlb21ldHJ5TGF5b3V0LlhZO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zdHJpZGUgPSAyO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gbnVsbDtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjb21wdXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXModGhpcy5mbGF0Q29vcmRpbmF0ZXMsXG4gICAgICAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheX0gQ29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGZpcnN0IGNvb3JkaW5hdGUgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IEZpcnN0IGNvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZpcnN0Q29vcmRpbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoMCwgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRGbGF0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbGFzdCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBMYXN0IHBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXN0Q29vcmRpbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UodGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC0gdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUge0BsaW5rIG1vZHVsZTpvbC9nZW9tL0dlb21ldHJ5TGF5b3V0IGxheW91dH0gb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeUxheW91dH0gTGF5b3V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIGlmICh0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY2xlYXIodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlDYWNoZSk7XG4gICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgPSAwO1xuICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlSZXZpc2lvbiA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgLy8gSWYgc3F1YXJlZFRvbGVyYW5jZSBpcyBuZWdhdGl2ZSBvciBpZiB3ZSBrbm93IHRoYXQgc2ltcGxpZmljYXRpb24gd2lsbCBub3RcbiAgICAvLyBoYXZlIGFueSBlZmZlY3QgdGhlbiBqdXN0IHJldHVybiB0aGlzLlxuICAgIGlmIChzcXVhcmVkVG9sZXJhbmNlIDwgMCB8fFxuICAgICAgICAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlICE9PSAwICYmXG4gICAgICAgICBzcXVhcmVkVG9sZXJhbmNlIDw9IHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBzcXVhcmVkVG9sZXJhbmNlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2ltcGxpZmllZEdlb21ldHJ5ID1cbiAgICAgICAgICB0aGlzLmdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpO1xuICAgICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IHNpbXBsaWZpZWRHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGlmIChzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA8IHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeUNhY2hlW2tleV0gPSBzaW1wbGlmaWVkR2VvbWV0cnk7XG4gICAgICAgIHJldHVybiBzaW1wbGlmaWVkR2VvbWV0cnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW1wbGlmaWNhdGlvbiBkaWQgbm90IGFjdHVhbGx5IHJlbW92ZSBhbnkgY29vcmRpbmF0ZXMuICBXZSBub3cga25vd1xuICAgICAgICAvLyB0aGF0IGFueSBjYWxscyB0byBnZXRTaW1wbGlmaWVkR2VvbWV0cnkgd2l0aCBhIHNxdWFyZWRUb2xlcmFuY2UgbGVzc1xuICAgICAgICAvLyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBjdXJyZW50IHNxdWFyZWRUb2xlcmFuY2Ugd2lsbCBhbHNvIG5vdCBoYXZlIGFueVxuICAgICAgICAvLyBlZmZlY3QuICBUaGlzIGFsbG93cyB1cyB0byBzaG9ydCBjaXJjdWl0IHNpbXBsaWZpY2F0aW9uIChzYXZpbmcgQ1BVXG4gICAgICAgIC8vIGN5Y2xlcykgYW5kIHByZXZlbnRzIHRoZSBjYWNoZSBvZiBzaW1wbGlmaWVkIGdlb21ldHJpZXMgZnJvbSBmaWxsaW5nXG4gICAgICAgIC8vIHVwIHdpdGggdXNlbGVzcyBpZGVudGljYWwgY29waWVzIG9mIHRoaXMgZ2VvbWV0cnkgKHNhdmluZyBtZW1vcnkpLlxuICAgICAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeU1heE1pblNxdWFyZWRUb2xlcmFuY2UgPSBzcXVhcmVkVG9sZXJhbmNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gICAqIEByZXR1cm4ge1NpbXBsZUdlb21ldHJ5fSBTaW1wbGlmaWVkIGdlb21ldHJ5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBTdHJpZGUuXG4gICAqL1xuICBnZXRTdHJpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaWRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBzZXRGbGF0Q29vcmRpbmF0ZXMobGF5b3V0LCBmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICB0aGlzLnN0cmlkZSA9IGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpO1xuICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gZmxhdENvb3JkaW5hdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0geyFBcnJheX0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0fHVuZGVmaW5lZH0gbGF5b3V0IExheW91dC5cbiAgICogQHBhcmFtIHtBcnJheX0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXN0aW5nIE5lc3RpbmcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNldExheW91dChsYXlvdXQsIGNvb3JkaW5hdGVzLCBuZXN0aW5nKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgbGV0IHN0cmlkZTtcbiAgICBpZiAobGF5b3V0KSB7XG4gICAgICBzdHJpZGUgPSBnZXRTdHJpZGVGb3JMYXlvdXQobGF5b3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXN0aW5nOyArK2kpIHtcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubGF5b3V0ID0gR2VvbWV0cnlMYXlvdXQuWFk7XG4gICAgICAgICAgdGhpcy5zdHJpZGUgPSAyO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7QXJyYXl9ICovIChjb29yZGluYXRlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmlkZSA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGxheW91dCA9IGdldExheW91dEZvclN0cmlkZShzdHJpZGUpO1xuICAgIH1cbiAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbikge1xuICAgIGlmICh0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdHJhbnNmb3JtRm4odGhpcy5mbGF0Q29vcmRpbmF0ZXMsIHRoaXMuZmxhdENvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgcm90YXRlKGFuZ2xlLCBhbmNob3IpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGlmIChmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuZ2V0U3RyaWRlKCk7XG4gICAgICByb3RhdGUoXG4gICAgICAgIGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCxcbiAgICAgICAgc3RyaWRlLCBhbmdsZSwgYW5jaG9yLCBmbGF0Q29vcmRpbmF0ZXMpO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIHNjYWxlKHN4LCBvcHRfc3ksIG9wdF9hbmNob3IpIHtcbiAgICBsZXQgc3kgPSBvcHRfc3k7XG4gICAgaWYgKHN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN5ID0gc3g7XG4gICAgfVxuICAgIGxldCBhbmNob3IgPSBvcHRfYW5jaG9yO1xuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSBnZXRDZW50ZXIodGhpcy5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKGZsYXRDb29yZGluYXRlcykge1xuICAgICAgY29uc3Qgc3RyaWRlID0gdGhpcy5nZXRTdHJpZGUoKTtcbiAgICAgIHNjYWxlKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIHN0cmlkZSwgc3gsIHN5LCBhbmNob3IsIGZsYXRDb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgdHJhbnNsYXRlKGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLmdldFN0cmlkZSgpO1xuICAgICAgdHJhbnNsYXRlKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSxcbiAgICAgICAgZGVsdGFYLCBkZWx0YVksIGZsYXRDb29yZGluYXRlcyk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7R2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGdldExheW91dEZvclN0cmlkZShzdHJpZGUpIHtcbiAgbGV0IGxheW91dDtcbiAgaWYgKHN0cmlkZSA9PSAyKSB7XG4gICAgbGF5b3V0ID0gR2VvbWV0cnlMYXlvdXQuWFk7XG4gIH0gZWxzZSBpZiAoc3RyaWRlID09IDMpIHtcbiAgICBsYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWVo7XG4gIH0gZWxzZSBpZiAoc3RyaWRlID09IDQpIHtcbiAgICBsYXlvdXQgPSBHZW9tZXRyeUxheW91dC5YWVpNO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqIEB0eXBlIHtHZW9tZXRyeUxheW91dH0gKi8gKGxheW91dClcbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXR9IGxheW91dCBMYXlvdXQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFN0cmlkZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0cmlkZUZvckxheW91dChsYXlvdXQpIHtcbiAgbGV0IHN0cmlkZTtcbiAgaWYgKGxheW91dCA9PSBHZW9tZXRyeUxheW91dC5YWSkge1xuICAgIHN0cmlkZSA9IDI7XG4gIH0gZWxzZSBpZiAobGF5b3V0ID09IEdlb21ldHJ5TGF5b3V0LlhZWiB8fCBsYXlvdXQgPT0gR2VvbWV0cnlMYXlvdXQuWFlNKSB7XG4gICAgc3RyaWRlID0gMztcbiAgfSBlbHNlIGlmIChsYXlvdXQgPT0gR2VvbWV0cnlMYXlvdXQuWFlaTSkge1xuICAgIHN0cmlkZSA9IDQ7XG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoc3RyaWRlKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7U2ltcGxlR2VvbWV0cnl9IHNpbXBsZUdlb21ldHJ5IFNpbXBsZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgZmxhdCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUdlb20yRChzaW1wbGVHZW9tZXRyeSwgdHJhbnNmb3JtLCBvcHRfZGVzdCkge1xuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBzaW1wbGVHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgaWYgKCFmbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdHJpZGUgPSBzaW1wbGVHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtMkQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSxcbiAgICAgIHRyYW5zZm9ybSwgb3B0X2Rlc3QpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbXBsZUdlb21ldHJ5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUVBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFoUEE7Ozs7Ozs7QUF1UEE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBR0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return inflateCoordinates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return inflateCoordinatesArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return inflateMultiCoordinatesArray; });\n/**\n * @module ol/geom/flat/inflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.\n * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.\n */\nfunction inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {\n  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n  var i = 0;\n\n  for (var j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n\n  coordinates.length = i;\n  return coordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.\n * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.\n */\n\nfunction inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n  var i = 0;\n\n  for (var j = 0, jj = ends.length; j < jj; ++j) {\n    var end = ends[j];\n    coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);\n    offset = end;\n  }\n\n  coordinatess.length = i;\n  return coordinatess;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss\n *     Coordinatesss.\n * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.\n */\n\nfunction inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n  var i = 0;\n\n  for (var j = 0, jj = endss.length; j < jj; ++j) {\n    var ends = endss[j];\n    coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);\n    offset = ends[ends.length - 1];\n  }\n\n  coordinatesss.length = i;\n  return coordinatesss;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9pbmZsYXRlLmpzPzBjZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbmZsYXRlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT49fSBvcHRfY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBDb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG9wdF9jb29yZGluYXRlcykge1xuICBjb25zdCBjb29yZGluYXRlcyA9IG9wdF9jb29yZGluYXRlcyAhPT0gdW5kZWZpbmVkID8gb3B0X2Nvb3JkaW5hdGVzIDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBjb29yZGluYXRlc1tpKytdID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKGosIGogKyBzdHJpZGUpO1xuICB9XG4gIGNvb3JkaW5hdGVzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlcztcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+PX0gb3B0X2Nvb3JkaW5hdGVzcyBDb29yZGluYXRlc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gQ29vcmRpbmF0ZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgb3B0X2Nvb3JkaW5hdGVzcykge1xuICBjb25zdCBjb29yZGluYXRlc3MgPSBvcHRfY29vcmRpbmF0ZXNzICE9PSB1bmRlZmluZWQgPyBvcHRfY29vcmRpbmF0ZXNzIDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IDAsIGpqID0gZW5kcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tqXTtcbiAgICBjb29yZGluYXRlc3NbaSsrXSA9IGluZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY29vcmRpbmF0ZXNzW2ldKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgY29vcmRpbmF0ZXNzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlc3M7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj49fSBvcHRfY29vcmRpbmF0ZXNzc1xuICogICAgIENvb3JkaW5hdGVzc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59IENvb3JkaW5hdGVzc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLCBvcHRfY29vcmRpbmF0ZXNzcykge1xuICBjb25zdCBjb29yZGluYXRlc3NzID0gb3B0X2Nvb3JkaW5hdGVzc3MgIT09IHVuZGVmaW5lZCA/IG9wdF9jb29yZGluYXRlc3NzIDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IDAsIGpqID0gZW5kc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tqXTtcbiAgICBjb29yZGluYXRlc3NzW2krK10gPSBpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIGNvb3JkaW5hdGVzc3NbaV0pO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICBjb29yZGluYXRlc3NzLmxlbmd0aCA9IGk7XG4gIHJldHVybiBjb29yZGluYXRlc3NzO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createOrUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getKeyZXY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fromKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return hash; });\n/* unused harmony export quadKey */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return withinExtentAndZ; });\n/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord=} opt_tileCoord Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nfunction createOrUpdate(z, x, y, opt_tileCoord) {\n  if (opt_tileCoord !== undefined) {\n    opt_tileCoord[0] = z;\n    opt_tileCoord[1] = x;\n    opt_tileCoord[2] = y;\n    return opt_tileCoord;\n  } else {\n    return [z, x, y];\n  }\n}\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\n\nfunction getKeyZXY(z, x, y) {\n  return z + \'/\' + x + \'/\' + y;\n}\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\n\nfunction getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\n\nfunction fromKey(key) {\n  return key.split(\'/\').map(Number);\n}\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\n\nfunction hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {string} Quad key.\n */\n\nfunction quadKey(tileCoord) {\n  var z = tileCoord[0];\n  var digits = new Array(z);\n  var mask = 1 << z - 1;\n  var i, charCode;\n\n  for (i = 0; i < z; ++i) {\n    // 48 is charCode for 0 - \'0\'.charCodeAt(0)\n    charCode = 48;\n\n    if (tileCoord[1] & mask) {\n      charCode += 1;\n    }\n\n    if (tileCoord[2] & mask) {\n      charCode += 2;\n    }\n\n    digits[i] = String.fromCharCode(charCode);\n    mask >>= 1;\n  }\n\n  return digits.join(\'\');\n}\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\n\nfunction withinExtentAndZ(tileCoord, tileGrid) {\n  var z = tileCoord[0];\n  var x = tileCoord[1];\n  var y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n\n  var extent = tileGrid.getExtent();\n  var tileRange;\n\n  if (!extent) {\n    tileRange = tileGrid.getFullTileRange(z);\n  } else {\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n  }\n\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x, y);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL3RpbGVjb29yZC5qcz8yYjM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC90aWxlY29vcmRcbiAqL1xuXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgdGhyZWUgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgdGlsZSBpbiBhIHRpbGVcbiAqIGdyaWQuIFRoZSBvcmRlciBpcyBgemAsIGB4YCwgYW5kIGB5YC4gYHpgIGlzIHRoZSB6b29tIGxldmVsLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IFRpbGVDb29yZFxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcGFyYW0ge1RpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICogQHJldHVybiB7VGlsZUNvb3JkfSBUaWxlIGNvb3JkaW5hdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPclVwZGF0ZSh6LCB4LCB5LCBvcHRfdGlsZUNvb3JkKSB7XG4gIGlmIChvcHRfdGlsZUNvb3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBvcHRfdGlsZUNvb3JkWzBdID0gejtcbiAgICBvcHRfdGlsZUNvb3JkWzFdID0geDtcbiAgICBvcHRfdGlsZUNvb3JkWzJdID0geTtcbiAgICByZXR1cm4gb3B0X3RpbGVDb29yZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3osIHgsIHldO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleVpYWSh6LCB4LCB5KSB7XG4gIHJldHVybiB6ICsgJy8nICsgeCArICcvJyArIHk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGtleSBmb3IgYSB0aWxlIGNvb3JkLlxuICogQHBhcmFtIHtUaWxlQ29vcmR9IHRpbGVDb29yZCBUaGUgdGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5KHRpbGVDb29yZCkge1xuICByZXR1cm4gZ2V0S2V5WlhZKHRpbGVDb29yZFswXSwgdGlsZUNvb3JkWzFdLCB0aWxlQ29vcmRbMl0pO1xufVxuXG5cbi8qKlxuICogR2V0IGEgdGlsZSBjb29yZCBnaXZlbiBhIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHRpbGUgY29vcmQga2V5LlxuICogQHJldHVybiB7VGlsZUNvb3JkfSBUaGUgdGlsZSBjb29yZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21LZXkoa2V5KSB7XG4gIHJldHVybiBrZXkuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7VGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZC5cbiAqIEByZXR1cm4ge251bWJlcn0gSGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2godGlsZUNvb3JkKSB7XG4gIHJldHVybiAodGlsZUNvb3JkWzFdIDw8IHRpbGVDb29yZFswXSkgKyB0aWxlQ29vcmRbMl07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFF1YWQga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhZEtleSh0aWxlQ29vcmQpIHtcbiAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgY29uc3QgZGlnaXRzID0gbmV3IEFycmF5KHopO1xuICBsZXQgbWFzayA9IDEgPDwgKHogLSAxKTtcbiAgbGV0IGksIGNoYXJDb2RlO1xuICBmb3IgKGkgPSAwOyBpIDwgejsgKytpKSB7XG4gICAgLy8gNDggaXMgY2hhckNvZGUgZm9yIDAgLSAnMCcuY2hhckNvZGVBdCgwKVxuICAgIGNoYXJDb2RlID0gNDg7XG4gICAgaWYgKHRpbGVDb29yZFsxXSAmIG1hc2spIHtcbiAgICAgIGNoYXJDb2RlICs9IDE7XG4gICAgfVxuICAgIGlmICh0aWxlQ29vcmRbMl0gJiBtYXNrKSB7XG4gICAgICBjaGFyQ29kZSArPSAyO1xuICAgIH1cbiAgICBkaWdpdHNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICBtYXNrID4+PSAxO1xuICB9XG4gIHJldHVybiBkaWdpdHMuam9pbignJyk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1RpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7IWltcG9ydChcIi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGlsZSBjb29yZGluYXRlIGlzIHdpdGhpbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwgcmFuZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5FeHRlbnRBbmRaKHRpbGVDb29yZCwgdGlsZUdyaWQpIHtcbiAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgY29uc3QgeCA9IHRpbGVDb29yZFsxXTtcbiAgY29uc3QgeSA9IHRpbGVDb29yZFsyXTtcblxuICBpZiAodGlsZUdyaWQuZ2V0TWluWm9vbSgpID4geiB8fCB6ID4gdGlsZUdyaWQuZ2V0TWF4Wm9vbSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGV4dGVudCA9IHRpbGVHcmlkLmdldEV4dGVudCgpO1xuICBsZXQgdGlsZVJhbmdlO1xuICBpZiAoIWV4dGVudCkge1xuICAgIHRpbGVSYW5nZSA9IHRpbGVHcmlkLmdldEZ1bGxUaWxlUmFuZ2Uoeik7XG4gIH0gZWxzZSB7XG4gICAgdGlsZVJhbmdlID0gdGlsZUdyaWQuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICB9XG4gIGlmICghdGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRpbGVSYW5nZS5jb250YWluc1hZKHgsIHkpO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return transform2D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return translate; });\n/**\n * @module ol/geom/flat/transform\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import("../../transform.js").Transform} transform Transform.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nfunction transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i = 0;\n\n  for (var j = offset; j < end; j += stride) {\n    var x = flatCoordinates[j];\n    var y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n\n  return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\n\nfunction rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i = 0;\n\n  for (var j = offset; j < end; j += stride) {\n    var deltaX = flatCoordinates[j] - anchorX;\n    var deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n\n  return dest;\n}\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\n\nfunction scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i = 0;\n\n  for (var j = offset; j < end; j += stride) {\n    var deltaX = flatCoordinates[j] - anchorX;\n    var deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n\n  return dest;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\n\nfunction translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i = 0;\n\n  for (var j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n\n  return dest;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC90cmFuc2Zvcm0uanM/NjllOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L3RyYW5zZm9ybVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2Rlc3QgRGVzdGluYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBUcmFuc2Zvcm1lZCBjb29yZGluYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybTJEKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgdHJhbnNmb3JtLCBvcHRfZGVzdCkge1xuICBjb25zdCBkZXN0ID0gb3B0X2Rlc3QgPyBvcHRfZGVzdCA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeCA9IGZsYXRDb29yZGluYXRlc1tqXTtcbiAgICBjb25zdCB5ID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXTtcbiAgICBkZXN0W2krK10gPSB0cmFuc2Zvcm1bMF0gKiB4ICsgdHJhbnNmb3JtWzJdICogeSArIHRyYW5zZm9ybVs0XTtcbiAgICBkZXN0W2krK10gPSB0cmFuc2Zvcm1bMV0gKiB4ICsgdHJhbnNmb3JtWzNdICogeSArIHRyYW5zZm9ybVs1XTtcbiAgfVxuICBpZiAob3B0X2Rlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW5nbGUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFuY2hvciBSb3RhdGlvbiBhbmNob3IgcG9pbnQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfZGVzdCBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgYW5nbGUsIGFuY2hvciwgb3B0X2Rlc3QpIHtcbiAgY29uc3QgZGVzdCA9IG9wdF9kZXN0ID8gb3B0X2Rlc3QgOiBbXTtcbiAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gIGNvbnN0IGFuY2hvclggPSBhbmNob3JbMF07XG4gIGNvbnN0IGFuY2hvclkgPSBhbmNob3JbMV07XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBjb25zdCBkZWx0YVggPSBmbGF0Q29vcmRpbmF0ZXNbal0gLSBhbmNob3JYO1xuICAgIGNvbnN0IGRlbHRhWSA9IGZsYXRDb29yZGluYXRlc1tqICsgMV0gLSBhbmNob3JZO1xuICAgIGRlc3RbaSsrXSA9IGFuY2hvclggKyBkZWx0YVggKiBjb3MgLSBkZWx0YVkgKiBzaW47XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIGRlbHRhWCAqIHNpbiArIGRlbHRhWSAqIGNvcztcbiAgICBmb3IgKGxldCBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdF9kZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG5cblxuLyoqXG4gKiBTY2FsZSB0aGUgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN4IFNjYWxlIGZhY3RvciBpbiB0aGUgeC1kaXJlY3Rpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gc3kgU2NhbGUgZmFjdG9yIGluIHRoZSB5LWRpcmVjdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYW5jaG9yIFNjYWxlIGFuY2hvciBwb2ludC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHN4LCBzeSwgYW5jaG9yLCBvcHRfZGVzdCkge1xuICBjb25zdCBkZXN0ID0gb3B0X2Rlc3QgPyBvcHRfZGVzdCA6IFtdO1xuICBjb25zdCBhbmNob3JYID0gYW5jaG9yWzBdO1xuICBjb25zdCBhbmNob3JZID0gYW5jaG9yWzFdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPCBlbmQ7IGogKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgZGVsdGFYID0gZmxhdENvb3JkaW5hdGVzW2pdIC0gYW5jaG9yWDtcbiAgICBjb25zdCBkZWx0YVkgPSBmbGF0Q29vcmRpbmF0ZXNbaiArIDFdIC0gYW5jaG9yWTtcbiAgICBkZXN0W2krK10gPSBhbmNob3JYICsgc3ggKiBkZWx0YVg7XG4gICAgZGVzdFtpKytdID0gYW5jaG9yWSArIHN5ICogZGVsdGFZO1xuICAgIGZvciAobGV0IGsgPSBqICsgMjsgayA8IGogKyBzdHJpZGU7ICsraykge1xuICAgICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2tdO1xuICAgIH1cbiAgfVxuICBpZiAob3B0X2Rlc3QgJiYgZGVzdC5sZW5ndGggIT0gaSkge1xuICAgIGRlc3QubGVuZ3RoID0gaTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFYIERlbHRhIFguXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfZGVzdCBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZGVsdGFYLCBkZWx0YVksIG9wdF9kZXN0KSB7XG4gIGNvbnN0IGRlc3QgPSBvcHRfZGVzdCA/IG9wdF9kZXN0IDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IG9mZnNldDsgaiA8IGVuZDsgaiArPSBzdHJpZGUpIHtcbiAgICBkZXN0W2krK10gPSBmbGF0Q29vcmRpbmF0ZXNbal0gKyBkZWx0YVg7XG4gICAgZGVzdFtpKytdID0gZmxhdENvb3JkaW5hdGVzW2ogKyAxXSArIGRlbHRhWTtcbiAgICBmb3IgKGxldCBrID0gaiArIDI7IGsgPCBqICsgc3RyaWRlOyArK2spIHtcbiAgICAgIGRlc3RbaSsrXSA9IGZsYXRDb29yZGluYXRlc1trXTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdF9kZXN0ICYmIGRlc3QubGVuZ3RoICE9IGkpIHtcbiAgICBkZXN0Lmxlbmd0aCA9IGk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return maxSquaredDelta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayMaxSquaredDelta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return multiArrayMaxSquaredDelta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return assignClosestPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return assignClosestArrayPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return assignClosestMultiArrayPoint; });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/**\n * @module ol/geom/flat/closest\n */\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\n\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var offset;\n\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* lerp */ "c"])(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n      }\n\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n\n  for (var i$1 = 0; i$1 < stride; ++i$1) {\n    closestPoint[i$1] = flatCoordinates[offset + i$1];\n  }\n\n  closestPoint.length = stride;\n}\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\n\nfunction maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "f"])(x1, y1, x2, y2);\n\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\nfunction arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\n\nfunction multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n\n  return max;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nfunction assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n\n  var i, squaredDistance;\n\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "f"])(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n\n  while (index < end) {\n    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "f"])(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we\'re currently\n      // at distance 10, the best we\'ve found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we\'ll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n    }\n  }\n\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "f"])(x, y, tmpPoint[0], tmpPoint[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n\n      closestPoint.length = stride;\n    }\n  }\n\n  return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nfunction assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n\n  return minSquaredDistance;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\n\nfunction assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n\n  return minSquaredDistance;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9jbG9zZXN0LmpzPzUxMDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jbG9zZXN0XG4gKi9cbmltcG9ydCB7bGVycCwgc3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgMkQgbGluZSBzZWdtZW50IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxXSB0b1xuICogZmxhdENvb3JkaW5hdGVzW29mZnNldDJdIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgcG9pbnQgKHgsIHkpLiAgRXh0cmFcbiAqIGRpbWVuc2lvbnMgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0MSBPZmZzZXQgMS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQyIE9mZnNldCAyLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3QoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQxLCBvZmZzZXQyLCBzdHJpZGUsIHgsIHksIGNsb3Nlc3RQb2ludCkge1xuICBjb25zdCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQxXTtcbiAgY29uc3QgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MSArIDFdO1xuICBjb25zdCBkeCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQyXSAtIHgxO1xuICBjb25zdCBkeSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQyICsgMV0gLSB5MTtcbiAgbGV0IG9mZnNldDtcbiAgaWYgKGR4ID09PSAwICYmIGR5ID09PSAwKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0MTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ID0gKCh4IC0geDEpICogZHggKyAoeSAtIHkxKSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQyO1xuICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gbGVycChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0MSArIGldLFxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQyICsgaV0sIHQpO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0MTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7ICsraSkge1xuICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgfVxuICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzcXVhcmVkIG9mIHRoZSBsYXJnZXN0IGRpc3RhbmNlIGJldHdlZW4gYW55IHBhaXIgb2YgY29uc2VjdXRpdmVcbiAqIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHNxdWFyZWQgZGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1heCBzcXVhcmVkIGRlbHRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbWF4KSB7XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIGZvciAob2Zmc2V0ICs9IHN0cmlkZTsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBzcXVhcmVkRGVsdGEgPSBzcXVhcmVkRHgoeDEsIHkxLCB4MiwgeTIpO1xuICAgIGlmIChzcXVhcmVkRGVsdGEgPiBtYXgpIHtcbiAgICAgIG1heCA9IHNxdWFyZWREZWx0YTtcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBNYXggc3F1YXJlZCBkZWx0YS5cbiAqIEByZXR1cm4ge251bWJlcn0gTWF4IHNxdWFyZWQgZGVsdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheU1heFNxdWFyZWREZWx0YShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBtYXggPSBtYXhTcXVhcmVkRGVsdGEoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG1heCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heCBNYXggc3F1YXJlZCBkZWx0YS5cbiAqIEByZXR1cm4ge251bWJlcn0gTWF4IHNxdWFyZWQgZGVsdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aUFycmF5TWF4U3F1YXJlZERlbHRhKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBtYXggPSBhcnJheU1heFNxdWFyZWREZWx0YShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIG1heCk7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF90bXBQb2ludCBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0UG9pbnQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCxcbiAgc3RyaWRlLCBtYXhEZWx0YSwgaXNSaW5nLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgb3B0X3RtcFBvaW50KSB7XG4gIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgfVxuICBsZXQgaSwgc3F1YXJlZERpc3RhbmNlO1xuICBpZiAobWF4RGVsdGEgPT09IDApIHtcbiAgICAvLyBBbGwgcG9pbnRzIGFyZSBpZGVudGljYWwsIHNvIGp1c3QgdGVzdCB0aGUgZmlyc3QgcG9pbnQuXG4gICAgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KFxuICAgICAgeCwgeSwgZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgICAgIH1cbiAgICAgIGNsb3Nlc3RQb2ludC5sZW5ndGggPSBzdHJpZGU7XG4gICAgICByZXR1cm4gc3F1YXJlZERpc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgfVxuICBjb25zdCB0bXBQb2ludCA9IG9wdF90bXBQb2ludCA/IG9wdF90bXBQb2ludCA6IFtOYU4sIE5hTl07XG4gIGxldCBpbmRleCA9IG9mZnNldCArIHN0cmlkZTtcbiAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgYXNzaWduQ2xvc2VzdChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgaW5kZXggLSBzdHJpZGUsIGluZGV4LCBzdHJpZGUsIHgsIHksIHRtcFBvaW50KTtcbiAgICBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoeCwgeSwgdG1wUG9pbnRbMF0sIHRtcFBvaW50WzFdKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gdG1wUG9pbnRbaV07XG4gICAgICB9XG4gICAgICBjbG9zZXN0UG9pbnQubGVuZ3RoID0gc3RyaWRlO1xuICAgICAgaW5kZXggKz0gc3RyaWRlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTa2lwIGFoZWFkIG11bHRpcGxlIHBvaW50cywgYmVjYXVzZSB3ZSBrbm93IHRoYXQgYWxsIHRoZSBza2lwcGVkXG4gICAgICAvLyBwb2ludHMgY2Fubm90IGJlIGFueSBjbG9zZXIgdGhhbiB0aGUgY2xvc2VzdCBwb2ludCB3ZSBoYXZlIGZvdW5kIHNvXG4gICAgICAvLyBmYXIuICBXZSBrbm93IHRoaXMgYmVjYXVzZSB3ZSBrbm93IGhvdyBjbG9zZSB0aGUgY3VycmVudCBwb2ludCBpcywgaG93XG4gICAgICAvLyBjbG9zZSB0aGUgY2xvc2VzdCBwb2ludCB3ZSBoYXZlIGZvdW5kIHNvIGZhciBpcywgYW5kIHRoZSBtYXhpbXVtXG4gICAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIHBvaW50cy4gIEZvciBleGFtcGxlLCBpZiB3ZSdyZSBjdXJyZW50bHlcbiAgICAgIC8vIGF0IGRpc3RhbmNlIDEwLCB0aGUgYmVzdCB3ZSd2ZSBmb3VuZCBzbyBmYXIgaXMgMywgYW5kIHRoYXQgdGhlIG1heGltdW1cbiAgICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gY29uc2VjdXRpdmUgcG9pbnRzIGlzIDIsIHRoZW4gd2UnbGwgbmVlZCB0byBza2lwIGF0XG4gICAgICAvLyBsZWFzdCAoMTAgLSAzKSAvIDIgPT0gMyAocm91bmRlZCBkb3duKSBwb2ludHMgdG8gaGF2ZSBhbnkgY2hhbmNlIG9mXG4gICAgICAvLyBmaW5kaW5nIGEgY2xvc2VyIHBvaW50LiAgV2UgdXNlIE1hdGgubWF4KC4uLiwgMSkgdG8gZW5zdXJlIHRoYXQgd2VcbiAgICAgIC8vIGFsd2F5cyBhZHZhbmNlIGF0IGxlYXN0IG9uZSBwb2ludCwgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgIGluZGV4ICs9IHN0cmlkZSAqIE1hdGgubWF4KFxuICAgICAgICAoKE1hdGguc3FydChzcXVhcmVkRGlzdGFuY2UpIC1cbiAgICAgICAgICAgIE1hdGguc3FydChtaW5TcXVhcmVkRGlzdGFuY2UpKSAvIG1heERlbHRhKSB8IDAsIDEpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNSaW5nKSB7XG4gICAgLy8gQ2hlY2sgdGhlIGNsb3Npbmcgc2VnbWVudC5cbiAgICBhc3NpZ25DbG9zZXN0KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBlbmQgLSBzdHJpZGUsIG9mZnNldCwgc3RyaWRlLCB4LCB5LCB0bXBQb2ludCk7XG4gICAgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KHgsIHksIHRtcFBvaW50WzBdLCB0bXBQb2ludFsxXSk7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0cmlkZTsgKytpKSB7XG4gICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IHRtcFBvaW50W2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RGVsdGEgTWF4IGRlbHRhLlxuICogQHBhcmFtIHtib29sZWFufSBpc1JpbmcgSXMgcmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbG9zZXN0UG9pbnQgQ2xvc2VzdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TcXVhcmVkRGlzdGFuY2UgTWluaW11bSBzcXVhcmVkIGRpc3RhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X3RtcFBvaW50IFRlbXBvcmFyeSBwb2ludCBvYmplY3QuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLFxuICBzdHJpZGUsIG1heERlbHRhLCBpc1JpbmcsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlLFxuICBvcHRfdG1wUG9pbnQpIHtcbiAgY29uc3QgdG1wUG9pbnQgPSBvcHRfdG1wUG9pbnQgPyBvcHRfdG1wUG9pbnQgOiBbTmFOLCBOYU5dO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSxcbiAgICAgIG1heERlbHRhLCBpc1JpbmcsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlLCB0bXBQb2ludCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heERlbHRhIE1heCBkZWx0YS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSaW5nIElzIHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF90bXBQb2ludCBUZW1wb3JhcnkgcG9pbnQgb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25DbG9zZXN0TXVsdGlBcnJheVBvaW50KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LFxuICBlbmRzcywgc3RyaWRlLCBtYXhEZWx0YSwgaXNSaW5nLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSxcbiAgb3B0X3RtcFBvaW50KSB7XG4gIGNvbnN0IHRtcFBvaW50ID0gb3B0X3RtcFBvaW50ID8gb3B0X3RtcFBvaW50IDogW05hTiwgTmFOXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsXG4gICAgICBtYXhEZWx0YSwgaXNSaW5nLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSwgdG1wUG9pbnQpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUdBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return deflateCoordinate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return deflateCoordinates; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return deflateCoordinatesArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return deflateMultiCoordinatesArray; });\n/**\n * @module ol/geom/flat/deflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nfunction deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n  for (var i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n\n  return offset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\n\nfunction deflateCoordinates(flatCoordinates, offset, coordinates, stride) {\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    var coordinate = coordinates[i];\n\n    for (var j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n\n  return offset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>=} opt_ends Ends.\n * @return {Array<number>} Ends.\n */\n\nfunction deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {\n  var ends = opt_ends ? opt_ends : [];\n  var i = 0;\n\n  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {\n    var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);\n    ends[i++] = end;\n    offset = end;\n  }\n\n  ends.length = i;\n  return ends;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>=} opt_endss Endss.\n * @return {Array<Array<number>>} Endss.\n */\n\nfunction deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\n  var endss = opt_endss ? opt_endss : [];\n  var i = 0;\n\n  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n\n  endss.length = i;\n  return endss;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9kZWZsYXRlLmpzPzExODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9kZWZsYXRlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVDb29yZGluYXRlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlLCBzdHJpZGUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCsrXSA9IGNvb3JkaW5hdGVbaV07XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmxhdGVDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZXMsIHN0cmlkZSkge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RyaWRlOyArK2opIHtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQrK10gPSBjb29yZGluYXRlW2pdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gY29vcmRpbmF0ZXNzIENvb3JkaW5hdGVzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2VuZHMgRW5kcy5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEVuZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZXNzLCBzdHJpZGUsIG9wdF9lbmRzKSB7XG4gIGNvbnN0IGVuZHMgPSBvcHRfZW5kcyA/IG9wdF9lbmRzIDogW107XG4gIGxldCBpID0gMDtcbiAgZm9yIChsZXQgaiA9IDAsIGpqID0gY29vcmRpbmF0ZXNzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICBjb25zdCBlbmQgPSBkZWZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgY29vcmRpbmF0ZXNzW2pdLCBzdHJpZGUpO1xuICAgIGVuZHNbaSsrXSA9IGVuZDtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgZW5kcy5sZW5ndGggPSBpO1xuICByZXR1cm4gZW5kcztcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fSBjb29yZGluYXRlc3NzIENvb3JkaW5hdGVzc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj49fSBvcHRfZW5kc3MgRW5kc3MuXG4gKiBAcmV0dXJuIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gRW5kc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlc3NzLCBzdHJpZGUsIG9wdF9lbmRzcykge1xuICBjb25zdCBlbmRzcyA9IG9wdF9lbmRzcyA/IG9wdF9lbmRzcyA6IFtdO1xuICBsZXQgaSA9IDA7XG4gIGZvciAobGV0IGogPSAwLCBqaiA9IGNvb3JkaW5hdGVzc3MubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgIGNvbnN0IGVuZHMgPSBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBjb29yZGluYXRlc3NzW2pdLCBzdHJpZGUsIGVuZHNzW2ldKTtcbiAgICBlbmRzc1tpKytdID0gZW5kcztcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgZW5kc3MubGVuZ3RoID0gaTtcbiAgcmV0dXJuIGVuZHNzO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return asString; });\n/* unused harmony export fromString */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return asArray; });\n/* unused harmony export normalize */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return toString; });\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/**\n * @module ol/color\n */\n\n\n/**\n * A color represented as a short array [red, green, blue, alpha].\n * red, green, and blue should be integers in the range 0..255 inclusive.\n * alpha should be a float in the range 0..1 inclusive. If no alpha value is\n * given then `1` will be used.\n * @typedef {Array<number>} Color\n * @api\n */\n\n/**\n * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.\n * @const\n * @type {RegExp}\n * @private\n */\n\nvar HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;\n/**\n * Regular expression for matching potential named color style strings.\n * @const\n * @type {RegExp}\n * @private\n */\n\nvar NAMED_COLOR_RE_ = /^([a-z]*)$/i;\n/**\n * Return the color as an rgba string.\n * @param {Color|string} color Color.\n * @return {string} Rgba string.\n * @api\n */\n\nfunction asString(color) {\n  if (typeof color === 'string') {\n    return color;\n  } else {\n    return toString(color);\n  }\n}\n/**\n * Return named color as an rgba string.\n * @param {string} color Named color.\n * @return {string} Rgb string.\n */\n\nfunction fromNamed(color) {\n  var el = document.createElement('div');\n  el.style.color = color;\n\n  if (el.style.color !== '') {\n    document.body.appendChild(el);\n    var rgb = getComputedStyle(el).color;\n    document.body.removeChild(el);\n    return rgb;\n  } else {\n    return '';\n  }\n}\n/**\n * @param {string} s String.\n * @return {Color} Color.\n */\n\n\nvar fromString = function () {\n  // We maintain a small cache of parsed strings.  To provide cheap LRU-like\n  // semantics, whenever the cache grows too large we simply delete an\n  // arbitrary 25% of the entries.\n\n  /**\n   * @const\n   * @type {number}\n   */\n  var MAX_CACHE_SIZE = 1024;\n  /**\n   * @type {Object<string, Color>}\n   */\n\n  var cache = {};\n  /**\n   * @type {number}\n   */\n\n  var cacheSize = 0;\n  return (\n    /**\n     * @param {string} s String.\n     * @return {Color} Color.\n     */\n    function (s) {\n      var color;\n\n      if (cache.hasOwnProperty(s)) {\n        color = cache[s];\n      } else {\n        if (cacheSize >= MAX_CACHE_SIZE) {\n          var i = 0;\n\n          for (var key in cache) {\n            if ((i++ & 3) === 0) {\n              delete cache[key];\n              --cacheSize;\n            }\n          }\n        }\n\n        color = fromStringInternal_(s);\n        cache[s] = color;\n        ++cacheSize;\n      }\n\n      return color;\n    }\n  );\n}();\n/**\n * Return the color as an array. This function maintains a cache of calculated\n * arrays which means the result should not be modified.\n * @param {Color|string} color Color.\n * @return {Color} Color.\n * @api\n */\n\nfunction asArray(color) {\n  if (Array.isArray(color)) {\n    return color;\n  } else {\n    return fromString(color);\n  }\n}\n/**\n * @param {string} s String.\n * @private\n * @return {Color} Color.\n */\n\nfunction fromStringInternal_(s) {\n  var r, g, b, a, color;\n\n  if (NAMED_COLOR_RE_.exec(s)) {\n    s = fromNamed(s);\n  }\n\n  if (HEX_COLOR_RE_.exec(s)) {\n    // hex\n    var n = s.length - 1; // number of hex digits\n\n    var d; // number of digits per channel\n\n    if (n <= 4) {\n      d = 1;\n    } else {\n      d = 2;\n    }\n\n    var hasAlpha = n === 4 || n === 8;\n    r = parseInt(s.substr(1 + 0 * d, d), 16);\n    g = parseInt(s.substr(1 + 1 * d, d), 16);\n    b = parseInt(s.substr(1 + 2 * d, d), 16);\n\n    if (hasAlpha) {\n      a = parseInt(s.substr(1 + 3 * d, d), 16);\n    } else {\n      a = 255;\n    }\n\n    if (d == 1) {\n      r = (r << 4) + r;\n      g = (g << 4) + g;\n      b = (b << 4) + b;\n\n      if (hasAlpha) {\n        a = (a << 4) + a;\n      }\n    }\n\n    color = [r, g, b, a / 255];\n  } else if (s.indexOf('rgba(') == 0) {\n    // rgba()\n    color = s.slice(5, -1).split(',').map(Number);\n    normalize(color);\n  } else if (s.indexOf('rgb(') == 0) {\n    // rgb()\n    color = s.slice(4, -1).split(',').map(Number);\n    color.push(1);\n    normalize(color);\n  } else {\n    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ \"a\"])(false, 14); // Invalid color\n  }\n\n  return color;\n}\n/**\n * TODO this function is only used in the test, we probably shouldn't export it\n * @param {Color} color Color.\n * @return {Color} Clamped color.\n */\n\n\nfunction normalize(color) {\n  color[0] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* clamp */ \"a\"])(color[0] + 0.5 | 0, 0, 255);\n  color[1] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* clamp */ \"a\"])(color[1] + 0.5 | 0, 0, 255);\n  color[2] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* clamp */ \"a\"])(color[2] + 0.5 | 0, 0, 255);\n  color[3] = Object(_math_js__WEBPACK_IMPORTED_MODULE_1__[/* clamp */ \"a\"])(color[3], 0, 1);\n  return color;\n}\n/**\n * @param {Color} color Color.\n * @return {string} String.\n */\n\nfunction toString(color) {\n  var r = color[0];\n\n  if (r != (r | 0)) {\n    r = r + 0.5 | 0;\n  }\n\n  var g = color[1];\n\n  if (g != (g | 0)) {\n    g = g + 0.5 | 0;\n  }\n\n  var b = color[2];\n\n  if (b != (b | 0)) {\n    b = b + 0.5 | 0;\n  }\n\n  var a = color[3] === undefined ? 1 : color[3];\n  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2NvbG9yLmpzP2YxYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2NvbG9yXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjbGFtcH0gZnJvbSAnLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEEgY29sb3IgcmVwcmVzZW50ZWQgYXMgYSBzaG9ydCBhcnJheSBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdLlxuICogcmVkLCBncmVlbiwgYW5kIGJsdWUgc2hvdWxkIGJlIGludGVnZXJzIGluIHRoZSByYW5nZSAwLi4yNTUgaW5jbHVzaXZlLlxuICogYWxwaGEgc2hvdWxkIGJlIGEgZmxvYXQgaW4gdGhlIHJhbmdlIDAuLjEgaW5jbHVzaXZlLiBJZiBubyBhbHBoYSB2YWx1ZSBpc1xuICogZ2l2ZW4gdGhlbiBgMWAgd2lsbCBiZSB1c2VkLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IENvbG9yXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIFRoaXMgUmVnRXhwIG1hdGNoZXMgIyBmb2xsb3dlZCBieSAzLCA0LCA2LCBvciA4IGhleCBkaWdpdHMuXG4gKiBAY29uc3RcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBIRVhfQ09MT1JfUkVfID0gL14jKFthLWYwLTldezN9fFthLWYwLTldezR9KD86W2EtZjAtOV17Mn0pezAsMn0pJC9pO1xuXG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBwb3RlbnRpYWwgbmFtZWQgY29sb3Igc3R5bGUgc3RyaW5ncy5cbiAqIEBjb25zdFxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IE5BTUVEX0NPTE9SX1JFXyA9IC9eKFthLXpdKikkL2k7XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGNvbG9yIGFzIGFuIHJnYmEgc3RyaW5nLlxuICogQHBhcmFtIHtDb2xvcnxzdHJpbmd9IGNvbG9yIENvbG9yLlxuICogQHJldHVybiB7c3RyaW5nfSBSZ2JhIHN0cmluZy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b1N0cmluZyhjb2xvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gbmFtZWQgY29sb3IgYXMgYW4gcmdiYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgTmFtZWQgY29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJnYiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGZyb21OYW1lZChjb2xvcikge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICBpZiAoZWwuc3R5bGUuY29sb3IgIT09ICcnKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgY29uc3QgcmdiID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuY29sb3I7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJnYjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZy5cbiAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21TdHJpbmcgPSAoXG4gIGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gV2UgbWFpbnRhaW4gYSBzbWFsbCBjYWNoZSBvZiBwYXJzZWQgc3RyaW5ncy4gIFRvIHByb3ZpZGUgY2hlYXAgTFJVLWxpa2VcbiAgICAvLyBzZW1hbnRpY3MsIHdoZW5ldmVyIHRoZSBjYWNoZSBncm93cyB0b28gbGFyZ2Ugd2Ugc2ltcGx5IGRlbGV0ZSBhblxuICAgIC8vIGFyYml0cmFyeSAyNSUgb2YgdGhlIGVudHJpZXMuXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbnN0IE1BWF9DQUNIRV9TSVpFID0gMTAyNDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBDb2xvcj59XG4gICAgICovXG4gICAgY29uc3QgY2FjaGUgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGV0IGNhY2hlU2l6ZSA9IDA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcyBTdHJpbmcuXG4gICAgICAgKiBAcmV0dXJuIHtDb2xvcn0gQ29sb3IuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgbGV0IGNvbG9yO1xuICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkocykpIHtcbiAgICAgICAgICBjb2xvciA9IGNhY2hlW3NdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWNoZVNpemUgPj0gTUFYX0NBQ0hFX1NJWkUpIHtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIGlmICgoaSsrICYgMykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICAtLWNhY2hlU2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb2xvciA9IGZyb21TdHJpbmdJbnRlcm5hbF8ocyk7XG4gICAgICAgICAgY2FjaGVbc10gPSBjb2xvcjtcbiAgICAgICAgICArK2NhY2hlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICB9XG4gICAgKTtcblxuICB9KSgpO1xuXG4vKipcbiAqIFJldHVybiB0aGUgY29sb3IgYXMgYW4gYXJyYXkuIFRoaXMgZnVuY3Rpb24gbWFpbnRhaW5zIGEgY2FjaGUgb2YgY2FsY3VsYXRlZFxuICogYXJyYXlzIHdoaWNoIG1lYW5zIHRoZSByZXN1bHQgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7Q29sb3J8c3RyaW5nfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yfSBDb2xvci5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXkoY29sb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgcmV0dXJuIGNvbG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKGNvbG9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZy5cbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtDb2xvcn0gQ29sb3IuXG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmdJbnRlcm5hbF8ocykge1xuICBsZXQgciwgZywgYiwgYSwgY29sb3I7XG5cbiAgaWYgKE5BTUVEX0NPTE9SX1JFXy5leGVjKHMpKSB7XG4gICAgcyA9IGZyb21OYW1lZChzKTtcbiAgfVxuXG4gIGlmIChIRVhfQ09MT1JfUkVfLmV4ZWMocykpIHsgLy8gaGV4XG4gICAgY29uc3QgbiA9IHMubGVuZ3RoIC0gMTsgLy8gbnVtYmVyIG9mIGhleCBkaWdpdHNcbiAgICBsZXQgZDsgLy8gbnVtYmVyIG9mIGRpZ2l0cyBwZXIgY2hhbm5lbFxuICAgIGlmIChuIDw9IDQpIHtcbiAgICAgIGQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBkID0gMjtcbiAgICB9XG4gICAgY29uc3QgaGFzQWxwaGEgPSBuID09PSA0IHx8IG4gPT09IDg7XG4gICAgciA9IHBhcnNlSW50KHMuc3Vic3RyKDEgKyAwICogZCwgZCksIDE2KTtcbiAgICBnID0gcGFyc2VJbnQocy5zdWJzdHIoMSArIDEgKiBkLCBkKSwgMTYpO1xuICAgIGIgPSBwYXJzZUludChzLnN1YnN0cigxICsgMiAqIGQsIGQpLCAxNik7XG4gICAgaWYgKGhhc0FscGhhKSB7XG4gICAgICBhID0gcGFyc2VJbnQocy5zdWJzdHIoMSArIDMgKiBkLCBkKSwgMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gMjU1O1xuICAgIH1cbiAgICBpZiAoZCA9PSAxKSB7XG4gICAgICByID0gKHIgPDwgNCkgKyByO1xuICAgICAgZyA9IChnIDw8IDQpICsgZztcbiAgICAgIGIgPSAoYiA8PCA0KSArIGI7XG4gICAgICBpZiAoaGFzQWxwaGEpIHtcbiAgICAgICAgYSA9IChhIDw8IDQpICsgYTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29sb3IgPSBbciwgZywgYiwgYSAvIDI1NV07XG4gIH0gZWxzZSBpZiAocy5pbmRleE9mKCdyZ2JhKCcpID09IDApIHsgLy8gcmdiYSgpXG4gICAgY29sb3IgPSBzLnNsaWNlKDUsIC0xKS5zcGxpdCgnLCcpLm1hcChOdW1iZXIpO1xuICAgIG5vcm1hbGl6ZShjb2xvcik7XG4gIH0gZWxzZSBpZiAocy5pbmRleE9mKCdyZ2IoJykgPT0gMCkgeyAvLyByZ2IoKVxuICAgIGNvbG9yID0gcy5zbGljZSg0LCAtMSkuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbiAgICBjb2xvci5wdXNoKDEpO1xuICAgIG5vcm1hbGl6ZShjb2xvcik7XG4gIH0gZWxzZSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAxNCk7IC8vIEludmFsaWQgY29sb3JcbiAgfVxuICByZXR1cm4gY29sb3I7XG59XG5cblxuLyoqXG4gKiBUT0RPIHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIGluIHRoZSB0ZXN0LCB3ZSBwcm9iYWJseSBzaG91bGRuJ3QgZXhwb3J0IGl0XG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0NvbG9yfSBDbGFtcGVkIGNvbG9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKGNvbG9yKSB7XG4gIGNvbG9yWzBdID0gY2xhbXAoKGNvbG9yWzBdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzFdID0gY2xhbXAoKGNvbG9yWzFdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzJdID0gY2xhbXAoKGNvbG9yWzJdICsgMC41KSB8IDAsIDAsIDI1NSk7XG4gIGNvbG9yWzNdID0gY2xhbXAoY29sb3JbM10sIDAsIDEpO1xuICByZXR1cm4gY29sb3I7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0NvbG9yfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoY29sb3IpIHtcbiAgbGV0IHIgPSBjb2xvclswXTtcbiAgaWYgKHIgIT0gKHIgfCAwKSkge1xuICAgIHIgPSAociArIDAuNSkgfCAwO1xuICB9XG4gIGxldCBnID0gY29sb3JbMV07XG4gIGlmIChnICE9IChnIHwgMCkpIHtcbiAgICBnID0gKGcgKyAwLjUpIHwgMDtcbiAgfVxuICBsZXQgYiA9IGNvbG9yWzJdO1xuICBpZiAoYiAhPSAoYiB8IDApKSB7XG4gICAgYiA9IChiICsgMC41KSB8IDA7XG4gIH1cbiAgY29uc3QgYSA9IGNvbG9yWzNdID09PSB1bmRlZmluZWQgPyAxIDogY29sb3JbM107XG4gIHJldHVybiAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7Ozs7Ozs7O0FBU0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BOzs7Ozs7Ozs7QUFXQTs7Ozs7QUFLQTs7Ozs7QUFLQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQXhCQTtBQTJCQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/render/EventType\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  /**\n   * @event module:ol/render/Event~RenderEvent#postcompose\n   * @api\n   */\n  POSTCOMPOSE: 'postcompose',\n\n  /**\n   * @event module:ol/render/Event~RenderEvent#precompose\n   * @api\n   */\n  PRECOMPOSE: 'precompose',\n\n  /**\n   * @event module:ol/render/Event~RenderEvent#render\n   * @api\n   */\n  RENDER: 'render',\n\n  /**\n   * Triggered when rendering is complete, i.e. all sources and tiles have\n   * finished loading for the current viewport, and all tiles are faded in.\n   * @event module:ol/render/Event~RenderEvent#rendercomplete\n   * @api\n   */\n  RENDERCOMPLETE: 'rendercomplete'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3JlbmRlci9FdmVudFR5cGUuanM/NTc0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50VHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcG9zdGNvbXBvc2VcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVENPTVBPU0U6ICdwb3N0Y29tcG9zZScsXG4gIC8qKlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwcmVjb21wb3NlXG4gICAqIEBhcGlcbiAgICovXG4gIFBSRUNPTVBPU0U6ICdwcmVjb21wb3NlJyxcbiAgLyoqXG4gICAqIEBldmVudCBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50I3JlbmRlclxuICAgKiBAYXBpXG4gICAqL1xuICBSRU5ERVI6ICdyZW5kZXInLFxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gcmVuZGVyaW5nIGlzIGNvbXBsZXRlLCBpLmUuIGFsbCBzb3VyY2VzIGFuZCB0aWxlcyBoYXZlXG4gICAqIGZpbmlzaGVkIGxvYWRpbmcgZm9yIHRoZSBjdXJyZW50IHZpZXdwb3J0LCBhbmQgYWxsIHRpbGVzIGFyZSBmYWRlZCBpbi5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcmVuZGVyY29tcGxldGVcbiAgICogQGFwaVxuICAgKi9cbiAgUkVOREVSQ09NUExFVEU6ICdyZW5kZXJjb21wbGV0ZSdcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBT0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFJQTtBQUNBOzs7OztBQUlBO0FBQ0E7Ozs7Ozs7QUFNQTtBQXRCQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return asColorLike; });\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);\n/**\n * @module ol/colorlike\n */\n\n/**\n * A type accepted by CanvasRenderingContext2D.fillStyle\n * or CanvasRenderingContext2D.strokeStyle.\n * Represents a color, pattern, or gradient. The origin for patterns and\n * gradients as fill style is an increment of 512 css pixels from map coordinate\n * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image\n * must be a factor of two (2, 4, 8, ..., 512).\n *\n * @typedef {string|CanvasPattern|CanvasGradient} ColorLike\n * @api\n */\n\n/**\n * @param {import("./color.js").Color|ColorLike} color Color.\n * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.\n * @api\n */\n\nfunction asColorLike(color) {\n  if (Array.isArray(color)) {\n    return Object(_color_js__WEBPACK_IMPORTED_MODULE_0__[/* toString */ "c"])(color);\n  } else {\n    return color;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2NvbG9ybGlrZS5qcz82ZjlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9jb2xvcmxpa2VcbiAqL1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnLi9jb2xvci5qcyc7XG5cblxuLyoqXG4gKiBBIHR5cGUgYWNjZXB0ZWQgYnkgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELmZpbGxTdHlsZVxuICogb3IgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnN0cm9rZVN0eWxlLlxuICogUmVwcmVzZW50cyBhIGNvbG9yLCBwYXR0ZXJuLCBvciBncmFkaWVudC4gVGhlIG9yaWdpbiBmb3IgcGF0dGVybnMgYW5kXG4gKiBncmFkaWVudHMgYXMgZmlsbCBzdHlsZSBpcyBhbiBpbmNyZW1lbnQgb2YgNTEyIGNzcyBwaXhlbHMgZnJvbSBtYXAgY29vcmRpbmF0ZVxuICogYFswLCAwXWAuIEZvciBzZWFtbGVzcyByZXBlYXQgcGF0dGVybnMsIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHBhdHRlcm4gaW1hZ2VcbiAqIG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xDYW52YXNQYXR0ZXJufENhbnZhc0dyYWRpZW50fSBDb2xvckxpa2VcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbG9yLmpzXCIpLkNvbG9yfENvbG9yTGlrZX0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtDb2xvckxpa2V9IFRoZSBjb2xvciBhcyBhbiB7QGxpbmsgb2wvY29sb3JsaWtlfkNvbG9yTGlrZX0uXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0NvbG9yTGlrZShjb2xvcikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb2xvcikpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcoY29sb3IpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///39\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _proj = _interopRequireDefault(__webpack_require__(85));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\r\n * @module nyc\r\n */\n\n\n_proj[\"default\"].defs([['EPSG:2263', '+proj=lcc +lat_1=41.03333333333333 +lat_2=40.66666666666666 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000.0000000001 +y_0=0 +ellps=GRS80 +datum=NAD83 +units=ft +to_meter=0.3048006096012192 +no_defs'], ['EPSG:6539', '+proj=lcc +lat_1=40.66666666666666 +lat_2=41.03333333333333 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000 +y_0=0 +ellps=GRS80 +units=us-ft +no_defs']]);\n/**\r\n  * @desc Top level namespace for NYC mapping\r\n  * @public\r\n  * @namespace\r\n  */\n\n\nvar nyc = {\n  /**\r\n   * @desc A proj4 instnce with NYC coordinate systems defined\r\n   * @public\r\n   * @const {proj4}\r\n   */\n  proj4: _proj[\"default\"],\n\n  /**\r\n   * @desc Provide inheritance for function-based classes using prototype\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {function} childCtor The constructor of the subclass\r\n   * @param {function} parentCtor The constructor of the superclass\r\n   */\n  inherits: function inherits(childCtor, parentCtor) {\n    nyc.copyFromParentProperties(childCtor.prototype, parentCtor.prototype);\n  },\n\n  /**\r\n   * @desc Provide for function-based classes to inherit from ES5 and ES6 classes\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {Object} childObj An instance of the subclass\r\n   * @param {Object} parentObj An instance of the superclass\r\n   */\n  subclass: function subclass(childObj, parentObj) {\n    var parentProto = Object.getPrototypeOf(parentObj);\n    nyc.copyFromParentProperties(childObj, parentProto);\n    nyc.copyFromParentKeys(childObj, parentObj);\n  },\n\n  /**\r\n   * @desc Provide mixin functionality\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {Object} obj The target of the mixins\r\n   * @param {Array<Object>} mixins An array of mixin objects - last in wins\r\n   */\n  mixin: function mixin(obj, mixins) {\n    mixins.forEach(function (mixin) {\n      _jquery[\"default\"].extend(obj, mixin);\n    });\n  },\n\n  /**\r\n   * @private\r\n   * @static\r\n   * @function\r\n   * @param {Object} childObj Child object\r\n   * @param {Object} parentObj Parent object\r\n   */\n  copyFromParentProperties: function copyFromParentProperties(childObj, parentObj) {\n    Object.getOwnPropertyNames(parentObj).forEach(function (member) {\n      if (!(member in childObj)) {\n        childObj[member] = parentObj[member];\n      }\n    });\n  },\n\n  /**\r\n   * @private\r\n   * @static\r\n   * @function\r\n   * @param {Object} childObj Child object\r\n   * @param {Object} parentObj Parent object\r\n   */\n  copyFromParentKeys: function copyFromParentKeys(childObj, parentObj) {\n    Object.keys(parentObj).forEach(function (member) {\n      if (!(member in childObj)) {\n        childObj[member] = parentObj[member];\n      }\n    });\n  },\n\n  /**\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {string} s A string\r\n   * @return {string} Input string with the first letter of each word capitalized\r\n   */\n  capitalize: function capitalize(s) {\n    var words = s.split(' ');\n    var result = '';\n    words.forEach(function (w) {\n      var word = w.toLowerCase();\n      result += word.substr(0, 1).toUpperCase();\n      result += word.substr(1).toLowerCase();\n      result += ' ';\n    });\n    return result.trim();\n  },\n\n  /**\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {string} prefix An id prefix\r\n   * @return {string} A unique id\r\n   */\n  nextId: function nextId(prefix) {\n    var last = nyc.uniqueIds[prefix];\n    nyc.uniqueIds[prefix] = typeof last === 'number' ? last + 1 : 0;\n    return \"\".concat(prefix, \"-\").concat(nyc.uniqueIds[prefix]);\n  },\n\n  /**\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {Object} object An object\r\n   * @return {jQuery} HTML string\r\n   */\n  html: function html(object) {\n    if (typeof object.html === 'function') {\n      return (0, _jquery[\"default\"])(object.html());\n    } else {\n      var html = (0, _jquery[\"default\"])('<div class=\"nyc-html\"></div>');\n\n      if (object.getProperties) {\n        object = object.getProperties();\n      } else if (object.properties) {\n        object = object.properties;\n      }\n\n      Object.keys(object).forEach(function (prop) {\n        html.append(\"<div><span class=\\\"fld\\\">\".concat(prop, \"</span><span class=\\\"val\\\">\").concat(object[prop], \"</span></div>\"));\n      });\n      return html;\n    }\n  },\n\n  /**\r\n   * @desc Shows the loading splash screen on eleents with loading class\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {jQuery} target Target elements\r\n   */\n  loading: function loading(target) {\n    if (target.hasClass('loading')) {\n      target.append((0, _jquery[\"default\"])('#loading').get(0) || nyc.LOADING_HTML);\n    }\n  },\n\n  /**\r\n   * @desc Clears the loading splash screen\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {jQuery} [target=body] Target elements\r\n   */\n  ready: function ready(target) {\n    (0, _jquery[\"default\"])(target || (0, _jquery[\"default\"])('body')).removeClass('loading').attr('aria-hidden', false);\n    (0, _jquery[\"default\"])('#loading').fadeOut();\n  },\n\n  /**\r\n   * @desc Returns a cache bust param for query strings\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {number} minutes Minutes\r\n   * @return {number} Time in milliseconds\r\n   */\n  cacheBust: function cacheBust(minutes) {\n    var offset = 1000 * 60 * minutes;\n    return Math.round(new Date().getTime() / offset) * offset;\n  },\n\n  /**\r\n   * @desc Disables scrolling on keypress when user presses the space bar on a button or a link by adding a kepress event handler to the document.  The click event is triggered on buttons and links without and href attribute or with an href value of #.  If a link has an href the browser will navigate to that location.  If a link also has a target attribute the navigation will take place in a new tab.\r\n   * @public\r\n   * @static\r\n   */\n  noSpaceBarScroll: function noSpaceBarScroll() {\n    (0, _jquery[\"default\"])(document).keypress(nyc.noSpaceBarHandler);\n  },\n\n  /**\r\n   * @private\r\n   * @const\r\n   * @type {function}\r\n   * @param {object} event The event object\r\n   */\n  noSpaceBarHandler: function noSpaceBarHandler(event) {\n    var tag = event.target.tagName;\n\n    if (_jquery[\"default\"].inArray(tag, ['INPUT', 'TEXTAREA', 'SELECT']) === -1) {\n      var key = event.key;\n\n      if (_jquery[\"default\"].inArray(key, [' ', 'Enter']) > -1) {\n        var elem = (0, _jquery[\"default\"])(event.target);\n        var href = elem.attr('href');\n        event.preventDefault();\n\n        if (!href || href === '#') {\n          elem.trigger('click');\n        } else {\n          var target = elem.attr('target');\n\n          if (target) {\n            window.open(href);\n          } else {\n            nyc.location(href);\n          }\n        }\n      }\n    }\n  },\n\n  /**\r\n   * @private\r\n   * @method\r\n   * @param {string} href Hyperlink\r\n   */\n  location: function location(href) {\n    window.location = href;\n  },\n\n  /**\r\n   * @desc Returns an object describing the element that currently has focus\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @return {Object} An object containing the element and a boolean indicating if it is a text input\r\n   */\n  activeElement: function activeElement() {\n    var activeElement = document.activeElement;\n    return {\n      activeElement: activeElement,\n      isTextInput: activeElement.tagName === 'INPUT' && activeElement.type === 'text'\n    };\n  },\n\n  /**\r\n   * @desc Returns an array with duplicates removed\r\n   * @public\r\n   * @static\r\n   * @function\r\n   * @param {Array<string>|Array<number>} arr An array with possible duplicates\r\n   * @return {Array<string>|Array<number>} An array without duplicates\r\n   */\n  removeDups: function removeDups(arr) {\n    var noDups = {};\n    var result = [];\n    arr.forEach(function (v) {\n      noDups[v] = _typeof(v);\n    });\n    Object.keys(noDups).forEach(function (v) {\n      result.push(noDups[v] === 'number' ? v * 1 : v);\n    });\n    return result;\n  },\n\n  /**\r\n   * @private\r\n   * @static\r\n   * @member {Object<string, number>}\r\n   */\n  uniqueIds: {}\n  /**\r\n   * @private\r\n   * @const\r\n   * @type {string}\r\n   */\n\n};\nnyc.LOADING_HTML = '<div id=\"loading\">' + '<div>' + '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"152\" height=\"52\">' + '<g transform=\"translate(1.5,0)\">' + '<polygon points=\"15.5,1.2 3.1,1.2 0,4.3 0,47.7 3.1,50.8 15.5,50.8 18.6,47.7 18.6,35.3 34.1,50.8 46.6,50.8 49.7,47.7 49.7,4.3 46.6,1.2 34.1,1.2 31,4.3 31,16.7 \"/>' + '<polygon points=\"83.8,47.7 83.8,38.4 99.3,22.9 99.3,10.5 99.3,4.3 96.2,1.2 83.8,1.2 80.7,4.3 80.7,10.5 74.5,16.7 68.3,10.5 68.3,4.3 65.2,1.2 52.8,1.2 49.7,4.3 49.7,22.9 65.2,38.4 65.2,47.7 68.3,50.8 80.7,50.8 \"/>' + '<polygon points=\"145.9,29.1 130.4,29.1 130.4,32.2 118,32.2 118,19.8 130.4,19.8 130.4,22.9 145.9,22.9 149,19.8 149,10.5 139.7,1.2 108.6,1.2 99.3,10.5 99.3,41.5 108.6,50.8 139.7,50.8 149,41.5 149,32.2 \"/>' + '</g>' + '</svg>' + '<h1>maps.nyc.gov</h1>' + '</div>' + '</div>';\n(0, _jquery[\"default\"])(document).ready(function () {\n  nyc.loading((0, _jquery[\"default\"])('body'));\n});\nvar _default = nyc;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnljLWxpYi9ueWMvaW5kZXguanM/NTg2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qcXVlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXG52YXIgX3Byb2ogPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9qNFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Y1xyXG4gKi9cbl9wcm9qLmRlZmF1bHQuZGVmcyhbWydFUFNHOjIyNjMnLCAnK3Byb2o9bGNjICtsYXRfMT00MS4wMzMzMzMzMzMzMzMzMyArbGF0XzI9NDAuNjY2NjY2NjY2NjY2NjYgK2xhdF8wPTQwLjE2NjY2NjY2NjY2NjY2ICtsb25fMD0tNzQgK3hfMD0zMDAwMDAuMDAwMDAwMDAwMSAreV8wPTAgK2VsbHBzPUdSUzgwICtkYXR1bT1OQUQ4MyArdW5pdHM9ZnQgK3RvX21ldGVyPTAuMzA0ODAwNjA5NjAxMjE5MiArbm9fZGVmcyddLCBbJ0VQU0c6NjUzOScsICcrcHJvaj1sY2MgK2xhdF8xPTQwLjY2NjY2NjY2NjY2NjY2ICtsYXRfMj00MS4wMzMzMzMzMzMzMzMzMyArbGF0XzA9NDAuMTY2NjY2NjY2NjY2NjYgK2xvbl8wPS03NCAreF8wPTMwMDAwMCAreV8wPTAgK2VsbHBzPUdSUzgwICt1bml0cz11cy1mdCArbm9fZGVmcyddXSk7XG4vKipcclxuICAqIEBkZXNjIFRvcCBsZXZlbCBuYW1lc3BhY2UgZm9yIE5ZQyBtYXBwaW5nXHJcbiAgKiBAcHVibGljXHJcbiAgKiBAbmFtZXNwYWNlXHJcbiAgKi9cblxuXG5jb25zdCBueWMgPSB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIEEgcHJvajQgaW5zdG5jZSB3aXRoIE5ZQyBjb29yZGluYXRlIHN5c3RlbXMgZGVmaW5lZFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3Qge3Byb2o0fVxyXG4gICAqL1xuICBwcm9qNDogX3Byb2ouZGVmYXVsdCxcblxuICAvKipcclxuICAgKiBAZGVzYyBQcm92aWRlIGluaGVyaXRhbmNlIGZvciBmdW5jdGlvbi1iYXNlZCBjbGFzc2VzIHVzaW5nIHByb3RvdHlwZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2hpbGRDdG9yIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc3ViY2xhc3NcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJlbnRDdG9yIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgc3VwZXJjbGFzc1xyXG4gICAqL1xuICBpbmhlcml0cyhjaGlsZEN0b3IsIHBhcmVudEN0b3IpIHtcbiAgICBueWMuY29weUZyb21QYXJlbnRQcm9wZXJ0aWVzKGNoaWxkQ3Rvci5wcm90b3R5cGUsIHBhcmVudEN0b3IucHJvdG90eXBlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBAZGVzYyBQcm92aWRlIGZvciBmdW5jdGlvbi1iYXNlZCBjbGFzc2VzIHRvIGluaGVyaXQgZnJvbSBFUzUgYW5kIEVTNiBjbGFzc2VzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hpbGRPYmogQW4gaW5zdGFuY2Ugb2YgdGhlIHN1YmNsYXNzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudE9iaiBBbiBpbnN0YW5jZSBvZiB0aGUgc3VwZXJjbGFzc1xyXG4gICAqL1xuICBzdWJjbGFzcyhjaGlsZE9iaiwgcGFyZW50T2JqKSB7XG4gICAgY29uc3QgcGFyZW50UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50T2JqKTtcbiAgICBueWMuY29weUZyb21QYXJlbnRQcm9wZXJ0aWVzKGNoaWxkT2JqLCBwYXJlbnRQcm90byk7XG4gICAgbnljLmNvcHlGcm9tUGFyZW50S2V5cyhjaGlsZE9iaiwgcGFyZW50T2JqKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBAZGVzYyBQcm92aWRlIG1peGluIGZ1bmN0aW9uYWxpdHlcclxuICAgKiBAcHVibGljXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIHRhcmdldCBvZiB0aGUgbWl4aW5zXHJcbiAgICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBtaXhpbnMgQW4gYXJyYXkgb2YgbWl4aW4gb2JqZWN0cyAtIGxhc3QgaW4gd2luc1xyXG4gICAqL1xuICBtaXhpbihvYmosIG1peGlucykge1xuICAgIG1peGlucy5mb3JFYWNoKG1peGluID0+IHtcbiAgICAgIF9qcXVlcnkuZGVmYXVsdC5leHRlbmQob2JqLCBtaXhpbik7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoaWxkT2JqIENoaWxkIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRPYmogUGFyZW50IG9iamVjdFxyXG4gICAqL1xuICBjb3B5RnJvbVBhcmVudFByb3BlcnRpZXMoY2hpbGRPYmosIHBhcmVudE9iaikge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudE9iaikuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgaWYgKCEobWVtYmVyIGluIGNoaWxkT2JqKSkge1xuICAgICAgICBjaGlsZE9ialttZW1iZXJdID0gcGFyZW50T2JqW21lbWJlcl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoaWxkT2JqIENoaWxkIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnRPYmogUGFyZW50IG9iamVjdFxyXG4gICAqL1xuICBjb3B5RnJvbVBhcmVudEtleXMoY2hpbGRPYmosIHBhcmVudE9iaikge1xuICAgIE9iamVjdC5rZXlzKHBhcmVudE9iaikuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgaWYgKCEobWVtYmVyIGluIGNoaWxkT2JqKSkge1xuICAgICAgICBjaGlsZE9ialttZW1iZXJdID0gcGFyZW50T2JqW21lbWJlcl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyBBIHN0cmluZ1xyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gSW5wdXQgc3RyaW5nIHdpdGggdGhlIGZpcnN0IGxldHRlciBvZiBlYWNoIHdvcmQgY2FwaXRhbGl6ZWRcclxuICAgKi9cbiAgY2FwaXRhbGl6ZShzKSB7XG4gICAgY29uc3Qgd29yZHMgPSBzLnNwbGl0KCcgJyk7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIHdvcmRzLmZvckVhY2godyA9PiB7XG4gICAgICBjb25zdCB3b3JkID0gdy50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmVzdWx0ICs9IHdvcmQuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXN1bHQgKz0gd29yZC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJlc3VsdCArPSAnICc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IEFuIGlkIHByZWZpeFxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSB1bmlxdWUgaWRcclxuICAgKi9cbiAgbmV4dElkKHByZWZpeCkge1xuICAgIGNvbnN0IGxhc3QgPSBueWMudW5pcXVlSWRzW3ByZWZpeF07XG4gICAgbnljLnVuaXF1ZUlkc1twcmVmaXhdID0gdHlwZW9mIGxhc3QgPT09ICdudW1iZXInID8gbGFzdCArIDEgOiAwO1xuICAgIHJldHVybiBgJHtwcmVmaXh9LSR7bnljLnVuaXF1ZUlkc1twcmVmaXhdfWA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IEFuIG9iamVjdFxyXG4gICAqIEByZXR1cm4ge2pRdWVyeX0gSFRNTCBzdHJpbmdcclxuICAgKi9cbiAgaHRtbChvYmplY3QpIHtcbiAgICBpZiAodHlwZW9mIG9iamVjdC5odG1sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gKDAsIF9qcXVlcnkuZGVmYXVsdCkob2JqZWN0Lmh0bWwoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGh0bWwgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KSgnPGRpdiBjbGFzcz1cIm55Yy1odG1sXCI+PC9kaXY+Jyk7XG5cbiAgICAgIGlmIChvYmplY3QuZ2V0UHJvcGVydGllcykge1xuICAgICAgICBvYmplY3QgPSBvYmplY3QuZ2V0UHJvcGVydGllcygpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3QucHJvcGVydGllcykge1xuICAgICAgICBvYmplY3QgPSBvYmplY3QucHJvcGVydGllcztcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBodG1sLmFwcGVuZChgPGRpdj48c3BhbiBjbGFzcz1cImZsZFwiPiR7cHJvcH08L3NwYW4+PHNwYW4gY2xhc3M9XCJ2YWxcIj4ke29iamVjdFtwcm9wXX08L3NwYW4+PC9kaXY+YCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBAZGVzYyBTaG93cyB0aGUgbG9hZGluZyBzcGxhc2ggc2NyZWVuIG9uIGVsZWVudHMgd2l0aCBsb2FkaW5nIGNsYXNzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge2pRdWVyeX0gdGFyZ2V0IFRhcmdldCBlbGVtZW50c1xyXG4gICAqL1xuICBsb2FkaW5nKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2xvYWRpbmcnKSkge1xuICAgICAgdGFyZ2V0LmFwcGVuZCgoMCwgX2pxdWVyeS5kZWZhdWx0KSgnI2xvYWRpbmcnKS5nZXQoMCkgfHwgbnljLkxPQURJTkdfSFRNTCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEBkZXNjIENsZWFycyB0aGUgbG9hZGluZyBzcGxhc2ggc2NyZWVuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge2pRdWVyeX0gW3RhcmdldD1ib2R5XSBUYXJnZXQgZWxlbWVudHNcclxuICAgKi9cbiAgcmVhZHkodGFyZ2V0KSB7XG4gICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkodGFyZ2V0IHx8ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKCdib2R5JykpLnJlbW92ZUNsYXNzKCdsb2FkaW5nJykuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoJyNsb2FkaW5nJykuZmFkZU91dCgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEBkZXNjIFJldHVybnMgYSBjYWNoZSBidXN0IHBhcmFtIGZvciBxdWVyeSBzdHJpbmdzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWludXRlcyBNaW51dGVzXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBUaW1lIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqL1xuICBjYWNoZUJ1c3QobWludXRlcykge1xuICAgIGNvbnN0IG9mZnNldCA9IDEwMDAgKiA2MCAqIG1pbnV0ZXM7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyBvZmZzZXQpICogb2Zmc2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEBkZXNjIERpc2FibGVzIHNjcm9sbGluZyBvbiBrZXlwcmVzcyB3aGVuIHVzZXIgcHJlc3NlcyB0aGUgc3BhY2UgYmFyIG9uIGEgYnV0dG9uIG9yIGEgbGluayBieSBhZGRpbmcgYSBrZXByZXNzIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGRvY3VtZW50LiAgVGhlIGNsaWNrIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiBidXR0b25zIGFuZCBsaW5rcyB3aXRob3V0IGFuZCBocmVmIGF0dHJpYnV0ZSBvciB3aXRoIGFuIGhyZWYgdmFsdWUgb2YgIy4gIElmIGEgbGluayBoYXMgYW4gaHJlZiB0aGUgYnJvd3NlciB3aWxsIG5hdmlnYXRlIHRvIHRoYXQgbG9jYXRpb24uICBJZiBhIGxpbmsgYWxzbyBoYXMgYSB0YXJnZXQgYXR0cmlidXRlIHRoZSBuYXZpZ2F0aW9uIHdpbGwgdGFrZSBwbGFjZSBpbiBhIG5ldyB0YWIuXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKi9cbiAgbm9TcGFjZUJhclNjcm9sbCgpIHtcbiAgICAoMCwgX2pxdWVyeS5kZWZhdWx0KShkb2N1bWVudCkua2V5cHJlc3MobnljLm5vU3BhY2VCYXJIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBjb25zdFxyXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdFxyXG4gICAqL1xuICBub1NwYWNlQmFySGFuZGxlcihldmVudCkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhcmdldC50YWdOYW1lO1xuXG4gICAgaWYgKF9qcXVlcnkuZGVmYXVsdC5pbkFycmF5KHRhZywgWydJTlBVVCcsICdURVhUQVJFQScsICdTRUxFQ1QnXSkgPT09IC0xKSB7XG4gICAgICBjb25zdCBrZXkgPSBldmVudC5rZXk7XG5cbiAgICAgIGlmIChfanF1ZXJ5LmRlZmF1bHQuaW5BcnJheShrZXksIFsnICcsICdFbnRlciddKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSAoMCwgX2pxdWVyeS5kZWZhdWx0KShldmVudC50YXJnZXQpO1xuICAgICAgICBjb25zdCBocmVmID0gZWxlbS5hdHRyKCdocmVmJyk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFocmVmIHx8IGhyZWYgPT09ICcjJykge1xuICAgICAgICAgIGVsZW0udHJpZ2dlcignY2xpY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlbGVtLmF0dHIoJ3RhcmdldCcpO1xuXG4gICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4oaHJlZik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG55Yy5sb2NhdGlvbihocmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgSHlwZXJsaW5rXHJcbiAgICovXG4gIGxvY2F0aW9uKGhyZWYpIHtcbiAgICB3aW5kb3cubG9jYXRpb24gPSBocmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEBkZXNjIFJldHVybnMgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGVsZW1lbnQgdGhhdCBjdXJyZW50bHkgaGFzIGZvY3VzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBlbGVtZW50IGFuZCBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBpdCBpcyBhIHRleHQgaW5wdXRcclxuICAgKi9cbiAgYWN0aXZlRWxlbWVudCgpIHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aXZlRWxlbWVudDogYWN0aXZlRWxlbWVudCxcbiAgICAgIGlzVGV4dElucHV0OiBhY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgYWN0aXZlRWxlbWVudC50eXBlID09PSAndGV4dCdcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEBkZXNjIFJldHVybnMgYW4gYXJyYXkgd2l0aCBkdXBsaWNhdGVzIHJlbW92ZWRcclxuICAgKiBAcHVibGljXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPnxBcnJheTxudW1iZXI+fSBhcnIgQW4gYXJyYXkgd2l0aCBwb3NzaWJsZSBkdXBsaWNhdGVzXHJcbiAgICogQHJldHVybiB7QXJyYXk8c3RyaW5nPnxBcnJheTxudW1iZXI+fSBBbiBhcnJheSB3aXRob3V0IGR1cGxpY2F0ZXNcclxuICAgKi9cbiAgcmVtb3ZlRHVwcyhhcnIpIHtcbiAgICBjb25zdCBub0R1cHMgPSB7fTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBhcnIuZm9yRWFjaCh2ID0+IHtcbiAgICAgIG5vRHVwc1t2XSA9IHR5cGVvZiB2O1xuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKG5vRHVwcykuZm9yRWFjaCh2ID0+IHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vRHVwc1t2XSA9PT0gJ251bWJlcicgPyB2ICogMSA6IHYpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAc3RhdGljXHJcbiAgICogQG1lbWJlciB7T2JqZWN0PHN0cmluZywgbnVtYmVyPn1cclxuICAgKi9cbiAgdW5pcXVlSWRzOiB7fVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBjb25zdFxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG5cbn07XG5ueWMuTE9BRElOR19IVE1MID0gJzxkaXYgaWQ9XCJsb2FkaW5nXCI+JyArICc8ZGl2PicgKyAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNTJcIiBoZWlnaHQ9XCI1MlwiPicgKyAnPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEuNSwwKVwiPicgKyAnPHBvbHlnb24gcG9pbnRzPVwiMTUuNSwxLjIgMy4xLDEuMiAwLDQuMyAwLDQ3LjcgMy4xLDUwLjggMTUuNSw1MC44IDE4LjYsNDcuNyAxOC42LDM1LjMgMzQuMSw1MC44IDQ2LjYsNTAuOCA0OS43LDQ3LjcgNDkuNyw0LjMgNDYuNiwxLjIgMzQuMSwxLjIgMzEsNC4zIDMxLDE2LjcgXCIvPicgKyAnPHBvbHlnb24gcG9pbnRzPVwiODMuOCw0Ny43IDgzLjgsMzguNCA5OS4zLDIyLjkgOTkuMywxMC41IDk5LjMsNC4zIDk2LjIsMS4yIDgzLjgsMS4yIDgwLjcsNC4zIDgwLjcsMTAuNSA3NC41LDE2LjcgNjguMywxMC41IDY4LjMsNC4zIDY1LjIsMS4yIDUyLjgsMS4yIDQ5LjcsNC4zIDQ5LjcsMjIuOSA2NS4yLDM4LjQgNjUuMiw0Ny43IDY4LjMsNTAuOCA4MC43LDUwLjggXCIvPicgKyAnPHBvbHlnb24gcG9pbnRzPVwiMTQ1LjksMjkuMSAxMzAuNCwyOS4xIDEzMC40LDMyLjIgMTE4LDMyLjIgMTE4LDE5LjggMTMwLjQsMTkuOCAxMzAuNCwyMi45IDE0NS45LDIyLjkgMTQ5LDE5LjggMTQ5LDEwLjUgMTM5LjcsMS4yIDEwOC42LDEuMiA5OS4zLDEwLjUgOTkuMyw0MS41IDEwOC42LDUwLjggMTM5LjcsNTAuOCAxNDksNDEuNSAxNDksMzIuMiBcIi8+JyArICc8L2c+JyArICc8L3N2Zz4nICsgJzxoMT5tYXBzLm55Yy5nb3Y8L2gxPicgKyAnPC9kaXY+JyArICc8L2Rpdj4nO1xuKDAsIF9qcXVlcnkuZGVmYXVsdCkoZG9jdW1lbnQpLnJlYWR5KCgpID0+IHtcbiAgbnljLmxvYWRpbmcoKDAsIF9qcXVlcnkuZGVmYXVsdCkoJ2JvZHknKSk7XG59KTtcbnZhciBfZGVmYXVsdCA9IG55YztcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7O0FBelFBO0FBZ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./node_modules/ol/string.js\n/**\n * @module ol/string\n */\n\n/**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)\n * @returns {string} Formatted string\n */\nfunction padNumber(number, width, opt_precision) {\n  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;\n  var decimal = numberString.indexOf('.');\n  decimal = decimal === -1 ? numberString.length : decimal;\n  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;\n}\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @returns {number} Value\n */\n\nfunction compareVersions(v1, v2) {\n  var s1 = ('' + v1).split('.');\n  var s2 = ('' + v2).split('.');\n\n  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {\n    var n1 = parseInt(s1[i] || '0', 10);\n    var n2 = parseInt(s2[i] || '0', 10);\n\n    if (n1 > n2) {\n      return 1;\n    }\n\n    if (n2 > n1) {\n      return -1;\n    }\n  }\n\n  return 0;\n}\n// CONCATENATED MODULE: ./node_modules/ol/coordinate.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closestOnCircle\", function() { return closestOnCircle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"closestOnSegment\", function() { return closestOnSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createStringXY\", function() { return createStringXY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"degreesToStringHDMS\", function() { return degreesToStringHDMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"format\", function() { return format; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistanceToSegment\", function() { return squaredDistanceToSegment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toStringHDMS\", function() { return toStringHDMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toStringXY\", function() { return toStringXY; });\n/**\n * @module ol/coordinate\n */\n\n\n/**\n * An array of numbers representing an xy coordinate. Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\n\nfunction add(coordinate, delta) {\n  coordinate[0] += delta[0];\n  coordinate[1] += delta[1];\n  return coordinate;\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\n\nfunction closestOnCircle(coordinate, circle) {\n  var r = circle.getRadius();\n  var center = circle.getCenter();\n  var x0 = center[0];\n  var y0 = center[1];\n  var x1 = coordinate[0];\n  var y1 = coordinate[1];\n  var dx = x1 - x0;\n  var dy = y1 - y0;\n\n  if (dx === 0 && dy === 0) {\n    dx = 1;\n  }\n\n  var d = Math.sqrt(dx * dx + dy * dy);\n  var x = x0 + r * dx / d;\n  var y = y0 + r * dy / d;\n  return [x, y];\n}\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\n\nfunction closestOnSegment(coordinate, segment) {\n  var x0 = coordinate[0];\n  var y0 = coordinate[1];\n  var start = segment[0];\n  var end = segment[1];\n  var x1 = start[0];\n  var y1 = start[1];\n  var x2 = end[0];\n  var y2 = end[1];\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n  var x, y;\n\n  if (along <= 0) {\n    x = x1;\n    y = y1;\n  } else if (along >= 1) {\n    x = x2;\n    y = y2;\n  } else {\n    x = x1 + along * dx;\n    y = y1 + along * dy;\n  }\n\n  return [x, y];\n}\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var stringifyFunc = createStringXY();\n *     var out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var stringifyFunc = createStringXY(2);\n *     var out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\n\nfunction createStringXY(opt_fractionDigits) {\n  return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n      return toStringXY(coordinate, opt_fractionDigits);\n    }\n  );\n}\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\n\nfunction degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {\n  var normalizedDegrees = Object(math[\"d\" /* modulo */])(degrees + 180, 360) - 180;\n  var x = Math.abs(3600 * normalizedDegrees);\n  var dflPrecision = opt_fractionDigits || 0;\n  var precision = Math.pow(10, dflPrecision);\n  var deg = Math.floor(x / 3600);\n  var min = Math.floor((x - deg * 3600) / 60);\n  var sec = x - deg * 3600 - min * 60;\n  sec = Math.ceil(sec * precision) / precision;\n\n  if (sec >= 60) {\n    sec = 0;\n    min += 1;\n  }\n\n  if (min >= 60) {\n    min = 0;\n    deg += 1;\n  }\n\n  return deg + \"\\xB0 \" + padNumber(min, 2) + \"\\u2032 \" + padNumber(sec, 2, dflPrecision) + \"\\u2033\" + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));\n}\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var template = 'Coordinate is ({x}|{y}).';\n *     var out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var template = 'Coordinate is ({x}|{y}).';\n *     var out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\n\nfunction format(coordinate, template, opt_fractionDigits) {\n  if (coordinate) {\n    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));\n  } else {\n    return '';\n  }\n}\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\n\nfunction equals(coordinate1, coordinate2) {\n  var equals = true;\n\n  for (var i = coordinate1.length - 1; i >= 0; --i) {\n    if (coordinate1[i] != coordinate2[i]) {\n      equals = false;\n      break;\n    }\n  }\n\n  return equals;\n}\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\n\nfunction rotate(coordinate, angle) {\n  var cosAngle = Math.cos(angle);\n  var sinAngle = Math.sin(angle);\n  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  coordinate[0] = x;\n  coordinate[1] = y;\n  return coordinate;\n}\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\n\nfunction scale(coordinate, scale) {\n  coordinate[0] *= scale;\n  coordinate[1] *= scale;\n  return coordinate;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\n\nfunction squaredDistance(coord1, coord2) {\n  var dx = coord1[0] - coord2[0];\n  var dy = coord1[1] - coord2[1];\n  return dx * dx + dy * dy;\n}\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\n\nfunction distance(coord1, coord2) {\n  return Math.sqrt(squaredDistance(coord1, coord2));\n}\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\n\nfunction squaredDistanceToSegment(coordinate, segment) {\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringHDMS(coord);\n *     // out is now '47 58 60 N 7 50 60 E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringHDMS(coord, 1);\n *     // out is now '47 58 60.0 N 7 50 60.0 E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\n\nfunction toStringHDMS(coordinate, opt_fractionDigits) {\n  if (coordinate) {\n    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);\n  } else {\n    return '';\n  }\n}\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate';\n *\n *     var coord = [7.85, 47.983333];\n *     var out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number=} opt_fractionDigits The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\n\nfunction toStringXY(coordinate, opt_fractionDigits) {\n  return format(coordinate, '{x}, {y}', opt_fractionDigits);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL3N0cmluZy5qcz83ZGU2Iiwid2VicGFjazovLy8uLi8uLi9zcmMvb2wvY29vcmRpbmF0ZS5qcz9iNzA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9zdHJpbmdcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgTnVtYmVyIHRvIGJlIGZvcm1hdHRlZFxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9wcmVjaXNpb24gUHJlY2lzaW9uIG9mIHRoZSBvdXRwdXQgc3RyaW5nIChpLmUuIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcylcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZE51bWJlcihudW1iZXIsIHdpZHRoLCBvcHRfcHJlY2lzaW9uKSB7XG4gIGNvbnN0IG51bWJlclN0cmluZyA9IG9wdF9wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IG51bWJlci50b0ZpeGVkKG9wdF9wcmVjaXNpb24pIDogJycgKyBudW1iZXI7XG4gIGxldCBkZWNpbWFsID0gbnVtYmVyU3RyaW5nLmluZGV4T2YoJy4nKTtcbiAgZGVjaW1hbCA9IGRlY2ltYWwgPT09IC0xID8gbnVtYmVyU3RyaW5nLmxlbmd0aCA6IGRlY2ltYWw7XG4gIHJldHVybiBkZWNpbWFsID4gd2lkdGggPyBudW1iZXJTdHJpbmcgOiBuZXcgQXJyYXkoMSArIHdpZHRoIC0gZGVjaW1hbCkuam9pbignMCcpICsgbnVtYmVyU3RyaW5nO1xufVxuXG5cbi8qKlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9vbWljaGVsc2VuL2NvbXBhcmUtdmVyc2lvbnMvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdjEgRmlyc3QgdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2MiBTZWNvbmQgdmVyc2lvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVWZXJzaW9ucyh2MSwgdjIpIHtcbiAgY29uc3QgczEgPSAoJycgKyB2MSkuc3BsaXQoJy4nKTtcbiAgY29uc3QgczIgPSAoJycgKyB2Mikuc3BsaXQoJy4nKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KHMxLmxlbmd0aCwgczIubGVuZ3RoKTsgaSsrKSB7XG4gICAgY29uc3QgbjEgPSBwYXJzZUludChzMVtpXSB8fCAnMCcsIDEwKTtcbiAgICBjb25zdCBuMiA9IHBhcnNlSW50KHMyW2ldIHx8ICcwJywgMTApO1xuXG4gICAgaWYgKG4xID4gbjIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAobjIgPiBuMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2Nvb3JkaW5hdGVcbiAqL1xuaW1wb3J0IHttb2R1bG99IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge3BhZE51bWJlcn0gZnJvbSAnLi9zdHJpbmcuanMnO1xuXG5cbi8qKlxuICogQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgYW4geHkgY29vcmRpbmF0ZS4gRXhhbXBsZTogYFsxNiwgNDhdYC5cbiAqIEB0eXBlZGVmIHtBcnJheTxudW1iZXI+fSBDb29yZGluYXRlXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvY29vcmRpbmF0ZX5Db29yZGluYXRlfSBhbmRcbiAqIHRyYW5zZm9ybXMgaXQgaW50byBhIGB7c3RyaW5nfWAuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChDb29yZGluYXRlfHVuZGVmaW5lZCkpOiBzdHJpbmd9IENvb3JkaW5hdGVGb3JtYXRcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQWRkIGBkZWx0YWAgdG8gYGNvb3JkaW5hdGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIHJldHVybmVkXG4gKiBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHthZGR9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICBhZGQoY29vcmQsIFstMiwgNF0pO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbNS44NSwgNTEuOTgzMzMzXVxuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBkZWx0YSBEZWx0YS5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFRoZSBpbnB1dCBjb29yZGluYXRlIGFkanVzdGVkIGJ5XG4gKiB0aGUgZ2l2ZW4gZGVsdGEuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGQoY29vcmRpbmF0ZSwgZGVsdGEpIHtcbiAgY29vcmRpbmF0ZVswXSArPSBkZWx0YVswXTtcbiAgY29vcmRpbmF0ZVsxXSArPSBkZWx0YVsxXTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBjbG9zZXN0IHRvIHRoZSBwYXNzZWQgY29vcmRpbmF0ZSBvbiB0aGUgcGFzc2VkIGNpcmNsZS5cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgVGhlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gY2lyY2xlIFRoZSBjaXJjbGUuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDbG9zZXN0IHBvaW50IG9uIHRoZSBjaXJjdW1mZXJlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdE9uQ2lyY2xlKGNvb3JkaW5hdGUsIGNpcmNsZSkge1xuICBjb25zdCByID0gY2lyY2xlLmdldFJhZGl1cygpO1xuICBjb25zdCBjZW50ZXIgPSBjaXJjbGUuZ2V0Q2VudGVyKCk7XG4gIGNvbnN0IHgwID0gY2VudGVyWzBdO1xuICBjb25zdCB5MCA9IGNlbnRlclsxXTtcbiAgY29uc3QgeDEgPSBjb29yZGluYXRlWzBdO1xuICBjb25zdCB5MSA9IGNvb3JkaW5hdGVbMV07XG5cbiAgbGV0IGR4ID0geDEgLSB4MDtcbiAgY29uc3QgZHkgPSB5MSAtIHkwO1xuICBpZiAoZHggPT09IDAgJiYgZHkgPT09IDApIHtcbiAgICBkeCA9IDE7XG4gIH1cbiAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgY29uc3QgeCA9IHgwICsgciAqIGR4IC8gZDtcbiAgY29uc3QgeSA9IHkwICsgciAqIGR5IC8gZDtcblxuICByZXR1cm4gW3gsIHldO1xufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9pbnQgY2xvc2VzdCB0byB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgb24gdGhlIHBhc3NlZCBzZWdtZW50LlxuICogVGhpcyBpcyB0aGUgZm9vdCBvZiB0aGUgcGVycGVuZGljdWxhciBvZiB0aGUgY29vcmRpbmF0ZSB0byB0aGUgc2VnbWVudCB3aGVuXG4gKiB0aGUgZm9vdCBpcyBvbiB0aGUgc2VnbWVudCwgb3IgdGhlIGNsb3Nlc3Qgc2VnbWVudCBjb29yZGluYXRlIHdoZW4gdGhlIGZvb3RcbiAqIGlzIG91dHNpZGUgdGhlIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gc2VnbWVudCBUaGUgdHdvIGNvb3JkaW5hdGVzXG4gKiBvZiB0aGUgc2VnbWVudC5cbiAqIEByZXR1cm4ge0Nvb3JkaW5hdGV9IFRoZSBmb290IG9mIHRoZSBwZXJwZW5kaWN1bGFyIG9mXG4gKiB0aGUgY29vcmRpbmF0ZSB0byB0aGUgc2VnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3RPblNlZ21lbnQoY29vcmRpbmF0ZSwgc2VnbWVudCkge1xuICBjb25zdCB4MCA9IGNvb3JkaW5hdGVbMF07XG4gIGNvbnN0IHkwID0gY29vcmRpbmF0ZVsxXTtcbiAgY29uc3Qgc3RhcnQgPSBzZWdtZW50WzBdO1xuICBjb25zdCBlbmQgPSBzZWdtZW50WzFdO1xuICBjb25zdCB4MSA9IHN0YXJ0WzBdO1xuICBjb25zdCB5MSA9IHN0YXJ0WzFdO1xuICBjb25zdCB4MiA9IGVuZFswXTtcbiAgY29uc3QgeTIgPSBlbmRbMV07XG4gIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICBjb25zdCBhbG9uZyA9IChkeCA9PT0gMCAmJiBkeSA9PT0gMCkgPyAwIDpcbiAgICAoKGR4ICogKHgwIC0geDEpKSArIChkeSAqICh5MCAtIHkxKSkpIC8gKChkeCAqIGR4ICsgZHkgKiBkeSkgfHwgMCk7XG4gIGxldCB4LCB5O1xuICBpZiAoYWxvbmcgPD0gMCkge1xuICAgIHggPSB4MTtcbiAgICB5ID0geTE7XG4gIH0gZWxzZSBpZiAoYWxvbmcgPj0gMSkge1xuICAgIHggPSB4MjtcbiAgICB5ID0geTI7XG4gIH0gZWxzZSB7XG4gICAgeCA9IHgxICsgYWxvbmcgKiBkeDtcbiAgICB5ID0geTEgKyBhbG9uZyAqIGR5O1xuICB9XG4gIHJldHVybiBbeCwgeV07XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGVGb3JtYXR9IGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gKiB1c2VkIHRvIGZvcm1hdFxuICogYSB7Q29vcmRpbmF0ZX0gdG8gYSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge2NyZWF0ZVN0cmluZ1hZfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIHN0cmluZ2lmeUZ1bmMgPSBjcmVhdGVTdHJpbmdYWSgpO1xuICogICAgIHZhciBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc4LCA0OCdcbiAqXG4gKiBFeGFtcGxlIHdpdGggZXhwbGljaXRseSBzcGVjaWZ5aW5nIDIgZnJhY3Rpb25hbCBkaWdpdHM6XG4gKlxuICogICAgIGltcG9ydCB7Y3JlYXRlU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgc3RyaW5naWZ5RnVuYyA9IGNyZWF0ZVN0cmluZ1hZKDIpO1xuICogICAgIHZhciBvdXQgPSBzdHJpbmdpZnlGdW5jKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc3Ljg1LCA0Ny45OCdcbiAqXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFjdGlvbkRpZ2l0cyBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlRm9ybWF0fSBDb29yZGluYXRlIGZvcm1hdC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1hZKG9wdF9mcmFjdGlvbkRpZ2l0cykge1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIFhZLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGNvb3JkaW5hdGUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZ1hZKGNvb3JkaW5hdGUsIG9wdF9mcmFjdGlvbkRpZ2l0cyk7XG4gICAgfVxuICApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhlbWlzcGhlcmVzIEhlbWlzcGhlcmVzLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlZ3JlZXMgRGVncmVlcy5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2ZyYWN0aW9uRGlnaXRzIFRoZSBudW1iZXIgb2YgZGlnaXRzIHRvIGluY2x1ZGVcbiAqICAgIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LiBEZWZhdWx0IGlzIGAwYC5cbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlc1RvU3RyaW5nSERNUyhoZW1pc3BoZXJlcywgZGVncmVlcywgb3B0X2ZyYWN0aW9uRGlnaXRzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWREZWdyZWVzID0gbW9kdWxvKGRlZ3JlZXMgKyAxODAsIDM2MCkgLSAxODA7XG4gIGNvbnN0IHggPSBNYXRoLmFicygzNjAwICogbm9ybWFsaXplZERlZ3JlZXMpO1xuICBjb25zdCBkZmxQcmVjaXNpb24gPSBvcHRfZnJhY3Rpb25EaWdpdHMgfHwgMDtcbiAgY29uc3QgcHJlY2lzaW9uID0gTWF0aC5wb3coMTAsIGRmbFByZWNpc2lvbik7XG5cbiAgbGV0IGRlZyA9IE1hdGguZmxvb3IoeCAvIDM2MDApO1xuICBsZXQgbWluID0gTWF0aC5mbG9vcigoeCAtIGRlZyAqIDM2MDApIC8gNjApO1xuICBsZXQgc2VjID0geCAtIChkZWcgKiAzNjAwKSAtIChtaW4gKiA2MCk7XG4gIHNlYyA9IE1hdGguY2VpbChzZWMgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXG4gIGlmIChzZWMgPj0gNjApIHtcbiAgICBzZWMgPSAwO1xuICAgIG1pbiArPSAxO1xuICB9XG5cbiAgaWYgKG1pbiA+PSA2MCkge1xuICAgIG1pbiA9IDA7XG4gICAgZGVnICs9IDE7XG4gIH1cblxuICByZXR1cm4gZGVnICsgJ1xcdTAwYjAgJyArIHBhZE51bWJlcihtaW4sIDIpICsgJ1xcdTIwMzIgJyArXG4gICAgcGFkTnVtYmVyKHNlYywgMiwgZGZsUHJlY2lzaW9uKSArICdcXHUyMDMzJyArXG4gICAgKG5vcm1hbGl6ZWREZWdyZWVzID09IDAgPyAnJyA6ICcgJyArIGhlbWlzcGhlcmVzLmNoYXJBdChub3JtYWxpemVkRGVncmVlcyA8IDAgPyAxIDogMCkpO1xufVxuXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGV9IHRvIGEgc3RyaW5nXG4gKiB1c2luZyB0aGUgZ2l2ZW4gc3RyaW5nIHRlbXBsYXRlLiBUaGUgc3RyaW5ncyBge3h9YCBhbmQgYHt5fWAgaW4gdGhlIHRlbXBsYXRlXG4gKiB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGZpcnN0IGFuZCBzZWNvbmQgY29vcmRpbmF0ZSB2YWx1ZXMgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgdGVtcGxhdGUgPSAnQ29vcmRpbmF0ZSBpcyAoe3h9fHt5fSkuJztcbiAqICAgICB2YXIgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoOHw0OCkuJ1xuICpcbiAqIEV4YW1wbGUgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHtmb3JtYXR9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgdGVtcGxhdGUgPSAnQ29vcmRpbmF0ZSBpcyAoe3h9fHt5fSkuJztcbiAqICAgICB2YXIgb3V0ID0gZm9ybWF0KGNvb3JkLCB0ZW1wbGF0ZSwgMik7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnQ29vcmRpbmF0ZSBpcyAoNy44NXw0Ny45OCkuJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIEEgdGVtcGxhdGUgc3RyaW5nIHdpdGggYHt4fWAgYW5kIGB7eX1gIHBsYWNlaG9sZGVyc1xuICogICAgIHRoYXQgd2lsbCBiZSByZXBsYWNlZCBieSBmaXJzdCBhbmQgc2Vjb25kIGNvb3JkaW5hdGUgdmFsdWVzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhY3Rpb25EaWdpdHMgVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBGb3JtYXR0ZWQgY29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChjb29yZGluYXRlLCB0ZW1wbGF0ZSwgb3B0X2ZyYWN0aW9uRGlnaXRzKSB7XG4gIGlmIChjb29yZGluYXRlKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlXG4gICAgICAucmVwbGFjZSgne3h9JywgY29vcmRpbmF0ZVswXS50b0ZpeGVkKG9wdF9mcmFjdGlvbkRpZ2l0cykpXG4gICAgICAucmVwbGFjZSgne3l9JywgY29vcmRpbmF0ZVsxXS50b0ZpeGVkKG9wdF9mcmFjdGlvbkRpZ2l0cykpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlMSBGaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlMiBTZWNvbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0d28gY29vcmRpbmF0ZXMgYXJlIGVxdWFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGNvb3JkaW5hdGUxLCBjb29yZGluYXRlMikge1xuICBsZXQgZXF1YWxzID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IGNvb3JkaW5hdGUxLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKGNvb3JkaW5hdGUxW2ldICE9IGNvb3JkaW5hdGUyW2ldKSB7XG4gICAgICBlcXVhbHMgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXF1YWxzO1xufVxuXG5cbi8qKlxuICogUm90YXRlIGBjb29yZGluYXRlYCBieSBgYW5nbGVgLiBgY29vcmRpbmF0ZWAgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kXG4gKiByZXR1cm5lZCBieSB0aGUgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IHtyb3RhdGV9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgcm90YXRlUmFkaWFucyA9IE1hdGguUEkgLyAyOyAvLyA5MCBkZWdyZWVzXG4gKiAgICAgcm90YXRlKGNvb3JkLCByb3RhdGVSYWRpYW5zKTtcbiAqICAgICAvLyBjb29yZCBpcyBub3cgWy00Ny45ODMzMzMsIDcuODVdXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgQW5nbGUgaW4gcmFkaWFuLlxuICogQHJldHVybiB7Q29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShjb29yZGluYXRlLCBhbmdsZSkge1xuICBjb25zdCBjb3NBbmdsZSA9IE1hdGguY29zKGFuZ2xlKTtcbiAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XG4gIGNvbnN0IHggPSBjb29yZGluYXRlWzBdICogY29zQW5nbGUgLSBjb29yZGluYXRlWzFdICogc2luQW5nbGU7XG4gIGNvbnN0IHkgPSBjb29yZGluYXRlWzFdICogY29zQW5nbGUgKyBjb29yZGluYXRlWzBdICogc2luQW5nbGU7XG4gIGNvb3JkaW5hdGVbMF0gPSB4O1xuICBjb29yZGluYXRlWzFdID0geTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBTY2FsZSBgY29vcmRpbmF0ZWAgYnkgYHNjYWxlYC4gYGNvb3JkaW5hdGVgIGlzIG1vZGlmaWVkIGluIHBsYWNlIGFuZCByZXR1cm5lZFxuICogYnkgdGhlIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIGltcG9ydCB7c2NhbGUgYXMgc2NhbGVDb29yZGluYXRlfSBmcm9tICdvbC9jb29yZGluYXRlJztcbiAqXG4gKiAgICAgdmFyIGNvb3JkID0gWzcuODUsIDQ3Ljk4MzMzM107XG4gKiAgICAgdmFyIHNjYWxlID0gMS4yO1xuICogICAgIHNjYWxlQ29vcmRpbmF0ZShjb29yZCwgc2NhbGUpO1xuICogICAgIC8vIGNvb3JkIGlzIG5vdyBbOS40MiwgNTcuNTc5OTk5Nl1cbiAqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBTY2FsZSBmYWN0b3IuXG4gKiBAcmV0dXJuIHtDb29yZGluYXRlfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUoY29vcmRpbmF0ZSwgc2NhbGUpIHtcbiAgY29vcmRpbmF0ZVswXSAqPSBzY2FsZTtcbiAgY29vcmRpbmF0ZVsxXSAqPSBzY2FsZTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMSBGaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZDIgU2Vjb25kIGNvb3JkaW5hdGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBjb29yZDEgYW5kIGNvb3JkMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShjb29yZDEsIGNvb3JkMikge1xuICBjb25zdCBkeCA9IGNvb3JkMVswXSAtIGNvb3JkMlswXTtcbiAgY29uc3QgZHkgPSBjb29yZDFbMV0gLSBjb29yZDJbMV07XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmQxIEZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge0Nvb3JkaW5hdGV9IGNvb3JkMiBTZWNvbmQgY29vcmRpbmF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiBjb29yZDEgYW5kIGNvb3JkMi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGNvb3JkMSwgY29vcmQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3F1YXJlZERpc3RhbmNlKGNvb3JkMSwgY29vcmQyKSk7XG59XG5cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHNxdWFyZWQgZGlzdGFuY2UgZnJvbSBhIGNvb3JkaW5hdGUgdG8gYSBsaW5lIHNlZ21lbnQuXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICogQHBhcmFtIHtBcnJheTxDb29yZGluYXRlPn0gc2VnbWVudCBMaW5lIHNlZ21lbnQgKDJcbiAqIGNvb3JkaW5hdGVzKS5cbiAqIEByZXR1cm4ge251bWJlcn0gU3F1YXJlZCBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbGluZSBzZWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlVG9TZWdtZW50KGNvb3JkaW5hdGUsIHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNxdWFyZWREaXN0YW5jZShjb29yZGluYXRlLFxuICAgIGNsb3Nlc3RPblNlZ21lbnQoY29vcmRpbmF0ZSwgc2VnbWVudCkpO1xufVxuXG5cbi8qKlxuICogRm9ybWF0IGEgZ2VvZ3JhcGhpYyBjb29yZGluYXRlIHdpdGggdGhlIGhlbWlzcGhlcmUsIGRlZ3JlZXMsIG1pbnV0ZXMsIGFuZFxuICogc2Vjb25kcy5cbiAqXG4gKiBFeGFtcGxlIHdpdGhvdXQgc3BlY2lmeWluZyBmcmFjdGlvbmFsIGRpZ2l0czpcbiAqXG4gKiAgICAgaW1wb3J0IHt0b1N0cmluZ0hETVN9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgb3V0ID0gdG9TdHJpbmdIRE1TKGNvb3JkKTtcbiAqICAgICAvLyBvdXQgaXMgbm93ICc0N8KwIDU44oCyIDYw4oCzIE4gN8KwIDUw4oCyIDYw4oCzIEUnXG4gKlxuICogRXhhbXBsZSBleHBsaWNpdGx5IHNwZWNpZnlpbmcgMSBmcmFjdGlvbmFsIGRpZ2l0OlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nSERNU30gZnJvbSAnb2wvY29vcmRpbmF0ZSc7XG4gKlxuICogICAgIHZhciBjb29yZCA9IFs3Ljg1LCA0Ny45ODMzMzNdO1xuICogICAgIHZhciBvdXQgPSB0b1N0cmluZ0hETVMoY29vcmQsIDEpO1xuICogICAgIC8vIG91dCBpcyBub3cgJzQ3wrAgNTjigLIgNjAuMOKAsyBOIDfCsCA1MOKAsiA2MC4w4oCzIEUnXG4gKlxuICogQHBhcmFtIHtDb29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9mcmFjdGlvbkRpZ2l0cyBUaGUgbnVtYmVyIG9mIGRpZ2l0cyB0byBpbmNsdWRlXG4gKiAgICBhZnRlciB0aGUgZGVjaW1hbCBwb2ludC4gRGVmYXVsdCBpcyBgMGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEhlbWlzcGhlcmUsIGRlZ3JlZXMsIG1pbnV0ZXMgYW5kIHNlY29uZHMuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ0hETVMoY29vcmRpbmF0ZSwgb3B0X2ZyYWN0aW9uRGlnaXRzKSB7XG4gIGlmIChjb29yZGluYXRlKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXNUb1N0cmluZ0hETVMoJ05TJywgY29vcmRpbmF0ZVsxXSwgb3B0X2ZyYWN0aW9uRGlnaXRzKSArICcgJyArXG4gICAgICAgIGRlZ3JlZXNUb1N0cmluZ0hETVMoJ0VXJywgY29vcmRpbmF0ZVswXSwgb3B0X2ZyYWN0aW9uRGlnaXRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuXG4vKipcbiAqIEZvcm1hdCBhIGNvb3JkaW5hdGUgYXMgYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGUgd2l0aG91dCBzcGVjaWZ5aW5nIGZyYWN0aW9uYWwgZGlnaXRzOlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgb3V0ID0gdG9TdHJpbmdYWShjb29yZCk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnOCwgNDgnXG4gKlxuICogRXhhbXBsZSBleHBsaWNpdGx5IHNwZWNpZnlpbmcgMSBmcmFjdGlvbmFsIGRpZ2l0OlxuICpcbiAqICAgICBpbXBvcnQge3RvU3RyaW5nWFl9IGZyb20gJ29sL2Nvb3JkaW5hdGUnO1xuICpcbiAqICAgICB2YXIgY29vcmQgPSBbNy44NSwgNDcuOTgzMzMzXTtcbiAqICAgICB2YXIgb3V0ID0gdG9TdHJpbmdYWShjb29yZCwgMSk7XG4gKiAgICAgLy8gb3V0IGlzIG5vdyAnNy44LCA0OC4wJ1xuICpcbiAqIEBwYXJhbSB7Q29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZnJhY3Rpb25EaWdpdHMgVGhlIG51bWJlciBvZiBkaWdpdHMgdG8gaW5jbHVkZVxuICogICAgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQuIERlZmF1bHQgaXMgYDBgLlxuICogQHJldHVybiB7c3RyaW5nfSBYWS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nWFkoY29vcmRpbmF0ZSwgb3B0X2ZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiBmb3JtYXQoY29vcmRpbmF0ZSwgJ3t4fSwge3l9Jywgb3B0X2ZyYWN0aW9uRGlnaXRzKTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export buffer */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return hasArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return toSize; });\n/**\n * @module ol/size\n */\n\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} The buffered size.\n */\nfunction buffer(size, num, opt_size) {\n  if (opt_size === undefined) {\n    opt_size = [0, 0];\n  }\n\n  opt_size[0] = size[0] + 2 * num;\n  opt_size[1] = size[1] + 2 * num;\n  return opt_size;\n}\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\n\nfunction hasArea(size) {\n  return size[0] > 0 && size[1] > 0;\n}\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} The scaled size.\n */\n\nfunction scale(size, ratio, opt_size) {\n  if (opt_size === undefined) {\n    opt_size = [0, 0];\n  }\n\n  opt_size[0] = size[0] * ratio + 0.5 | 0;\n  opt_size[1] = size[1] * ratio + 0.5 | 0;\n  return opt_size;\n}\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\n\nfunction toSize(size, opt_size) {\n  if (Array.isArray(size)) {\n    return size;\n  } else {\n    if (opt_size === undefined) {\n      opt_size = [size, size];\n    } else {\n      opt_size[0] = opt_size[1] =\n      /** @type {number} */\n      size;\n    }\n\n    return opt_size;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL3NpemUuanM/M2Y3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc2l6ZVxuICovXG5cblxuLyoqXG4gKiBBbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBhIHNpemU6IGBbd2lkdGgsIGhlaWdodF1gLlxuICogQHR5cGVkZWYge0FycmF5PG51bWJlcj59IFNpemVcbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlcmVkIHNpemUuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGFtb3VudCBieSB3aGljaCB0byBidWZmZXIuXG4gKiBAcGFyYW0ge1NpemU9fSBvcHRfc2l6ZSBPcHRpb25hbCByZXVzYWJsZSBzaXplIGFycmF5LlxuICogQHJldHVybiB7U2l6ZX0gVGhlIGJ1ZmZlcmVkIHNpemUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXIoc2l6ZSwgbnVtLCBvcHRfc2l6ZSkge1xuICBpZiAob3B0X3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdF9zaXplID0gWzAsIDBdO1xuICB9XG4gIG9wdF9zaXplWzBdID0gc2l6ZVswXSArIDIgKiBudW07XG4gIG9wdF9zaXplWzFdID0gc2l6ZVsxXSArIDIgKiBudW07XG4gIHJldHVybiBvcHRfc2l6ZTtcbn1cblxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKiBAcGFyYW0ge1NpemV9IHNpemUgVGhlIHNpemUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzaXplIGhhcyBhIHBvc2l0aXZlIGFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNBcmVhKHNpemUpIHtcbiAgcmV0dXJuIHNpemVbMF0gPiAwICYmIHNpemVbMV0gPiAwO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhIHNpemUgc2NhbGVkIGJ5IGEgcmF0aW8uIFRoZSByZXN1bHQgd2lsbCBiZSBhbiBhcnJheSBvZiBpbnRlZ2Vycy5cbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSBTaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFJhdGlvLlxuICogQHBhcmFtIHtTaXplPX0gb3B0X3NpemUgT3B0aW9uYWwgcmV1c2FibGUgc2l6ZSBhcnJheS5cbiAqIEByZXR1cm4ge1NpemV9IFRoZSBzY2FsZWQgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHNpemUsIHJhdGlvLCBvcHRfc2l6ZSkge1xuICBpZiAob3B0X3NpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wdF9zaXplID0gWzAsIDBdO1xuICB9XG4gIG9wdF9zaXplWzBdID0gKHNpemVbMF0gKiByYXRpbyArIDAuNSkgfCAwO1xuICBvcHRfc2l6ZVsxXSA9IChzaXplWzFdICogcmF0aW8gKyAwLjUpIHwgMDtcbiAgcmV0dXJuIG9wdF9zaXplO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhbiBgU2l6ZWAgYXJyYXkgZm9yIHRoZSBwYXNzZWQgaW4gbnVtYmVyIChtZWFuaW5nOiBzcXVhcmUpIG9yXG4gKiBgU2l6ZWAgYXJyYXkuXG4gKiAobWVhbmluZzogbm9uLXNxdWFyZSksXG4gKiBAcGFyYW0ge251bWJlcnxTaXplfSBzaXplIFdpZHRoIGFuZCBoZWlnaHQuXG4gKiBAcGFyYW0ge1NpemU9fSBvcHRfc2l6ZSBPcHRpb25hbCByZXVzYWJsZSBzaXplIGFycmF5LlxuICogQHJldHVybiB7U2l6ZX0gU2l6ZS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU2l6ZShzaXplLCBvcHRfc2l6ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzaXplKSkge1xuICAgIHJldHVybiBzaXplO1xuICB9IGVsc2Uge1xuICAgIGlmIChvcHRfc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRfc2l6ZSA9IFtzaXplLCBzaXplXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0X3NpemVbMF0gPSBvcHRfc2l6ZVsxXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRfc2l6ZTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ORDER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return TEXT_ALIGN; });\n/* harmony import */ var _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);\n/**\n * @module ol/render/replay\n */\n\n/**\n * @const\n * @type {Array<ReplayType>}\n */\n\nvar ORDER = [_ReplayType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].POLYGON, _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].CIRCLE, _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].LINE_STRING, _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].IMAGE, _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].TEXT, _ReplayType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].DEFAULT];\n/**\n * @const\n * @enum {number}\n */\n\nvar TEXT_ALIGN = {};\nTEXT_ALIGN['left'] = 0;\nTEXT_ALIGN['end'] = 0;\nTEXT_ALIGN['center'] = 0.5;\nTEXT_ALIGN['right'] = 1;\nTEXT_ALIGN['start'] = 1;\nTEXT_ALIGN['top'] = 0;\nTEXT_ALIGN['middle'] = 0.5;\nTEXT_ALIGN['hanging'] = 0.2;\nTEXT_ALIGN['alphabetic'] = 0.8;\nTEXT_ALIGN['ideographic'] = 0.8;\nTEXT_ALIGN['bottom'] = 1;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3JlbmRlci9yZXBsYXkuanM/ZDMyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL3JlcGxheVxuICovXG5pbXBvcnQgUmVwbGF5VHlwZSBmcm9tICcuL1JlcGxheVR5cGUuanMnO1xuXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7QXJyYXk8UmVwbGF5VHlwZT59XG4gKi9cbmV4cG9ydCBjb25zdCBPUkRFUiA9IFtcbiAgUmVwbGF5VHlwZS5QT0xZR09OLFxuICBSZXBsYXlUeXBlLkNJUkNMRSxcbiAgUmVwbGF5VHlwZS5MSU5FX1NUUklORyxcbiAgUmVwbGF5VHlwZS5JTUFHRSxcbiAgUmVwbGF5VHlwZS5URVhULFxuICBSZXBsYXlUeXBlLkRFRkFVTFRcbl07XG5cbi8qKlxuICogQGNvbnN0XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgVEVYVF9BTElHTiA9IHt9O1xuVEVYVF9BTElHTlsnbGVmdCddID0gMDtcblRFWFRfQUxJR05bJ2VuZCddID0gMDtcblRFWFRfQUxJR05bJ2NlbnRlciddID0gMC41O1xuVEVYVF9BTElHTlsncmlnaHQnXSA9IDE7XG5URVhUX0FMSUdOWydzdGFydCddID0gMTtcblRFWFRfQUxJR05bJ3RvcCddID0gMDtcblRFWFRfQUxJR05bJ21pZGRsZSddID0gMC41O1xuVEVYVF9BTElHTlsnaGFuZ2luZyddID0gMC4yO1xuVEVYVF9BTElHTlsnYWxwaGFiZXRpYyddID0gMC44O1xuVEVYVF9BTElHTlsnaWRlb2dyYXBoaWMnXSA9IDAuODtcblRFWFRfQUxJR05bJ2JvdHRvbSddID0gMTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBOzs7Ozs7QUFPQTs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(70);\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);\n/**\n * @module ol/events/Target\n */\n\n\n\n\n/**\n * @typedef {EventTarget|Target} EventTargetLike\n */\n\n/**\n * @classdesc\n * A simplified implementation of the W3C DOM Level 2 EventTarget interface.\n * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.\n *\n * There are two important simplifications compared to the specification:\n *\n * 1. The handling of `useCapture` in `addEventListener` and\n *    `removeEventListener`. There is no real capture model.\n * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.\n *    There is no event target hierarchy. When a listener calls\n *    `stopPropagation` or `preventDefault` on an event object, it means that no\n *    more listeners after this one will be called. Same as when the listener\n *    returns false.\n */\n\nvar Target =\n/*@__PURE__*/\nfunction (Disposable) {\n  function Target() {\n    Disposable.call(this);\n    /**\n     * @private\n     * @type {!Object<string, number>}\n     */\n\n    this.pendingRemovals_ = {};\n    /**\n     * @private\n     * @type {!Object<string, number>}\n     */\n\n    this.dispatching_ = {};\n    /**\n     * @private\n     * @type {!Object<string, Array<import("../events.js").ListenerFunction>>}\n     */\n\n    this.listeners_ = {};\n  }\n\n  if (Disposable) Target.__proto__ = Disposable;\n  Target.prototype = Object.create(Disposable && Disposable.prototype);\n  Target.prototype.constructor = Target;\n  /**\n   * @param {string} type Type.\n   * @param {import("../events.js").ListenerFunction} listener Listener.\n   */\n\n  Target.prototype.addEventListener = function addEventListener(type, listener) {\n    var listeners = this.listeners_[type];\n\n    if (!listeners) {\n      listeners = this.listeners_[type] = [];\n    }\n\n    if (listeners.indexOf(listener) === -1) {\n      listeners.push(listener);\n    }\n  };\n  /**\n   * Dispatches an event and calls all listeners listening for events\n   * of this type. The event parameter can either be a string or an\n   * Object with a `type` property.\n   *\n   * @param {{type: string,\n   *     target: (EventTargetLike|undefined),\n   *     propagationStopped: (boolean|undefined)}|\n   *     import("./Event.js").default|string} event Event object.\n   * @return {boolean|undefined} `false` if anyone called preventDefault on the\n   *     event object or if any of the listeners returned false.\n   * @api\n   */\n\n\n  Target.prototype.dispatchEvent = function dispatchEvent(event) {\n    var evt = typeof event === \'string\' ? new _Event_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](event) : event;\n    var type = evt.type;\n    evt.target = this;\n    var listeners = this.listeners_[type];\n    var propagate;\n\n    if (listeners) {\n      if (!(type in this.dispatching_)) {\n        this.dispatching_[type] = 0;\n        this.pendingRemovals_[type] = 0;\n      }\n\n      ++this.dispatching_[type];\n\n      for (var i = 0, ii = listeners.length; i < ii; ++i) {\n        if (listeners[i].call(this, evt) === false || evt.propagationStopped) {\n          propagate = false;\n          break;\n        }\n      }\n\n      --this.dispatching_[type];\n\n      if (this.dispatching_[type] === 0) {\n        var pendingRemovals = this.pendingRemovals_[type];\n        delete this.pendingRemovals_[type];\n\n        while (pendingRemovals--) {\n          this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__[/* VOID */ "c"]);\n        }\n\n        delete this.dispatching_[type];\n      }\n\n      return propagate;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Target.prototype.disposeInternal = function disposeInternal() {\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__[/* unlistenAll */ "d"])(this);\n  };\n  /**\n   * Get the listeners for a specified event type. Listeners are returned in the\n   * order that they will be called in.\n   *\n   * @param {string} type Type.\n   * @return {Array<import("../events.js").ListenerFunction>} Listeners.\n   */\n\n\n  Target.prototype.getListeners = function getListeners(type) {\n    return this.listeners_[type];\n  };\n  /**\n   * @param {string=} opt_type Type. If not provided,\n   *     `true` will be returned if this event target has any listeners.\n   * @return {boolean} Has listeners.\n   */\n\n\n  Target.prototype.hasListener = function hasListener(opt_type) {\n    return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;\n  };\n  /**\n   * @param {string} type Type.\n   * @param {import("../events.js").ListenerFunction} listener Listener.\n   */\n\n\n  Target.prototype.removeEventListener = function removeEventListener(type, listener) {\n    var listeners = this.listeners_[type];\n\n    if (listeners) {\n      var index = listeners.indexOf(listener);\n\n      if (type in this.pendingRemovals_) {\n        // make listener a no-op, and remove later in #dispatchEvent()\n        listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__[/* VOID */ "c"];\n        ++this.pendingRemovals_[type];\n      } else {\n        listeners.splice(index, 1);\n\n        if (listeners.length === 0) {\n          delete this.listeners_[type];\n        }\n      }\n    }\n  };\n\n  return Target;\n}(_Disposable_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["a"] = (Target);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2V2ZW50cy9UYXJnZXQuanM/NjBhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL1RhcmdldFxuICovXG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7dW5saXN0ZW5BbGx9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9FdmVudC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7RXZlbnRUYXJnZXR8VGFyZ2V0fSBFdmVudFRhcmdldExpa2VcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBXM0MgRE9NIExldmVsIDIgRXZlbnRUYXJnZXQgaW50ZXJmYWNlLlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1FdmVudHMtMjAwMDExMTMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0LlxuICpcbiAqIFRoZXJlIGFyZSB0d28gaW1wb3J0YW50IHNpbXBsaWZpY2F0aW9ucyBjb21wYXJlZCB0byB0aGUgc3BlY2lmaWNhdGlvbjpcbiAqXG4gKiAxLiBUaGUgaGFuZGxpbmcgb2YgYHVzZUNhcHR1cmVgIGluIGBhZGRFdmVudExpc3RlbmVyYCBhbmRcbiAqICAgIGByZW1vdmVFdmVudExpc3RlbmVyYC4gVGhlcmUgaXMgbm8gcmVhbCBjYXB0dXJlIG1vZGVsLlxuICogMi4gVGhlIGhhbmRsaW5nIG9mIGBzdG9wUHJvcGFnYXRpb25gIGFuZCBgcHJldmVudERlZmF1bHRgIG9uIGBkaXNwYXRjaEV2ZW50YC5cbiAqICAgIFRoZXJlIGlzIG5vIGV2ZW50IHRhcmdldCBoaWVyYXJjaHkuIFdoZW4gYSBsaXN0ZW5lciBjYWxsc1xuICogICAgYHN0b3BQcm9wYWdhdGlvbmAgb3IgYHByZXZlbnREZWZhdWx0YCBvbiBhbiBldmVudCBvYmplY3QsIGl0IG1lYW5zIHRoYXQgbm9cbiAqICAgIG1vcmUgbGlzdGVuZXJzIGFmdGVyIHRoaXMgb25lIHdpbGwgYmUgY2FsbGVkLiBTYW1lIGFzIHdoZW4gdGhlIGxpc3RlbmVyXG4gKiAgICByZXR1cm5zIGZhbHNlLlxuICovXG5jbGFzcyBUYXJnZXQgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nUmVtb3ZhbHNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmRpc3BhdGNoaW5nXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEFycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lckZ1bmN0aW9uPj59XG4gICAgICovXG4gICAgdGhpcy5saXN0ZW5lcnNfID0ge307XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5MaXN0ZW5lckZ1bmN0aW9ufSBsaXN0ZW5lciBMaXN0ZW5lci5cbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc19bdHlwZV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgY2FsbHMgYWxsIGxpc3RlbmVycyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgKiBvZiB0aGlzIHR5cGUuIFRoZSBldmVudCBwYXJhbWV0ZXIgY2FuIGVpdGhlciBiZSBhIHN0cmluZyBvciBhblxuICAgKiBPYmplY3Qgd2l0aCBhIGB0eXBlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHt7dHlwZTogc3RyaW5nLFxuICAgKiAgICAgdGFyZ2V0OiAoRXZlbnRUYXJnZXRMaWtlfHVuZGVmaW5lZCksXG4gICAqICAgICBwcm9wYWdhdGlvblN0b3BwZWQ6IChib29sZWFufHVuZGVmaW5lZCl9fFxuICAgKiAgICAgaW1wb3J0KFwiLi9FdmVudC5qc1wiKS5kZWZhdWx0fHN0cmluZ30gZXZlbnQgRXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gYGZhbHNlYCBpZiBhbnlvbmUgY2FsbGVkIHByZXZlbnREZWZhdWx0IG9uIHRoZVxuICAgKiAgICAgZXZlbnQgb2JqZWN0IG9yIGlmIGFueSBvZiB0aGUgbGlzdGVuZXJzIHJldHVybmVkIGZhbHNlLlxuICAgKiBAYXBpXG4gICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZXZ0ID0gdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJyA/IG5ldyBFdmVudChldmVudCkgOiBldmVudDtcbiAgICBjb25zdCB0eXBlID0gZXZ0LnR5cGU7XG4gICAgZXZ0LnRhcmdldCA9IHRoaXM7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGxldCBwcm9wYWdhdGU7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgaWYgKCEodHlwZSBpbiB0aGlzLmRpc3BhdGNoaW5nXykpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGluZ19bdHlwZV0gPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZW1vdmFsc19bdHlwZV0gPSAwO1xuICAgICAgfVxuICAgICAgKyt0aGlzLmRpc3BhdGNoaW5nX1t0eXBlXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBldnQpID09PSBmYWxzZSB8fCBldnQucHJvcGFnYXRpb25TdG9wcGVkKSB7XG4gICAgICAgICAgcHJvcGFnYXRlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC0tdGhpcy5kaXNwYXRjaGluZ19bdHlwZV07XG4gICAgICBpZiAodGhpcy5kaXNwYXRjaGluZ19bdHlwZV0gPT09IDApIHtcbiAgICAgICAgbGV0IHBlbmRpbmdSZW1vdmFscyA9IHRoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgICAgd2hpbGUgKHBlbmRpbmdSZW1vdmFscy0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIFZPSUQpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRpc3BhdGNoaW5nX1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wYWdhdGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdW5saXN0ZW5BbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuIExpc3RlbmVycyBhcmUgcmV0dXJuZWQgaW4gdGhlXG4gICAqIG9yZGVyIHRoYXQgdGhleSB3aWxsIGJlIGNhbGxlZCBpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkxpc3RlbmVyRnVuY3Rpb24+fSBMaXN0ZW5lcnMuXG4gICAqL1xuICBnZXRMaXN0ZW5lcnModHlwZSkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdHlwZSBUeXBlLiBJZiBub3QgcHJvdmlkZWQsXG4gICAqICAgICBgdHJ1ZWAgd2lsbCBiZSByZXR1cm5lZCBpZiB0aGlzIGV2ZW50IHRhcmdldCBoYXMgYW55IGxpc3RlbmVycy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIGxpc3RlbmVycy5cbiAgICovXG4gIGhhc0xpc3RlbmVyKG9wdF90eXBlKSB7XG4gICAgcmV0dXJuIG9wdF90eXBlID9cbiAgICAgIG9wdF90eXBlIGluIHRoaXMubGlzdGVuZXJzXyA6XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmxpc3RlbmVyc18pLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuTGlzdGVuZXJGdW5jdGlvbn0gbGlzdGVuZXIgTGlzdGVuZXIuXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNfW3R5cGVdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKHR5cGUgaW4gdGhpcy5wZW5kaW5nUmVtb3ZhbHNfKSB7XG4gICAgICAgIC8vIG1ha2UgbGlzdGVuZXIgYSBuby1vcCwgYW5kIHJlbW92ZSBsYXRlciBpbiAjZGlzcGF0Y2hFdmVudCgpXG4gICAgICAgIGxpc3RlbmVyc1tpbmRleF0gPSBWT0lEO1xuICAgICAgICArK3RoaXMucGVuZGluZ1JlbW92YWxzX1t0eXBlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc19bdHlwZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBUYXJnZXQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBR0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBcElBO0FBQ0E7QUFzSUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/source/State\n */\n\n/**\n * @enum {string}\n * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  UNDEFINED: 'undefined',\n  LOADING: 'loading',\n  READY: 'ready',\n  ERROR: 'error'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3NvdXJjZS9TdGF0ZS5qcz8zOGEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvU3RhdGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBTdGF0ZSBvZiB0aGUgc291cmNlLCBvbmUgb2YgJ3VuZGVmaW5lZCcsICdsb2FkaW5nJywgJ3JlYWR5JyBvciAnZXJyb3InLlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFVOREVGSU5FRDogJ3VuZGVmaW5lZCcsXG4gIExPQURJTkc6ICdsb2FkaW5nJyxcbiAgUkVBRFk6ICdyZWFkeScsXG4gIEVSUk9SOiAnZXJyb3InXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export simplifyLineString */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return douglasPeucker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return douglasPeuckerArray; });\n/* unused harmony export douglasPeuckerMultiArray */\n/* unused harmony export radialDistance */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return snap; });\n/* unused harmony export quantize */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return quantizeArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return quantizeMultiArray; });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\n\nfunction simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];\n\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n\n  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nfunction douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n\n\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n\n  var stack = [offset, end - stride];\n  var index = 0;\n\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n\n    for (var i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredSegmentDistance */ "g"])(x, y, x1, y1, x2, y2);\n\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n\n  for (var i$1 = 0; i$1 < n; ++i$1) {\n    if (markers[i$1]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i$1 * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i$1 * stride + 1];\n    }\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\nfunction douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\nfunction douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nfunction radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n\n    return simplifiedOffset;\n  }\n\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1]; // copy first point\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n\n    if (Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* squaredDistance */ "f"])(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\n\nfunction snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\n\nfunction quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  } // snap the first coordinate (P1)\n\n\n  var x1 = snap(flatCoordinates[offset], tolerance);\n  var y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride; // add the first coordinate to the output\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n\n  var x2, y2;\n\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    var x3 = snap(flatCoordinates[offset], tolerance);\n    var y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride; // skip P3 if it is equal to P2\n\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    } // calculate the delta between P1 and P2\n\n\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1; // calculate the delta between P3 and P1\n\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n\n    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n\n\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  } // add the last point (P2)\n\n\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\n\nfunction quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n\n  return simplifiedOffset;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\n\nfunction quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n\n  return simplifiedOffset;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9zaW1wbGlmeS5qcz9kMzI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc2ltcGxpZnlcbiAqL1xuLy8gQmFzZWQgb24gc2ltcGxpZnktanMgaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvc2ltcGxpZnktanNcbi8vIENvcHlyaWdodCAoYykgMjAxMiwgVmxhZGltaXIgQWdhZm9ua2luXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4vL1xuLy8gICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuLy8gICAgICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vXG4vLyAgICAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuLy8gICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuLy8gQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuLy8gSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0Vcbi8vIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbi8vIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1Jcbi8vIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4vLyBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1Ncbi8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4vLyBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuLy8gQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbi8vIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQge3NxdWFyZWRTZWdtZW50RGlzdGFuY2UsIHNxdWFyZWREaXN0YW5jZX0gZnJvbSAnLi4vLi4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhpZ2hRdWFsaXR5IEhpZ2hlc3QgcXVhbGl0eS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9zaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gU2ltcGxpZmllZCBsaW5lIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5TGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLFxuICBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsIGhpZ2hRdWFsaXR5LCBvcHRfc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcykge1xuICBjb25zdCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gb3B0X3NpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X3NpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgOiBbXTtcbiAgaWYgKCFoaWdoUXVhbGl0eSkge1xuICAgIGVuZCA9IHJhZGlhbERpc3RhbmNlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsXG4gICAgICBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXMgPSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzO1xuICAgIG9mZnNldCA9IDA7XG4gICAgc3RyaWRlID0gMjtcbiAgfVxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyKFxuICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwKTtcbiAgcmV0dXJuIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXM7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3VnbGFzUGV1Y2tlcihmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLFxuICBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQpIHtcbiAgY29uc3QgbiA9IChlbmQgLSBvZmZzZXQpIC8gc3RyaWRlO1xuICBpZiAobiA8IDMpIHtcbiAgICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID1cbiAgICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xuICB9XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgbWFya2VycyA9IG5ldyBBcnJheShuKTtcbiAgbWFya2Vyc1swXSA9IDE7XG4gIG1hcmtlcnNbbiAtIDFdID0gMTtcbiAgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqL1xuICBjb25zdCBzdGFjayA9IFtvZmZzZXQsIGVuZCAtIHN0cmlkZV07XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGFzdCA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGZpcnN0ID0gc3RhY2sucG9wKCk7XG4gICAgbGV0IG1heFNxdWFyZWREaXN0YW5jZSA9IDA7XG4gICAgY29uc3QgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZmlyc3RdO1xuICAgIGNvbnN0IHkxID0gZmxhdENvb3JkaW5hdGVzW2ZpcnN0ICsgMV07XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbbGFzdF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbbGFzdCArIDFdO1xuICAgIGZvciAobGV0IGkgPSBmaXJzdCArIHN0cmlkZTsgaSA8IGxhc3Q7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCB4ID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgY29uc3QgeSA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkU2VnbWVudERpc3RhbmNlKFxuICAgICAgICB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlID4gbWF4U3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgbWF4U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF4U3F1YXJlZERpc3RhbmNlID4gc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgICAgbWFya2Vyc1soaW5kZXggLSBvZmZzZXQpIC8gc3RyaWRlXSA9IDE7XG4gICAgICBpZiAoZmlyc3QgKyBzdHJpZGUgPCBpbmRleCkge1xuICAgICAgICBzdGFjay5wdXNoKGZpcnN0LCBpbmRleCk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggKyBzdHJpZGUgPCBsYXN0KSB7XG4gICAgICAgIHN0YWNrLnB1c2goaW5kZXgsIGxhc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChtYXJrZXJzW2ldKSB7XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpICogc3RyaWRlXTtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGkgKiBzdHJpZGUgKyAxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNxdWFyZWRUb2xlcmFuY2UgU3F1YXJlZCB0b2xlcmFuY2UuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgU2ltcGxpZmllZCBmbGF0XG4gKiAgICAgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc2ltcGxpZmllZE9mZnNldCBTaW1wbGlmaWVkIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEVuZHMgU2ltcGxpZmllZCBlbmRzLlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvdWdsYXNQZXVja2VyQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsXG4gIGVuZHMsIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyxcbiAgc2ltcGxpZmllZE9mZnNldCwgc2ltcGxpZmllZEVuZHMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gZG91Z2xhc1BldWNrZXIoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0KTtcbiAgICBzaW1wbGlmaWVkRW5kcy5wdXNoKHNpbXBsaWZpZWRPZmZzZXQpO1xuICAgIG9mZnNldCA9IGVuZDtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gc2ltcGxpZmllZEVuZHNzIFNpbXBsaWZpZWQgZW5kc3MuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG91Z2xhc1BldWNrZXJNdWx0aUFycmF5KFxuICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSxcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCwgc2ltcGxpZmllZEVuZHNzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmRzID0gZW5kc3NbaV07XG4gICAgY29uc3Qgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkT2Zmc2V0ID0gZG91Z2xhc1BldWNrZXJBcnJheShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUsIHNxdWFyZWRUb2xlcmFuY2UsXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kcyk7XG4gICAgc2ltcGxpZmllZEVuZHNzLnB1c2goc2ltcGxpZmllZEVuZHMpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbERpc3RhbmNlKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsXG4gIHN0cmlkZSwgc3F1YXJlZFRvbGVyYW5jZSwgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCkge1xuICBpZiAoZW5kIDw9IG9mZnNldCArIHN0cmlkZSkge1xuICAgIC8vIHplcm8gb3Igb25lIHBvaW50LCBubyBzaW1wbGlmaWNhdGlvbiBwb3NzaWJsZSwgc28gY29weSBhbmQgcmV0dXJuXG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPVxuICAgICAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gIH1cbiAgbGV0IHgxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gIGxldCB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgLy8gY29weSBmaXJzdCBwb2ludFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MTtcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTE7XG4gIGxldCB4MiA9IHgxO1xuICBsZXQgeTIgPSB5MTtcbiAgZm9yIChvZmZzZXQgKz0gc3RyaWRlOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIGlmIChzcXVhcmVkRGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpID4gc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgICAgLy8gY29weSBwb2ludCBhdCBvZmZzZXRcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9XG4gIH1cbiAgaWYgKHgyICE9IHgxIHx8IHkyICE9IHkxKSB7XG4gICAgLy8gY29weSBsYXN0IHBvaW50XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geTI7XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEByZXR1cm4ge251bWJlcn0gUm91bmRlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuYXAodmFsdWUsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gdG9sZXJhbmNlICogTWF0aC5yb3VuZCh2YWx1ZSAvIHRvbGVyYW5jZSk7XG59XG5cblxuLyoqXG4gKiBTaW1wbGlmaWVzIGEgbGluZSBzdHJpbmcgdXNpbmcgYW4gYWxnb3JpdGhtIGRlc2lnbmVkIGJ5IFRpbSBTY2hhdWIuXG4gKiBDb29yZGluYXRlcyBhcmUgc25hcHBlZCB0byB0aGUgbmVhcmVzdCB2YWx1ZSBpbiBhIHZpcnR1YWwgZ3JpZCBhbmRcbiAqIGNvbnNlY3V0aXZlIGR1cGxpY2F0ZSBjb29yZGluYXRlcyBhcmUgZGlzY2FyZGVkLiAgVGhpcyBlZmZlY3RpdmVseSBwcmVzZXJ2ZXNcbiAqIHRvcG9sb2d5IGFzIHRoZSBzaW1wbGlmaWNhdGlvbiBvZiBhbnkgc3Vic2VjdGlvbiBvZiBhIGxpbmUgc3RyaW5nIGlzXG4gKiBpbmRlcGVuZGVudCBvZiB0aGUgcmVzdCBvZiB0aGUgbGluZSBzdHJpbmcuICBUaGlzIG1lYW5zIHRoYXQsIGZvciBleGFtcGxlcyxcbiAqIHRoZSBjb21tb24gZWRnZSBiZXR3ZWVuIHR3byBwb2x5Z29ucyB3aWxsIGJlIHNpbXBsaWZpZWQgdG8gdGhlIHNhbWUgbGluZVxuICogc3RyaW5nIGluZGVwZW5kZW50bHkgaW4gYm90aCBwb2x5Z29ucy4gIFRoaXMgaW1wbGVtZW50YXRpb24gdXNlcyBhIHNpbmdsZVxuICogcGFzcyBvdmVyIHRoZSBjb29yZGluYXRlcyBhbmQgZWxpbWluYXRlcyBpbnRlcm1lZGlhdGUgY29sbGluZWFyIHBvaW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybiB7bnVtYmVyfSBTaW1wbGlmaWVkIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1YW50aXplKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSxcbiAgdG9sZXJhbmNlLCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0KSB7XG4gIC8vIGRvIG5vdGhpbmcgaWYgdGhlIGxpbmUgaXMgZW1wdHlcbiAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbiAgfVxuICAvLyBzbmFwIHRoZSBmaXJzdCBjb29yZGluYXRlIChQMSlcbiAgbGV0IHgxID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgbGV0IHkxID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0sIHRvbGVyYW5jZSk7XG4gIG9mZnNldCArPSBzdHJpZGU7XG4gIC8vIGFkZCB0aGUgZmlyc3QgY29vcmRpbmF0ZSB0byB0aGUgb3V0cHV0XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgxO1xuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB5MTtcbiAgLy8gZmluZCB0aGUgbmV4dCBjb29yZGluYXRlIHRoYXQgZG9lcyBub3Qgc25hcCB0byB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgZmlyc3RcbiAgLy8gY29vcmRpbmF0ZSAoUDIpXG4gIGxldCB4MiwgeTI7XG4gIGRvIHtcbiAgICB4MiA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldF0sIHRvbGVyYW5jZSk7XG4gICAgeTIgPSBzbmFwKGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXSwgdG9sZXJhbmNlKTtcbiAgICBvZmZzZXQgKz0gc3RyaWRlO1xuICAgIGlmIChvZmZzZXQgPT0gZW5kKSB7XG4gICAgICAvLyBhbGwgY29vcmRpbmF0ZXMgc25hcCB0byB0aGUgc2FtZSB2YWx1ZSwgdGhlIGxpbmUgY29sbGFwc2VzIHRvIGEgcG9pbnRcbiAgICAgIC8vIHB1c2ggdGhlIGxhc3Qgc25hcHBlZCB2YWx1ZSBhbnl3YXkgdG8gZW5zdXJlIHRoYXQgdGhlIG91dHB1dCBjb250YWluc1xuICAgICAgLy8gYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgICAgLy8gRklYTUUgc2hvdWxkIHdlIHJlYWxseSByZXR1cm4gYXQgbGVhc3QgdHdvIHBvaW50cyBhbnl3YXk/XG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzW3NpbXBsaWZpZWRPZmZzZXQrK10gPSB4MjtcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgICAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG4gICAgfVxuICB9IHdoaWxlICh4MiA9PSB4MSAmJiB5MiA9PSB5MSk7XG4gIHdoaWxlIChvZmZzZXQgPCBlbmQpIHtcbiAgICAvLyBzbmFwIHRoZSBuZXh0IGNvb3JkaW5hdGUgKFAzKVxuICAgIGNvbnN0IHgzID0gc25hcChmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgdG9sZXJhbmNlKTtcbiAgICBjb25zdCB5MyA9IHNuYXAoZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdLCB0b2xlcmFuY2UpO1xuICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgLy8gc2tpcCBQMyBpZiBpdCBpcyBlcXVhbCB0byBQMlxuICAgIGlmICh4MyA9PSB4MiAmJiB5MyA9PSB5Mikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiBQMSBhbmQgUDJcbiAgICBjb25zdCBkeDEgPSB4MiAtIHgxO1xuICAgIGNvbnN0IGR5MSA9IHkyIC0geTE7XG4gICAgLy8gY2FsY3VsYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIFAzIGFuZCBQMVxuICAgIGNvbnN0IGR4MiA9IHgzIC0geDE7XG4gICAgY29uc3QgZHkyID0geTMgLSB5MTtcbiAgICAvLyBpZiBQMSwgUDIsIGFuZCBQMyBhcmUgY29saW5lYXIgYW5kIFAzIGlzIGZ1cnRoZXIgZnJvbSBQMSB0aGFuIFAyIGlzIGZyb21cbiAgICAvLyBQMSBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gdGhlbiBQMiBpcyBvbiB0aGUgc3RyYWlnaHQgbGluZSBiZXR3ZWVuIFAxIGFuZFxuICAgIC8vIFAzXG4gICAgaWYgKChkeDEgKiBkeTIgPT0gZHkxICogZHgyKSAmJlxuICAgICAgICAoKGR4MSA8IDAgJiYgZHgyIDwgZHgxKSB8fCBkeDEgPT0gZHgyIHx8IChkeDEgPiAwICYmIGR4MiA+IGR4MSkpICYmXG4gICAgICAgICgoZHkxIDwgMCAmJiBkeTIgPCBkeTEpIHx8IGR5MSA9PSBkeTIgfHwgKGR5MSA+IDAgJiYgZHkyID4gZHkxKSkpIHtcbiAgICAgIC8vIGRpc2NhcmQgUDIgYW5kIHNldCBQMiA9IFAzXG4gICAgICB4MiA9IHgzO1xuICAgICAgeTIgPSB5MztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBlaXRoZXIgUDEsIFAyLCBhbmQgUDMgYXJlIG5vdCBjb2xpbmVhciwgb3IgdGhleSBhcmUgY29saW5lYXIgYnV0IFAzIGlzXG4gICAgLy8gYmV0d2VlbiBQMyBhbmQgUDEgb3Igb24gdGhlIG9wcG9zaXRlIGhhbGYgb2YgdGhlIGxpbmUgdG8gUDIuICBhZGQgUDIsXG4gICAgLy8gYW5kIGNvbnRpbnVlIHdpdGggUDEgPSBQMiBhbmQgUDIgPSBQM1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHgyO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgICB4MiA9IHgzO1xuICAgIHkyID0geTM7XG4gIH1cbiAgLy8gYWRkIHRoZSBsYXN0IHBvaW50IChQMilcbiAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlc1tzaW1wbGlmaWVkT2Zmc2V0KytdID0geDI7XG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXNbc2ltcGxpZmllZE9mZnNldCsrXSA9IHkyO1xuICByZXR1cm4gc2ltcGxpZmllZE9mZnNldDtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyBTaW1wbGlmaWVkIGZsYXRcbiAqICAgICBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaW1wbGlmaWVkT2Zmc2V0IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRW5kcyBTaW1wbGlmaWVkIGVuZHMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFNpbXBsaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVhbnRpemVBcnJheShcbiAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSxcbiAgdG9sZXJhbmNlLFxuICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBzaW1wbGlmaWVkT2Zmc2V0LCBzaW1wbGlmaWVkRW5kcykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIHNpbXBsaWZpZWRPZmZzZXQgPSBxdWFudGl6ZShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSxcbiAgICAgIHRvbGVyYW5jZSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQpO1xuICAgIHNpbXBsaWZpZWRFbmRzLnB1c2goc2ltcGxpZmllZE9mZnNldCk7XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBzaW1wbGlmaWVkT2Zmc2V0O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzIFNpbXBsaWZpZWQgZmxhdFxuICogICAgIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpbXBsaWZpZWRPZmZzZXQgU2ltcGxpZmllZCBvZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBzaW1wbGlmaWVkRW5kc3MgU2ltcGxpZmllZCBlbmRzcy5cbiAqIEByZXR1cm4ge251bWJlcn0gU2ltcGxpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGl6ZU11bHRpQXJyYXkoXG4gIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLFxuICB0b2xlcmFuY2UsXG4gIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIHNpbXBsaWZpZWRPZmZzZXQsIHNpbXBsaWZpZWRFbmRzcykge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZE9mZnNldCA9IHF1YW50aXplQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLFxuICAgICAgdG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgc2ltcGxpZmllZE9mZnNldCwgc2ltcGxpZmllZEVuZHMpO1xuICAgIHNpbXBsaWZpZWRFbmRzcy5wdXNoKHNpbXBsaWZpZWRFbmRzKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIHNpbXBsaWZpZWRPZmZzZXQ7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBY0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(13);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryLayout.js\nvar GeometryLayout = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js\nvar GeometryType = __webpack_require__(3);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/SimpleGeometry.js\nvar geom_SimpleGeometry = __webpack_require__(31);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/area.js\nvar flat_area = __webpack_require__(75);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/closest.js\nvar closest = __webpack_require__(35);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/deflate.js\nvar deflate = __webpack_require__(36);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js\nvar inflate = __webpack_require__(32);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js\nvar simplify = __webpack_require__(46);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/LinearRing.js\n/**\n * @module ol/geom/LinearRing\n */\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\n\nvar LinearRing_LinearRing =\n/*@__PURE__*/\nfunction (SimpleGeometry) {\n  function LinearRing(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout,\n      /** @type {Array<number>} */\n      coordinates);\n    } else {\n      this.setCoordinates(\n      /** @type {Array<import("../coordinate.js").Coordinate>} */\n      coordinates, opt_layout);\n    }\n  }\n\n  if (SimpleGeometry) LinearRing.__proto__ = SimpleGeometry;\n  LinearRing.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  LinearRing.prototype.constructor = LinearRing;\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LinearRing} Clone.\n   * @override\n   * @api\n   */\n\n  LinearRing.prototype.clone = function clone() {\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LinearRing.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < Object(ol_extent["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(Object(closest["e" /* maxSquaredDelta */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return Object(closest["d" /* assignClosestPoint */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * Return the area of the linear ring on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n\n\n  LinearRing.prototype.getArea = function getArea() {\n    return Object(flat_area["a" /* linearRing */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  /**\n   * Return the coordinates of the linear ring.\n   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  LinearRing.prototype.getCoordinates = function getCoordinates() {\n    return Object(inflate["a" /* inflateCoordinates */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LinearRing.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = Object(simplify["a" /* douglasPeucker */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LinearRing(simplifiedFlatCoordinates, GeometryLayout["a" /* default */].XY);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  LinearRing.prototype.getType = function getType() {\n    return GeometryType["a" /* default */].LINEAR_RING;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LinearRing.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return false;\n  };\n  /**\n   * Set the coordinates of the linear ring.\n   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n\n\n  LinearRing.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    this.flatCoordinates.length = Object(deflate["b" /* deflateCoordinates */])(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return LinearRing;\n}(geom_SimpleGeometry["a" /* default */]);\n\n/* harmony default export */ var geom_LinearRing = (LinearRing_LinearRing);\n// EXTERNAL MODULE: ./node_modules/ol/geom/Point.js\nvar Point = __webpack_require__(52);\n\n// EXTERNAL MODULE: ./node_modules/ol/sphere.js\nvar sphere = __webpack_require__(79);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/contains.js\nvar contains = __webpack_require__(48);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/interiorpoint.js\nvar interiorpoint = __webpack_require__(97);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/intersectsextent.js\nvar intersectsextent = __webpack_require__(61);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/orient.js + 1 modules\nvar orient = __webpack_require__(63);\n\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/Polygon.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return circular; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return fromExtent; });\n/* unused harmony export fromCircle */\n/* unused harmony export makeRegular */\n/**\n * @module ol/geom/Polygon\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\n\nvar Polygon_Polygon =\n/*@__PURE__*/\nfunction (SimpleGeometry) {\n  function Polygon(coordinates, opt_layout, opt_ends) {\n    SimpleGeometry.call(this);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    this.ends_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.flatInteriorPointRevision_ = -1;\n    /**\n     * @private\n     * @type {import("../coordinate.js").Coordinate}\n     */\n\n    this.flatInteriorPoint_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDeltaRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.orientedRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.orientedFlatCoordinates_ = null;\n\n    if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout,\n      /** @type {Array<number>} */\n      coordinates);\n      this.ends_ = opt_ends;\n    } else {\n      this.setCoordinates(\n      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */\n      coordinates, opt_layout);\n    }\n  }\n\n  if (SimpleGeometry) Polygon.__proto__ = SimpleGeometry;\n  Polygon.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  Polygon.prototype.constructor = Polygon;\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n\n  Polygon.prototype.appendLinearRing = function appendLinearRing(linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      Object(array["c" /* extend */])(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @override\n   * @api\n   */\n\n\n  Polygon.prototype.clone = function clone() {\n    return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polygon.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < Object(ol_extent["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(Object(closest["a" /* arrayMaxSquaredDelta */])(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return Object(closest["b" /* assignClosestArrayPoint */])(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polygon.prototype.containsXY = function containsXY(x, y) {\n    return Object(contains["c" /* linearRingsContainsXY */])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n  };\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n\n\n  Polygon.prototype.getArea = function getArea() {\n    return Object(flat_area["b" /* linearRings */])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n  };\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  Polygon.prototype.getCoordinates = function getCoordinates(opt_right) {\n    var flatCoordinates;\n\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      Object(orient["c" /* orientLinearRings */])(flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return Object(inflate["b" /* inflateCoordinatesArray */])(flatCoordinates, 0, this.ends_, this.stride);\n  };\n  /**\n   * @return {Array<number>} Ends.\n   */\n\n\n  Polygon.prototype.getEnds = function getEnds() {\n    return this.ends_;\n  };\n  /**\n   * @return {Array<number>} Interior point.\n   */\n\n\n  Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      var flatCenter = Object(ol_extent["getCenter"])(this.getExtent());\n      this.flatInteriorPoint_ = Object(interiorpoint["a" /* getInteriorPointOfArray */])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n\n    return this.flatInteriorPoint_;\n  };\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n\n\n  Polygon.prototype.getInteriorPoint = function getInteriorPoint() {\n    return new Point["default"](this.getFlatInteriorPoint(), GeometryLayout["a" /* default */].XYM);\n  };\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRingCount = function getLinearRingCount() {\n    return this.ends_.length;\n  };\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing} Linear ring.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRing = function getLinearRing(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n\n    return new geom_LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n\n\n  Polygon.prototype.getLinearRings = function getLinearRings() {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var linearRings = [];\n    var offset = 0;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var linearRing = new geom_LinearRing(flatCoordinates.slice(offset, end), layout);\n      linearRings.push(linearRing);\n      offset = end;\n    }\n\n    return linearRings;\n  };\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n\n\n  Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n\n      if (Object(orient["a" /* linearRingIsOriented */])(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = Object(orient["c" /* orientLinearRings */])(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n      }\n\n      this.orientedRevision_ = this.getRevision();\n    }\n\n    return this.orientedFlatCoordinates_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = Object(simplify["c" /* quantizeArray */])(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new Polygon(simplifiedFlatCoordinates, GeometryLayout["a" /* default */].XY, simplifiedEnds);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Polygon.prototype.getType = function getType() {\n    return GeometryType["a" /* default */].POLYGON;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Polygon.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return Object(intersectsextent["c" /* intersectsLinearRingArray */])(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n\n\n  Polygon.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    var ends = Object(deflate["c" /* deflateCoordinatesArray */])(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return Polygon;\n}(geom_SimpleGeometry["a" /* default */]);\n\n/* harmony default export */ var geom_Polygon = __webpack_exports__["b"] = (Polygon_Polygon);\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices.\n * @param {number=} opt_n Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to\n *     the Earth\'s mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The "circular" polygon.\n * @api\n */\n\nfunction circular(center, radius, opt_n, opt_sphereRadius) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array<number>} */\n\n  var flatCoordinates = [];\n\n  for (var i = 0; i < n; ++i) {\n    Object(array["c" /* extend */])(flatCoordinates, Object(sphere["b" /* offset */])(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));\n  }\n\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon_Polygon(flatCoordinates, GeometryLayout["a" /* default */].XY, [flatCoordinates.length]);\n}\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import("../extent.js").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\n\nfunction fromExtent(extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  return new Polygon_Polygon(flatCoordinates, GeometryLayout["a" /* default */].XY, [flatCoordinates.length]);\n}\n/**\n * Create a regular polygon from a circle.\n * @param {import("./Circle.js").default} circle Circle geometry.\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\n\nfunction fromCircle(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var center = circle.getCenter();\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n\n  for (var i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n\n    for (var j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n\n  var ends = [flatCoordinates.length];\n  var polygon = new Polygon_Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), opt_angle);\n  return polygon;\n}\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n */\n\nfunction makeRegular(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var stride = polygon.getStride();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n\n  for (var i = 0; i <= sides; ++i) {\n    var offset = i * stride;\n    var angle = startAngle + Object(math["d" /* modulo */])(i, sides) * 2 * Math.PI / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n\n  polygon.changed();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2dlb20vTGluZWFyUmluZy5qcz8wNWQ3Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvZ2VvbS9Qb2x5Z29uLmpzP2QxNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTGluZWFyUmluZ1xuICovXG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeUxheW91dCBmcm9tICcuL0dlb21ldHJ5TGF5b3V0LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nIGFzIGxpbmVhclJpbmdBcmVhfSBmcm9tICcuL2ZsYXQvYXJlYS5qcyc7XG5pbXBvcnQge2Fzc2lnbkNsb3Nlc3RQb2ludCwgbWF4U3F1YXJlZERlbHRhfSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXN9IGZyb20gJy4vZmxhdC9pbmZsYXRlLmpzJztcbmltcG9ydCB7ZG91Z2xhc1BldWNrZXJ9IGZyb20gJy4vZmxhdC9zaW1wbGlmeS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGluZWFyIHJpbmcgZ2VvbWV0cnkuIE9ubHkgdXNlZCBhcyBwYXJ0IG9mIHBvbHlnb247IGNhbm5vdCBiZSByZW5kZXJlZFxuICogb24gaXRzIG93bi5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIExpbmVhclJpbmcgZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogICAgIEZvciBpbnRlcm5hbCB1c2UsIGZsYXQgY29vcmRpbmF0ZXMgaW4gY29tYmluYXRpb24gd2l0aCBgb3B0X2xheW91dGAgYXJlIGFsc28gYWNjZXB0ZWQuXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKG9wdF9sYXlvdXQsIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGNvb3JkaW5hdGVzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqLyAoY29vcmRpbmF0ZXMpLCBvcHRfbGF5b3V0KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEByZXR1cm4geyFMaW5lYXJSaW5nfSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgaWYgKG1pblNxdWFyZWREaXN0YW5jZSA8IGNsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWSh0aGlzLmdldEV4dGVudCgpLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLm1heERlbHRhXyA9IE1hdGguc3FydChtYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCAwKSk7XG4gICAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzaWduQ2xvc2VzdFBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsXG4gICAgICB0aGlzLm1heERlbHRhXywgdHJ1ZSwgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYXJlYSBvZiB0aGUgbGluZWFyIHJpbmcgb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFyZWEoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdBcmVhKHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lYXIgcmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZG91Z2xhc1BldWNrZXIoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSxcbiAgICAgIHNxdWFyZWRUb2xlcmFuY2UsIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDApO1xuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyhzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLkxJTkVBUl9SSU5HO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lYXIgcmluZy5cbiAgICogQHBhcmFtIHshQXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQob3B0X2xheW91dCwgY29vcmRpbmF0ZXMsIDEpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRlZmxhdGVDb29yZGluYXRlcyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTGluZWFyUmluZztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL1BvbHlnb25cbiAqL1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZLCBnZXRDZW50ZXJ9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBMaW5lYXJSaW5nIGZyb20gJy4vTGluZWFyUmluZy5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge29mZnNldCBhcyBzcGhlcmVPZmZzZXR9IGZyb20gJy4uL3NwaGVyZS5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzIGFzIGxpbmVhclJpbmdzQXJlYX0gZnJvbSAnLi9mbGF0L2FyZWEuanMnO1xuaW1wb3J0IHthc3NpZ25DbG9zZXN0QXJyYXlQb2ludCwgYXJyYXlNYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7bGluZWFyUmluZ3NDb250YWluc1hZfSBmcm9tICcuL2ZsYXQvY29udGFpbnMuanMnO1xuaW1wb3J0IHtkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXNBcnJheX0gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtnZXRJbnRlcmlvclBvaW50T2ZBcnJheX0gZnJvbSAnLi9mbGF0L2ludGVyaW9ycG9pbnQuanMnO1xuaW1wb3J0IHtpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5fSBmcm9tICcuL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdJc09yaWVudGVkLCBvcmllbnRMaW5lYXJSaW5nc30gZnJvbSAnLi9mbGF0L29yaWVudC5qcyc7XG5pbXBvcnQge3F1YW50aXplQXJyYXl9IGZyb20gJy4vZmxhdC9zaW1wbGlmeS5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUG9seWdvbiBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBvbHlnb24gZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fCFBcnJheTxudW1iZXI+fSBjb29yZGluYXRlc1xuICAgKiAgICAgQXJyYXkgb2YgbGluZWFyIHJpbmdzIHRoYXQgZGVmaW5lIHRoZSBwb2x5Z29uLiBUaGUgZmlyc3QgbGluZWFyIHJpbmcgb2YgdGhlXG4gICAqICAgICBhcnJheSBkZWZpbmVzIHRoZSBvdXRlci1ib3VuZGFyeSBvciBzdXJmYWNlIG9mIHRoZSBwb2x5Z29uLiBFYWNoIHN1YnNlcXVlbnRcbiAgICogICAgIGxpbmVhciByaW5nIGRlZmluZXMgYSBob2xlIGluIHRoZSBzdXJmYWNlIG9mIHRoZSBwb2x5Z29uLiBBIGxpbmVhciByaW5nIGlzXG4gICAqICAgICBhbiBhcnJheSBvZiB2ZXJ0aWNlcycgY29vcmRpbmF0ZXMgd2hlcmUgdGhlIGZpcnN0IGNvb3JkaW5hdGUgYW5kIHRoZSBsYXN0IGFyZVxuICAgKiAgICAgZXF1aXZhbGVudC4gKEZvciBpbnRlcm5hbCB1c2UsIGZsYXQgY29vcmRpbmF0ZXMgaW4gY29tYmluYXRpb24gd2l0aFxuICAgKiAgICAgYG9wdF9sYXlvdXRgIGFuZCBgb3B0X2VuZHNgIGFyZSBhbHNvIGFjY2VwdGVkLilcbiAgICogQHBhcmFtIHtHZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfZW5kcyBFbmRzIChmb3IgaW50ZXJuYWwgdXNlIHdpdGggZmxhdCBjb29yZGluYXRlcykuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgb3B0X2xheW91dCwgb3B0X2VuZHMpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW5kc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50UmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFfID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBudWxsO1xuXG4gICAgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRfZW5kcykge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICAgIHRoaXMuZW5kc18gPSBvcHRfZW5kcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcygvKiogQHR5cGUge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSAqLyAoY29vcmRpbmF0ZXMpLCBvcHRfbGF5b3V0KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHBhc3NlZCBsaW5lYXIgcmluZyB0byB0aGlzIHBvbHlnb24uXG4gICAqIEBwYXJhbSB7TGluZWFyUmluZ30gbGluZWFyUmluZyBMaW5lYXIgcmluZy5cbiAgICogQGFwaVxuICAgKi9cbiAgYXBwZW5kTGluZWFyUmluZyhsaW5lYXJSaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBsaW5lYXJSaW5nLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dGVuZCh0aGlzLmZsYXRDb29yZGluYXRlcywgbGluZWFyUmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgfVxuICAgIHRoaXMuZW5kc18ucHVzaCh0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IVBvbHlnb259IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0LCB0aGlzLmVuZHNfLnNsaWNlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQoYXJyYXlNYXhTcXVhcmVkRGVsdGEoXG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSwgMCkpO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RBcnJheVBvaW50KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sIHRydWUsIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgY29udGFpbnNYWSh4LCB5KSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzQ29udGFpbnNYWSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIHBvbHlnb24gb24gcHJvamVjdGVkIHBsYW5lLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEgKG9uIHByb2plY3RlZCBwbGFuZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFyZWEoKSB7XG4gICAgcmV0dXJuIGxpbmVhclJpbmdzQXJlYSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgYXJyYXkgZm9yIHRoaXMgZ2VvbWV0cnkuICBUaGlzIGFycmF5IGhhcyB0aGUgc3RydWN0dXJlXG4gICAqIG9mIGEgR2VvSlNPTiBjb29yZGluYXRlIGFycmF5IGZvciBwb2x5Z29ucy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IE9yaWVudCBjb29yZGluYXRlcyBhY2NvcmRpbmcgdG8gdGhlIHJpZ2h0LWhhbmRcbiAgICogICAgIHJ1bGUgKGNvdW50ZXItY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY2xvY2t3aXNlIGZvciBpbnRlcmlvciByaW5ncykuXG4gICAqICAgICBJZiBgZmFsc2VgLCBjb29yZGluYXRlcyB3aWxsIGJlIG9yaWVudGVkIGFjY29yZGluZyB0byB0aGUgbGVmdC1oYW5kIHJ1bGVcbiAgICogICAgIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZCBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgQnkgZGVmYXVsdCwgY29vcmRpbmF0ZSBvcmllbnRhdGlvbiB3aWxsIGRlcGVuZCBvbiBob3cgdGhlIGdlb21ldHJ5IHdhc1xuICAgKiAgICAgY29uc3RydWN0ZWQuXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSBDb29yZGluYXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVzKG9wdF9yaWdodCkge1xuICAgIGxldCBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgaWYgKG9wdF9yaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICAgIG9yaWVudExpbmVhclJpbmdzKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBvcHRfcmlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBFbmRzLlxuICAgKi9cbiAgZ2V0RW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBJbnRlcmlvciBwb2ludC5cbiAgICovXG4gIGdldEZsYXRJbnRlcmlvclBvaW50KCkge1xuICAgIGlmICh0aGlzLmZsYXRJbnRlcmlvclBvaW50UmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY29uc3QgZmxhdENlbnRlciA9IGdldENlbnRlcih0aGlzLmdldEV4dGVudCgpKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfID0gZ2V0SW50ZXJpb3JQb2ludE9mQXJyYXkoXG4gICAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsXG4gICAgICAgIGZsYXRDZW50ZXIsIDApO1xuICAgICAgdGhpcy5mbGF0SW50ZXJpb3JQb2ludFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmxhdEludGVyaW9yUG9pbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBpbnRlcmlvciBwb2ludCBvZiB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7UG9pbnR9IEludGVyaW9yIHBvaW50IGFzIFhZTSBjb29yZGluYXRlLCB3aGVyZSBNIGlzIHRoZVxuICAgKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEludGVyaW9yUG9pbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmdldEZsYXRJbnRlcmlvclBvaW50KCksIEdlb21ldHJ5TGF5b3V0LlhZTSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgcmluZ3Mgb2YgdGhlIHBvbHlnb24sICB0aGlzIGluY2x1ZGVzIHRoZSBleHRlcmlvclxuICAgKiByaW5nIGFuZCBhbnkgaW50ZXJpb3IgcmluZ3MuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIHJpbmdzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lYXJSaW5nQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5kc18ubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgTnRoIGxpbmVhciByaW5nIG9mIHRoZSBwb2x5Z29uIGdlb21ldHJ5LiBSZXR1cm4gYG51bGxgIGlmIHRoZVxuICAgKiBnaXZlbiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAqIFRoZSBleHRlcmlvciBsaW5lYXIgcmluZyBpcyBhdmFpbGFibGUgYXQgaW5kZXggYDBgIGFuZCB0aGUgaW50ZXJpb3IgcmluZ3NcbiAgICogYXQgaW5kZXggYDFgIGFuZCBiZXlvbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7TGluZWFyUmluZ30gTGluZWFyIHJpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExpbmVhclJpbmcoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IHRoaXMuZW5kc18ubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKFxuICAgICAgaW5kZXggPT09IDAgPyAwIDogdGhpcy5lbmRzX1tpbmRleCAtIDFdLCB0aGlzLmVuZHNfW2luZGV4XSksIHRoaXMubGF5b3V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpbmVhciByaW5ncyBvZiB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7QXJyYXk8TGluZWFyUmluZz59IExpbmVhciByaW5ncy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZWFyUmluZ3MoKSB7XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3QgZW5kcyA9IHRoaXMuZW5kc187XG4gICAgY29uc3QgbGluZWFyUmluZ3MgPSBbXTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgICBjb25zdCBsaW5lYXJSaW5nID0gbmV3IExpbmVhclJpbmcoZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSwgbGF5b3V0KTtcbiAgICAgIGxpbmVhclJpbmdzLnB1c2gobGluZWFyUmluZyk7XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBsaW5lYXJSaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmllbnRlZCBmbGF0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSB7XG4gICAgaWYgKHRoaXMub3JpZW50ZWRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICAgIGlmIChsaW5lYXJSaW5nSXNPcmllbnRlZChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSkpIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IGZsYXRDb29yZGluYXRlcy5zbGljZSgpO1xuICAgICAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXy5sZW5ndGggPVxuICAgICAgICAgICAgb3JpZW50TGluZWFyUmluZ3MoXG4gICAgICAgICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9yaWVudGVkUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc187XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldFNpbXBsaWZpZWRHZW9tZXRyeUludGVybmFsKHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICBjb25zdCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgY29uc3Qgc2ltcGxpZmllZEVuZHMgPSBbXTtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IHF1YW50aXplQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsXG4gICAgICBNYXRoLnNxcnQoc3F1YXJlZFRvbGVyYW5jZSksXG4gICAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwLCBzaW1wbGlmaWVkRW5kcyk7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIEdlb21ldHJ5TGF5b3V0LlhZLCBzaW1wbGlmaWVkRW5kcyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLlBPTFlHT047XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVhclJpbmdBcnJheShcbiAgICAgIHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIGV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHshQXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAyKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gZGVmbGF0ZUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlLCB0aGlzLmVuZHNfKTtcbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBlbmRzLmxlbmd0aCA9PT0gMCA/IDAgOiBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBQb2x5Z29uO1xuXG5cbi8qKlxuICogQ3JlYXRlIGFuIGFwcHJveGltYXRpb24gb2YgYSBjaXJjbGUgb24gdGhlIHN1cmZhY2Ugb2YgYSBzcGhlcmUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyIENlbnRlciAoYFtsb24sIGxhdF1gIGluIGRlZ3JlZXMpLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBUaGUgZ3JlYXQtY2lyY2xlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciB0b1xuICogICAgIHRoZSBwb2x5Z29uIHZlcnRpY2VzLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbiBPcHRpb25hbCBudW1iZXIgb2YgdmVydGljZXMgZm9yIHRoZSByZXN1bHRpbmdcbiAqICAgICBwb2x5Z29uLiBEZWZhdWx0IGlzIGAzMmAuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9zcGhlcmVSYWRpdXMgT3B0aW9uYWwgcmFkaXVzIGZvciB0aGUgc3BoZXJlIChkZWZhdWx0cyB0b1xuICogICAgIHRoZSBFYXJ0aCdzIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQpLlxuICogQHJldHVybiB7UG9seWdvbn0gVGhlIFwiY2lyY3VsYXJcIiBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2lyY3VsYXIoY2VudGVyLCByYWRpdXMsIG9wdF9uLCBvcHRfc3BoZXJlUmFkaXVzKSB7XG4gIGNvbnN0IG4gPSBvcHRfbiA/IG9wdF9uIDogMzI7XG4gIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZXh0ZW5kKGZsYXRDb29yZGluYXRlcywgc3BoZXJlT2Zmc2V0KGNlbnRlciwgcmFkaXVzLCAyICogTWF0aC5QSSAqIGkgLyBuLCBvcHRfc3BoZXJlUmFkaXVzKSk7XG4gIH1cbiAgZmxhdENvb3JkaW5hdGVzLnB1c2goZmxhdENvb3JkaW5hdGVzWzBdLCBmbGF0Q29vcmRpbmF0ZXNbMV0pO1xuICByZXR1cm4gbmV3IFBvbHlnb24oZmxhdENvb3JkaW5hdGVzLCBHZW9tZXRyeUxheW91dC5YWSwgW2ZsYXRDb29yZGluYXRlcy5sZW5ndGhdKTtcbn1cblxuXG4vKipcbiAqIENyZWF0ZSBhIHBvbHlnb24gZnJvbSBhbiBleHRlbnQuIFRoZSBsYXlvdXQgdXNlZCBpcyBgWFlgLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgVGhlIGV4dGVudC5cbiAqIEByZXR1cm4ge1BvbHlnb259IFRoZSBwb2x5Z29uLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV4dGVudChleHRlbnQpIHtcbiAgY29uc3QgbWluWCA9IGV4dGVudFswXTtcbiAgY29uc3QgbWluWSA9IGV4dGVudFsxXTtcbiAgY29uc3QgbWF4WCA9IGV4dGVudFsyXTtcbiAgY29uc3QgbWF4WSA9IGV4dGVudFszXTtcbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID1cbiAgICAgIFttaW5YLCBtaW5ZLCBtaW5YLCBtYXhZLCBtYXhYLCBtYXhZLCBtYXhYLCBtaW5ZLCBtaW5YLCBtaW5ZXTtcbiAgcmV0dXJuIG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXSk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIHBvbHlnb24gZnJvbSBhIGNpcmNsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9DaXJjbGUuanNcIikuZGVmYXVsdH0gY2lyY2xlIENpcmNsZSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3NpZGVzIE51bWJlciBvZiBzaWRlcyBvZiB0aGUgcG9seWdvbi4gRGVmYXVsdCBpcyAzMi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2FuZ2xlIFN0YXJ0IGFuZ2xlIGZvciB0aGUgZmlyc3QgdmVydGV4IG9mIHRoZSBwb2x5Z29uIGluXG4gKiAgICAgcmFkaWFucy4gRGVmYXVsdCBpcyAwLlxuICogQHJldHVybiB7UG9seWdvbn0gUG9seWdvbiBnZW9tZXRyeS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21DaXJjbGUoY2lyY2xlLCBvcHRfc2lkZXMsIG9wdF9hbmdsZSkge1xuICBjb25zdCBzaWRlcyA9IG9wdF9zaWRlcyA/IG9wdF9zaWRlcyA6IDMyO1xuICBjb25zdCBzdHJpZGUgPSBjaXJjbGUuZ2V0U3RyaWRlKCk7XG4gIGNvbnN0IGxheW91dCA9IGNpcmNsZS5nZXRMYXlvdXQoKTtcbiAgY29uc3QgY2VudGVyID0gY2lyY2xlLmdldENlbnRlcigpO1xuICBjb25zdCBhcnJheUxlbmd0aCA9IHN0cmlkZSAqIChzaWRlcyArIDEpO1xuICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoYXJyYXlMZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5TGVuZ3RoOyBpICs9IHN0cmlkZSkge1xuICAgIGZsYXRDb29yZGluYXRlc1tpXSA9IDA7XG4gICAgZmxhdENvb3JkaW5hdGVzW2kgKyAxXSA9IDA7XG4gICAgZm9yIChsZXQgaiA9IDI7IGogPCBzdHJpZGU7IGorKykge1xuICAgICAgZmxhdENvb3JkaW5hdGVzW2kgKyBqXSA9IGNlbnRlcltqXTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW5kcyA9IFtmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoXTtcbiAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcywgbGF5b3V0LCBlbmRzKTtcbiAgbWFrZVJlZ3VsYXIocG9seWdvbiwgY2VudGVyLCBjaXJjbGUuZ2V0UmFkaXVzKCksIG9wdF9hbmdsZSk7XG4gIHJldHVybiBwb2x5Z29uO1xufVxuXG5cbi8qKlxuICogTW9kaWZ5IHRoZSBjb29yZGluYXRlcyBvZiBhIHBvbHlnb24gdG8gbWFrZSBpdCBhIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7UG9seWdvbn0gcG9seWdvbiBQb2x5Z29uIGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNlbnRlciBDZW50ZXIgb2YgdGhlIHJlZ3VsYXIgcG9seWdvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIHRoZSByZWd1bGFyIHBvbHlnb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9hbmdsZSBTdGFydCBhbmdsZSBmb3IgdGhlIGZpcnN0IHZlcnRleCBvZiB0aGUgcG9seWdvbiBpblxuICogICAgIHJhZGlhbnMuIERlZmF1bHQgaXMgMC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZWd1bGFyKHBvbHlnb24sIGNlbnRlciwgcmFkaXVzLCBvcHRfYW5nbGUpIHtcbiAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gcG9seWdvbi5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgY29uc3Qgc3RyaWRlID0gcG9seWdvbi5nZXRTdHJpZGUoKTtcbiAgY29uc3Qgc2lkZXMgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC8gc3RyaWRlIC0gMTtcbiAgY29uc3Qgc3RhcnRBbmdsZSA9IG9wdF9hbmdsZSA/IG9wdF9hbmdsZSA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHNpZGVzOyArK2kpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBpICogc3RyaWRlO1xuICAgIGNvbnN0IGFuZ2xlID0gc3RhcnRBbmdsZSArIChtb2R1bG8oaSwgc2lkZXMpICogMiAqIE1hdGguUEkgLyBzaWRlcyk7XG4gICAgZmxhdENvb3JkaW5hdGVzW29mZnNldF0gPSBjZW50ZXJbMF0gKyAocmFkaXVzICogTWF0aC5jb3MoYW5nbGUpKTtcbiAgICBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0gPSBjZW50ZXJbMV0gKyAocmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKTtcbiAgfVxuICBwb2x5Z29uLmNoYW5nZWQoKTtcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUFBO0FBQUE7QUFPQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7QUF4SEE7QUFDQTtBQTBIQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQUE7QUFBQTtBQWFBO0FBRUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBN1NBO0FBQ0E7QUErU0E7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///47\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return linearRingContainsExtent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return linearRingContainsXY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return linearRingsContainsXY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return linearRingssContainsXY; });\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/**\n * @module ol/geom/flat/contains\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import("../../extent.js").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\n\nfunction linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {\n  var outside = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["forEachCorner"])(extent,\n  /**\n   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains (x, y).\n   */\n  function (coordinate) {\n    return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);\n  });\n  return !outside;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n\nfunction linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {\n  // http://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  var wn = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return wn !== 0;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n\nfunction linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {\n  if (ends.length === 0) {\n    return false;\n  }\n\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n\n  for (var i = 1, ii = ends.length; i < ii; ++i) {\n    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\n\nfunction linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {\n  if (endss.length === 0) {\n    return false;\n  }\n\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n\n    offset = ends[ends.length - 1];\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9jb250YWlucy5qcz8wOTU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvY29udGFpbnNcbiAqL1xuaW1wb3J0IHtmb3JFYWNoQ29ybmVyfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGV4dGVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdDb250YWluc0V4dGVudChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudCkge1xuICBjb25zdCBvdXRzaWRlID0gZm9yRWFjaENvcm5lcihleHRlbnQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuICAgICAgcmV0dXJuICFsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0pO1xuICAgIH0pO1xuICByZXR1cm4gIW91dHNpZGU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIHgsIHkpIHtcbiAgLy8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDMtX2luY2x1c2lvbi5odG1sXG4gIC8vIENvcHlyaWdodCAyMDAwIHNvZnRTdXJmZXIsIDIwMTIgRGFuIFN1bmRheVxuICAvLyBUaGlzIGNvZGUgbWF5IGJlIGZyZWVseSB1c2VkIGFuZCBtb2RpZmllZCBmb3IgYW55IHB1cnBvc2VcbiAgLy8gcHJvdmlkaW5nIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIGluY2x1ZGVkIHdpdGggaXQuXG4gIC8vIFNvZnRTdXJmZXIgbWFrZXMgbm8gd2FycmFudHkgZm9yIHRoaXMgY29kZSwgYW5kIGNhbm5vdCBiZSBoZWxkXG4gIC8vIGxpYWJsZSBmb3IgYW55IHJlYWwgb3IgaW1hZ2luZWQgZGFtYWdlIHJlc3VsdGluZyBmcm9tIGl0cyB1c2UuXG4gIC8vIFVzZXJzIG9mIHRoaXMgY29kZSBtdXN0IHZlcmlmeSBjb3JyZWN0bmVzcyBmb3IgdGhlaXIgYXBwbGljYXRpb24uXG4gIGxldCB3biA9IDA7XG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGVdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlICsgMV07XG4gIGZvciAoOyBvZmZzZXQgPCBlbmQ7IG9mZnNldCArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICAgIGlmICh5MSA8PSB5KSB7XG4gICAgICBpZiAoeTIgPiB5ICYmICgoeDIgLSB4MSkgKiAoeSAtIHkxKSkgLSAoKHggLSB4MSkgKiAoeTIgLSB5MSkpID4gMCkge1xuICAgICAgICB3bisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeTIgPD0geSAmJiAoKHgyIC0geDEpICogKHkgLSB5MSkpIC0gKCh4IC0geDEpICogKHkyIC0geTEpKSA8IDApIHtcbiAgICAgIHduLS07XG4gICAgfVxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gd24gIT09IDA7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyAoeCwgeSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkge1xuICBpZiAoZW5kcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFsaW5lYXJSaW5nQ29udGFpbnNYWShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc1swXSwgc3RyaWRlLCB4LCB5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMSwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAobGluZWFyUmluZ0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBlbmRzW2kgLSAxXSwgZW5kc1tpXSwgc3RyaWRlLCB4LCB5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIHgsIHkpIHtcbiAgaWYgKGVuZHNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGlmIChsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBOzs7Ozs7Ozs7O0FBV0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVlBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export CollectionEvent */\n/* harmony import */ var _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87);\n/* harmony import */ var _CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);\n/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);\n/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);\n/**\n * @module ol/Collection\n */\n\n\n\n\n/**\n * @enum {string}\n * @private\n */\n\nvar Property = {\n  LENGTH: \'length\'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this\n * type.\n */\n\nvar CollectionEvent =\n/*@__PURE__*/\nfunction (Event) {\n  function CollectionEvent(type, opt_element) {\n    Event.call(this, type);\n    /**\n     * The element that is added to or removed from the collection.\n     * @type {*}\n     * @api\n     */\n\n    this.element = opt_element;\n  }\n\n  if (Event) CollectionEvent.__proto__ = Event;\n  CollectionEvent.prototype = Object.create(Event && Event.prototype);\n  CollectionEvent.prototype.constructor = CollectionEvent;\n  return CollectionEvent;\n}(_events_Event_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]);\n/**\n * @typedef {Object} Options\n * @property {boolean} [unique=false] Disallow the same item from being added to\n * the collection twice.\n */\n\n/**\n * @classdesc\n * An expanded version of standard JS Array, adding convenience methods for\n * manipulation. Add and remove changes to the Collection trigger a Collection\n * event. Note that this does not cover changes to the objects _within_ the\n * Collection; they trigger events on the appropriate object, not on the\n * Collection as a whole.\n *\n * @fires CollectionEvent\n *\n * @template T\n * @api\n */\n\nvar Collection =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function Collection(opt_array, opt_options) {\n    BaseObject.call(this);\n    var options = opt_options || {};\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.unique_ = !!options.unique;\n    /**\n     * @private\n     * @type {!Array<T>}\n     */\n\n    this.array_ = opt_array ? opt_array : [];\n\n    if (this.unique_) {\n      for (var i = 0, ii = this.array_.length; i < ii; ++i) {\n        this.assertUnique_(this.array_[i], i);\n      }\n    }\n\n    this.updateLength_();\n  }\n\n  if (BaseObject) Collection.__proto__ = BaseObject;\n  Collection.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Collection.prototype.constructor = Collection;\n  /**\n   * Remove all elements from the collection.\n   * @api\n   */\n\n  Collection.prototype.clear = function clear() {\n    while (this.getLength() > 0) {\n      this.pop();\n    }\n  };\n  /**\n   * Add elements to the collection.  This pushes each item in the provided array\n   * to the end of the collection.\n   * @param {!Array<T>} arr Array.\n   * @return {Collection<T>} This collection.\n   * @api\n   */\n\n\n  Collection.prototype.extend = function extend(arr) {\n    for (var i = 0, ii = arr.length; i < ii; ++i) {\n      this.push(arr[i]);\n    }\n\n    return this;\n  };\n  /**\n   * Iterate over each element, calling the provided callback.\n   * @param {function(T, number, Array<T>): *} f The function to call\n   *     for every element. This function takes 3 arguments (the element, the\n   *     index and the array). The return value is ignored.\n   * @api\n   */\n\n\n  Collection.prototype.forEach = function forEach(f) {\n    var array = this.array_;\n\n    for (var i = 0, ii = array.length; i < ii; ++i) {\n      f(array[i], i, array);\n    }\n  };\n  /**\n   * Get a reference to the underlying Array object. Warning: if the array\n   * is mutated, no events will be dispatched by the collection, and the\n   * collection\'s "length" property won\'t be in sync with the actual length\n   * of the array.\n   * @return {!Array<T>} Array.\n   * @api\n   */\n\n\n  Collection.prototype.getArray = function getArray() {\n    return this.array_;\n  };\n  /**\n   * Get the element at the provided index.\n   * @param {number} index Index.\n   * @return {T} Element.\n   * @api\n   */\n\n\n  Collection.prototype.item = function item(index) {\n    return this.array_[index];\n  };\n  /**\n   * Get the length of this collection.\n   * @return {number} The length of the array.\n   * @observable\n   * @api\n   */\n\n\n  Collection.prototype.getLength = function getLength() {\n    return this.get(Property.LENGTH);\n  };\n  /**\n   * Insert an element at the provided index.\n   * @param {number} index Index.\n   * @param {T} elem Element.\n   * @api\n   */\n\n\n  Collection.prototype.insertAt = function insertAt(index, elem) {\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n\n    this.array_.splice(index, 0, elem);\n    this.updateLength_();\n    this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ADD, elem));\n  };\n  /**\n   * Remove the last element of the collection and return it.\n   * Return `undefined` if the collection is empty.\n   * @return {T|undefined} Element.\n   * @api\n   */\n\n\n  Collection.prototype.pop = function pop() {\n    return this.removeAt(this.getLength() - 1);\n  };\n  /**\n   * Insert the provided element at the end of the collection.\n   * @param {T} elem Element.\n   * @return {number} New length of the collection.\n   * @api\n   */\n\n\n  Collection.prototype.push = function push(elem) {\n    if (this.unique_) {\n      this.assertUnique_(elem);\n    }\n\n    var n = this.getLength();\n    this.insertAt(n, elem);\n    return this.getLength();\n  };\n  /**\n   * Remove the first occurrence of an element from the collection.\n   * @param {T} elem Element.\n   * @return {T|undefined} The removed element or undefined if none found.\n   * @api\n   */\n\n\n  Collection.prototype.remove = function remove(elem) {\n    var arr = this.array_;\n\n    for (var i = 0, ii = arr.length; i < ii; ++i) {\n      if (arr[i] === elem) {\n        return this.removeAt(i);\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * Remove the element at the provided index and return it.\n   * Return `undefined` if the collection does not contain this index.\n   * @param {number} index Index.\n   * @return {T|undefined} Value.\n   * @api\n   */\n\n\n  Collection.prototype.removeAt = function removeAt(index) {\n    var prev = this.array_[index];\n    this.array_.splice(index, 1);\n    this.updateLength_();\n    this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REMOVE, prev));\n    return prev;\n  };\n  /**\n   * Set the element at the provided index.\n   * @param {number} index Index.\n   * @param {T} elem Element.\n   * @api\n   */\n\n\n  Collection.prototype.setAt = function setAt(index, elem) {\n    var n = this.getLength();\n\n    if (index < n) {\n      if (this.unique_) {\n        this.assertUnique_(elem, index);\n      }\n\n      var prev = this.array_[index];\n      this.array_[index] = elem;\n      this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REMOVE, prev));\n      this.dispatchEvent(new CollectionEvent(_CollectionEventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ADD, elem));\n    } else {\n      for (var j = n; j < index; ++j) {\n        this.insertAt(j, undefined);\n      }\n\n      this.insertAt(index, elem);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  Collection.prototype.updateLength_ = function updateLength_() {\n    this.set(Property.LENGTH, this.array_.length);\n  };\n  /**\n   * @private\n   * @param {T} elem Element.\n   * @param {number=} opt_except Optional index to ignore.\n   */\n\n\n  Collection.prototype.assertUnique_ = function assertUnique_(elem, opt_except) {\n    for (var i = 0, ii = this.array_.length; i < ii; ++i) {\n      if (this.array_[i] === elem && i !== opt_except) {\n        throw new _AssertionError_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](58);\n      }\n    }\n  };\n\n  return Collection;\n}(_Object_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["a"] = (Collection);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL0NvbGxlY3Rpb24uanM/YjE5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvQ29sbGVjdGlvblxuICovXG5pbXBvcnQgQXNzZXJ0aW9uRXJyb3IgZnJvbSAnLi9Bc3NlcnRpb25FcnJvci5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QgZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IEV2ZW50IGZyb20gJy4vZXZlbnRzL0V2ZW50LmpzJztcblxuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBQcm9wZXJ0eSA9IHtcbiAgTEVOR1RIOiAnbGVuZ3RoJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn5Db2xsZWN0aW9ufSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZiB0aGlzXG4gKiB0eXBlLlxuICovXG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvbkV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25FdmVudFR5cGV9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHsqPX0gb3B0X2VsZW1lbnQgRWxlbWVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdF9lbGVtZW50KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IGlzIGFkZGVkIHRvIG9yIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gb3B0X2VsZW1lbnQ7XG5cbiAgfVxuXG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1bmlxdWU9ZmFsc2VdIERpc2FsbG93IHRoZSBzYW1lIGl0ZW0gZnJvbSBiZWluZyBhZGRlZCB0b1xuICogdGhlIGNvbGxlY3Rpb24gdHdpY2UuXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbiBleHBhbmRlZCB2ZXJzaW9uIG9mIHN0YW5kYXJkIEpTIEFycmF5LCBhZGRpbmcgY29udmVuaWVuY2UgbWV0aG9kcyBmb3JcbiAqIG1hbmlwdWxhdGlvbi4gQWRkIGFuZCByZW1vdmUgY2hhbmdlcyB0byB0aGUgQ29sbGVjdGlvbiB0cmlnZ2VyIGEgQ29sbGVjdGlvblxuICogZXZlbnQuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNvdmVyIGNoYW5nZXMgdG8gdGhlIG9iamVjdHMgX3dpdGhpbl8gdGhlXG4gKiBDb2xsZWN0aW9uOyB0aGV5IHRyaWdnZXIgZXZlbnRzIG9uIHRoZSBhcHByb3ByaWF0ZSBvYmplY3QsIG5vdCBvbiB0aGVcbiAqIENvbGxlY3Rpb24gYXMgYSB3aG9sZS5cbiAqXG4gKiBAZmlyZXMgQ29sbGVjdGlvbkV2ZW50XG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ29sbGVjdGlvbiBleHRlbmRzIEJhc2VPYmplY3Qge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+PX0gb3B0X2FycmF5IEFycmF5LlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBDb2xsZWN0aW9uIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfYXJyYXksIG9wdF9vcHRpb25zKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuaXF1ZV8gPSAhIW9wdGlvbnMudW5pcXVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PFQ+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyYXlfID0gb3B0X2FycmF5ID8gb3B0X2FycmF5IDogW107XG5cbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyh0aGlzLmFycmF5X1tpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVMZW5ndGhfKCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGVsZW1lbnRzIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHdoaWxlICh0aGlzLmdldExlbmd0aCgpID4gMCkge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGVsZW1lbnRzIHRvIHRoZSBjb2xsZWN0aW9uLiAgVGhpcyBwdXNoZXMgZWFjaCBpdGVtIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICAgKiB0byB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0geyFBcnJheTxUPn0gYXJyIEFycmF5LlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPFQ+fSBUaGlzIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGV4dGVuZChhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgdGhpcy5wdXNoKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBlYWNoIGVsZW1lbnQsIGNhbGxpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsIG51bWJlciwgQXJyYXk8VD4pOiAqfSBmIFRoZSBmdW5jdGlvbiB0byBjYWxsXG4gICAqICAgICBmb3IgZXZlcnkgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiB0YWtlcyAzIGFyZ3VtZW50cyAodGhlIGVsZW1lbnQsIHRoZVxuICAgKiAgICAgaW5kZXggYW5kIHRoZSBhcnJheSkuIFRoZSByZXR1cm4gdmFsdWUgaXMgaWdub3JlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZm9yRWFjaChmKSB7XG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLmFycmF5XztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBmKGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBBcnJheSBvYmplY3QuIFdhcm5pbmc6IGlmIHRoZSBhcnJheVxuICAgKiBpcyBtdXRhdGVkLCBubyBldmVudHMgd2lsbCBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBjb2xsZWN0aW9uLCBhbmQgdGhlXG4gICAqIGNvbGxlY3Rpb24ncyBcImxlbmd0aFwiIHByb3BlcnR5IHdvbid0IGJlIGluIHN5bmMgd2l0aCB0aGUgYWN0dWFsIGxlbmd0aFxuICAgKiBvZiB0aGUgYXJyYXkuXG4gICAqIEByZXR1cm4geyFBcnJheTxUPn0gQXJyYXkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1R9IEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGl0ZW0oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV9baW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmdldChQcm9wZXJ0eS5MRU5HVEgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhbiBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgaW5zZXJ0QXQoaW5kZXgsIGVsZW0pIHtcbiAgICBpZiAodGhpcy51bmlxdWVfKSB7XG4gICAgICB0aGlzLmFzc2VydFVuaXF1ZV8oZWxlbSk7XG4gICAgfVxuICAgIHRoaXMuYXJyYXlfLnNwbGljZShpbmRleCwgMCwgZWxlbSk7XG4gICAgdGhpcy51cGRhdGVMZW5ndGhfKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IENvbGxlY3Rpb25FdmVudChDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCwgZWxlbSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBjb2xsZWN0aW9uIGFuZCByZXR1cm4gaXQuXG4gICAqIFJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IEVsZW1lbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVBdCh0aGlzLmdldExlbmd0aCgpIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRoZSBwcm92aWRlZCBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHB1c2goZWxlbSkge1xuICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgIHRoaXMuYXNzZXJ0VW5pcXVlXyhlbGVtKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG4gICAgdGhpcy5pbnNlcnRBdChuLCBlbGVtKTtcbiAgICByZXR1cm4gdGhpcy5nZXRMZW5ndGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge1R9IGVsZW0gRWxlbWVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGVsZW1lbnQgb3IgdW5kZWZpbmVkIGlmIG5vbmUgZm91bmQuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZShlbGVtKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5hcnJheV87XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IGVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBlbGVtZW50IGF0IHRoZSBwcm92aWRlZCBpbmRleCBhbmQgcmV0dXJuIGl0LlxuICAgKiBSZXR1cm4gYHVuZGVmaW5lZGAgaWYgdGhlIGNvbGxlY3Rpb24gZG9lcyBub3QgY29udGFpbiB0aGlzIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBWYWx1ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlQXQoaW5kZXgpIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5hcnJheV9baW5kZXhdO1xuICAgIHRoaXMuYXJyYXlfLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy51cGRhdGVMZW5ndGhfKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsIHByZXYpKTtcbiAgICByZXR1cm4gcHJldjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEBwYXJhbSB7VH0gZWxlbSBFbGVtZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRBdChpbmRleCwgZWxlbSkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldExlbmd0aCgpO1xuICAgIGlmIChpbmRleCA8IG4pIHtcbiAgICAgIGlmICh0aGlzLnVuaXF1ZV8pIHtcbiAgICAgICAgdGhpcy5hc3NlcnRVbmlxdWVfKGVsZW0sIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXYgPSB0aGlzLmFycmF5X1tpbmRleF07XG4gICAgICB0aGlzLmFycmF5X1tpbmRleF0gPSBlbGVtO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ29sbGVjdGlvbkV2ZW50KENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLCBwcmV2KSk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDb2xsZWN0aW9uRXZlbnQoQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsIGVsZW0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaiA9IG47IGogPCBpbmRleDsgKytqKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0QXQoaiwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zZXJ0QXQoaW5kZXgsIGVsZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdXBkYXRlTGVuZ3RoXygpIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5MRU5HVEgsIHRoaXMuYXJyYXlfLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUfSBlbGVtIEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2V4Y2VwdCBPcHRpb25hbCBpbmRleCB0byBpZ25vcmUuXG4gICAqL1xuICBhc3NlcnRVbmlxdWVfKGVsZW0sIG9wdF9leGNlcHQpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBpZiAodGhpcy5hcnJheV9baV0gPT09IGVsZW0gJiYgaSAhPT0gb3B0X2V4Y2VwdCkge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IoNTgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENvbGxlY3Rpb247XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7QUFEQTs7Ozs7OztBQVVBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7Ozs7Ozs7QUFPQTs7Ozs7QUFFQTs7QUFoQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdDQTtBQUFBO0FBQUE7QUFNQTtBQUVBO0FBRUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN05BO0FBQ0E7QUErTkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///49\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return clear; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return add; });\n/* unused harmony export remove */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return get; });\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/**\n * @module ol/proj/transforms\n */\n\n/**\n * @private\n * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}\n */\n\nvar transforms = {};\n/**\n * Clear the transform cache.\n */\n\nfunction clear() {\n  transforms = {};\n}\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import("./Projection.js").default} source Source.\n * @param {import("./Projection.js").default} destination Destination.\n * @param {import("../proj.js").TransformFunction} transformFn Transform.\n */\n\nfunction add(source, destination, transformFn) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import("./Projection.js").default} source Source projection.\n * @param {import("./Projection.js").default} destination Destination projection.\n * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.\n */\n\nfunction remove(source, destination) {\n  var sourceCode = source.getCode();\n  var destinationCode = destination.getCode();\n  var transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n\n  if (Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__[/* isEmpty */ "d"])(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n\n  return transform;\n}\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).\n */\n\nfunction get(sourceCode, destinationCode) {\n  var transform;\n\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n\n  return transform;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3Byb2ovdHJhbnNmb3Jtcy5qcz8xNzVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL3RyYW5zZm9ybXNcbiAqL1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbj4+fVxuICovXG5sZXQgdHJhbnNmb3JtcyA9IHt9O1xuXG5cbi8qKlxuICogQ2xlYXIgdGhlIHRyYW5zZm9ybSBjYWNoZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuICB0cmFuc2Zvcm1zID0ge307XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIHRvIGNvbnZlcnQgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBwcm9qZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBTb3VyY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5UcmFuc2Zvcm1GdW5jdGlvbn0gdHJhbnNmb3JtRm4gVHJhbnNmb3JtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkKHNvdXJjZSwgZGVzdGluYXRpb24sIHRyYW5zZm9ybUZuKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGlmICghKHNvdXJjZUNvZGUgaW4gdHJhbnNmb3JtcykpIHtcbiAgICB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdID0ge307XG4gIH1cbiAgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXVtkZXN0aW5hdGlvbkNvZGVdID0gdHJhbnNmb3JtRm47XG59XG5cblxuLyoqXG4gKiBVbnJlZ2lzdGVycyB0aGUgY29udmVyc2lvbiBmdW5jdGlvbiB0byBjb252ZXJ0IGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZVxuICogcHJvamVjdGlvbiB0byB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi4gIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY2xlYW4gdXBcbiAqIGNhY2hlZCB0cmFuc2Zvcm1zIGR1cmluZyB0ZXN0aW5nLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IGRlc3RpbmF0aW9uIERlc3RpbmF0aW9uIHByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUaGUgdW5yZWdpc3RlcmVkIHRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBzb3VyY2UuZ2V0Q29kZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvbkNvZGUgPSBkZXN0aW5hdGlvbi5nZXRDb2RlKCk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgZGVsZXRlIHRyYW5zZm9ybXNbc291cmNlQ29kZV1bZGVzdGluYXRpb25Db2RlXTtcbiAgaWYgKGlzRW1wdHkodHJhbnNmb3Jtc1tzb3VyY2VDb2RlXSkpIHtcbiAgICBkZWxldGUgdHJhbnNmb3Jtc1tzb3VyY2VDb2RlXTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5cbi8qKlxuICogR2V0IGEgdHJhbnNmb3JtIGdpdmVuIGEgc291cmNlIGNvZGUgYW5kIGEgZGVzdGluYXRpb24gY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VDb2RlIFRoZSBjb2RlIGZvciB0aGUgc291cmNlIHByb2plY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25Db2RlIFRoZSBjb2RlIGZvciB0aGUgZGVzdGluYXRpb24gcHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ouanNcIikuVHJhbnNmb3JtRnVuY3Rpb258dW5kZWZpbmVkfSBUaGUgdHJhbnNmb3JtIGZ1bmN0aW9uIChpZiBmb3VuZCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQoc291cmNlQ29kZSwgZGVzdGluYXRpb25Db2RlKSB7XG4gIGxldCB0cmFuc2Zvcm07XG4gIGlmIChzb3VyY2VDb2RlIGluIHRyYW5zZm9ybXMgJiYgZGVzdGluYXRpb25Db2RlIGluIHRyYW5zZm9ybXNbc291cmNlQ29kZV0pIHtcbiAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW3NvdXJjZUNvZGVdW2Rlc3RpbmF0aW9uQ29kZV07XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTs7Ozs7O0FBT0E7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defaultOrder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getSquaredTolerance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getTolerance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return renderFeature; });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _ImageState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);\n/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);\n/* harmony import */ var _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14);\n/**\n * @module ol/renderer/vector\n */\n\n\n\n\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\n\nvar SIMPLIFY_TOLERANCE = 0.5;\n/**\n * @const\n * @type {Object<import("../geom/GeometryType.js").default,\n *                function(import("../render/ReplayGroup.js").default, import("../geom/Geometry.js").default,\n *                         import("../style/Style.js").default, Object)>}\n */\n\nvar GEOMETRY_RENDERERS = {\n  \'Point\': renderPointGeometry,\n  \'LineString\': renderLineStringGeometry,\n  \'Polygon\': renderPolygonGeometry,\n  \'MultiPoint\': renderMultiPointGeometry,\n  \'MultiLineString\': renderMultiLineStringGeometry,\n  \'MultiPolygon\': renderMultiPolygonGeometry,\n  \'GeometryCollection\': renderGeometryCollectionGeometry,\n  \'Circle\': renderCircleGeometry\n};\n/**\n * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.\n * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\n\nfunction defaultOrder(feature1, feature2) {\n  return parseInt(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* getUid */ "c"])(feature1), 10) - parseInt(Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* getUid */ "c"])(feature2), 10);\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\n\nfunction getSquaredTolerance(resolution, pixelRatio) {\n  var tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\n\nfunction getTolerance(resolution, pixelRatio) {\n  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/Circle.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").default} feature Feature.\n */\n\nfunction renderCircleGeometry(replayGroup, geometry, style, feature) {\n  var fillStyle = style.getFill();\n  var strokeStyle = style.getStroke();\n\n  if (fillStyle || strokeStyle) {\n    var circleReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].CIRCLE);\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature);\n  }\n\n  var textStyle = style.getText();\n\n  if (textStyle) {\n    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].TEXT);\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n    textReplay.drawText(geometry, feature);\n  }\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n * @param {import("../style/Style.js").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.\n * @param {T} thisArg Value to use as `this` when executing `listener`.\n * @return {boolean} `true` if style is loading.\n * @template T\n */\n\n\nfunction renderFeature(replayGroup, feature, style, squaredTolerance, listener, thisArg) {\n  var loading = false;\n  var imageStyle = style.getImage();\n\n  if (imageStyle) {\n    var imageState = imageStyle.getImageState();\n\n    if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOADED || imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].ERROR) {\n      imageStyle.unlistenImageChange(listener, thisArg);\n    } else {\n      if (imageState == _ImageState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].IDLE) {\n        imageStyle.load();\n      }\n\n      imageState = imageStyle.getImageState();\n      imageStyle.listenImageChange(listener, thisArg);\n      loading = true;\n    }\n  }\n\n  renderFeatureInternal(replayGroup, feature, style, squaredTolerance);\n  return loading;\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n * @param {import("../style/Style.js").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n */\n\nfunction renderFeatureInternal(replayGroup, feature, style, squaredTolerance) {\n  var geometry = style.getGeometryFunction()(feature);\n\n  if (!geometry) {\n    return;\n  }\n\n  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n  var renderer = style.getRenderer();\n\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature);\n  } else {\n    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);\n  }\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n */\n\n\nfunction renderGeometry(replayGroup, geometry, style, feature) {\n  if (geometry.getType() == _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].GEOMETRY_COLLECTION) {\n    var geometries =\n    /** @type {import("../geom/GeometryCollection.js").default} */\n    geometry.getGeometries();\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      renderGeometry(replayGroup, geometries[i], style, feature);\n    }\n\n    return;\n  }\n\n  var replay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].DEFAULT);\n  replay.drawCustom(\n  /** @type {import("../geom/SimpleGeometry.js").default} */\n  geometry, feature, style.getRenderer());\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").default} feature Feature.\n */\n\n\nfunction renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {\n  var geometries = geometry.getGeometriesArray();\n  var i, ii;\n\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n    geometryRenderer(replayGroup, geometries[i], style, feature);\n  }\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n */\n\n\nfunction renderLineStringGeometry(replayGroup, geometry, style, feature) {\n  var strokeStyle = style.getStroke();\n\n  if (strokeStyle) {\n    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LINE_STRING);\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature);\n  }\n\n  var textStyle = style.getText();\n\n  if (textStyle) {\n    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].TEXT);\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n    textReplay.drawText(geometry, feature);\n  }\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n */\n\n\nfunction renderMultiLineStringGeometry(replayGroup, geometry, style, feature) {\n  var strokeStyle = style.getStroke();\n\n  if (strokeStyle) {\n    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LINE_STRING);\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature);\n  }\n\n  var textStyle = style.getText();\n\n  if (textStyle) {\n    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].TEXT);\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n    textReplay.drawText(geometry, feature);\n  }\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").default} feature Feature.\n */\n\n\nfunction renderMultiPolygonGeometry(replayGroup, geometry, style, feature) {\n  var fillStyle = style.getFill();\n  var strokeStyle = style.getStroke();\n\n  if (strokeStyle || fillStyle) {\n    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].POLYGON);\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature);\n  }\n\n  var textStyle = style.getText();\n\n  if (textStyle) {\n    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].TEXT);\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n    textReplay.drawText(geometry, feature);\n  }\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n */\n\n\nfunction renderPointGeometry(replayGroup, geometry, style, feature) {\n  var imageStyle = style.getImage();\n\n  if (imageStyle) {\n    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOADED) {\n      return;\n    }\n\n    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].IMAGE);\n    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));\n    imageReplay.drawPoint(geometry, feature);\n  }\n\n  var textStyle = style.getText();\n\n  if (textStyle) {\n    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].TEXT);\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));\n    textReplay.drawText(geometry, feature);\n  }\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n */\n\n\nfunction renderMultiPointGeometry(replayGroup, geometry, style, feature) {\n  var imageStyle = style.getImage();\n\n  if (imageStyle) {\n    if (imageStyle.getImageState() != _ImageState_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOADED) {\n      return;\n    }\n\n    var imageReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].IMAGE);\n    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));\n    imageReplay.drawMultiPoint(geometry, feature);\n  }\n\n  var textStyle = style.getText();\n\n  if (textStyle) {\n    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].TEXT);\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));\n    textReplay.drawText(geometry, feature);\n  }\n}\n/**\n * @param {import("../render/ReplayGroup.js").default} replayGroup Replay group.\n * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.\n * @param {import("../style/Style.js").default} style Style.\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n */\n\n\nfunction renderPolygonGeometry(replayGroup, geometry, style, feature) {\n  var fillStyle = style.getFill();\n  var strokeStyle = style.getStroke();\n\n  if (fillStyle || strokeStyle) {\n    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].POLYGON);\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature);\n  }\n\n  var textStyle = style.getText();\n\n  if (textStyle) {\n    var textReplay = replayGroup.getReplay(style.getZIndex(), _render_ReplayType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].TEXT);\n    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));\n    textReplay.drawText(geometry, feature);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3JlbmRlcmVyL3ZlY3Rvci5qcz9lOGZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci92ZWN0b3JcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4uL2dlb20vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBSZXBsYXlUeXBlIGZyb20gJy4uL3JlbmRlci9SZXBsYXlUeXBlLmpzJztcblxuXG4vKipcbiAqIFRvbGVyYW5jZSBmb3IgZ2VvbWV0cnkgc2ltcGxpZmljYXRpb24gaW4gZGV2aWNlIHBpeGVscy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IFNJTVBMSUZZX1RPTEVSQU5DRSA9IDAuNTtcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5VHlwZS5qc1wiKS5kZWZhdWx0LFxuICogICAgICAgICAgICAgICAgZnVuY3Rpb24oaW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQsIE9iamVjdCk+fVxuICovXG5jb25zdCBHRU9NRVRSWV9SRU5ERVJFUlMgPSB7XG4gICdQb2ludCc6IHJlbmRlclBvaW50R2VvbWV0cnksXG4gICdMaW5lU3RyaW5nJzogcmVuZGVyTGluZVN0cmluZ0dlb21ldHJ5LFxuICAnUG9seWdvbic6IHJlbmRlclBvbHlnb25HZW9tZXRyeSxcbiAgJ011bHRpUG9pbnQnOiByZW5kZXJNdWx0aVBvaW50R2VvbWV0cnksXG4gICdNdWx0aUxpbmVTdHJpbmcnOiByZW5kZXJNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSxcbiAgJ011bHRpUG9seWdvbic6IHJlbmRlck11bHRpUG9seWdvbkdlb21ldHJ5LFxuICAnR2VvbWV0cnlDb2xsZWN0aW9uJzogcmVuZGVyR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnksXG4gICdDaXJjbGUnOiByZW5kZXJDaXJjbGVHZW9tZXRyeVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZTEgRmVhdHVyZSAxLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlMiBGZWF0dXJlIDIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE9yZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE9yZGVyKGZlYXR1cmUxLCBmZWF0dXJlMikge1xuICByZXR1cm4gcGFyc2VJbnQoZ2V0VWlkKGZlYXR1cmUxKSwgMTApIC0gcGFyc2VJbnQoZ2V0VWlkKGZlYXR1cmUyKSwgMTApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHJldHVybiB7bnVtYmVyfSBTcXVhcmVkIHBpeGVsIHRvbGVyYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNxdWFyZWRUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbykge1xuICBjb25zdCB0b2xlcmFuY2UgPSBnZXRUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyk7XG4gIHJldHVybiB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFBpeGVsIHRvbGVyYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSB7XG4gIHJldHVybiBTSU1QTElGWV9UT0xFUkFOQ0UgKiByZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbztcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ2lyY2xlR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsKCk7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChmaWxsU3R5bGUgfHwgc3Ryb2tlU3R5bGUpIHtcbiAgICBjb25zdCBjaXJjbGVSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuQ0lSQ0xFKTtcbiAgICBjaXJjbGVSZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpO1xuICAgIGNpcmNsZVJlcGxheS5kcmF3Q2lyY2xlKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCl9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtUfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxpc3RlbmVyYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiBzdHlsZSBpcyBsb2FkaW5nLlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckZlYXR1cmUocmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlLCBzcXVhcmVkVG9sZXJhbmNlLCBsaXN0ZW5lciwgdGhpc0FyZykge1xuICBsZXQgbG9hZGluZyA9IGZhbHNlO1xuICBjb25zdCBpbWFnZVN0eWxlID0gc3R5bGUuZ2V0SW1hZ2UoKTtcbiAgaWYgKGltYWdlU3R5bGUpIHtcbiAgICBsZXQgaW1hZ2VTdGF0ZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpO1xuICAgIGlmIChpbWFnZVN0YXRlID09IEltYWdlU3RhdGUuTE9BREVEIHx8IGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5FUlJPUikge1xuICAgICAgaW1hZ2VTdHlsZS51bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICAgIGltYWdlU3R5bGUubG9hZCgpO1xuICAgICAgfVxuICAgICAgaW1hZ2VTdGF0ZSA9IGltYWdlU3R5bGUuZ2V0SW1hZ2VTdGF0ZSgpO1xuICAgICAgaW1hZ2VTdHlsZS5saXN0ZW5JbWFnZUNoYW5nZShsaXN0ZW5lciwgdGhpc0FyZyk7XG4gICAgICBsb2FkaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyRmVhdHVyZUludGVybmFsKHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZSwgc3F1YXJlZFRvbGVyYW5jZSk7XG5cbiAgcmV0dXJuIGxvYWRpbmc7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyRmVhdHVyZUludGVybmFsKHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZSwgc3F1YXJlZFRvbGVyYW5jZSkge1xuICBjb25zdCBnZW9tZXRyeSA9IHN0eWxlLmdldEdlb21ldHJ5RnVuY3Rpb24oKShmZWF0dXJlKTtcbiAgaWYgKCFnZW9tZXRyeSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzaW1wbGlmaWVkR2VvbWV0cnkgPSBnZW9tZXRyeS5nZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSk7XG4gIGNvbnN0IHJlbmRlcmVyID0gc3R5bGUuZ2V0UmVuZGVyZXIoKTtcbiAgaWYgKHJlbmRlcmVyKSB7XG4gICAgcmVuZGVyR2VvbWV0cnkocmVwbGF5R3JvdXAsIHNpbXBsaWZpZWRHZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGdlb21ldHJ5UmVuZGVyZXIgPSBHRU9NRVRSWV9SRU5ERVJFUlNbc2ltcGxpZmllZEdlb21ldHJ5LmdldFR5cGUoKV07XG4gICAgZ2VvbWV0cnlSZW5kZXJlcihyZXBsYXlHcm91cCwgc2ltcGxpZmllZEdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICovXG5mdW5jdGlvbiByZW5kZXJHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIGlmIChnZW9tZXRyeS5nZXRUeXBlKCkgPT0gR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT04pIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEdlb21ldHJpZXMoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIHJlbmRlckdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyaWVzW2ldLCBzdHlsZSwgZmVhdHVyZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuREVGQVVMVCk7XG4gIHJlcGxheS5kcmF3Q3VzdG9tKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLCBmZWF0dXJlLCBzdHlsZS5nZXRSZW5kZXJlcigpKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICBjb25zdCBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCk7XG4gIGxldCBpLCBpaTtcbiAgZm9yIChpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBnZW9tZXRyeVJlbmRlcmVyID1cbiAgICAgICAgR0VPTUVUUllfUkVOREVSRVJTW2dlb21ldHJpZXNbaV0uZ2V0VHlwZSgpXTtcbiAgICBnZW9tZXRyeVJlbmRlcmVyKHJlcGxheUdyb3VwLCBnZW9tZXRyaWVzW2ldLCBzdHlsZSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpbmVTdHJpbmdHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChzdHJva2VTdHlsZSkge1xuICAgIGNvbnN0IGxpbmVTdHJpbmdSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuTElORV9TVFJJTkcpO1xuICAgIGxpbmVTdHJpbmdSZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKG51bGwsIHN0cm9rZVN0eWxlKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LmRyYXdMaW5lU3RyaW5nKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICBjb25zdCBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICBjb25zdCBsaW5lU3RyaW5nUmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLkxJTkVfU1RSSU5HKTtcbiAgICBsaW5lU3RyaW5nUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShudWxsLCBzdHJva2VTdHlsZSk7XG4gICAgbGluZVN0cmluZ1JlcGxheS5kcmF3TXVsdGlMaW5lU3RyaW5nKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvbHlnb24uanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTXVsdGlQb2x5Z29uR2VvbWV0cnkocmVwbGF5R3JvdXAsIGdlb21ldHJ5LCBzdHlsZSwgZmVhdHVyZSkge1xuICBjb25zdCBmaWxsU3R5bGUgPSBzdHlsZS5nZXRGaWxsKCk7XG4gIGNvbnN0IHN0cm9rZVN0eWxlID0gc3R5bGUuZ2V0U3Ryb2tlKCk7XG4gIGlmIChzdHJva2VTdHlsZSB8fCBmaWxsU3R5bGUpIHtcbiAgICBjb25zdCBwb2x5Z29uUmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlBPTFlHT04pO1xuICAgIHBvbHlnb25SZXBsYXkuc2V0RmlsbFN0cm9rZVN0eWxlKGZpbGxTdHlsZSwgc3Ryb2tlU3R5bGUpO1xuICAgIHBvbHlnb25SZXBsYXkuZHJhd011bHRpUG9seWdvbihnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgY29uc3QgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgY29uc3QgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcihmYWxzZSkpO1xuICAgIHRleHRSZXBsYXkuZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fSByZXBsYXlHcm91cCBSZXBsYXkgZ3JvdXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyUG9pbnRHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIGNvbnN0IGltYWdlU3R5bGUgPSBzdHlsZS5nZXRJbWFnZSgpO1xuICBpZiAoaW1hZ2VTdHlsZSkge1xuICAgIGlmIChpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKSAhPSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZVJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5JTUFHRSk7XG4gICAgaW1hZ2VSZXBsYXkuc2V0SW1hZ2VTdHlsZShpbWFnZVN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICBpbWFnZVJlcGxheS5kcmF3UG9pbnQoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG4gIGNvbnN0IHRleHRTdHlsZSA9IHN0eWxlLmdldFRleHQoKTtcbiAgaWYgKHRleHRTdHlsZSkge1xuICAgIGNvbnN0IHRleHRSZXBsYXkgPSByZXBsYXlHcm91cC5nZXRSZXBsYXkoc3R5bGUuZ2V0WkluZGV4KCksIFJlcGxheVR5cGUuVEVYVCk7XG4gICAgdGV4dFJlcGxheS5zZXRUZXh0U3R5bGUodGV4dFN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoISFpbWFnZVN0eWxlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFN0eWxlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck11bHRpUG9pbnRHZW9tZXRyeShyZXBsYXlHcm91cCwgZ2VvbWV0cnksIHN0eWxlLCBmZWF0dXJlKSB7XG4gIGNvbnN0IGltYWdlU3R5bGUgPSBzdHlsZS5nZXRJbWFnZSgpO1xuICBpZiAoaW1hZ2VTdHlsZSkge1xuICAgIGlmIChpbWFnZVN0eWxlLmdldEltYWdlU3RhdGUoKSAhPSBJbWFnZVN0YXRlLkxPQURFRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWFnZVJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5JTUFHRSk7XG4gICAgaW1hZ2VSZXBsYXkuc2V0SW1hZ2VTdHlsZShpbWFnZVN0eWxlLCByZXBsYXlHcm91cC5hZGREZWNsdXR0ZXIoZmFsc2UpKTtcbiAgICBpbWFnZVJlcGxheS5kcmF3TXVsdGlQb2ludChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbiAgY29uc3QgdGV4dFN0eWxlID0gc3R5bGUuZ2V0VGV4dCgpO1xuICBpZiAodGV4dFN0eWxlKSB7XG4gICAgY29uc3QgdGV4dFJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5URVhUKTtcbiAgICB0ZXh0UmVwbGF5LnNldFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlcGxheUdyb3VwLmFkZERlY2x1dHRlcighIWltYWdlU3R5bGUpKTtcbiAgICB0ZXh0UmVwbGF5LmRyYXdUZXh0KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9yZW5kZXIvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9yZW5kZXIvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyUG9seWdvbkdlb21ldHJ5KHJlcGxheUdyb3VwLCBnZW9tZXRyeSwgc3R5bGUsIGZlYXR1cmUpIHtcbiAgY29uc3QgZmlsbFN0eWxlID0gc3R5bGUuZ2V0RmlsbCgpO1xuICBjb25zdCBzdHJva2VTdHlsZSA9IHN0eWxlLmdldFN0cm9rZSgpO1xuICBpZiAoZmlsbFN0eWxlIHx8IHN0cm9rZVN0eWxlKSB7XG4gICAgY29uc3QgcG9seWdvblJlcGxheSA9IHJlcGxheUdyb3VwLmdldFJlcGxheShzdHlsZS5nZXRaSW5kZXgoKSwgUmVwbGF5VHlwZS5QT0xZR09OKTtcbiAgICBwb2x5Z29uUmVwbGF5LnNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKTtcbiAgICBwb2x5Z29uUmVwbGF5LmRyYXdQb2x5Z29uKGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgfVxuICBjb25zdCB0ZXh0U3R5bGUgPSBzdHlsZS5nZXRUZXh0KCk7XG4gIGlmICh0ZXh0U3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0UmVwbGF5ID0gcmVwbGF5R3JvdXAuZ2V0UmVwbGF5KHN0eWxlLmdldFpJbmRleCgpLCBSZXBsYXlUeXBlLlRFWFQpO1xuICAgIHRleHRSZXBsYXkuc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgcmVwbGF5R3JvdXAuYWRkRGVjbHV0dGVyKGZhbHNlKSk7XG4gICAgdGV4dFJlcGxheS5kcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBT0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31);\n/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);\n/**\n * @module ol/geom/Point\n */\n\n\n\n\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\n\nvar Point =\n/*@__PURE__*/\nfunction (SimpleGeometry) {\n  function Point(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    this.setCoordinates(coordinates, opt_layout);\n  }\n\n  if (SimpleGeometry) Point.__proto__ = SimpleGeometry;\n  Point.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  Point.prototype.constructor = Point;\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @override\n   * @api\n   */\n\n  Point.prototype.clone = function clone() {\n    var point = new Point(this.flatCoordinates.slice(), this.layout);\n    return point;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Point.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var squaredDistance = Object(_math_js__WEBPACK_IMPORTED_MODULE_4__[/* squaredDistance */ "f"])(x, y, flatCoordinates[0], flatCoordinates[1]);\n\n    if (squaredDistance < minSquaredDistance) {\n      var stride = this.stride;\n\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n  /**\n   * Return the coordinate of the point.\n   * @return {import("../coordinate.js").Coordinate} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  Point.prototype.getCoordinates = function getCoordinates() {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Point.prototype.computeExtent = function computeExtent(extent) {\n    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createOrUpdateFromCoordinate"])(this.flatCoordinates, extent);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Point.prototype.getType = function getType() {\n    return _GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINT;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Point.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsXY"])(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Point.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 0);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    this.flatCoordinates.length = Object(_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__[/* deflateCoordinate */ "a"])(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return Point;\n}(_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["default"] = (Point);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2dlb20vUG9pbnQuanM/OTlhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9Qb2ludFxuICovXG5pbXBvcnQge2NyZWF0ZU9yVXBkYXRlRnJvbUNvb3JkaW5hdGUsIGNvbnRhaW5zWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4vZmxhdC9kZWZsYXRlLmpzJztcbmltcG9ydCB7c3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUG9pbnQgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBQb2ludCBleHRlbmRzIFNpbXBsZUdlb21ldHJ5IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnlMYXlvdXQuanNcIikuZGVmYXVsdD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IVBvaW50fSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNsb3Nlc3RQb2ludFhZKHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3Qgc3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZER4KHgsIHksIGZsYXRDb29yZGluYXRlc1swXSwgZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgfVxuICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIHJldHVybiBzcXVhcmVkRGlzdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gIXRoaXMuZmxhdENvb3JkaW5hdGVzID8gW10gOiB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjb21wdXRlRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5QT0lOVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBjb250YWluc1hZKGV4dGVudCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXNbMF0sIHRoaXMuZmxhdENvb3JkaW5hdGVzWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAwKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkZWZsYXRlQ29vcmRpbmF0ZShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTs7Ozs7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBOztBQXRGQTtBQUNBO0FBd0ZBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///52\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/LayerType\n */\n\n/**\n * A layer type used when creating layer renderers.\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  IMAGE: 'IMAGE',\n  TILE: 'TILE',\n  VECTOR_TILE: 'VECTOR_TILE',\n  VECTOR: 'VECTOR'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL0xheWVyVHlwZS5qcz9kZWY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9MYXllclR5cGVcbiAqL1xuXG4vKipcbiAqIEEgbGF5ZXIgdHlwZSB1c2VkIHdoZW4gY3JlYXRpbmcgbGF5ZXIgcmVuZGVyZXJzLlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBJTUFHRTogJ0lNQUdFJyxcbiAgVElMRTogJ1RJTEUnLFxuICBWRUNUT1JfVElMRTogJ1ZFQ1RPUl9USUxFJyxcbiAgVkVDVE9SOiAnVkVDVE9SJ1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/ObjectEventType\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  /**\n   * Triggered when a property is changed.\n   * @event module:ol/Object.ObjectEvent#propertychange\n   * @api\n   */\n  PROPERTYCHANGE: 'propertychange'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL09iamVjdEV2ZW50VHlwZS5qcz9hMzFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9PYmplY3RFdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgcHJvcGVydHkgaXMgY2hhbmdlZC5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9PYmplY3QuT2JqZWN0RXZlbnQjcHJvcGVydHljaGFuZ2VcbiAgICogQGFwaVxuICAgKi9cbiAgUFJPUEVSVFlDSEFOR0U6ICdwcm9wZXJ0eWNoYW5nZSdcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBT0E7Ozs7OztBQU1BO0FBTkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///54\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return visibleAtResolution; });\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);\n/* harmony import */ var _Base_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(93);\n/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24);\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);\n/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(38);\n/* harmony import */ var _source_State_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(45);\n/**\n * @module ol/layer/Layer\n */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map\'s `layers` collection, or `Infinity` when the layer\'s `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,\n * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after\n * construction.\n * @property {import("../PluggableMap.js").default} [map] Map.\n */\n\n/**\n * @typedef {Object} State\n * @property {import("./Base.js").default} layer\n * @property {number} opacity\n * @property {SourceState} sourceState\n * @property {boolean} visible\n * @property {boolean} managed\n * @property {import("../extent.js").Extent} [extent]\n * @property {number} zIndex\n * @property {number} maxResolution\n * @property {number} minResolution\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * A visual representation of raster or vector map data.\n * Layers group together those properties that pertain to how the data is to be\n * displayed, irrespective of the source of that data.\n *\n * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components\n * like {@link module:ol/interaction/Select~Select} use unmanaged layers\n * internally. These unmanaged layers are associated with the map using\n * {@link module:ol/layer/Layer~Layer#setMap} instead.\n *\n * A generic `change` event is fired when the state of the source changes.\n *\n * @fires import("../render/Event.js").RenderEvent\n */\n\nvar Layer =\n/*@__PURE__*/\nfunction (BaseLayer) {\n  function Layer(options) {\n    var baseOptions = Object(_obj_js__WEBPACK_IMPORTED_MODULE_6__[/* assign */ "a"])({}, options);\n    delete baseOptions.source;\n    BaseLayer.call(this, baseOptions);\n    /**\n     * @private\n     * @type {?import("../events.js").EventsKey}\n     */\n\n    this.mapPrecomposeKey_ = null;\n    /**\n     * @private\n     * @type {?import("../events.js").EventsKey}\n     */\n\n    this.mapRenderKey_ = null;\n    /**\n     * @private\n     * @type {?import("../events.js").EventsKey}\n     */\n\n    this.sourceChangeKey_ = null;\n\n    if (options.map) {\n      this.setMap(options.map);\n    }\n\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* listen */ "a"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__[/* getChangeEventType */ "b"])(_Property_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].SOURCE), this.handleSourcePropertyChange_, this);\n    var source = options.source ? options.source : null;\n    this.setSource(source);\n  }\n\n  if (BaseLayer) Layer.__proto__ = BaseLayer;\n  Layer.prototype = Object.create(BaseLayer && BaseLayer.prototype);\n  Layer.prototype.constructor = Layer;\n  /**\n   * @inheritDoc\n   */\n\n  Layer.prototype.getLayersArray = function getLayersArray(opt_array) {\n    var array = opt_array ? opt_array : [];\n    array.push(this);\n    return array;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Layer.prototype.getLayerStatesArray = function getLayerStatesArray(opt_states) {\n    var states = opt_states ? opt_states : [];\n    states.push(this.getLayerState());\n    return states;\n  };\n  /**\n   * Get the layer source.\n   * @return {import("../source/Source.js").default} The layer source (or `null` if not yet set).\n   * @observable\n   * @api\n   */\n\n\n  Layer.prototype.getSource = function getSource() {\n    var source = this.get(_Property_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].SOURCE);\n    return (\n      /** @type {import("../source/Source.js").default} */\n      source || null\n    );\n  };\n  /**\n    * @inheritDoc\n    */\n\n\n  Layer.prototype.getSourceState = function getSourceState() {\n    var source = this.getSource();\n    return !source ? _source_State_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].UNDEFINED : source.getState();\n  };\n  /**\n   * @private\n   */\n\n\n  Layer.prototype.handleSourceChange_ = function handleSourceChange_() {\n    this.changed();\n  };\n  /**\n   * @private\n   */\n\n\n  Layer.prototype.handleSourcePropertyChange_ = function handleSourcePropertyChange_() {\n    if (this.sourceChangeKey_) {\n      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* unlistenByKey */ "e"])(this.sourceChangeKey_);\n      this.sourceChangeKey_ = null;\n    }\n\n    var source = this.getSource();\n\n    if (source) {\n      this.sourceChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* listen */ "a"])(source, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE, this.handleSourceChange_, this);\n    }\n\n    this.changed();\n  };\n  /**\n   * Sets the layer to be rendered on top of other layers on a map. The map will\n   * not manage this layer in its layers collection, and the callback in\n   * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This\n   * is useful for temporary layers. To remove an unmanaged layer from the map,\n   * use `#setMap(null)`.\n   *\n   * To add the layer to a map and have it managed by the map, use\n   * {@link module:ol/Map#addLayer} instead.\n   * @param {import("../PluggableMap.js").default} map Map.\n   * @api\n   */\n\n\n  Layer.prototype.setMap = function setMap(map) {\n    if (this.mapPrecomposeKey_) {\n      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* unlistenByKey */ "e"])(this.mapPrecomposeKey_);\n      this.mapPrecomposeKey_ = null;\n    }\n\n    if (!map) {\n      this.changed();\n    }\n\n    if (this.mapRenderKey_) {\n      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* unlistenByKey */ "e"])(this.mapRenderKey_);\n      this.mapRenderKey_ = null;\n    }\n\n    if (map) {\n      this.mapPrecomposeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* listen */ "a"])(map, _render_EventType_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].PRECOMPOSE, function (evt) {\n        var renderEvent =\n        /** @type {import("../render/Event.js").default} */\n        evt;\n        var layerState = this.getLayerState();\n        layerState.managed = false;\n\n        if (this.getZIndex() === undefined) {\n          layerState.zIndex = Infinity;\n        }\n\n        renderEvent.frameState.layerStatesArray.push(layerState);\n        renderEvent.frameState.layerStates[Object(_util_js__WEBPACK_IMPORTED_MODULE_2__[/* getUid */ "c"])(this)] = layerState;\n      }, this);\n      this.mapRenderKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* listen */ "a"])(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CHANGE, map.render, map);\n      this.changed();\n    }\n  };\n  /**\n   * Set the layer source.\n   * @param {import("../source/Source.js").default} source The layer source.\n   * @observable\n   * @api\n   */\n\n\n  Layer.prototype.setSource = function setSource(source) {\n    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].SOURCE, source);\n  };\n\n  return Layer;\n}(_Base_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);\n/**\n * Return `true` if the layer is visible, and if the passed resolution is\n * between the layer\'s minResolution and maxResolution. The comparison is\n * inclusive for `minResolution` and exclusive for `maxResolution`.\n * @param {State} layerState Layer state.\n * @param {number} resolution Resolution.\n * @return {boolean} The layer is visible at the given resolution.\n */\n\n\nfunction visibleAtResolution(layerState, resolution) {\n  return layerState.visible && resolution >= layerState.minResolution && resolution < layerState.maxResolution;\n}\n/* harmony default export */ __webpack_exports__["a"] = (Layer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2xheWVyL0xheWVyLmpzPzExN2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0xheWVyXG4gKi9cbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCB7Z2V0Q2hhbmdlRXZlbnRUeXBlfSBmcm9tICcuLi9PYmplY3QuanMnO1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuL0Jhc2UuanMnO1xuaW1wb3J0IExheWVyUHJvcGVydHkgZnJvbSAnLi9Qcm9wZXJ0eS5qcyc7XG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgU291cmNlU3RhdGUgZnJvbSAnLi4vc291cmNlL1N0YXRlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5ICgwLCAxKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJpbGl0eS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIGJvdW5kaW5nIGV4dGVudCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgVGhlIGxheWVyIHdpbGwgbm90IGJlXG4gKiByZW5kZXJlZCBvdXRzaWRlIG9mIHRoaXMgZXh0ZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXhdIFRoZSB6LWluZGV4IGZvciBsYXllciByZW5kZXJpbmcuICBBdCByZW5kZXJpbmcgdGltZSwgdGhlIGxheWVyc1xuICogd2lsbCBiZSBvcmRlcmVkLCBmaXJzdCBieSBaLWluZGV4IGFuZCB0aGVuIGJ5IHBvc2l0aW9uLiBXaGVuIGB1bmRlZmluZWRgLCBhIGB6SW5kZXhgIG9mIDAgaXMgYXNzdW1lZFxuICogZm9yIGxheWVycyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbWFwJ3MgYGxheWVyc2AgY29sbGVjdGlvbiwgb3IgYEluZmluaXR5YCB3aGVuIHRoZSBsYXllcidzIGBzZXRNYXAoKWBcbiAqIG1ldGhvZCB3YXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiAoaW5jbHVzaXZlKSBhdCB3aGljaCB0aGlzIGxheWVyIHdpbGwgYmVcbiAqIHZpc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFJlc29sdXRpb25dIFRoZSBtYXhpbXVtIHJlc29sdXRpb24gKGV4Y2x1c2l2ZSkgYmVsb3cgd2hpY2ggdGhpcyBsYXllciB3aWxsXG4gKiBiZSB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHR9IFtzb3VyY2VdIFNvdXJjZSBmb3IgdGhpcyBsYXllci4gIElmIG5vdCBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IsXG4gKiB0aGUgc291cmNlIGNhbiBiZSBzZXQgYnkgY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyI3NldFNvdXJjZSBsYXllci5zZXRTb3VyY2Uoc291cmNlKX0gYWZ0ZXJcbiAqIGNvbnN0cnVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IFttYXBdIE1hcC5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhdGVcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyXG4gKiBAcHJvcGVydHkge251bWJlcn0gb3BhY2l0eVxuICogQHByb3BlcnR5IHtTb3VyY2VTdGF0ZX0gc291cmNlU3RhdGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdmlzaWJsZVxuICogQHByb3BlcnR5IHtib29sZWFufSBtYW5hZ2VkXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gekluZGV4XG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4UmVzb2x1dGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblJlc29sdXRpb25cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHJhc3RlciBvciB2ZWN0b3IgbWFwIGRhdGEuXG4gKiBMYXllcnMgZ3JvdXAgdG9nZXRoZXIgdGhvc2UgcHJvcGVydGllcyB0aGF0IHBlcnRhaW4gdG8gaG93IHRoZSBkYXRhIGlzIHRvIGJlXG4gKiBkaXNwbGF5ZWQsIGlycmVzcGVjdGl2ZSBvZiB0aGUgc291cmNlIG9mIHRoYXQgZGF0YS5cbiAqXG4gKiBMYXllcnMgYXJlIHVzdWFsbHkgYWRkZWQgdG8gYSBtYXAgd2l0aCB7QGxpbmsgbW9kdWxlOm9sL01hcCNhZGRMYXllcn0uIENvbXBvbmVudHNcbiAqIGxpa2Uge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9TZWxlY3R+U2VsZWN0fSB1c2UgdW5tYW5hZ2VkIGxheWVyc1xuICogaW50ZXJuYWxseS4gVGhlc2UgdW5tYW5hZ2VkIGxheWVycyBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtYXAgdXNpbmdcbiAqIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIjc2V0TWFwfSBpbnN0ZWFkLlxuICpcbiAqIEEgZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlIGNoYW5nZXMuXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4uL3JlbmRlci9FdmVudC5qc1wiKS5SZW5kZXJFdmVudFxuICovXG5jbGFzcyBMYXllciBleHRlbmRzIEJhc2VMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgTGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMuc291cmNlO1xuXG4gICAgc3VwZXIoYmFzZU9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5tYXBQcmVjb21wb3NlS2V5XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleX1cbiAgICAgKi9cbiAgICB0aGlzLm1hcFJlbmRlcktleV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbnVsbDtcblxuICAgIGlmIChvcHRpb25zLm1hcCkge1xuICAgICAgdGhpcy5zZXRNYXAob3B0aW9ucy5tYXApO1xuICAgIH1cblxuICAgIGxpc3Rlbih0aGlzLFxuICAgICAgZ2V0Q2hhbmdlRXZlbnRUeXBlKExheWVyUHJvcGVydHkuU09VUkNFKSxcbiAgICAgIHRoaXMuaGFuZGxlU291cmNlUHJvcGVydHlDaGFuZ2VfLCB0aGlzKTtcblxuICAgIGNvbnN0IHNvdXJjZSA9IG9wdGlvbnMuc291cmNlID8gb3B0aW9ucy5zb3VyY2UgOiBudWxsO1xuICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldExheWVyc0FycmF5KG9wdF9hcnJheSkge1xuICAgIGNvbnN0IGFycmF5ID0gb3B0X2FycmF5ID8gb3B0X2FycmF5IDogW107XG4gICAgYXJyYXkucHVzaCh0aGlzKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldExheWVyU3RhdGVzQXJyYXkob3B0X3N0YXRlcykge1xuICAgIGNvbnN0IHN0YXRlcyA9IG9wdF9zdGF0ZXMgPyBvcHRfc3RhdGVzIDogW107XG4gICAgc3RhdGVzLnB1c2godGhpcy5nZXRMYXllclN0YXRlKCkpO1xuICAgIHJldHVybiBzdGF0ZXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllciBzb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NvdXJjZS9Tb3VyY2UuanNcIikuZGVmYXVsdH0gVGhlIGxheWVyIHNvdXJjZSAob3IgYG51bGxgIGlmIG5vdCB5ZXQgc2V0KS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U291cmNlKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0KExheWVyUHJvcGVydHkuU09VUkNFKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9zb3VyY2UvU291cmNlLmpzXCIpLmRlZmF1bHR9ICovIChzb3VyY2UpIHx8IG51bGxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAgKiBAaW5oZXJpdERvY1xuICAgICovXG4gIGdldFNvdXJjZVN0YXRlKCkge1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgcmV0dXJuICFzb3VyY2UgPyBTb3VyY2VTdGF0ZS5VTkRFRklORUQgOiBzb3VyY2UuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU291cmNlQ2hhbmdlXygpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU291cmNlUHJvcGVydHlDaGFuZ2VfKCkge1xuICAgIGlmICh0aGlzLnNvdXJjZUNoYW5nZUtleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5zb3VyY2VDaGFuZ2VLZXlfKTtcbiAgICAgIHRoaXMuc291cmNlQ2hhbmdlS2V5XyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2VDaGFuZ2VLZXlfID0gbGlzdGVuKHNvdXJjZSxcbiAgICAgICAgRXZlbnRUeXBlLkNIQU5HRSwgdGhpcy5oYW5kbGVTb3VyY2VDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXIgdG8gYmUgcmVuZGVyZWQgb24gdG9wIG9mIG90aGVyIGxheWVycyBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsXG4gICAqIG5vdCBtYW5hZ2UgdGhpcyBsYXllciBpbiBpdHMgbGF5ZXJzIGNvbGxlY3Rpb24sIGFuZCB0aGUgY2FsbGJhY2sgaW5cbiAgICoge0BsaW5rIG1vZHVsZTpvbC9NYXAjZm9yRWFjaExheWVyQXRQaXhlbH0gd2lsbCByZWNlaXZlIGBudWxsYCBhcyBsYXllci4gVGhpc1xuICAgKiBpcyB1c2VmdWwgZm9yIHRlbXBvcmFyeSBsYXllcnMuIFRvIHJlbW92ZSBhbiB1bm1hbmFnZWQgbGF5ZXIgZnJvbSB0aGUgbWFwLFxuICAgKiB1c2UgYCNzZXRNYXAobnVsbClgLlxuICAgKlxuICAgKiBUbyBhZGQgdGhlIGxheWVyIHRvIGEgbWFwIGFuZCBoYXZlIGl0IG1hbmFnZWQgYnkgdGhlIG1hcCwgdXNlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvTWFwI2FkZExheWVyfSBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgaWYgKHRoaXMubWFwUHJlY29tcG9zZUtleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5tYXBQcmVjb21wb3NlS2V5Xyk7XG4gICAgICB0aGlzLm1hcFByZWNvbXBvc2VLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFtYXApIHtcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXBSZW5kZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubWFwUmVuZGVyS2V5Xyk7XG4gICAgICB0aGlzLm1hcFJlbmRlcktleV8gPSBudWxsO1xuICAgIH1cbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLm1hcFByZWNvbXBvc2VLZXlfID0gbGlzdGVuKG1hcCwgUmVuZGVyRXZlbnRUeXBlLlBSRUNPTVBPU0UsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBjb25zdCByZW5kZXJFdmVudCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50LmpzXCIpLmRlZmF1bHR9ICovIChldnQpO1xuICAgICAgICBjb25zdCBsYXllclN0YXRlID0gdGhpcy5nZXRMYXllclN0YXRlKCk7XG4gICAgICAgIGxheWVyU3RhdGUubWFuYWdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5nZXRaSW5kZXgoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGF5ZXJTdGF0ZS56SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJFdmVudC5mcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXkucHVzaChsYXllclN0YXRlKTtcbiAgICAgICAgcmVuZGVyRXZlbnQuZnJhbWVTdGF0ZS5sYXllclN0YXRlc1tnZXRVaWQodGhpcyldID0gbGF5ZXJTdGF0ZTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5tYXBSZW5kZXJLZXlfID0gbGlzdGVuKHRoaXMsIEV2ZW50VHlwZS5DSEFOR0UsIG1hcC5yZW5kZXIsIG1hcCk7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsYXllciBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc291cmNlL1NvdXJjZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgVGhlIGxheWVyIHNvdXJjZS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U291cmNlKHNvdXJjZSkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuU09VUkNFLCBzb3VyY2UpO1xuICB9XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gYHRydWVgIGlmIHRoZSBsYXllciBpcyB2aXNpYmxlLCBhbmQgaWYgdGhlIHBhc3NlZCByZXNvbHV0aW9uIGlzXG4gKiBiZXR3ZWVuIHRoZSBsYXllcidzIG1pblJlc29sdXRpb24gYW5kIG1heFJlc29sdXRpb24uIFRoZSBjb21wYXJpc29uIGlzXG4gKiBpbmNsdXNpdmUgZm9yIGBtaW5SZXNvbHV0aW9uYCBhbmQgZXhjbHVzaXZlIGZvciBgbWF4UmVzb2x1dGlvbmAuXG4gKiBAcGFyYW0ge1N0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBsYXllciBpcyB2aXNpYmxlIGF0IHRoZSBnaXZlbiByZXNvbHV0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmlzaWJsZUF0UmVzb2x1dGlvbihsYXllclN0YXRlLCByZXNvbHV0aW9uKSB7XG4gIHJldHVybiBsYXllclN0YXRlLnZpc2libGUgJiYgcmVzb2x1dGlvbiA+PSBsYXllclN0YXRlLm1pblJlc29sdXRpb24gJiZcbiAgICAgIHJlc29sdXRpb24gPCBsYXllclN0YXRlLm1heFJlc29sdXRpb247XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7Ozs7O0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOztBQUNBO0FBREE7QUFHQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQXhKQTs7Ozs7Ozs7Ozs7QUFtS0E7QUFDQTtBQUVBO0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///55\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/tilegrid/common.js\nvar common = __webpack_require__(65);\n\n// EXTERNAL MODULE: ./node_modules/ol/size.js\nvar ol_size = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent/Corner.js\nvar Corner = __webpack_require__(66);\n\n// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules\nvar proj = __webpack_require__(10);\n\n// EXTERNAL MODULE: ./node_modules/ol/proj/Units.js\nvar Units = __webpack_require__(26);\n\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(11);\n\n// EXTERNAL MODULE: ./node_modules/ol/TileRange.js\nvar TileRange = __webpack_require__(67);\n\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(13);\n\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./node_modules/ol/tilecoord.js\nvar tilecoord = __webpack_require__(33);\n\n// CONCATENATED MODULE: ./node_modules/ol/tilegrid/TileGrid.js\n/**\n * @module ol/tilegrid/TileGrid\n */\n\n\n\n\n\n\n\n\n/**\n * @private\n * @type {import("../tilecoord.js").TileCoord}\n */\n\nvar tmpTileCoord = [0, 0, 0];\n/**\n * @typedef {Object} Options\n * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import("../size.js").Size>} [sizes] Sizes.\n * @property {number|import("../size.js").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\n\nvar TileGrid_TileGrid = function TileGrid(options) {\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n  /**\n   * @private\n   * @type {!Array<number>}\n   */\n\n  this.resolutions_ = options.resolutions;\n  Object(asserts["a" /* assert */])(Object(array["e" /* isSorted */])(this.resolutions_, function (a, b) {\n    return b - a;\n  }, true), 17); // `resolutions` must be sorted in descending order\n  // check if we\'ve got a consistent zoom factor and origin\n\n  var zoomFactor;\n\n  if (!options.origins) {\n    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n      if (!zoomFactor) {\n        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n      } else {\n        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n          zoomFactor = undefined;\n          break;\n        }\n      }\n    }\n  }\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n\n\n  this.zoomFactor_ = zoomFactor;\n  /**\n   * @protected\n   * @type {number}\n   */\n\n  this.maxZoom = this.resolutions_.length - 1;\n  /**\n   * @private\n   * @type {import("../coordinate.js").Coordinate}\n   */\n\n  this.origin_ = options.origin !== undefined ? options.origin : null;\n  /**\n   * @private\n   * @type {Array<import("../coordinate.js").Coordinate>}\n   */\n\n  this.origins_ = null;\n\n  if (options.origins !== undefined) {\n    this.origins_ = options.origins;\n    Object(asserts["a" /* assert */])(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal\n  }\n\n  var extent = options.extent;\n\n  if (extent !== undefined && !this.origin_ && !this.origins_) {\n    this.origin_ = Object(ol_extent["getTopLeft"])(extent);\n  }\n\n  Object(asserts["a" /* assert */])(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both\n\n  /**\n   * @private\n   * @type {Array<number|import("../size.js").Size>}\n   */\n\n  this.tileSizes_ = null;\n\n  if (options.tileSizes !== undefined) {\n    this.tileSizes_ = options.tileSizes;\n    Object(asserts["a" /* assert */])(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal\n  }\n  /**\n   * @private\n   * @type {number|import("../size.js").Size}\n   */\n\n\n  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? common["b" /* DEFAULT_TILE_SIZE */] : null;\n  Object(asserts["a" /* assert */])(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both\n\n  /**\n   * @private\n   * @type {import("../extent.js").Extent}\n   */\n\n  this.extent_ = extent !== undefined ? extent : null;\n  /**\n   * @private\n   * @type {Array<import("../TileRange.js").default>}\n   */\n\n  this.fullTileRanges_ = null;\n  /**\n   * @private\n   * @type {import("../size.js").Size}\n   */\n\n  this.tmpSize_ = [0, 0];\n\n  if (options.sizes !== undefined) {\n    this.fullTileRanges_ = options.sizes.map(function (size, z) {\n      var tileRange = new TileRange["b" /* default */](Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n      return tileRange;\n    }, this);\n  } else if (extent) {\n    this.calculateTileRanges_(extent);\n  }\n};\n/**\n * Call a function with each tile coordinate for a given extent and zoom level.\n *\n * @param {import("../extent.js").Extent} extent Extent.\n * @param {number} zoom Integer zoom level.\n * @param {function(import("../tilecoord.js").TileCoord)} callback Function called with each tile coordinate.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.forEachTileCoord = function forEachTileCoord(extent, zoom, callback) {\n  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n\n  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n      callback([zoom, i, j]);\n    }\n  }\n};\n/**\n * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @param {function(this: T, number, import("../TileRange.js").default): boolean} callback Callback.\n * @param {T=} opt_this The object to use as `this` in `callback`.\n * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.\n * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.\n * @return {boolean} Callback succeeded.\n * @template T\n */\n\n\nTileGrid_TileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange(tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\n  var tileRange, x, y;\n  var tileCoordExtent = null;\n  var z = tileCoord[0] - 1;\n\n  if (this.zoomFactor_ === 2) {\n    x = tileCoord[1];\n    y = tileCoord[2];\n  } else {\n    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n  }\n\n  while (z >= this.minZoom) {\n    if (this.zoomFactor_ === 2) {\n      x = Math.floor(x / 2);\n      y = Math.floor(y / 2);\n      tileRange = Object(TileRange["a" /* createOrUpdate */])(x, x, y, y, opt_tileRange);\n    } else {\n      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    }\n\n    if (callback.call(opt_this, z, tileRange)) {\n      return true;\n    }\n\n    --z;\n  }\n\n  return false;\n};\n/**\n * Get the extent for this tile grid, if it was configured.\n * @return {import("../extent.js").Extent} Extent.\n */\n\n\nTileGrid_TileGrid.prototype.getExtent = function getExtent() {\n  return this.extent_;\n};\n/**\n * Get the maximum zoom level for the grid.\n * @return {number} Max zoom.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getMaxZoom = function getMaxZoom() {\n  return this.maxZoom;\n};\n/**\n * Get the minimum zoom level for the grid.\n * @return {number} Min zoom.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getMinZoom = function getMinZoom() {\n  return this.minZoom;\n};\n/**\n * Get the origin for the grid at the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {import("../coordinate.js").Coordinate} Origin.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getOrigin = function getOrigin(z) {\n  if (this.origin_) {\n    return this.origin_;\n  } else {\n    return this.origins_[z];\n  }\n};\n/**\n * Get the resolution for the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {number} Resolution.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getResolution = function getResolution(z) {\n  return this.resolutions_[z];\n};\n/**\n * Get the list of resolutions for the tile grid.\n * @return {Array<number>} Resolutions.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getResolutions = function getResolutions() {\n  return this.resolutions_;\n};\n/**\n * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.\n * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.\n * @return {import("../TileRange.js").default} Tile range.\n */\n\n\nTileGrid_TileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange(tileCoord, opt_tileRange, opt_extent) {\n  if (tileCoord[0] < this.maxZoom) {\n    if (this.zoomFactor_ === 2) {\n      var minX = tileCoord[1] * 2;\n      var minY = tileCoord[2] * 2;\n      return Object(TileRange["a" /* createOrUpdate */])(minX, minX + 1, minY, minY + 1, opt_tileRange);\n    }\n\n    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n  }\n\n  return null;\n};\n/**\n * Get the extent for a tile range.\n * @param {number} z Integer zoom level.\n * @param {import("../TileRange.js").default} tileRange Tile range.\n * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.\n * @return {import("../extent.js").Extent} Extent.\n */\n\n\nTileGrid_TileGrid.prototype.getTileRangeExtent = function getTileRangeExtent(z, tileRange, opt_extent) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = Object(ol_size["c" /* toSize */])(this.getTileSize(z), this.tmpSize_);\n  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n  return Object(ol_extent["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);\n};\n/**\n * Get a tile range for the given extent and integer zoom level.\n * @param {import("../extent.js").Extent} extent Extent.\n * @param {number} z Integer zoom level.\n * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.\n * @return {import("../TileRange.js").default} Tile range.\n */\n\n\nTileGrid_TileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ(extent, z, opt_tileRange) {\n  var tileCoord = tmpTileCoord;\n  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\n  var minX = tileCoord[1];\n  var minY = tileCoord[2];\n  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\n  return Object(TileRange["a" /* createOrUpdate */])(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n};\n/**\n * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @return {import("../coordinate.js").Coordinate} Tile center.\n */\n\n\nTileGrid_TileGrid.prototype.getTileCoordCenter = function getTileCoordCenter(tileCoord) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = Object(ol_size["c" /* toSize */])(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];\n};\n/**\n * Get the extent of a tile coordinate.\n *\n * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.\n * @return {import("../extent.js").Extent} Extent.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getTileCoordExtent = function getTileCoordExtent(tileCoord, opt_extent) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = Object(ol_size["c" /* toSize */])(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\n  var maxX = minX + tileSize[0] * resolution;\n  var maxY = minY + tileSize[1] * resolution;\n  return Object(ol_extent["createOrUpdate"])(minX, minY, maxX, maxY, opt_extent);\n};\n/**\n * Get the tile coordinate for the given map coordinate and resolution.This\n * method considers that coordinates that intersect tile boundaries should be\n * assigned the higher tile coordinate.\n *\n * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.\n * @return {import("../tilecoord.js").TileCoord} Tile coordinate.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {\n  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n};\n/**\n * Note that this method should not be called for resolutions that correspond\n * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} resolution Resolution (for a non-integer zoom level).\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *   intersections go to the higher tile coordinate, let edge intersections\n *   go to the lower tile coordinate.\n * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.\n * @return {import("../tilecoord.js").TileCoord} Tile coordinate.\n * @private\n */\n\n\nTileGrid_TileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n  var z = this.getZForResolution(resolution);\n  var scale = resolution / this.getResolution(z);\n  var origin = this.getOrigin(z);\n  var tileSize = Object(ol_size["c" /* toSize */])(this.getTileSize(z), this.tmpSize_);\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = scale * xFromOrigin / tileSize[0];\n  var tileCoordY = scale * yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return Object(tilecoord["a" /* createOrUpdate */])(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n/**\n * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n * they should have separate implementations.This method is for integer zoom\n * levels.The other method should only be called for resolutions corresponding\n * to non-integer zoom levels.\n * @param {number} x Map x coordinate.\n * @param {number} y Map y coordinate.\n * @param {number} z Integer zoom level.\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *   intersections go to the higher tile coordinate, let edge intersections\n *   go to the lower tile coordinate.\n * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.\n * @return {import("../tilecoord.js").TileCoord} Tile coordinate.\n * @private\n */\n\n\nTileGrid_TileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = Object(ol_size["c" /* toSize */])(this.getTileSize(z), this.tmpSize_);\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = xFromOrigin / tileSize[0];\n  var tileCoordY = yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return Object(tilecoord["a" /* createOrUpdate */])(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n/**\n * Get a tile coordinate given a map coordinate and zoom level.\n * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n * @param {number} z Zoom level.\n * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.\n * @return {import("../tilecoord.js").TileCoord} Tile coordinate.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {\n  return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);\n};\n/**\n * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @return {number} Tile resolution.\n */\n\n\nTileGrid_TileGrid.prototype.getTileCoordResolution = function getTileCoordResolution(tileCoord) {\n  return this.resolutions_[tileCoord[0]];\n};\n/**\n * Get the tile size for a zoom level. The type of the return value matches the\n * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.\n * @param {number} z Z.\n * @return {number|import("../size.js").Size} Tile size.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getTileSize = function getTileSize(z) {\n  if (this.tileSize_) {\n    return this.tileSize_;\n  } else {\n    return this.tileSizes_[z];\n  }\n};\n/**\n * @param {number} z Zoom level.\n * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.\n */\n\n\nTileGrid_TileGrid.prototype.getFullTileRange = function getFullTileRange(z) {\n  if (!this.fullTileRanges_) {\n    return null;\n  } else {\n    return this.fullTileRanges_[z];\n  }\n};\n/**\n * @param {number} resolution Resolution.\n * @param {number=} opt_direction If 0, the nearest resolution will be used.\n *   If 1, the nearest lower resolution will be used. If -1, the nearest\n *   higher resolution will be used. Default is 0.\n * @return {number} Z.\n * @api\n */\n\n\nTileGrid_TileGrid.prototype.getZForResolution = function getZForResolution(resolution, opt_direction) {\n  var z = Object(array["f" /* linearFindNearest */])(this.resolutions_, resolution, opt_direction || 0);\n  return Object(math["a" /* clamp */])(z, this.minZoom, this.maxZoom);\n};\n/**\n * @param {!import("../extent.js").Extent} extent Extent for this tile grid.\n * @private\n */\n\n\nTileGrid_TileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_(extent) {\n  var length = this.resolutions_.length;\n  var fullTileRanges = new Array(length);\n\n  for (var z = this.minZoom; z < length; ++z) {\n    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n  }\n\n  this.fullTileRanges_ = fullTileRanges;\n};\n\n/* harmony default export */ var tilegrid_TileGrid = (TileGrid_TileGrid);\n// CONCATENATED MODULE: ./node_modules/ol/tilegrid.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getForProjection", function() { return getForProjection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapX", function() { return wrapX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForExtent", function() { return createForExtent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createXYZ", function() { return createXYZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createForProjection", function() { return createForProjection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extentFromProjection", function() { return extentFromProjection; });\n/**\n * @module ol/tilegrid\n */\n\n\n\n\n\n\n\n/**\n * @param {import("./proj/Projection.js").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\n\nfunction getForProjection(projection) {\n  var tileGrid = projection.getDefaultTileGrid();\n\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n\n  return tileGrid;\n}\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @param {import("./proj/Projection.js").default} projection Projection.\n * @return {import("./tilecoord.js").TileCoord} Tile coordinate.\n */\n\nfunction wrapX(tileGrid, tileCoord, projection) {\n  var z = tileCoord[0];\n  var center = tileGrid.getTileCoordCenter(tileCoord);\n  var projectionExtent = extentFromProjection(projection);\n\n  if (!Object(ol_extent["containsCoordinate"])(projectionExtent, center)) {\n    var worldWidth = Object(ol_extent["getWidth"])(projectionExtent);\n    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  } else {\n    return tileCoord;\n  }\n}\n/**\n * @param {import("./extent.js").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {Corner=} opt_corner Extent corner (default is `\'top-left\'`).\n * @return {!TileGrid} TileGrid instance.\n */\n\nfunction createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n  var corner = opt_corner !== undefined ? opt_corner : Corner["a" /* default */].TOP_LEFT;\n  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n  return new tilegrid_TileGrid({\n    extent: extent,\n    origin: Object(ol_extent["getCorner"])(extent, corner),\n    resolutions: resolutions,\n    tileSize: opt_tileSize\n  });\n}\n/**\n * @typedef {Object} XYZOptions\n * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the\n * provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions=} opt_options Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\n\nfunction createXYZ(opt_options) {\n  /** @type {XYZOptions} */\n  var xyzOptions = opt_options || {};\n  var extent = xyzOptions.extent || Object(proj["get"])(\'EPSG:3857\').getExtent();\n  /** @type {import("./tilegrid/TileGrid.js").Options} */\n\n  var gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize)\n  };\n  return new tilegrid_TileGrid(gridOptions);\n}\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import("./extent.js").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @return {!Array<number>} Resolutions array.\n */\n\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {\n  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : common["a" /* DEFAULT_MAX_ZOOM */];\n  var height = Object(ol_extent["getHeight"])(extent);\n  var width = Object(ol_extent["getWidth"])(extent);\n  var tileSize = Object(ol_size["c" /* toSize */])(opt_tileSize !== undefined ? opt_tileSize : common["b" /* DEFAULT_TILE_SIZE */]);\n  var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);\n  var length = maxZoom + 1;\n  var resolutions = new Array(length);\n\n  for (var z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n\n  return resolutions;\n}\n/**\n * @param {import("./proj.js").ProjectionLike} projection Projection.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {Corner=} opt_corner Extent corner (default is `\'top-left\'`).\n * @return {!TileGrid} TileGrid instance.\n */\n\n\nfunction createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n  var extent = extentFromProjection(projection);\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import("./proj.js").ProjectionLike} projection Projection.\n * @return {import("./extent.js").Extent} Extent.\n */\n\nfunction extentFromProjection(projection) {\n  projection = Object(proj["get"])(projection);\n  var extent = projection.getExtent();\n\n  if (!extent) {\n    var half = 180 * proj["METERS_PER_UNIT"][Units["b" /* default */].DEGREES] / projection.getMetersPerUnit();\n    extent = Object(ol_extent["createOrUpdate"])(-half, -half, half, half);\n  }\n\n  return extent;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3RpbGVncmlkL1RpbGVHcmlkLmpzPzcyYTQiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC90aWxlZ3JpZC5qcz9jODYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9UaWxlR3JpZFxuICovXG5pbXBvcnQge0RFRkFVTFRfVElMRV9TSVpFfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQgVGlsZVJhbmdlLCB7Y3JlYXRlT3JVcGRhdGUgYXMgY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2V9IGZyb20gJy4uL1RpbGVSYW5nZS5qcyc7XG5pbXBvcnQge2lzU29ydGVkLCBsaW5lYXJGaW5kTmVhcmVzdH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSwgZ2V0VG9wTGVmdH0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4uL3NpemUuanMnO1xuaW1wb3J0IHtjcmVhdGVPclVwZGF0ZSBhcyBjcmVhdGVPclVwZGF0ZVRpbGVDb29yZH0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH1cbiAqL1xuY29uc3QgdG1wVGlsZUNvb3JkID0gWzAsIDAsIDBdO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBFeHRlbnQgZm9yIHRoZSB0aWxlIGdyaWQuIE5vIHRpbGVzIG91dHNpZGUgdGhpc1xuICogZXh0ZW50IHdpbGwgYmUgcmVxdWVzdGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV9IHNvdXJjZXMuIFdoZW4gbm8gYG9yaWdpbmAgb3JcbiAqIGBvcmlnaW5zYCBhcmUgY29uZmlndXJlZCwgdGhlIGBvcmlnaW5gIHdpbGwgYmUgc2V0IHRvIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBNaW5pbXVtIHpvb20uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW29yaWdpbl0gVGhlIHRpbGUgZ3JpZCBvcmlnaW4sIGkuZS4gd2hlcmUgdGhlIGB4YFxuICogYW5kIGB5YCBheGVzIG1lZXQgKGBbeiwgMCwgMF1gKS4gVGlsZSBjb29yZGluYXRlcyBpbmNyZWFzZSBsZWZ0IHRvIHJpZ2h0IGFuZCB1cHdhcmRzLiBJZiBub3RcbiAqIHNwZWNpZmllZCwgYGV4dGVudGAgb3IgYG9yaWdpbnNgIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IFtvcmlnaW5zXSBUaWxlIGdyaWQgb3JpZ2lucywgaS5lLiB3aGVyZVxuICogdGhlIGB4YCBhbmQgYHlgIGF4ZXMgbWVldCAoYFt6LCAwLCAwXWApLCBmb3IgZWFjaCB6b29tIGxldmVsLiBJZiBnaXZlbiwgdGhlIGFycmF5IGxlbmd0aFxuICogc2hvdWxkIG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGByZXNvbHV0aW9uc2AgYXJyYXksIGkuZS4gZWFjaCByZXNvbHV0aW9uIGNhbiBoYXZlIGEgZGlmZmVyZW50XG4gKiBvcmlnaW4uIFRpbGUgY29vcmRpbmF0ZXMgaW5jcmVhc2UgbGVmdCB0byByaWdodCBhbmQgdXB3YXJkcy4gSWYgbm90IHNwZWNpZmllZCwgYGV4dGVudGAgb3JcbiAqIGBvcmlnaW5gIG11c3QgYmUgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkgeyFBcnJheTxudW1iZXI+fSByZXNvbHV0aW9ucyBSZXNvbHV0aW9ucy4gVGhlIGFycmF5IGluZGV4IG9mIGVhY2ggcmVzb2x1dGlvbiBuZWVkc1xuICogdG8gbWF0Y2ggdGhlIHpvb20gbGV2ZWwuIFRoaXMgbWVhbnMgdGhhdCBldmVuIGlmIGEgYG1pblpvb21gIGlzIGNvbmZpZ3VyZWQsIHRoZSByZXNvbHV0aW9uc1xuICogYXJyYXkgd2lsbCBoYXZlIGEgbGVuZ3RoIG9mIGBtYXhab29tICsgMWAuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFtzaXplc10gU2l6ZXMuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZV0gVGlsZSBzaXplLlxuICogRGVmYXVsdCBpcyBgWzI1NiwgMjU2XWAuXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZT59IFt0aWxlU2l6ZXNdIFRpbGUgc2l6ZXMuIElmIGdpdmVuLCB0aGUgYXJyYXkgbGVuZ3RoXG4gKiBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgYHJlc29sdXRpb25zYCBhcnJheSwgaS5lLiBlYWNoIHJlc29sdXRpb24gY2FuIGhhdmUgYSBkaWZmZXJlbnRcbiAqIHRpbGUgc2l6ZS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc2V0dGluZyB0aGUgZ3JpZCBwYXR0ZXJuIGZvciBzb3VyY2VzIGFjY2Vzc2luZyB0aWxlZC1pbWFnZVxuICogc2VydmVycy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgVGlsZUdyaWQge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIFRpbGUgZ3JpZCBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5ab29tID0gb3B0aW9ucy5taW5ab29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1pblpvb20gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uc18gPSBvcHRpb25zLnJlc29sdXRpb25zO1xuICAgIGFzc2VydChpc1NvcnRlZCh0aGlzLnJlc29sdXRpb25zXywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGIgLSBhO1xuICAgIH0sIHRydWUpLCAxNyk7IC8vIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBzb3J0ZWQgaW4gZGVzY2VuZGluZyBvcmRlclxuXG5cbiAgICAvLyBjaGVjayBpZiB3ZSd2ZSBnb3QgYSBjb25zaXN0ZW50IHpvb20gZmFjdG9yIGFuZCBvcmlnaW5cbiAgICBsZXQgem9vbUZhY3RvcjtcbiAgICBpZiAoIW9wdGlvbnMub3JpZ2lucykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgaWYgKCF6b29tRmFjdG9yKSB7XG4gICAgICAgICAgem9vbUZhY3RvciA9IHRoaXMucmVzb2x1dGlvbnNfW2ldIC8gdGhpcy5yZXNvbHV0aW9uc19baSArIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLnJlc29sdXRpb25zX1tpXSAvIHRoaXMucmVzb2x1dGlvbnNfW2kgKyAxXSAhPT0gem9vbUZhY3Rvcikge1xuICAgICAgICAgICAgem9vbUZhY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnpvb21GYWN0b3JfID0gem9vbUZhY3RvcjtcblxuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhab29tID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoIC0gMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbl8gPSBvcHRpb25zLm9yaWdpbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcmlnaW4gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbnNfID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy5vcmlnaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3JpZ2luc18gPSBvcHRpb25zLm9yaWdpbnM7XG4gICAgICBhc3NlcnQodGhpcy5vcmlnaW5zXy5sZW5ndGggPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoLFxuICAgICAgICAyMCk7IC8vIE51bWJlciBvZiBgb3JpZ2luc2AgYW5kIGByZXNvbHV0aW9uc2AgbXVzdCBiZSBlcXVhbFxuICAgIH1cblxuICAgIGNvbnN0IGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50O1xuXG4gICAgaWYgKGV4dGVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF0aGlzLm9yaWdpbl8gJiYgIXRoaXMub3JpZ2luc18pIHtcbiAgICAgIHRoaXMub3JpZ2luXyA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgICB9XG5cbiAgICBhc3NlcnQoXG4gICAgICAoIXRoaXMub3JpZ2luXyAmJiB0aGlzLm9yaWdpbnNfKSB8fCAodGhpcy5vcmlnaW5fICYmICF0aGlzLm9yaWdpbnNfKSxcbiAgICAgIDE4KTsgLy8gRWl0aGVyIGBvcmlnaW5gIG9yIGBvcmlnaW5zYCBtdXN0IGJlIGNvbmZpZ3VyZWQsIG5ldmVyIGJvdGhcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemU+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZVNpemVzXyA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMudGlsZVNpemVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGlsZVNpemVzXyA9IG9wdGlvbnMudGlsZVNpemVzO1xuICAgICAgYXNzZXJ0KHRoaXMudGlsZVNpemVzXy5sZW5ndGggPT0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoLFxuICAgICAgICAxOSk7IC8vIE51bWJlciBvZiBgdGlsZVNpemVzYCBhbmQgYHJlc29sdXRpb25zYCBtdXN0IGJlIGVxdWFsXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVTaXplXyA9IG9wdGlvbnMudGlsZVNpemUgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnRpbGVTaXplIDpcbiAgICAgICF0aGlzLnRpbGVTaXplc18gPyBERUZBVUxUX1RJTEVfU0laRSA6IG51bGw7XG4gICAgYXNzZXJ0KFxuICAgICAgKCF0aGlzLnRpbGVTaXplXyAmJiB0aGlzLnRpbGVTaXplc18pIHx8XG4gICAgICAgICh0aGlzLnRpbGVTaXplXyAmJiAhdGhpcy50aWxlU2l6ZXNfKSxcbiAgICAgIDIyKTsgLy8gRWl0aGVyIGB0aWxlU2l6ZWAgb3IgYHRpbGVTaXplc2AgbXVzdCBiZSBjb25maWd1cmVkLCBuZXZlciBib3RoXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGV4dGVudCAhPT0gdW5kZWZpbmVkID8gZXh0ZW50IDogbnVsbDtcblxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMuZnVsbFRpbGVSYW5nZXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFNpemVfID0gWzAsIDBdO1xuXG4gICAgaWYgKG9wdGlvbnMuc2l6ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5mdWxsVGlsZVJhbmdlc18gPSBvcHRpb25zLnNpemVzLm1hcChmdW5jdGlvbihzaXplLCB6KSB7XG4gICAgICAgIGNvbnN0IHRpbGVSYW5nZSA9IG5ldyBUaWxlUmFuZ2UoXG4gICAgICAgICAgTWF0aC5taW4oMCwgc2l6ZVswXSksIE1hdGgubWF4KHNpemVbMF0gLSAxLCAtMSksXG4gICAgICAgICAgTWF0aC5taW4oMCwgc2l6ZVsxXSksIE1hdGgubWF4KHNpemVbMV0gLSAxLCAtMSkpO1xuICAgICAgICByZXR1cm4gdGlsZVJhbmdlO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChleHRlbnQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZSBmb3IgYSBnaXZlbiBleHRlbnQgYW5kIHpvb20gbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQpfSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZm9yRWFjaFRpbGVDb29yZChleHRlbnQsIHpvb20sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdGlsZVJhbmdlID0gdGhpcy5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgem9vbSk7XG4gICAgZm9yIChsZXQgaSA9IHRpbGVSYW5nZS5taW5YLCBpaSA9IHRpbGVSYW5nZS5tYXhYOyBpIDw9IGlpOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGogPSB0aWxlUmFuZ2UubWluWSwgamogPSB0aWxlUmFuZ2UubWF4WTsgaiA8PSBqajsgKytqKSB7XG4gICAgICAgIGNhbGxiYWNrKFt6b29tLCBpLCBqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBudW1iZXIsIGltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0KTogYm9vbGVhbn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gICAqIEBwYXJhbSB7VD19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgY2FsbGJhY2tgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0PX0gb3B0X3RpbGVSYW5nZSBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FsbGJhY2sgc3VjY2VlZGVkLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZm9yRWFjaFRpbGVDb29yZFBhcmVudFRpbGVSYW5nZSh0aWxlQ29vcmQsIGNhbGxiYWNrLCBvcHRfdGhpcywgb3B0X3RpbGVSYW5nZSwgb3B0X2V4dGVudCkge1xuICAgIGxldCB0aWxlUmFuZ2UsIHgsIHk7XG4gICAgbGV0IHRpbGVDb29yZEV4dGVudCA9IG51bGw7XG4gICAgbGV0IHogPSB0aWxlQ29vcmRbMF0gLSAxO1xuICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICB4ID0gdGlsZUNvb3JkWzFdO1xuICAgICAgeSA9IHRpbGVDb29yZFsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZUNvb3JkRXh0ZW50ID0gdGhpcy5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkLCBvcHRfZXh0ZW50KTtcbiAgICB9XG4gICAgd2hpbGUgKHogPj0gdGhpcy5taW5ab29tKSB7XG4gICAgICBpZiAodGhpcy56b29tRmFjdG9yXyA9PT0gMikge1xuICAgICAgICB4ID0gTWF0aC5mbG9vcih4IC8gMik7XG4gICAgICAgIHkgPSBNYXRoLmZsb29yKHkgLyAyKTtcbiAgICAgICAgdGlsZVJhbmdlID0gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UoeCwgeCwgeSwgeSwgb3B0X3RpbGVSYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlUmFuZ2UgPSB0aGlzLmdldFRpbGVSYW5nZUZvckV4dGVudEFuZFoodGlsZUNvb3JkRXh0ZW50LCB6LCBvcHRfdGlsZVJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9wdF90aGlzLCB6LCB0aWxlUmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLS16O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLCBpZiBpdCB3YXMgY29uZmlndXJlZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKi9cbiAgZ2V0RXh0ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVudF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1heCB6b29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhab29tKCkge1xuICAgIHJldHVybiB0aGlzLm1heFpvb207XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBncmlkLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE1pbiB6b29tLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNaW5ab29tKCkge1xuICAgIHJldHVybiB0aGlzLm1pblpvb207XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gZm9yIHRoZSBncmlkIGF0IHRoZSBnaXZlbiB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gT3JpZ2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcmlnaW4oeikge1xuICAgIGlmICh0aGlzLm9yaWdpbl8pIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbnNfW3pdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIHRoZSBnaXZlbiB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBJbnRlZ2VyIHpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbih6KSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfW3pdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdCBvZiByZXNvbHV0aW9ucyBmb3IgdGhlIHRpbGUgZ3JpZC5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUmVzb2x1dGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ9fSBvcHRfdGlsZVJhbmdlIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCBvYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD19IG9wdF9leHRlbnQgVGVtcG9yYXJ5IGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gVGlsZSByYW5nZS5cbiAgICovXG4gIGdldFRpbGVDb29yZENoaWxkVGlsZVJhbmdlKHRpbGVDb29yZCwgb3B0X3RpbGVSYW5nZSwgb3B0X2V4dGVudCkge1xuICAgIGlmICh0aWxlQ29vcmRbMF0gPCB0aGlzLm1heFpvb20pIHtcbiAgICAgIGlmICh0aGlzLnpvb21GYWN0b3JfID09PSAyKSB7XG4gICAgICAgIGNvbnN0IG1pblggPSB0aWxlQ29vcmRbMV0gKiAyO1xuICAgICAgICBjb25zdCBtaW5ZID0gdGlsZUNvb3JkWzJdICogMjtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZVJhbmdlKG1pblgsIG1pblggKyAxLCBtaW5ZLCBtaW5ZICsgMSwgb3B0X3RpbGVSYW5nZSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aWxlQ29vcmRFeHRlbnQgPSB0aGlzLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIG9wdF9leHRlbnQpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihcbiAgICAgICAgdGlsZUNvb3JkRXh0ZW50LCB0aWxlQ29vcmRbMF0gKyAxLCBvcHRfdGlsZVJhbmdlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgZm9yIGEgdGlsZSByYW5nZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogSW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50PX0gb3B0X2V4dGVudCBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICovXG4gIGdldFRpbGVSYW5nZUV4dGVudCh6LCB0aWxlUmFuZ2UsIG9wdF9leHRlbnQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKHopO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRoaXMuZ2V0VGlsZVNpemUoeiksIHRoaXMudG1wU2l6ZV8pO1xuICAgIGNvbnN0IG1pblggPSBvcmlnaW5bMF0gKyB0aWxlUmFuZ2UubWluWCAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtYXhYID0gb3JpZ2luWzBdICsgKHRpbGVSYW5nZS5tYXhYICsgMSkgKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWluWSA9IG9yaWdpblsxXSArIHRpbGVSYW5nZS5taW5ZICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uO1xuICAgIGNvbnN0IG1heFkgPSBvcmlnaW5bMV0gKyAodGlsZVJhbmdlLm1heFkgKyAxKSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgb3B0X2V4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGlsZSByYW5nZSBmb3IgdGhlIGdpdmVuIGV4dGVudCBhbmQgaW50ZWdlciB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdD19IG9wdF90aWxlUmFuZ2UgVGVtcG9yYXJ5IHRpbGUgcmFuZ2Ugb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gVGlsZSByYW5nZS5cbiAgICovXG4gIGdldFRpbGVSYW5nZUZvckV4dGVudEFuZFooZXh0ZW50LCB6LCBvcHRfdGlsZVJhbmdlKSB7XG4gICAgY29uc3QgdGlsZUNvb3JkID0gdG1wVGlsZUNvb3JkO1xuICAgIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhleHRlbnRbMF0sIGV4dGVudFsxXSwgeiwgZmFsc2UsIHRpbGVDb29yZCk7XG4gICAgY29uc3QgbWluWCA9IHRpbGVDb29yZFsxXTtcbiAgICBjb25zdCBtaW5ZID0gdGlsZUNvb3JkWzJdO1xuICAgIHRoaXMuZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyhleHRlbnRbMl0sIGV4dGVudFszXSwgeiwgdHJ1ZSwgdGlsZUNvb3JkKTtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlUmFuZ2UobWluWCwgdGlsZUNvb3JkWzFdLCBtaW5ZLCB0aWxlQ29vcmRbMl0sIG9wdF90aWxlUmFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaWxlIGNlbnRlci5cbiAgICovXG4gIGdldFRpbGVDb29yZENlbnRlcih0aWxlQ29vcmQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHRpbGVDb29yZFswXSksIHRoaXMudG1wU2l6ZV8pO1xuICAgIHJldHVybiBbXG4gICAgICBvcmlnaW5bMF0gKyAodGlsZUNvb3JkWzFdICsgMC41KSAqIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbixcbiAgICAgIG9yaWdpblsxXSArICh0aWxlQ29vcmRbMl0gKyAwLjUpICogdGlsZVNpemVbMV0gKiByZXNvbHV0aW9uXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiBhIHRpbGUgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IFRlbXBvcmFyeSBleHRlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIG9wdF9leHRlbnQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24odGlsZUNvb3JkWzBdKTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHRpbGVDb29yZFswXSksIHRoaXMudG1wU2l6ZV8pO1xuICAgIGNvbnN0IG1pblggPSBvcmlnaW5bMF0gKyB0aWxlQ29vcmRbMV0gKiB0aWxlU2l6ZVswXSAqIHJlc29sdXRpb247XG4gICAgY29uc3QgbWluWSA9IG9yaWdpblsxXSArIHRpbGVDb29yZFsyXSAqIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtYXhYID0gbWluWCArIHRpbGVTaXplWzBdICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBtYXhZID0gbWluWSArIHRpbGVTaXplWzFdICogcmVzb2x1dGlvbjtcbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGUobWluWCwgbWluWSwgbWF4WCwgbWF4WSwgb3B0X2V4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0aWxlIGNvb3JkaW5hdGUgZm9yIHRoZSBnaXZlbiBtYXAgY29vcmRpbmF0ZSBhbmQgcmVzb2x1dGlvbi4gIFRoaXNcbiAgICogbWV0aG9kIGNvbnNpZGVycyB0aGF0IGNvb3JkaW5hdGVzIHRoYXQgaW50ZXJzZWN0IHRpbGUgYm91bmRhcmllcyBzaG91bGQgYmVcbiAgICogYXNzaWduZWQgdGhlIGhpZ2hlciB0aWxlIGNvb3JkaW5hdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgRGVzdGluYXRpb24gaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRSZXNvbHV0aW9uKGNvb3JkaW5hdGUsIHJlc29sdXRpb24sIG9wdF90aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFJlc29sdXRpb25fKFxuICAgICAgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgcmVzb2x1dGlvbiwgZmFsc2UsIG9wdF90aWxlQ29vcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGNhbGxlZCBmb3IgcmVzb2x1dGlvbnMgdGhhdCBjb3JyZXNwb25kXG4gICAqIHRvIGFuIGludGVnZXIgem9vbSBsZXZlbC4gIEluc3RlYWQgY2FsbCB0aGUgYGdldFRpbGVDb29yZEZvclhZQW5kWl9gIG1ldGhvZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbiAoZm9yIGEgbm9uLWludGVnZXIgem9vbSBsZXZlbCkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSBJbnN0ZWFkIG9mIGxldHRpbmcgZWRnZVxuICAgKiAgICAgaW50ZXJzZWN0aW9ucyBnbyB0byB0aGUgaGlnaGVyIHRpbGUgY29vcmRpbmF0ZSwgbGV0IGVkZ2UgaW50ZXJzZWN0aW9uc1xuICAgKiAgICAgZ28gdG8gdGhlIGxvd2VyIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkPX0gb3B0X3RpbGVDb29yZCBUZW1wb3JhcnkgaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl8oeCwgeSwgcmVzb2x1dGlvbiwgcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSwgb3B0X3RpbGVDb29yZCkge1xuICAgIGNvbnN0IHogPSB0aGlzLmdldFpGb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIGNvbnN0IHNjYWxlID0gcmVzb2x1dGlvbiAvIHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLmdldE9yaWdpbih6KTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICAgIGNvbnN0IGFkanVzdFggPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMC41IDogMDtcbiAgICBjb25zdCBhZGp1c3RZID0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSA/IDAgOiAwLjU7XG4gICAgY29uc3QgeEZyb21PcmlnaW4gPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luWzBdKSAvIHJlc29sdXRpb24gKyBhZGp1c3RYKTtcbiAgICBjb25zdCB5RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHkgLSBvcmlnaW5bMV0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFkpO1xuICAgIGxldCB0aWxlQ29vcmRYID0gc2NhbGUgKiB4RnJvbU9yaWdpbiAvIHRpbGVTaXplWzBdO1xuICAgIGxldCB0aWxlQ29vcmRZID0gc2NhbGUgKiB5RnJvbU9yaWdpbiAvIHRpbGVTaXplWzFdO1xuXG4gICAgaWYgKHJldmVyc2VJbnRlcnNlY3Rpb25Qb2xpY3kpIHtcbiAgICAgIHRpbGVDb29yZFggPSBNYXRoLmNlaWwodGlsZUNvb3JkWCkgLSAxO1xuICAgICAgdGlsZUNvb3JkWSA9IE1hdGguY2VpbCh0aWxlQ29vcmRZKSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbGVDb29yZFggPSBNYXRoLmZsb29yKHRpbGVDb29yZFgpO1xuICAgICAgdGlsZUNvb3JkWSA9IE1hdGguZmxvb3IodGlsZUNvb3JkWSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlVGlsZUNvb3JkKHosIHRpbGVDb29yZFgsIHRpbGVDb29yZFksIG9wdF90aWxlQ29vcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsdGhvdWdoIHRoZXJlIGlzIHJlcGV0aXRpb24gYmV0d2VlbiB0aGlzIG1ldGhvZCBhbmQgYGdldFRpbGVDb29yZEZvclhZQW5kUmVzb2x1dGlvbl9gLFxuICAgKiB0aGV5IHNob3VsZCBoYXZlIHNlcGFyYXRlIGltcGxlbWVudGF0aW9ucy4gIFRoaXMgbWV0aG9kIGlzIGZvciBpbnRlZ2VyIHpvb21cbiAgICogbGV2ZWxzLiAgVGhlIG90aGVyIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgZm9yIHJlc29sdXRpb25zIGNvcnJlc3BvbmRpbmdcbiAgICogdG8gbm9uLWludGVnZXIgem9vbSBsZXZlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IE1hcCB4IGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IE1hcCB5IGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IEludGVnZXIgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtib29sZWFufSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5IEluc3RlYWQgb2YgbGV0dGluZyBlZGdlXG4gICAqICAgICBpbnRlcnNlY3Rpb25zIGdvIHRvIHRoZSBoaWdoZXIgdGlsZSBjb29yZGluYXRlLCBsZXQgZWRnZSBpbnRlcnNlY3Rpb25zXG4gICAqICAgICBnbyB0byB0aGUgbG93ZXIgdGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmQ9fSBvcHRfdGlsZUNvb3JkIFRlbXBvcmFyeSBpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkIG9iamVjdC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yWFlBbmRaXyh4LCB5LCB6LCByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5LCBvcHRfdGlsZUNvb3JkKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oeik7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZSh0aGlzLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemVfKTtcblxuICAgIGNvbnN0IGFkanVzdFggPSByZXZlcnNlSW50ZXJzZWN0aW9uUG9saWN5ID8gMC41IDogMDtcbiAgICBjb25zdCBhZGp1c3RZID0gcmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSA/IDAgOiAwLjU7XG4gICAgY29uc3QgeEZyb21PcmlnaW4gPSBNYXRoLmZsb29yKCh4IC0gb3JpZ2luWzBdKSAvIHJlc29sdXRpb24gKyBhZGp1c3RYKTtcbiAgICBjb25zdCB5RnJvbU9yaWdpbiA9IE1hdGguZmxvb3IoKHkgLSBvcmlnaW5bMV0pIC8gcmVzb2x1dGlvbiArIGFkanVzdFkpO1xuICAgIGxldCB0aWxlQ29vcmRYID0geEZyb21PcmlnaW4gLyB0aWxlU2l6ZVswXTtcbiAgICBsZXQgdGlsZUNvb3JkWSA9IHlGcm9tT3JpZ2luIC8gdGlsZVNpemVbMV07XG5cbiAgICBpZiAocmV2ZXJzZUludGVyc2VjdGlvblBvbGljeSkge1xuICAgICAgdGlsZUNvb3JkWCA9IE1hdGguY2VpbCh0aWxlQ29vcmRYKSAtIDE7XG4gICAgICB0aWxlQ29vcmRZID0gTWF0aC5jZWlsKHRpbGVDb29yZFkpIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZUNvb3JkWCA9IE1hdGguZmxvb3IodGlsZUNvb3JkWCk7XG4gICAgICB0aWxlQ29vcmRZID0gTWF0aC5mbG9vcih0aWxlQ29vcmRZKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlT3JVcGRhdGVUaWxlQ29vcmQoeiwgdGlsZUNvb3JkWCwgdGlsZUNvb3JkWSwgb3B0X3RpbGVDb29yZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGlsZSBjb29yZGluYXRlIGdpdmVuIGEgbWFwIGNvb3JkaW5hdGUgYW5kIHpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZD19IG9wdF90aWxlQ29vcmQgRGVzdGluYXRpb24gaW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCBvYmplY3QuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkRm9yQ29vcmRBbmRaKGNvb3JkaW5hdGUsIHosIG9wdF90aWxlQ29vcmQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlQ29vcmRGb3JYWUFuZFpfKFxuICAgICAgY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgeiwgZmFsc2UsIG9wdF90aWxlQ29vcmQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaWxlIHJlc29sdXRpb24uXG4gICAqL1xuICBnZXRUaWxlQ29vcmRSZXNvbHV0aW9uKHRpbGVDb29yZCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdXRpb25zX1t0aWxlQ29vcmRbMF1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBzaXplIGZvciBhIHpvb20gbGV2ZWwuIFRoZSB0eXBlIG9mIHRoZSByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGVcbiAgICogYHRpbGVTaXplYCBvciBgdGlsZVNpemVzYCB0aGF0IHRoZSB0aWxlIGdyaWQgd2FzIGNvbmZpZ3VyZWQgd2l0aC4gVG8gYWx3YXlzXG4gICAqIGdldCBhbiBgaW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplYCwgcnVuIHRoZSByZXN1bHQgdGhyb3VnaCBgaW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplLnRvU2l6ZSgpYC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHogWi5cbiAgICogQHJldHVybiB7bnVtYmVyfGltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gVGlsZSBzaXplLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUaWxlU2l6ZSh6KSB7XG4gICAgaWYgKHRoaXMudGlsZVNpemVfKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlU2l6ZV87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVTaXplc19bel07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFpvb20gbGV2ZWwuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSBFeHRlbnQgdGlsZSByYW5nZSBmb3IgdGhlIHNwZWNpZmllZCB6b29tIGxldmVsLlxuICAgKi9cbiAgZ2V0RnVsbFRpbGVSYW5nZSh6KSB7XG4gICAgaWYgKCF0aGlzLmZ1bGxUaWxlUmFuZ2VzXykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZ1bGxUaWxlUmFuZ2VzX1t6XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGlyZWN0aW9uIElmIDAsIHRoZSBuZWFyZXN0IHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLlxuICAgKiAgICAgSWYgMSwgdGhlIG5lYXJlc3QgbG93ZXIgcmVzb2x1dGlvbiB3aWxsIGJlIHVzZWQuIElmIC0xLCB0aGUgbmVhcmVzdFxuICAgKiAgICAgaGlnaGVyIHJlc29sdXRpb24gd2lsbCBiZSB1c2VkLiBEZWZhdWx0IGlzIDAuXG4gICAqIEByZXR1cm4ge251bWJlcn0gWi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0WkZvclJlc29sdXRpb24ocmVzb2x1dGlvbiwgb3B0X2RpcmVjdGlvbikge1xuICAgIGNvbnN0IHogPSBsaW5lYXJGaW5kTmVhcmVzdCh0aGlzLnJlc29sdXRpb25zXywgcmVzb2x1dGlvbiwgb3B0X2RpcmVjdGlvbiB8fCAwKTtcbiAgICByZXR1cm4gY2xhbXAoeiwgdGhpcy5taW5ab29tLCB0aGlzLm1heFpvb20pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IWltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQgZm9yIHRoaXMgdGlsZSBncmlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FsY3VsYXRlVGlsZVJhbmdlc18oZXh0ZW50KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZXNvbHV0aW9uc18ubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxUaWxlUmFuZ2VzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgeiA9IHRoaXMubWluWm9vbTsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgICBmdWxsVGlsZVJhbmdlc1t6XSA9IHRoaXMuZ2V0VGlsZVJhbmdlRm9yRXh0ZW50QW5kWihleHRlbnQsIHopO1xuICAgIH1cbiAgICB0aGlzLmZ1bGxUaWxlUmFuZ2VzXyA9IGZ1bGxUaWxlUmFuZ2VzO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVGlsZUdyaWQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvdGlsZWdyaWRcbiAqL1xuaW1wb3J0IHtERUZBVUxUX01BWF9aT09NLCBERUZBVUxUX1RJTEVfU0laRX0gZnJvbSAnLi90aWxlZ3JpZC9jb21tb24uanMnO1xuaW1wb3J0IHt0b1NpemV9IGZyb20gJy4vc2l6ZS5qcyc7XG5pbXBvcnQge2NvbnRhaW5zQ29vcmRpbmF0ZSwgY3JlYXRlT3JVcGRhdGUsIGdldENvcm5lciwgZ2V0SGVpZ2h0LCBnZXRXaWR0aH0gZnJvbSAnLi9leHRlbnQuanMnO1xuaW1wb3J0IENvcm5lciBmcm9tICcuL2V4dGVudC9Db3JuZXIuanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0UHJvamVjdGlvbiwgTUVURVJTX1BFUl9VTklUfSBmcm9tICcuL3Byb2ouanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4vcHJvai9Vbml0cy5qcyc7XG5pbXBvcnQgVGlsZUdyaWQgZnJvbSAnLi90aWxlZ3JpZC9UaWxlR3JpZC5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gRGVmYXVsdCB0aWxlIGdyaWQgZm9yIHRoZVxuICogcGFzc2VkIHByb2plY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgbGV0IHRpbGVHcmlkID0gcHJvamVjdGlvbi5nZXREZWZhdWx0VGlsZUdyaWQoKTtcbiAgaWYgKCF0aWxlR3JpZCkge1xuICAgIHRpbGVHcmlkID0gY3JlYXRlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBwcm9qZWN0aW9uLnNldERlZmF1bHRUaWxlR3JpZCh0aWxlR3JpZCk7XG4gIH1cbiAgcmV0dXJuIHRpbGVHcmlkO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtUaWxlR3JpZH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGlsZSBjb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFgodGlsZUdyaWQsIHRpbGVDb29yZCwgcHJvamVjdGlvbikge1xuICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICBjb25zdCBjZW50ZXIgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRDZW50ZXIodGlsZUNvb3JkKTtcbiAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBpZiAoIWNvbnRhaW5zQ29vcmRpbmF0ZShwcm9qZWN0aW9uRXh0ZW50LCBjZW50ZXIpKSB7XG4gICAgY29uc3Qgd29ybGRXaWR0aCA9IGdldFdpZHRoKHByb2plY3Rpb25FeHRlbnQpO1xuICAgIGNvbnN0IHdvcmxkc0F3YXkgPSBNYXRoLmNlaWwoKHByb2plY3Rpb25FeHRlbnRbMF0gLSBjZW50ZXJbMF0pIC8gd29ybGRXaWR0aCk7XG4gICAgY2VudGVyWzBdICs9IHdvcmxkV2lkdGggKiB3b3JsZHNBd2F5O1xuICAgIHJldHVybiB0aWxlR3JpZC5nZXRUaWxlQ29vcmRGb3JDb29yZEFuZFooY2VudGVyLCB6KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGlsZUNvb3JkO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heFpvb20gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7Q29ybmVyPX0gb3B0X2Nvcm5lciBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcikge1xuICBjb25zdCBjb3JuZXIgPSBvcHRfY29ybmVyICE9PSB1bmRlZmluZWQgPyBvcHRfY29ybmVyIDogQ29ybmVyLlRPUF9MRUZUO1xuXG4gIGNvbnN0IHJlc29sdXRpb25zID0gcmVzb2x1dGlvbnNGcm9tRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSk7XG5cbiAgcmV0dXJuIG5ldyBUaWxlR3JpZCh7XG4gICAgZXh0ZW50OiBleHRlbnQsXG4gICAgb3JpZ2luOiBnZXRDb3JuZXIoZXh0ZW50LCBjb3JuZXIpLFxuICAgIHJlc29sdXRpb25zOiByZXNvbHV0aW9ucyxcbiAgICB0aWxlU2l6ZTogb3B0X3RpbGVTaXplXG4gIH0pO1xufVxuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWFlaT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIEV4dGVudCBmb3IgdGhlIHRpbGUgZ3JpZC4gVGhlIG9yaWdpbiBmb3IgYW4gWFlaIHRpbGUgZ3JpZCBpcyB0aGVcbiAqIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgZXh0ZW50LiBUaGUgemVybyBsZXZlbCBvZiB0aGUgZ3JpZCBpcyBkZWZpbmVkIGJ5IHRoZSByZXNvbHV0aW9uIGF0IHdoaWNoIG9uZSB0aWxlIGZpdHMgaW4gdGhlXG4gKiBwcm92aWRlZCBleHRlbnQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGV4dGVudCBvZiB0aGUgRVBTRzozODU3IHByb2plY3Rpb24gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Wm9vbV0gTWF4aW11bSB6b29tLiBUaGUgZGVmYXVsdCBpcyBgNDJgLiBUaGlzIGRldGVybWluZXMgdGhlIG51bWJlciBvZiBsZXZlbHNcbiAqIGluIHRoZSBncmlkIHNldC4gRm9yIGV4YW1wbGUsIGEgYG1heFpvb21gIG9mIDIxIG1lYW5zIHRoZXJlIGFyZSAyMiBsZXZlbHMgaW4gdGhlIGdyaWQgc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE1pbmltdW0gem9vbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBbdGlsZVNpemU9WzI1NiwgMjU2XV0gVGlsZSBzaXplIGluIHBpeGVscy5cbiAqL1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHRpbGUgZ3JpZCB3aXRoIGEgc3RhbmRhcmQgWFlaIHRpbGluZyBzY2hlbWUuXG4gKiBAcGFyYW0ge1hZWk9wdGlvbnM9fSBvcHRfb3B0aW9ucyBUaWxlIGdyaWQgb3B0aW9ucy5cbiAqIEByZXR1cm4geyFUaWxlR3JpZH0gVGlsZSBncmlkIGluc3RhbmNlLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWFlaKG9wdF9vcHRpb25zKSB7XG4gIC8qKiBAdHlwZSB7WFlaT3B0aW9uc30gKi9cbiAgY29uc3QgeHl6T3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGV4dGVudCA9IHh5ek9wdGlvbnMuZXh0ZW50IHx8IGdldFByb2plY3Rpb24oJ0VQU0c6Mzg1NycpLmdldEV4dGVudCgpO1xuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5PcHRpb25zfSAqL1xuICBjb25zdCBncmlkT3B0aW9ucyA9IHtcbiAgICBleHRlbnQ6IGV4dGVudCxcbiAgICBtaW5ab29tOiB4eXpPcHRpb25zLm1pblpvb20sXG4gICAgdGlsZVNpemU6IHh5ek9wdGlvbnMudGlsZVNpemUsXG4gICAgcmVzb2x1dGlvbnM6IHJlc29sdXRpb25zRnJvbUV4dGVudChcbiAgICAgIGV4dGVudCxcbiAgICAgIHh5ek9wdGlvbnMubWF4Wm9vbSxcbiAgICAgIHh5ek9wdGlvbnMudGlsZVNpemVcbiAgICApXG4gIH07XG4gIHJldHVybiBuZXcgVGlsZUdyaWQoZ3JpZE9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlIGEgcmVzb2x1dGlvbnMgYXJyYXkgZnJvbSBhbiBleHRlbnQuICBBIHpvb20gZmFjdG9yIG9mIDIgaXMgYXNzdW1lZC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbWF4Wm9vbSBNYXhpbXVtIHpvb20gbGV2ZWwgKGRlZmF1bHQgaXNcbiAqICAgICBERUZBVUxUX01BWF9aT09NKS5cbiAqIEBwYXJhbSB7bnVtYmVyfGltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplPX0gb3B0X3RpbGVTaXplIFRpbGUgc2l6ZSAoZGVmYXVsdCB1c2VzXG4gKiAgICAgREVGQVVMVF9USUxFX1NJWkUpLlxuICogQHJldHVybiB7IUFycmF5PG51bWJlcj59IFJlc29sdXRpb25zIGFycmF5LlxuICovXG5mdW5jdGlvbiByZXNvbHV0aW9uc0Zyb21FeHRlbnQoZXh0ZW50LCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplKSB7XG4gIGNvbnN0IG1heFpvb20gPSBvcHRfbWF4Wm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRfbWF4Wm9vbSA6IERFRkFVTFRfTUFYX1pPT007XG5cbiAgY29uc3QgaGVpZ2h0ID0gZ2V0SGVpZ2h0KGV4dGVudCk7XG4gIGNvbnN0IHdpZHRoID0gZ2V0V2lkdGgoZXh0ZW50KTtcblxuICBjb25zdCB0aWxlU2l6ZSA9IHRvU2l6ZShvcHRfdGlsZVNpemUgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0X3RpbGVTaXplIDogREVGQVVMVF9USUxFX1NJWkUpO1xuICBjb25zdCBtYXhSZXNvbHV0aW9uID0gTWF0aC5tYXgoXG4gICAgd2lkdGggLyB0aWxlU2l6ZVswXSwgaGVpZ2h0IC8gdGlsZVNpemVbMV0pO1xuXG4gIGNvbnN0IGxlbmd0aCA9IG1heFpvb20gKyAxO1xuICBjb25zdCByZXNvbHV0aW9ucyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCB6ID0gMDsgeiA8IGxlbmd0aDsgKyt6KSB7XG4gICAgcmVzb2x1dGlvbnNbel0gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coMiwgeik7XG4gIH1cbiAgcmV0dXJuIHJlc29sdXRpb25zO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heFpvb20gTWF4aW11bSB6b29tIGxldmVsIChkZWZhdWx0IGlzXG4gKiAgICAgREVGQVVMVF9NQVhfWk9PTSkuXG4gKiBAcGFyYW0ge251bWJlcnxpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZT19IG9wdF90aWxlU2l6ZSBUaWxlIHNpemUgKGRlZmF1bHQgdXNlc1xuICogICAgIERFRkFVTFRfVElMRV9TSVpFKS5cbiAqIEBwYXJhbSB7Q29ybmVyPX0gb3B0X2Nvcm5lciBFeHRlbnQgY29ybmVyIChkZWZhdWx0IGlzIGAndG9wLWxlZnQnYCkuXG4gKiBAcmV0dXJuIHshVGlsZUdyaWR9IFRpbGVHcmlkIGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uLCBvcHRfbWF4Wm9vbSwgb3B0X3RpbGVTaXplLCBvcHRfY29ybmVyKSB7XG4gIGNvbnN0IGV4dGVudCA9IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICByZXR1cm4gY3JlYXRlRm9yRXh0ZW50KGV4dGVudCwgb3B0X21heFpvb20sIG9wdF90aWxlU2l6ZSwgb3B0X2Nvcm5lcik7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHRpbGUgZ3JpZCBleHRlbnQgZnJvbSBhIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBoYXMgYW5cbiAqIGV4dGVudCwgaXQgaXMgdXNlZC4gIElmIG5vdCwgYSBnbG9iYWwgZXh0ZW50IGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBFeHRlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRlbnRGcm9tUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICBsZXQgZXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgaWYgKCFleHRlbnQpIHtcbiAgICBjb25zdCBoYWxmID0gMTgwICogTUVURVJTX1BFUl9VTklUW1VuaXRzLkRFR1JFRVNdIC8gcHJvamVjdGlvbi5nZXRNZXRlcnNQZXJVbml0KCk7XG4gICAgZXh0ZW50ID0gY3JlYXRlT3JVcGRhdGUoLWhhbGYsIC1oYWxmLCBoYWxmLCBoYWxmKTtcbiAgfVxuICByZXR1cm4gZXh0ZW50O1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTtBQU1BOzs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQUlBO0FBR0E7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7QUFJQTtBQUdBO0FBQ0E7QUFJQTs7Ozs7QUFJQTtBQUdBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUVBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTs7QUN4aUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7O0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBVUE7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///56\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/**\n * @module ol/format/FormatType\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  ARRAY_BUFFER: 'arraybuffer',\n  JSON: 'json',\n  TEXT: 'text',\n  XML: 'xml'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2Zvcm1hdC9Gb3JtYXRUeXBlLmpzPzMzYmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9Gb3JtYXRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFSUkFZX0JVRkZFUjogJ2FycmF5YnVmZmVyJyxcbiAgSlNPTjogJ2pzb24nLFxuICBURVhUOiAndGV4dCcsXG4gIFhNTDogJ3htbCdcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///57\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);\n/**\n * @module ol/style/Fill\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.\n * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.\n * Default null; if null, the Canvas/renderer default black will be used.\n */\n\n/**\n * @classdesc\n * Set fill style for vector features.\n * @api\n */\n\nvar Fill = function Fill(opt_options) {\n  var options = opt_options || {};\n  /**\n   * @private\n   * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}\n   */\n\n  this.color_ = options.color !== undefined ? options.color : null;\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n\n  this.checksum_ = undefined;\n};\n/**\n * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.\n * @return {Fill} The cloned style.\n * @api\n */\n\n\nFill.prototype.clone = function clone() {\n  var color = this.getColor();\n  return new Fill({\n    color: Array.isArray(color) ? color.slice() : color || undefined\n  });\n};\n/**\n * Get the fill color.\n * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.\n * @api\n */\n\n\nFill.prototype.getColor = function getColor() {\n  return this.color_;\n};\n/**\n * Set the color.\n *\n * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.\n * @api\n */\n\n\nFill.prototype.setColor = function setColor(color) {\n  this.color_ = color;\n  this.checksum_ = undefined;\n};\n/**\n * @return {string} The checksum.\n */\n\n\nFill.prototype.getChecksum = function getChecksum() {\n  if (this.checksum_ === undefined) {\n    var color = this.color_;\n\n    if (color) {\n      if (Array.isArray(color) || typeof color == \'string\') {\n        this.checksum_ = \'f\' + Object(_color_js__WEBPACK_IMPORTED_MODULE_1__[/* asString */ "b"])(\n        /** @type {import("../color.js").Color|string} */\n        color);\n      } else {\n        this.checksum_ = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* getUid */ "c"])(this.color_);\n      }\n    } else {\n      this.checksum_ = \'f-\';\n    }\n  }\n\n  return this.checksum_;\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (Fill);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL0ZpbGwuanM/ZGRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvRmlsbFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2FzU3RyaW5nfSBmcm9tICcuLi9jb2xvci5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtjb2xvcl0gQSBjb2xvciwgZ3JhZGllbnQgb3IgcGF0dGVybi5cbiAqIFNlZSB7QGxpbmsgbW9kdWxlOm9sL2NvbG9yfkNvbG9yfSBhbmQge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfSBmb3IgcG9zc2libGUgZm9ybWF0cy5cbiAqIERlZmF1bHQgbnVsbDsgaWYgbnVsbCwgdGhlIENhbnZhcy9yZW5kZXJlciBkZWZhdWx0IGJsYWNrIHdpbGwgYmUgdXNlZC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IGZpbGwgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRmlsbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X29wdGlvbnMpIHtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNvbG9yIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBzdHlsZS4gVGhlIGNvbG9yIGlzIG5vdCBjbG9uZWQgaWYgaXQgaXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9jb2xvcmxpa2V+Q29sb3JMaWtlfS5cbiAgICogQHJldHVybiB7RmlsbH0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgcmV0dXJuIG5ldyBGaWxsKHtcbiAgICAgIGNvbG9yOiBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yLnNsaWNlKCkgOiBjb2xvciB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbGwgY29sb3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb2xvci5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sb3IoY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICAgIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNoZWNrc3VtLlxuICAgKi9cbiAgZ2V0Q2hlY2tzdW0oKSB7XG4gICAgaWYgKHRoaXMuY2hlY2tzdW1fID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5jb2xvcl87XG4gICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpIHx8IHR5cGVvZiBjb2xvciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuY2hlY2tzdW1fID0gJ2YnICsgYXNTdHJpbmcoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxzdHJpbmd9ICovIChjb2xvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2hlY2tzdW1fID0gZ2V0VWlkKHRoaXMuY29sb3JfKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jaGVja3N1bV8gPSAnZi0nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrc3VtXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaWxsO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBTUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///58\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStyleFunction", function() { return createStyleFunction; });\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\n/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);\n/**\n * @module ol/Feature\n */\n\n\n\n\n/**\n * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass\n */\n\n/**\n * @typedef {Feature|import("./render/Feature.js").default} FeatureLike\n */\n\n/**\n * @classdesc\n * A vector object for geographic features with a geometry and other\n * attribute properties, similar to the features in vector file formats like\n * GeoJSON.\n *\n * Features can be styled individually with `setStyle`; otherwise they use the\n * style of their vector layer.\n *\n * Note that attribute properties are set as {@link module:ol/Object} properties on\n * the feature object, so they are observable, and have get/set accessors.\n *\n * Typically, a feature has a single geometry property. You can set the\n * geometry using the `setGeometry` method and get it with `getGeometry`.\n * It is possible to store more than one geometry on a feature using attribute\n * properties. By default, the geometry used for rendering is identified by\n * the property name `geometry`. If you want to use another geometry property\n * for rendering, use the `setGeometryName` method to change the attribute\n * property associated with the geometry for the feature.  For example:\n *\n * ```js\n *\n * import Feature from \'ol/Feature\';\n * import Polygon from \'ol/geom/Polygon\';\n * import Point from \'ol/geom/Point\';\n *\n * var feature = new Feature({\n *   geometry: new Polygon(polyCoords),\n *   labelPoint: new Point(labelCoords),\n *   name: \'My Polygon\'\n * });\n *\n * // get the polygon geometry\n * var poly = feature.getGeometry();\n *\n * // Render the feature as a point using the coordinates from labelPoint\n * feature.setGeometryName(\'labelPoint\');\n *\n * // get the point geometry\n * var point = feature.getGeometry();\n * ```\n *\n * @api\n */\n\nvar Feature =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function Feature(opt_geometryOrProperties) {\n    BaseObject.call(this);\n    /**\n     * @private\n     * @type {number|string|undefined}\n     */\n\n    this.id_ = undefined;\n    /**\n     * @type {string}\n     * @private\n     */\n\n    this.geometryName_ = \'geometry\';\n    /**\n     * User provided style.\n     * @private\n     * @type {import("./style/Style.js").StyleLike}\n     */\n\n    this.style_ = null;\n    /**\n     * @private\n     * @type {import("./style/Style.js").StyleFunction|undefined}\n     */\n\n    this.styleFunction_ = undefined;\n    /**\n     * @private\n     * @type {?import("./events.js").EventsKey}\n     */\n\n    this.geometryChangeKey_ = null;\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__[/* listen */ "a"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__[/* getChangeEventType */ "b"])(this.geometryName_), this.handleGeometryChanged_, this);\n\n    if (opt_geometryOrProperties) {\n      if (typeof\n      /** @type {?} */\n      opt_geometryOrProperties.getSimplifiedGeometry === \'function\') {\n        var geometry =\n        /** @type {import("./geom/Geometry.js").default} */\n        opt_geometryOrProperties;\n        this.setGeometry(geometry);\n      } else {\n        /** @type {Object<string, *>} */\n        var properties = opt_geometryOrProperties;\n        this.setProperties(properties);\n      }\n    }\n  }\n\n  if (BaseObject) Feature.__proto__ = BaseObject;\n  Feature.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Feature.prototype.constructor = Feature;\n  /**\n   * Clone this feature. If the original feature has a geometry it\n   * is also cloned. The feature id is not set in the clone.\n   * @return {Feature} The clone.\n   * @api\n   */\n\n  Feature.prototype.clone = function clone() {\n    var clone = new Feature(this.getProperties());\n    clone.setGeometryName(this.getGeometryName());\n    var geometry = this.getGeometry();\n\n    if (geometry) {\n      clone.setGeometry(geometry.clone());\n    }\n\n    var style = this.getStyle();\n\n    if (style) {\n      clone.setStyle(style);\n    }\n\n    return clone;\n  };\n  /**\n   * Get the feature\'s default geometry.  A feature may have any number of named\n   * geometries.  The "default" geometry (the one that is rendered by default) is\n   * set when calling {@link module:ol/Feature~Feature#setGeometry}.\n   * @return {import("./geom/Geometry.js").default|undefined} The default geometry for the feature.\n   * @api\n   * @observable\n   */\n\n\n  Feature.prototype.getGeometry = function getGeometry() {\n    return (\n      /** @type {import("./geom/Geometry.js").default|undefined} */\n      this.get(this.geometryName_)\n    );\n  };\n  /**\n   * Get the feature identifier.  This is a stable identifier for the feature and\n   * is either set when reading data from a remote source or set explicitly by\n   * calling {@link module:ol/Feature~Feature#setId}.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n\n\n  Feature.prototype.getId = function getId() {\n    return this.id_;\n  };\n  /**\n   * Get the name of the feature\'s default geometry.  By default, the default\n   * geometry is named `geometry`.\n   * @return {string} Get the property name associated with the default geometry\n   *     for this feature.\n   * @api\n   */\n\n\n  Feature.prototype.getGeometryName = function getGeometryName() {\n    return this.geometryName_;\n  };\n  /**\n   * Get the feature\'s style. Will return what was provided to the\n   * {@link module:ol/Feature~Feature#setStyle} method.\n   * @return {import("./style/Style.js").StyleLike} The feature style.\n   * @api\n   */\n\n\n  Feature.prototype.getStyle = function getStyle() {\n    return this.style_;\n  };\n  /**\n   * Get the feature\'s style function.\n   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function\n   * representing the current style of this feature.\n   * @api\n   */\n\n\n  Feature.prototype.getStyleFunction = function getStyleFunction() {\n    return this.styleFunction_;\n  };\n  /**\n   * @private\n   */\n\n\n  Feature.prototype.handleGeometryChange_ = function handleGeometryChange_() {\n    this.changed();\n  };\n  /**\n   * @private\n   */\n\n\n  Feature.prototype.handleGeometryChanged_ = function handleGeometryChanged_() {\n    if (this.geometryChangeKey_) {\n      Object(_events_js__WEBPACK_IMPORTED_MODULE_1__[/* unlistenByKey */ "e"])(this.geometryChangeKey_);\n      this.geometryChangeKey_ = null;\n    }\n\n    var geometry = this.getGeometry();\n\n    if (geometry) {\n      this.geometryChangeKey_ = Object(_events_js__WEBPACK_IMPORTED_MODULE_1__[/* listen */ "a"])(geometry, _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].CHANGE, this.handleGeometryChange_, this);\n    }\n\n    this.changed();\n  };\n  /**\n   * Set the default geometry for the feature.  This will update the property\n   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.\n   * @param {import("./geom/Geometry.js").default|undefined} geometry The new geometry.\n   * @api\n   * @observable\n   */\n\n\n  Feature.prototype.setGeometry = function setGeometry(geometry) {\n    this.set(this.geometryName_, geometry);\n  };\n  /**\n   * Set the style for the feature.  This can be a single style object, an array\n   * of styles, or a function that takes a resolution and returns an array of\n   * styles. If it is `null` the feature has no style (a `null` style).\n   * @param {import("./style/Style.js").StyleLike} style Style for this feature.\n   * @api\n   * @fires module:ol/events/Event~Event#event:change\n   */\n\n\n  Feature.prototype.setStyle = function setStyle(style) {\n    this.style_ = style;\n    this.styleFunction_ = !style ? undefined : createStyleFunction(style);\n    this.changed();\n  };\n  /**\n   * Set the feature id.  The feature id is considered stable and may be used when\n   * requesting features or comparing identifiers returned from a remote source.\n   * The feature id can be used with the\n   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.\n   * @param {number|string|undefined} id The feature id.\n   * @api\n   * @fires module:ol/events/Event~Event#event:change\n   */\n\n\n  Feature.prototype.setId = function setId(id) {\n    this.id_ = id;\n    this.changed();\n  };\n  /**\n   * Set the property name to be used when getting the feature\'s default geometry.\n   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with\n   * this name will be returned.\n   * @param {string} name The property name of the default geometry.\n   * @api\n   */\n\n\n  Feature.prototype.setGeometryName = function setGeometryName(name) {\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__[/* unlisten */ "c"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__[/* getChangeEventType */ "b"])(this.geometryName_), this.handleGeometryChanged_, this);\n    this.geometryName_ = name;\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__[/* listen */ "a"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_3__[/* getChangeEventType */ "b"])(this.geometryName_), this.handleGeometryChanged_, this);\n    this.handleGeometryChanged_();\n  };\n\n  return Feature;\n}(_Object_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]);\n/**\n * Convert the provided object into a feature style function.  Functions passed\n * through unchanged.  Arrays of Style or single style objects wrapped\n * in a new feature style function.\n * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj\n *     A feature style function, a single style, or an array of styles.\n * @return {import("./style/Style.js").StyleFunction} A style function.\n */\n\n\nfunction createStyleFunction(obj) {\n  if (typeof obj === \'function\') {\n    return obj;\n  } else {\n    /**\n     * @type {Array<import("./style/Style.js").default>}\n     */\n    var styles;\n\n    if (Array.isArray(obj)) {\n      styles = obj;\n    } else {\n      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(typeof\n      /** @type {?} */\n      obj.getZIndex === \'function\', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`\n\n      var style =\n      /** @type {import("./style/Style.js").default} */\n      obj;\n      styles = [style];\n    }\n\n    return function () {\n      return styles;\n    };\n  }\n}\n/* harmony default export */ __webpack_exports__["default"] = (Feature);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL0ZlYXR1cmUuanM/YTYyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvRmVhdHVyZVxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QsIHtnZXRDaGFuZ2VFdmVudFR5cGV9IGZyb20gJy4vT2JqZWN0LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7dHlwZW9mIEZlYXR1cmV8dHlwZW9mIGltcG9ydChcIi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZUNsYXNzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RmVhdHVyZXxpbXBvcnQoXCIuL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IEZlYXR1cmVMaWtlXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBIHZlY3RvciBvYmplY3QgZm9yIGdlb2dyYXBoaWMgZmVhdHVyZXMgd2l0aCBhIGdlb21ldHJ5IGFuZCBvdGhlclxuICogYXR0cmlidXRlIHByb3BlcnRpZXMsIHNpbWlsYXIgdG8gdGhlIGZlYXR1cmVzIGluIHZlY3RvciBmaWxlIGZvcm1hdHMgbGlrZVxuICogR2VvSlNPTi5cbiAqXG4gKiBGZWF0dXJlcyBjYW4gYmUgc3R5bGVkIGluZGl2aWR1YWxseSB3aXRoIGBzZXRTdHlsZWA7IG90aGVyd2lzZSB0aGV5IHVzZSB0aGVcbiAqIHN0eWxlIG9mIHRoZWlyIHZlY3RvciBsYXllci5cbiAqXG4gKiBOb3RlIHRoYXQgYXR0cmlidXRlIHByb3BlcnRpZXMgYXJlIHNldCBhcyB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH0gcHJvcGVydGllcyBvblxuICogdGhlIGZlYXR1cmUgb2JqZWN0LCBzbyB0aGV5IGFyZSBvYnNlcnZhYmxlLCBhbmQgaGF2ZSBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBUeXBpY2FsbHksIGEgZmVhdHVyZSBoYXMgYSBzaW5nbGUgZ2VvbWV0cnkgcHJvcGVydHkuIFlvdSBjYW4gc2V0IHRoZVxuICogZ2VvbWV0cnkgdXNpbmcgdGhlIGBzZXRHZW9tZXRyeWAgbWV0aG9kIGFuZCBnZXQgaXQgd2l0aCBgZ2V0R2VvbWV0cnlgLlxuICogSXQgaXMgcG9zc2libGUgdG8gc3RvcmUgbW9yZSB0aGFuIG9uZSBnZW9tZXRyeSBvbiBhIGZlYXR1cmUgdXNpbmcgYXR0cmlidXRlXG4gKiBwcm9wZXJ0aWVzLiBCeSBkZWZhdWx0LCB0aGUgZ2VvbWV0cnkgdXNlZCBmb3IgcmVuZGVyaW5nIGlzIGlkZW50aWZpZWQgYnlcbiAqIHRoZSBwcm9wZXJ0eSBuYW1lIGBnZW9tZXRyeWAuIElmIHlvdSB3YW50IHRvIHVzZSBhbm90aGVyIGdlb21ldHJ5IHByb3BlcnR5XG4gKiBmb3IgcmVuZGVyaW5nLCB1c2UgdGhlIGBzZXRHZW9tZXRyeU5hbWVgIG1ldGhvZCB0byBjaGFuZ2UgdGhlIGF0dHJpYnV0ZVxuICogcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuICBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICpcbiAqIGltcG9ydCBGZWF0dXJlIGZyb20gJ29sL0ZlYXR1cmUnO1xuICogaW1wb3J0IFBvbHlnb24gZnJvbSAnb2wvZ2VvbS9Qb2x5Z29uJztcbiAqIGltcG9ydCBQb2ludCBmcm9tICdvbC9nZW9tL1BvaW50JztcbiAqXG4gKiB2YXIgZmVhdHVyZSA9IG5ldyBGZWF0dXJlKHtcbiAqICAgZ2VvbWV0cnk6IG5ldyBQb2x5Z29uKHBvbHlDb29yZHMpLFxuICogICBsYWJlbFBvaW50OiBuZXcgUG9pbnQobGFiZWxDb29yZHMpLFxuICogICBuYW1lOiAnTXkgUG9seWdvbidcbiAqIH0pO1xuICpcbiAqIC8vIGdldCB0aGUgcG9seWdvbiBnZW9tZXRyeVxuICogdmFyIHBvbHkgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gKlxuICogLy8gUmVuZGVyIHRoZSBmZWF0dXJlIGFzIGEgcG9pbnQgdXNpbmcgdGhlIGNvb3JkaW5hdGVzIGZyb20gbGFiZWxQb2ludFxuICogZmVhdHVyZS5zZXRHZW9tZXRyeU5hbWUoJ2xhYmVsUG9pbnQnKTtcbiAqXG4gKiAvLyBnZXQgdGhlIHBvaW50IGdlb21ldHJ5XG4gKiB2YXIgcG9pbnQgPSBmZWF0dXJlLmdldEdlb21ldHJ5KCk7XG4gKiBgYGBcbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEZlYXR1cmUgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8T2JqZWN0PHN0cmluZywgKj49fSBvcHRfZ2VvbWV0cnlPclByb3BlcnRpZXNcbiAgICogICAgIFlvdSBtYXkgcGFzcyBhIEdlb21ldHJ5IG9iamVjdCBkaXJlY3RseSwgb3IgYW4gb2JqZWN0IGxpdGVyYWwgY29udGFpbmluZ1xuICAgKiAgICAgcHJvcGVydGllcy4gSWYgeW91IHBhc3MgYW4gb2JqZWN0IGxpdGVyYWwsIHlvdSBtYXkgaW5jbHVkZSBhIEdlb21ldHJ5XG4gICAqICAgICBhc3NvY2lhdGVkIHdpdGggYSBgZ2VvbWV0cnlgIGtleS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9nZW9tZXRyeU9yUHJvcGVydGllcykge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuaWRfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlOYW1lXyA9ICdnZW9tZXRyeSc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VyIHByb3ZpZGVkIHN0eWxlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfVxuICAgICAqL1xuICAgIHRoaXMuc3R5bGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBudWxsO1xuXG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKHRoaXMuZ2VvbWV0cnlOYW1lXyksXG4gICAgICB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlZF8sIHRoaXMpO1xuXG4gICAgaWYgKG9wdF9nZW9tZXRyeU9yUHJvcGVydGllcykge1xuICAgICAgaWYgKHR5cGVvZiAvKiogQHR5cGUgez99ICovIChvcHRfZ2VvbWV0cnlPclByb3BlcnRpZXMpLmdldFNpbXBsaWZpZWRHZW9tZXRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChvcHRfZ2VvbWV0cnlPclByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnNldEdlb21ldHJ5KGdlb21ldHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59ICovXG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBvcHRfZ2VvbWV0cnlPclByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmUgdGhpcyBmZWF0dXJlLiBJZiB0aGUgb3JpZ2luYWwgZmVhdHVyZSBoYXMgYSBnZW9tZXRyeSBpdFxuICAgKiBpcyBhbHNvIGNsb25lZC4gVGhlIGZlYXR1cmUgaWQgaXMgbm90IHNldCBpbiB0aGUgY2xvbmUuXG4gICAqIEByZXR1cm4ge0ZlYXR1cmV9IFRoZSBjbG9uZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgRmVhdHVyZSh0aGlzLmdldFByb3BlcnRpZXMoKSk7XG4gICAgY2xvbmUuc2V0R2VvbWV0cnlOYW1lKHRoaXMuZ2V0R2VvbWV0cnlOYW1lKCkpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgY2xvbmUuc2V0R2VvbWV0cnkoZ2VvbWV0cnkuY2xvbmUoKSk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgY2xvbmUuc2V0U3R5bGUoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlJ3MgZGVmYXVsdCBnZW9tZXRyeS4gIEEgZmVhdHVyZSBtYXkgaGF2ZSBhbnkgbnVtYmVyIG9mIG5hbWVkXG4gICAqIGdlb21ldHJpZXMuICBUaGUgXCJkZWZhdWx0XCIgZ2VvbWV0cnkgKHRoZSBvbmUgdGhhdCBpcyByZW5kZXJlZCBieSBkZWZhdWx0KSBpc1xuICAgKiBzZXQgd2hlbiBjYWxsaW5nIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI3NldEdlb21ldHJ5fS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgZGVmYXVsdCBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICogQG9ic2VydmFibGVcbiAgICovXG4gIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KHRoaXMuZ2VvbWV0cnlOYW1lXykpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlYXR1cmUgaWRlbnRpZmllci4gIFRoaXMgaXMgYSBzdGFibGUgaWRlbnRpZmllciBmb3IgdGhlIGZlYXR1cmUgYW5kXG4gICAqIGlzIGVpdGhlciBzZXQgd2hlbiByZWFkaW5nIGRhdGEgZnJvbSBhIHJlbW90ZSBzb3VyY2Ugb3Igc2V0IGV4cGxpY2l0bHkgYnlcbiAgICogY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNzZXRJZH0uXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd8dW5kZWZpbmVkfSBJZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuICBCeSBkZWZhdWx0LCB0aGUgZGVmYXVsdFxuICAgKiBnZW9tZXRyeSBpcyBuYW1lZCBgZ2VvbWV0cnlgLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEdldCB0aGUgcHJvcGVydHkgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGRlZmF1bHQgZ2VvbWV0cnlcbiAgICogICAgIGZvciB0aGlzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEdlb21ldHJ5TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5hbWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmVhdHVyZSdzIHN0eWxlLiBXaWxsIHJldHVybiB3aGF0IHdhcyBwcm92aWRlZCB0byB0aGVcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9GZWF0dXJlfkZlYXR1cmUjc2V0U3R5bGV9IG1ldGhvZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFRoZSBmZWF0dXJlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlJ3Mgc3R5bGUgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9IFJldHVybiBhIGZ1bmN0aW9uXG4gICAqIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdHlsZSBvZiB0aGlzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0eWxlRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVGdW5jdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUdlb21ldHJ5Q2hhbmdlXygpIHtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXygpIHtcbiAgICBpZiAodGhpcy5nZW9tZXRyeUNoYW5nZUtleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5nZW9tZXRyeUNoYW5nZUtleV8pO1xuICAgICAgdGhpcy5nZW9tZXRyeUNoYW5nZUtleV8gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlDaGFuZ2VLZXlfID0gbGlzdGVuKGdlb21ldHJ5LFxuICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZUdlb21ldHJ5Q2hhbmdlXywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCBnZW9tZXRyeSBmb3IgdGhlIGZlYXR1cmUuICBUaGlzIHdpbGwgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgKiB3aXRoIHRoZSBuYW1lIHJldHVybmVkIGJ5IHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX5GZWF0dXJlI2dldEdlb21ldHJ5TmFtZX0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBnZW9tZXRyeSBUaGUgbmV3IGdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqL1xuICBzZXRHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIHRoaXMuc2V0KHRoaXMuZ2VvbWV0cnlOYW1lXywgZ2VvbWV0cnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3R5bGUgZm9yIHRoZSBmZWF0dXJlLiAgVGhpcyBjYW4gYmUgYSBzaW5nbGUgc3R5bGUgb2JqZWN0LCBhbiBhcnJheVxuICAgKiBvZiBzdHlsZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHJlc29sdXRpb24gYW5kIHJldHVybnMgYW4gYXJyYXkgb2ZcbiAgICogc3R5bGVzLiBJZiBpdCBpcyBgbnVsbGAgdGhlIGZlYXR1cmUgaGFzIG5vIHN0eWxlIChhIGBudWxsYCBzdHlsZSkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IHN0eWxlIFN0eWxlIGZvciB0aGlzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICogQGZpcmVzIG1vZHVsZTpvbC9ldmVudHMvRXZlbnR+RXZlbnQjZXZlbnQ6Y2hhbmdlXG4gICAqL1xuICBzZXRTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuc3R5bGVfID0gc3R5bGU7XG4gICAgdGhpcy5zdHlsZUZ1bmN0aW9uXyA9ICFzdHlsZSA/IHVuZGVmaW5lZCA6IGNyZWF0ZVN0eWxlRnVuY3Rpb24oc3R5bGUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmVhdHVyZSBpZC4gIFRoZSBmZWF0dXJlIGlkIGlzIGNvbnNpZGVyZWQgc3RhYmxlIGFuZCBtYXkgYmUgdXNlZCB3aGVuXG4gICAqIHJlcXVlc3RpbmcgZmVhdHVyZXMgb3IgY29tcGFyaW5nIGlkZW50aWZpZXJzIHJldHVybmVkIGZyb20gYSByZW1vdGUgc291cmNlLlxuICAgKiBUaGUgZmVhdHVyZSBpZCBjYW4gYmUgdXNlZCB3aXRoIHRoZVxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2dldEZlYXR1cmVCeUlkfSBtZXRob2QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3x1bmRlZmluZWR9IGlkIFRoZSBmZWF0dXJlIGlkLlxuICAgKiBAYXBpXG4gICAqIEBmaXJlcyBtb2R1bGU6b2wvZXZlbnRzL0V2ZW50fkV2ZW50I2V2ZW50OmNoYW5nZVxuICAgKi9cbiAgc2V0SWQoaWQpIHtcbiAgICB0aGlzLmlkXyA9IGlkO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcHJvcGVydHkgbmFtZSB0byBiZSB1c2VkIHdoZW4gZ2V0dGluZyB0aGUgZmVhdHVyZSdzIGRlZmF1bHQgZ2VvbWV0cnkuXG4gICAqIFdoZW4gY2FsbGluZyB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZSNnZXRHZW9tZXRyeX0sIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aFxuICAgKiB0aGlzIG5hbWUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGRlZmF1bHQgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEdlb21ldHJ5TmFtZShuYW1lKSB7XG4gICAgdW5saXN0ZW4oXG4gICAgICB0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUodGhpcy5nZW9tZXRyeU5hbWVfKSxcbiAgICAgIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXywgdGhpcyk7XG4gICAgdGhpcy5nZW9tZXRyeU5hbWVfID0gbmFtZTtcbiAgICBsaXN0ZW4oXG4gICAgICB0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUodGhpcy5nZW9tZXRyeU5hbWVfKSxcbiAgICAgIHRoaXMuaGFuZGxlR2VvbWV0cnlDaGFuZ2VkXywgdGhpcyk7XG4gICAgdGhpcy5oYW5kbGVHZW9tZXRyeUNoYW5nZWRfKCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHByb3ZpZGVkIG9iamVjdCBpbnRvIGEgZmVhdHVyZSBzdHlsZSBmdW5jdGlvbi4gIEZ1bmN0aW9ucyBwYXNzZWRcbiAqIHRocm91Z2ggdW5jaGFuZ2VkLiAgQXJyYXlzIG9mIFN0eWxlIG9yIHNpbmdsZSBzdHlsZSBvYmplY3RzIHdyYXBwZWRcbiAqIGluIGEgbmV3IGZlYXR1cmUgc3R5bGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyFpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258IUFycmF5PGltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD58IWltcG9ydChcIi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gb2JqXG4gKiAgICAgQSBmZWF0dXJlIHN0eWxlIGZ1bmN0aW9uLCBhIHNpbmdsZSBzdHlsZSwgb3IgYW4gYXJyYXkgb2Ygc3R5bGVzLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3R5bGVGdW5jdGlvbihvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIGxldCBzdHlsZXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgc3R5bGVzID0gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9iaikuZ2V0WkluZGV4ID09PSAnZnVuY3Rpb24nLFxuICAgICAgICA0MSk7IC8vIEV4cGVjdGVkIGFuIGBpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlYCBvciBhbiBhcnJheSBvZiBgaW1wb3J0KFwiLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZWBcbiAgICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9ICovIChvYmopO1xuICAgICAgc3R5bGVzID0gW3N0eWxlXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBGZWF0dXJlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTtBQUFBO0FBQUE7QUFPQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFHQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQXJOQTs7Ozs7Ozs7Ozs7QUFnT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///59\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);\n/**\n * @module ol/proj/Projection\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import("./Units.js").default|string} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation=\'enu\'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}\n * lookup table.\n * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns\n * the `{number}` resolution at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj#getPointResolution} function will be used.\n */\n\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj~get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4~register} function.\n *\n * @api\n */\n\nvar Projection = function Projection(options) {\n  /**\n   * @private\n   * @type {string}\n   */\n  this.code_ = options.code;\n  /**\n   * Units of projected coordinates. When set to `TILE_PIXELS`, a\n   * `this.extent_` and `this.worldExtent_` must be configured properly for each\n   * tile.\n   * @private\n   * @type {import("./Units.js").default}\n   */\n\n  this.units_ =\n  /** @type {import("./Units.js").default} */\n  options.units;\n  /**\n   * Validity extent of the projection in projected coordinates. For projections\n   * with `TILE_PIXELS` units, this is the extent of the tile in\n   * tile pixel space.\n   * @private\n   * @type {import("../extent.js").Extent}\n   */\n\n  this.extent_ = options.extent !== undefined ? options.extent : null;\n  /**\n   * Extent of the world in EPSG:4326. For projections with\n   * `TILE_PIXELS` units, this is the extent of the tile in\n   * projected coordinate space.\n   * @private\n   * @type {import("../extent.js").Extent}\n   */\n\n  this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;\n  /**\n   * @private\n   * @type {string}\n   */\n\n  this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : \'enu\';\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.global_ = options.global !== undefined ? options.global : false;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.canWrapX_ = !!(this.global_ && this.extent_);\n  /**\n   * @private\n   * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}\n   */\n\n  this.getPointResolutionFunc_ = options.getPointResolution;\n  /**\n   * @private\n   * @type {import("../tilegrid/TileGrid.js").default}\n   */\n\n  this.defaultTileGrid_ = null;\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n\n  this.metersPerUnit_ = options.metersPerUnit;\n};\n/**\n * @return {boolean} The projection is suitable for wrapping the x-axis\n */\n\n\nProjection.prototype.canWrapX = function canWrapX() {\n  return this.canWrapX_;\n};\n/**\n * Get the code for this projection, e.g. \'EPSG:4326\'.\n * @return {string} Code.\n * @api\n */\n\n\nProjection.prototype.getCode = function getCode() {\n  return this.code_;\n};\n/**\n * Get the validity extent for this projection.\n * @return {import("../extent.js").Extent} Extent.\n * @api\n */\n\n\nProjection.prototype.getExtent = function getExtent() {\n  return this.extent_;\n};\n/**\n * Get the units of this projection.\n * @return {import("./Units.js").default} Units.\n * @api\n */\n\n\nProjection.prototype.getUnits = function getUnits() {\n  return this.units_;\n};\n/**\n * Get the amount of meters per unit of this projection.If the projection is\n * not configured with `metersPerUnit` or a units identifier, the return is\n * `undefined`.\n * @return {number|undefined} Meters.\n * @api\n */\n\n\nProjection.prototype.getMetersPerUnit = function getMetersPerUnit() {\n  return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__[/* METERS_PER_UNIT */ "a"][this.units_];\n};\n/**\n * Get the world extent for this projection.\n * @return {import("../extent.js").Extent} Extent.\n * @api\n */\n\n\nProjection.prototype.getWorldExtent = function getWorldExtent() {\n  return this.worldExtent_;\n};\n/**\n * Get the axis orientation of this projection.\n * Example values are:\n * enu - the default easting, northing, elevation.\n * neu - northing, easting, up - useful for "lat/long" geographic coordinates,\n *   or south orientated transverse mercator.\n * wnu - westing, northing, up - some planetary coordinate systems have\n *   "west positive" coordinate systems\n * @return {string} Axis orientation.\n * @api\n */\n\n\nProjection.prototype.getAxisOrientation = function getAxisOrientation() {\n  return this.axisOrientation_;\n};\n/**\n * Is this projection a global projection which spans the whole world?\n * @return {boolean} Whether the projection is global.\n * @api\n */\n\n\nProjection.prototype.isGlobal = function isGlobal() {\n  return this.global_;\n};\n/**\n * Set if the projection is a global projection which spans the whole world\n * @param {boolean} global Whether the projection is global.\n * @api\n */\n\n\nProjection.prototype.setGlobal = function setGlobal(global) {\n  this.global_ = global;\n  this.canWrapX_ = !!(global && this.extent_);\n};\n/**\n * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.\n */\n\n\nProjection.prototype.getDefaultTileGrid = function getDefaultTileGrid() {\n  return this.defaultTileGrid_;\n};\n/**\n * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.\n */\n\n\nProjection.prototype.setDefaultTileGrid = function setDefaultTileGrid(tileGrid) {\n  this.defaultTileGrid_ = tileGrid;\n};\n/**\n * Set the validity extent for this projection.\n * @param {import("../extent.js").Extent} extent Extent.\n * @api\n */\n\n\nProjection.prototype.setExtent = function setExtent(extent) {\n  this.extent_ = extent;\n  this.canWrapX_ = !!(this.global_ && extent);\n};\n/**\n * Set the world extent for this projection.\n * @param {import("../extent.js").Extent} worldExtent World extent\n *   [minlon, minlat, maxlon, maxlat].\n * @api\n */\n\n\nProjection.prototype.setWorldExtent = function setWorldExtent(worldExtent) {\n  this.worldExtent_ = worldExtent;\n};\n/**\n * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}\n * for this projection.\n * @param {function(number, import("../coordinate.js").Coordinate):number} func Function\n * @api\n */\n\n\nProjection.prototype.setGetPointResolution = function setGetPointResolution(func) {\n  this.getPointResolutionFunc_ = func;\n};\n/**\n * Get the custom point resolution function for this projection (if set).\n * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point\n * resolution function (if set).\n */\n\n\nProjection.prototype.getPointResolutionFunc = function getPointResolutionFunc() {\n  return this.getPointResolutionFunc_;\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (Projection);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3Byb2ovUHJvamVjdGlvbi5qcz8wY2ZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9wcm9qL1Byb2plY3Rpb25cbiAqL1xuaW1wb3J0IHtNRVRFUlNfUEVSX1VOSVR9IGZyb20gJy4vVW5pdHMuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvZGUgVGhlIFNSUyBpZGVudGlmaWVyIGNvZGUsIGUuZy4gYEVQU0c6NDMyNmAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVW5pdHMuanNcIikuZGVmYXVsdHxzdHJpbmd9IFt1bml0c10gVW5pdHMuIFJlcXVpcmVkIHVubGVzcyBhXG4gKiBwcm9qNCBwcm9qZWN0aW9uIGlzIGRlZmluZWQgZm9yIGBjb2RlYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhlIFNSUy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXhpc09yaWVudGF0aW9uPSdlbnUnXSBUaGUgYXhpcyBvcmllbnRhdGlvbiBhcyBzcGVjaWZpZWQgaW4gUHJvajQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnbG9iYWw9ZmFsc2VdIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgdmFsaWQgZm9yIHRoZSB3aG9sZSBnbG9iZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWV0ZXJzUGVyVW5pdF0gVGhlIG1ldGVycyBwZXIgdW5pdCBmb3IgdGhlIFNSUy5cbiAqIElmIG5vdCBwcm92aWRlZCwgdGhlIGB1bml0c2AgYXJlIHVzZWQgdG8gZ2V0IHRoZSBtZXRlcnMgcGVyIHVuaXQgZnJvbSB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1VuaXRzfk1FVEVSU19QRVJfVU5JVH1cbiAqIGxvb2t1cCB0YWJsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW3dvcmxkRXh0ZW50XSBUaGUgd29ybGQgZXh0ZW50IGZvciB0aGUgU1JTLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihudW1iZXIsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6bnVtYmVyfSBbZ2V0UG9pbnRSZXNvbHV0aW9uXVxuICogRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHJlc29sdXRpb24gYXQgYSBwb2ludC4gVGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAqIGB7bnVtYmVyfWAgdmlldyByZXNvbHV0aW9uIGFuZCBhbiBge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1gIGFzIGFyZ3VtZW50cywgYW5kIHJldHVybnNcbiAqIHRoZSBge251bWJlcn1gIHJlc29sdXRpb24gYXQgdGhlIHBhc3NlZCBjb29yZGluYXRlLiBJZiB0aGlzIGlzIGB1bmRlZmluZWRgLFxuICogdGhlIGRlZmF1bHQge0BsaW5rIG1vZHVsZTpvbC9wcm9qI2dldFBvaW50UmVzb2x1dGlvbn0gZnVuY3Rpb24gd2lsbCBiZSB1c2VkLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcm9qZWN0aW9uIGRlZmluaXRpb24gY2xhc3MuIE9uZSBvZiB0aGVzZSBpcyBjcmVhdGVkIGZvciBlYWNoIHByb2plY3Rpb25cbiAqIHN1cHBvcnRlZCBpbiB0aGUgYXBwbGljYXRpb24gYW5kIHN0b3JlZCBpbiB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qfSBuYW1lc3BhY2UuXG4gKiBZb3UgY2FuIHVzZSB0aGVzZSBpbiBhcHBsaWNhdGlvbnMsIGJ1dCB0aGlzIGlzIG5vdCByZXF1aXJlZCwgYXMgQVBJIHBhcmFtc1xuICogYW5kIG9wdGlvbnMgdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5Qcm9qZWN0aW9uTGlrZX0gd2hpY2ggbWVhbnMgdGhlIHNpbXBsZSBzdHJpbmdcbiAqIGNvZGUgd2lsbCBzdWZmaWNlLlxuICpcbiAqIFlvdSBjYW4gdXNlIHtAbGluayBtb2R1bGU6b2wvcHJvan5nZXR9IHRvIHJldHJpZXZlIHRoZSBvYmplY3QgZm9yIGEgcGFydGljdWxhclxuICogcHJvamVjdGlvbi5cbiAqXG4gKiBUaGUgbGlicmFyeSBpbmNsdWRlcyBkZWZpbml0aW9ucyBmb3IgYEVQU0c6NDMyNmAgYW5kIGBFUFNHOjM4NTdgLCB0b2dldGhlclxuICogd2l0aCB0aGUgZm9sbG93aW5nIGFsaWFzZXM6XG4gKiAqIGBFUFNHOjQzMjZgOiBDUlM6ODQsIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuNjo0MzI2LFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpPR0M6MS4zOkNSUzg0LCB1cm46b2djOmRlZjpjcnM6T0dDOjI6ODQsXG4gKiAgICAgaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9nbWwvc3JzL2Vwc2cueG1sIzQzMjYsXG4gKiAgICAgdXJuOngtb2djOmRlZjpjcnM6RVBTRzo0MzI2XG4gKiAqIGBFUFNHOjM4NTdgOiBFUFNHOjEwMjEwMCwgRVBTRzoxMDIxMTMsIEVQU0c6OTAwOTEzLFxuICogICAgIHVybjpvZ2M6ZGVmOmNyczpFUFNHOjYuMTg6MzozODU3LFxuICogICAgIGh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sL3Nycy9lcHNnLnhtbCMzODU3XG4gKlxuICogSWYgeW91IHVzZSBbcHJvajRqc10oaHR0cHM6Ly9naXRodWIuY29tL3Byb2o0anMvcHJvajRqcyksIGFsaWFzZXMgY2FuXG4gKiBiZSBhZGRlZCB1c2luZyBgcHJvajQuZGVmcygpYC4gQWZ0ZXIgYWxsIHJlcXVpcmVkIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgYXJlXG4gKiBhZGRlZCwgY2FsbCB0aGUge0BsaW5rIG1vZHVsZTpvbC9wcm9qL3Byb2o0fnJlZ2lzdGVyfSBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFByb2plY3Rpb24ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgUHJvamVjdGlvbiBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNvZGVfID0gb3B0aW9ucy5jb2RlO1xuXG4gICAgLyoqXG4gICAgICogVW5pdHMgb2YgcHJvamVjdGVkIGNvb3JkaW5hdGVzLiBXaGVuIHNldCB0byBgVElMRV9QSVhFTFNgLCBhXG4gICAgICogYHRoaXMuZXh0ZW50X2AgYW5kIGB0aGlzLndvcmxkRXh0ZW50X2AgbXVzdCBiZSBjb25maWd1cmVkIHByb3Blcmx5IGZvciBlYWNoXG4gICAgICogdGlsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1VuaXRzLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy51bml0c18gPSAvKiogQHR5cGUge2ltcG9ydChcIi4vVW5pdHMuanNcIikuZGVmYXVsdH0gKi8gKG9wdGlvbnMudW5pdHMpO1xuXG4gICAgLyoqXG4gICAgICogVmFsaWRpdHkgZXh0ZW50IG9mIHRoZSBwcm9qZWN0aW9uIGluIHByb2plY3RlZCBjb29yZGluYXRlcy4gRm9yIHByb2plY3Rpb25zXG4gICAgICogd2l0aCBgVElMRV9QSVhFTFNgIHVuaXRzLCB0aGlzIGlzIHRoZSBleHRlbnQgb2YgdGhlIHRpbGUgaW5cbiAgICAgKiB0aWxlIHBpeGVsIHNwYWNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRfID0gb3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0ZW50IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEV4dGVudCBvZiB0aGUgd29ybGQgaW4gRVBTRzo0MzI2LiBGb3IgcHJvamVjdGlvbnMgd2l0aFxuICAgICAqIGBUSUxFX1BJWEVMU2AgdW5pdHMsIHRoaXMgaXMgdGhlIGV4dGVudCBvZiB0aGUgdGlsZSBpblxuICAgICAqIHByb2plY3RlZCBjb29yZGluYXRlIHNwYWNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZEV4dGVudF8gPSBvcHRpb25zLndvcmxkRXh0ZW50ICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy53b3JsZEV4dGVudCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5heGlzT3JpZW50YXRpb25fID0gb3B0aW9ucy5heGlzT3JpZW50YXRpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLmF4aXNPcmllbnRhdGlvbiA6ICdlbnUnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdsb2JhbF8gPSBvcHRpb25zLmdsb2JhbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5nbG9iYWwgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgdGhpcy5leHRlbnRfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG51bWJlciwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTpudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBvcHRpb25zLmdldFBvaW50UmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0VGlsZUdyaWRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5tZXRlcnNQZXJVbml0XyA9IG9wdGlvbnMubWV0ZXJzUGVyVW5pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcHJvamVjdGlvbiBpcyBzdWl0YWJsZSBmb3Igd3JhcHBpbmcgdGhlIHgtYXhpc1xuICAgKi9cbiAgY2FuV3JhcFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuV3JhcFhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29kZSBmb3IgdGhpcyBwcm9qZWN0aW9uLCBlLmcuICdFUFNHOjQzMjYnLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvZGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWxpZGl0eSBleHRlbnQgZm9yIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVuaXRzIG9mIHRoaXMgcHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9Vbml0cy5qc1wiKS5kZWZhdWx0fSBVbml0cy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VW5pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5pdHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW1vdW50IG9mIG1ldGVycyBwZXIgdW5pdCBvZiB0aGlzIHByb2plY3Rpb24uICBJZiB0aGUgcHJvamVjdGlvbiBpc1xuICAgKiBub3QgY29uZmlndXJlZCB3aXRoIGBtZXRlcnNQZXJVbml0YCBvciBhIHVuaXRzIGlkZW50aWZpZXIsIHRoZSByZXR1cm4gaXNcbiAgICogYHVuZGVmaW5lZGAuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IE1ldGVycy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWV0ZXJzUGVyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRlcnNQZXJVbml0XyB8fCBNRVRFUlNfUEVSX1VOSVRbdGhpcy51bml0c19dO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd29ybGQgZXh0ZW50IGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0V29ybGRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMud29ybGRFeHRlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXhpcyBvcmllbnRhdGlvbiBvZiB0aGlzIHByb2plY3Rpb24uXG4gICAqIEV4YW1wbGUgdmFsdWVzIGFyZTpcbiAgICogZW51IC0gdGhlIGRlZmF1bHQgZWFzdGluZywgbm9ydGhpbmcsIGVsZXZhdGlvbi5cbiAgICogbmV1IC0gbm9ydGhpbmcsIGVhc3RpbmcsIHVwIC0gdXNlZnVsIGZvciBcImxhdC9sb25nXCIgZ2VvZ3JhcGhpYyBjb29yZGluYXRlcyxcbiAgICogICAgIG9yIHNvdXRoIG9yaWVudGF0ZWQgdHJhbnN2ZXJzZSBtZXJjYXRvci5cbiAgICogd251IC0gd2VzdGluZywgbm9ydGhpbmcsIHVwIC0gc29tZSBwbGFuZXRhcnkgY29vcmRpbmF0ZSBzeXN0ZW1zIGhhdmVcbiAgICogICAgIFwid2VzdCBwb3NpdGl2ZVwiIGNvb3JkaW5hdGUgc3lzdGVtc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEF4aXMgb3JpZW50YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEF4aXNPcmllbnRhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzT3JpZW50YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgcHJvamVjdGlvbiBhIGdsb2JhbCBwcm9qZWN0aW9uIHdoaWNoIHNwYW5zIHRoZSB3aG9sZSB3b3JsZD9cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvamVjdGlvbiBpcyBnbG9iYWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGlzR2xvYmFsKCkge1xuICAgIHJldHVybiB0aGlzLmdsb2JhbF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGlmIHRoZSBwcm9qZWN0aW9uIGlzIGEgZ2xvYmFsIHByb2plY3Rpb24gd2hpY2ggc3BhbnMgdGhlIHdob2xlIHdvcmxkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ2xvYmFsIFdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgZ2xvYmFsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHbG9iYWwoZ2xvYmFsKSB7XG4gICAgdGhpcy5nbG9iYWxfID0gZ2xvYmFsO1xuICAgIHRoaXMuY2FuV3JhcFhfID0gISEoZ2xvYmFsICYmIHRoaXMuZXh0ZW50Xyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gVGhlIGRlZmF1bHQgdGlsZSBncmlkLlxuICAgKi9cbiAgZ2V0RGVmYXVsdFRpbGVHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRUaWxlR3JpZF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaGUgZGVmYXVsdCB0aWxlIGdyaWQuXG4gICAqL1xuICBzZXREZWZhdWx0VGlsZUdyaWQodGlsZUdyaWQpIHtcbiAgICB0aGlzLmRlZmF1bHRUaWxlR3JpZF8gPSB0aWxlR3JpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbGlkaXR5IGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEV4dGVudChleHRlbnQpIHtcbiAgICB0aGlzLmV4dGVudF8gPSBleHRlbnQ7XG4gICAgdGhpcy5jYW5XcmFwWF8gPSAhISh0aGlzLmdsb2JhbF8gJiYgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdvcmxkIGV4dGVudCBmb3IgdGhpcyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IHdvcmxkRXh0ZW50IFdvcmxkIGV4dGVudFxuICAgKiAgICAgW21pbmxvbiwgbWlubGF0LCBtYXhsb24sIG1heGxhdF0uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFdvcmxkRXh0ZW50KHdvcmxkRXh0ZW50KSB7XG4gICAgdGhpcy53b3JsZEV4dGVudF8gPSB3b3JsZEV4dGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGdldFBvaW50UmVzb2x1dGlvbiBmdW5jdGlvbiAoc2VlIHtAbGluayBtb2R1bGU6b2wvcHJvan5nZXRQb2ludFJlc29sdXRpb259XG4gICAqIGZvciB0aGlzIHByb2plY3Rpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcn0gZnVuYyBGdW5jdGlvblxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHZXRQb2ludFJlc29sdXRpb24oZnVuYykge1xuICAgIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY18gPSBmdW5jO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VzdG9tIHBvaW50IHJlc29sdXRpb24gZnVuY3Rpb24gZm9yIHRoaXMgcHJvamVjdGlvbiAoaWYgc2V0KS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUpOm51bWJlcnx1bmRlZmluZWR9IFRoZSBjdXN0b20gcG9pbnRcbiAgICogcmVzb2x1dGlvbiBmdW5jdGlvbiAoaWYgc2V0KS5cbiAgICovXG4gIGdldFBvaW50UmVzb2x1dGlvbkZ1bmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRSZXNvbHV0aW9uRnVuY187XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvamVjdGlvbjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtEQTtBQU1BOzs7O0FBSUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUVBOzs7Ozs7OztBQU9BO0FBR0E7Ozs7O0FBSUE7QUFHQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///60\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return intersectsLineString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return intersectsLineStringArray; });\n/* unused harmony export intersectsLinearRing */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return intersectsLinearRingArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return intersectsLinearRingMultiArray; });\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);\n/* harmony import */ var _segments_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95);\n/**\n * @module ol/geom/flat/intersectsextent\n */\n\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import("../../extent.js").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nfunction intersectsLineString(flatCoordinates, offset, end, stride, extent) {\n  var coordinatesExtent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["extendFlatCoordinates"])(Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["createEmpty"])(), flatCoordinates, offset, end, stride);\n\n  if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersects"])(extent, coordinatesExtent)) {\n    return false;\n  }\n\n  if (Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["containsExtent"])(extent, coordinatesExtent)) {\n    return true;\n  }\n\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n\n  return Object(_segments_js__WEBPACK_IMPORTED_MODULE_2__[/* forEach */ "a"])(flatCoordinates, offset, end, stride,\n  /**\n   * @param {import("../../coordinate.js").Coordinate} point1 Start point.\n   * @param {import("../../coordinate.js").Coordinate} point2 End point.\n   * @return {boolean} `true` if the segment and the extent intersect,\n   *     `false` otherwise.\n   */\n  function (point1, point2) {\n    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_0__["intersectsSegment"])(extent, point1, point2);\n  });\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import("../../extent.js").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nfunction intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {\n      return true;\n    }\n\n    offset = ends[i];\n  }\n\n  return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import("../../extent.js").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nfunction intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n\n  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__[/* linearRingContainsXY */ "b"])(flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n    return true;\n  }\n\n  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__[/* linearRingContainsXY */ "b"])(flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n    return true;\n  }\n\n  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__[/* linearRingContainsXY */ "b"])(flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n    return true;\n  }\n\n  if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__[/* linearRingContainsXY */ "b"])(flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import("../../extent.js").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nfunction intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n\n  if (ends.length === 1) {\n    return true;\n  }\n\n  for (var i = 1, ii = ends.length; i < ii; ++i) {\n    if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__[/* linearRingContainsExtent */ "a"])(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import("../../extent.js").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\n\nfunction intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n\n    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {\n      return true;\n    }\n\n    offset = ends[ends.length - 1];\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzP2ZkODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcnNlY3RzZXh0ZW50XG4gKi9cbmltcG9ydCB7Y29udGFpbnNFeHRlbnQsIGNyZWF0ZUVtcHR5LCBleHRlbmRGbGF0Q29vcmRpbmF0ZXMsIGludGVyc2VjdHMsIGludGVyc2VjdHNTZWdtZW50fSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nQ29udGFpbnNYWSwgbGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50fSBmcm9tICcuL2NvbnRhaW5zLmpzJztcbmltcG9ydCB7Zm9yRWFjaCBhcyBmb3JFYWNoU2VnbWVudH0gZnJvbSAnLi9zZWdtZW50cy5qcyc7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0c0xpbmVTdHJpbmcoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnQpIHtcbiAgY29uc3QgY29vcmRpbmF0ZXNFeHRlbnQgPSBleHRlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgY3JlYXRlRW1wdHkoKSwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgaWYgKCFpbnRlcnNlY3RzKGV4dGVudCwgY29vcmRpbmF0ZXNFeHRlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjb250YWluc0V4dGVudChleHRlbnQsIGNvb3JkaW5hdGVzRXh0ZW50KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFswXSA+PSBleHRlbnRbMF0gJiZcbiAgICAgIGNvb3JkaW5hdGVzRXh0ZW50WzJdIDw9IGV4dGVudFsyXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjb29yZGluYXRlc0V4dGVudFsxXSA+PSBleHRlbnRbMV0gJiZcbiAgICAgIGNvb3JkaW5hdGVzRXh0ZW50WzNdIDw9IGV4dGVudFszXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmb3JFYWNoU2VnbWVudChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHBvaW50MSBTdGFydCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcG9pbnQyIEVuZCBwb2ludC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHNlZ21lbnQgYW5kIHRoZSBleHRlbnQgaW50ZXJzZWN0LFxuICAgICAqICAgICBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihwb2ludDEsIHBvaW50Mikge1xuICAgICAgcmV0dXJuIGludGVyc2VjdHNTZWdtZW50KGV4dGVudCwgcG9pbnQxLCBwb2ludDIpO1xuICAgIH0pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lU3RyaW5nQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGlmIChpbnRlcnNlY3RzTGluZVN0cmluZyhcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2ldLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmRzW2ldO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZWFyUmluZyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGV4dGVudCkge1xuICBpZiAoaW50ZXJzZWN0c0xpbmVTdHJpbmcoXG4gICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBleHRlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50WzBdLCBleHRlbnRbMV0pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50WzBdLCBleHRlbnRbM10pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50WzJdLCBleHRlbnRbMV0pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGxpbmVhclJpbmdDb250YWluc1hZKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZXh0ZW50WzJdLCBleHRlbnRbM10pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGdlb21ldHJ5IGFuZCB0aGUgZXh0ZW50IGludGVyc2VjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdHNMaW5lYXJSaW5nQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgZXh0ZW50KSB7XG4gIGlmICghaW50ZXJzZWN0c0xpbmVhclJpbmcoXG4gICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbMF0sIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZW5kcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMSwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBpZiAobGluZWFyUmluZ0NvbnRhaW5zRXh0ZW50KGZsYXRDb29yZGluYXRlcywgZW5kc1tpIC0gMV0sIGVuZHNbaV0sIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgICAgaWYgKCFpbnRlcnNlY3RzTGluZVN0cmluZyhmbGF0Q29vcmRpbmF0ZXMsIGVuZHNbaSAtIDFdLCBlbmRzW2ldLCBzdHJpZGUsIGV4dGVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEVuZHNzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3RzTGluZWFyUmluZ011bHRpQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIGV4dGVudCkge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kcyA9IGVuZHNzW2ldO1xuICAgIGlmIChpbnRlcnNlY3RzTGluZWFyUmluZ0FycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgZXh0ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return centroid; });\n/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);\n/**\n * @module ol/interaction/Pointer\n */\n\n\n\n/**\n * @typedef {Object} Options\n * @property {function(import("../MapBrowserPointerEvent.js").default):boolean} [handleDownEvent]\n * Function handling "down" events. If the function returns `true` then a drag\n * sequence is started.\n * @property {function(import("../MapBrowserPointerEvent.js").default)} [handleDragEvent]\n * Function handling "drag" events. This function is called on "move" events\n * during a drag sequence.\n * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. The function may return `false` to prevent the\n * propagation of the event to other interactions in the map\'s interactions\n * chain.\n * @property {function(import("../MapBrowserPointerEvent.js").default)} [handleMoveEvent]\n * Function handling "move" events. This function is called on "move" events,\n * also during a drag sequence (so during a drag sequence both the\n * `handleDragEvent` function and this function are called).\n * @property {function(import("../MapBrowserPointerEvent.js").default):boolean} [handleUpEvent]\n *  Function handling "up" events. If the function returns `false` then the\n * current drag sequence is stopped.\n * @property {function(boolean):boolean} [stopDown]\n * Should the down event be propagated to other interactions, or should be\n * stopped?\n */\n\n/**\n * @classdesc\n * Base class that calls user-defined functions on `down`, `move` and `up`\n * events. This class also manages "drag sequences".\n *\n * When the `handleDownEvent` user function returns `true` a drag sequence is\n * started. During a drag sequence the `handleDragEvent` user function is\n * called on `move` events. The drag sequence ends when the `handleUpEvent`\n * user function is called and returns `false`.\n * @api\n */\n\nvar PointerInteraction =\n/*@__PURE__*/\nfunction (Interaction) {\n  function PointerInteraction(opt_options) {\n    var options = opt_options ? opt_options : {};\n    Interaction.call(\n    /** @type {import("./Interaction.js").InteractionOptions} */\n    this, options);\n\n    if (options.handleDownEvent) {\n      this.handleDownEvent = options.handleDownEvent;\n    }\n\n    if (options.handleDragEvent) {\n      this.handleDragEvent = options.handleDragEvent;\n    }\n\n    if (options.handleMoveEvent) {\n      this.handleMoveEvent = options.handleMoveEvent;\n    }\n\n    if (options.handleUpEvent) {\n      this.handleUpEvent = options.handleUpEvent;\n    }\n\n    if (options.stopDown) {\n      this.stopDown = options.stopDown;\n    }\n    /**\n     * @type {boolean}\n     * @protected\n     */\n\n\n    this.handlingDownUpSequence = false;\n    /**\n     * @type {!Object<string, import("../pointer/PointerEvent.js").default>}\n     * @private\n     */\n\n    this.trackedPointers_ = {};\n    /**\n     * @type {Array<import("../pointer/PointerEvent.js").default>}\n     * @protected\n     */\n\n    this.targetPointers = [];\n  }\n\n  if (Interaction) PointerInteraction.__proto__ = Interaction;\n  PointerInteraction.prototype = Object.create(Interaction && Interaction.prototype);\n  PointerInteraction.prototype.constructor = PointerInteraction;\n  /**\n   * Handle pointer down events.\n   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n\n  PointerInteraction.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n    return false;\n  };\n  /**\n   * Handle pointer drag events.\n   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.\n   * @protected\n   */\n\n\n  PointerInteraction.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {};\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into\n   * other functions, if event sequences like e.g. \'drag\' or \'down-up\' etc. are\n   * detected.\n   * @override\n   * @api\n   */\n\n\n  PointerInteraction.prototype.handleEvent = function handleEvent(mapBrowserEvent) {\n    if (!\n    /** @type {import("../MapBrowserPointerEvent.js").default} */\n    mapBrowserEvent.pointerEvent) {\n      return true;\n    }\n\n    var stopEvent = false;\n    this.updateTrackedPointers_(mapBrowserEvent);\n\n    if (this.handlingDownUpSequence) {\n      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERDRAG) {\n        this.handleDragEvent(mapBrowserEvent);\n      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERUP) {\n        var handledUp = this.handleUpEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;\n      }\n    } else {\n      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERDOWN) {\n        var handled = this.handleDownEvent(mapBrowserEvent);\n\n        if (handled) {\n          mapBrowserEvent.preventDefault();\n        }\n\n        this.handlingDownUpSequence = handled;\n        stopEvent = this.stopDown(handled);\n      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERMOVE) {\n        this.handleMoveEvent(mapBrowserEvent);\n      }\n    }\n\n    return !stopEvent;\n  };\n  /**\n   * Handle pointer move events.\n   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.\n   * @protected\n   */\n\n\n  PointerInteraction.prototype.handleMoveEvent = function handleMoveEvent(mapBrowserEvent) {};\n  /**\n   * Handle pointer up events.\n   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n\n\n  PointerInteraction.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n    return false;\n  };\n  /**\n   * This function is used to determine if "down" events should be propagated\n   * to other interactions or should be stopped.\n   * @param {boolean} handled Was the event handled by the interaction?\n   * @return {boolean} Should the `down` event be stopped?\n   */\n\n\n  PointerInteraction.prototype.stopDown = function stopDown(handled) {\n    return handled;\n  };\n  /**\n   * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.\n   * @private\n   */\n\n\n  PointerInteraction.prototype.updateTrackedPointers_ = function updateTrackedPointers_(mapBrowserEvent) {\n    if (isPointerDraggingEvent(mapBrowserEvent)) {\n      var event = mapBrowserEvent.pointerEvent;\n      var id = event.pointerId.toString();\n\n      if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERUP) {\n        delete this.trackedPointers_[id];\n      } else if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERDOWN) {\n        this.trackedPointers_[id] = event;\n      } else if (id in this.trackedPointers_) {\n        // update only when there was a pointerdown event for this pointer\n        this.trackedPointers_[id] = event;\n      }\n\n      this.targetPointers = Object(_obj_js__WEBPACK_IMPORTED_MODULE_2__[/* getValues */ "c"])(this.trackedPointers_);\n    }\n  };\n\n  return PointerInteraction;\n}(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n/**\n * @param {Array<import("../pointer/PointerEvent.js").default>} pointerEvents List of events.\n * @return {import("../pixel.js").Pixel} Centroid pixel.\n */\n\n\nfunction centroid(pointerEvents) {\n  var length = pointerEvents.length;\n  var clientX = 0;\n  var clientY = 0;\n\n  for (var i = 0; i < length; i++) {\n    clientX += pointerEvents[i].clientX;\n    clientY += pointerEvents[i].clientY;\n  }\n\n  return [clientX / length, clientY / length];\n}\n/**\n * @param {import("../MapBrowserPointerEvent.js").default} mapBrowserEvent Event.\n * @return {boolean} Whether the event is a pointerdown, pointerdrag\n *     or pointerup event.\n */\n\nfunction isPointerDraggingEvent(mapBrowserEvent) {\n  var type = mapBrowserEvent.type;\n  return type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERDOWN || type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERDRAG || type === _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].POINTERUP;\n}\n\n/* harmony default export */ __webpack_exports__["b"] = (PointerInteraction);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2ludGVyYWN0aW9uL1BvaW50ZXIuanM/YWMyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUG9pbnRlclxuICovXG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50VHlwZSBmcm9tICcuLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0VmFsdWVzfSBmcm9tICcuLi9vYmouanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHQpOmJvb2xlYW59IFtoYW5kbGVEb3duRXZlbnRdXG4gKiBGdW5jdGlvbiBoYW5kbGluZyBcImRvd25cIiBldmVudHMuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCB0aGVuIGEgZHJhZ1xuICogc2VxdWVuY2UgaXMgc3RhcnRlZC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0KX0gW2hhbmRsZURyYWdFdmVudF1cbiAqIEZ1bmN0aW9uIGhhbmRsaW5nIFwiZHJhZ1wiIGV2ZW50cy4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gXCJtb3ZlXCIgZXZlbnRzXG4gKiBkdXJpbmcgYSBkcmFnIHNlcXVlbmNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZUV2ZW50XVxuICogTWV0aG9kIGNhbGxlZCBieSB0aGUgbWFwIHRvIG5vdGlmeSB0aGUgaW50ZXJhY3Rpb24gdGhhdCBhIGJyb3dzZXIgZXZlbnQgd2FzXG4gKiBkaXNwYXRjaGVkIHRvIHRoZSBtYXAuIFRoZSBmdW5jdGlvbiBtYXkgcmV0dXJuIGBmYWxzZWAgdG8gcHJldmVudCB0aGVcbiAqIHByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCB0byBvdGhlciBpbnRlcmFjdGlvbnMgaW4gdGhlIG1hcCdzIGludGVyYWN0aW9uc1xuICogY2hhaW4uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdCl9IFtoYW5kbGVNb3ZlRXZlbnRdXG4gKiBGdW5jdGlvbiBoYW5kbGluZyBcIm1vdmVcIiBldmVudHMuIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIFwibW92ZVwiIGV2ZW50cyxcbiAqIGFsc28gZHVyaW5nIGEgZHJhZyBzZXF1ZW5jZSAoc28gZHVyaW5nIGEgZHJhZyBzZXF1ZW5jZSBib3RoIHRoZVxuICogYGhhbmRsZURyYWdFdmVudGAgZnVuY3Rpb24gYW5kIHRoaXMgZnVuY3Rpb24gYXJlIGNhbGxlZCkuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gW2hhbmRsZVVwRXZlbnRdXG4gKiAgRnVuY3Rpb24gaGFuZGxpbmcgXCJ1cFwiIGV2ZW50cy4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGVuIHRoZVxuICogY3VycmVudCBkcmFnIHNlcXVlbmNlIGlzIHN0b3BwZWQuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pOmJvb2xlYW59IFtzdG9wRG93bl1cbiAqIFNob3VsZCB0aGUgZG93biBldmVudCBiZSBwcm9wYWdhdGVkIHRvIG90aGVyIGludGVyYWN0aW9ucywgb3Igc2hvdWxkIGJlXG4gKiBzdG9wcGVkP1xuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIHRoYXQgY2FsbHMgdXNlci1kZWZpbmVkIGZ1bmN0aW9ucyBvbiBgZG93bmAsIGBtb3ZlYCBhbmQgYHVwYFxuICogZXZlbnRzLiBUaGlzIGNsYXNzIGFsc28gbWFuYWdlcyBcImRyYWcgc2VxdWVuY2VzXCIuXG4gKlxuICogV2hlbiB0aGUgYGhhbmRsZURvd25FdmVudGAgdXNlciBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBhIGRyYWcgc2VxdWVuY2UgaXNcbiAqIHN0YXJ0ZWQuIER1cmluZyBhIGRyYWcgc2VxdWVuY2UgdGhlIGBoYW5kbGVEcmFnRXZlbnRgIHVzZXIgZnVuY3Rpb24gaXNcbiAqIGNhbGxlZCBvbiBgbW92ZWAgZXZlbnRzLiBUaGUgZHJhZyBzZXF1ZW5jZSBlbmRzIHdoZW4gdGhlIGBoYW5kbGVVcEV2ZW50YFxuICogdXNlciBmdW5jdGlvbiBpcyBjYWxsZWQgYW5kIHJldHVybnMgYGZhbHNlYC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgUG9pbnRlckludGVyYWN0aW9uIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9vcHRpb25zKSB7XG5cbiAgICBjb25zdCBvcHRpb25zID0gb3B0X29wdGlvbnMgPyBvcHRfb3B0aW9ucyA6IHt9O1xuXG4gICAgc3VwZXIoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0ludGVyYWN0aW9uLmpzXCIpLkludGVyYWN0aW9uT3B0aW9uc30gKi8gKG9wdGlvbnMpKTtcblxuICAgIGlmIChvcHRpb25zLmhhbmRsZURvd25FdmVudCkge1xuICAgICAgdGhpcy5oYW5kbGVEb3duRXZlbnQgPSBvcHRpb25zLmhhbmRsZURvd25FdmVudDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5oYW5kbGVEcmFnRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlRHJhZ0V2ZW50ID0gb3B0aW9ucy5oYW5kbGVEcmFnRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlTW92ZUV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVFdmVudCA9IG9wdGlvbnMuaGFuZGxlTW92ZUV2ZW50O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhhbmRsZVVwRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlVXBFdmVudCA9IG9wdGlvbnMuaGFuZGxlVXBFdmVudDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdG9wRG93bikge1xuICAgICAgdGhpcy5zdG9wRG93biA9IG9wdGlvbnMuc3RvcERvd247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuaGFuZGxpbmdEb3duVXBTZXF1ZW5jZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhY2tlZFBvaW50ZXJzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFBvaW50ZXJzID0gW107XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGV2ZW50IHdhcyBjb25zdW1lZC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBkcmFnIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlRHJhZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkge31cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnQgbWFwIGJyb3dzZXIgZXZlbnR9IGFuZCBtYXkgY2FsbCBpbnRvXG4gICAqIG90aGVyIGZ1bmN0aW9ucywgaWYgZXZlbnQgc2VxdWVuY2VzIGxpa2UgZS5nLiAnZHJhZycgb3IgJ2Rvd24tdXAnIGV0Yy4gYXJlXG4gICAqIGRldGVjdGVkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCEoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9ICovIChtYXBCcm93c2VyRXZlbnQpLnBvaW50ZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGxldCBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVRyYWNrZWRQb2ludGVyc18obWFwQnJvd3NlckV2ZW50KTtcbiAgICBpZiAodGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRFJBRykge1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCkge1xuICAgICAgICBjb25zdCBoYW5kbGVkVXAgPSB0aGlzLmhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KTtcbiAgICAgICAgdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlID0gaGFuZGxlZFVwICYmIHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04pIHtcbiAgICAgICAgY29uc3QgaGFuZGxlZCA9IHRoaXMuaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgbWFwQnJvd3NlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlID0gaGFuZGxlZDtcbiAgICAgICAgc3RvcEV2ZW50ID0gdGhpcy5zdG9wRG93bihoYW5kbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSkge1xuICAgICAgICB0aGlzLmhhbmRsZU1vdmVFdmVudChtYXBCcm93c2VyRXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gIXN0b3BFdmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcG9pbnRlciBtb3ZlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBFdmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlTW92ZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge31cblxuICAvKipcbiAgICogSGFuZGxlIHBvaW50ZXIgdXAgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgZXZlbnQgd2FzIGNvbnN1bWVkLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIFwiZG93blwiIGV2ZW50cyBzaG91bGQgYmUgcHJvcGFnYXRlZFxuICAgKiB0byBvdGhlciBpbnRlcmFjdGlvbnMgb3Igc2hvdWxkIGJlIHN0b3BwZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFuZGxlZCBXYXMgdGhlIGV2ZW50IGhhbmRsZWQgYnkgdGhlIGludGVyYWN0aW9uP1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBTaG91bGQgdGhlIGBkb3duYCBldmVudCBiZSBzdG9wcGVkP1xuICAgKi9cbiAgc3RvcERvd24oaGFuZGxlZCkge1xuICAgIHJldHVybiBoYW5kbGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBtYXBCcm93c2VyRXZlbnQgRXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVUcmFja2VkUG9pbnRlcnNfKG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmIChpc1BvaW50ZXJEcmFnZ2luZ0V2ZW50KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbWFwQnJvd3NlckV2ZW50LnBvaW50ZXJFdmVudDtcblxuICAgICAgY29uc3QgaWQgPSBldmVudC5wb2ludGVySWQudG9TdHJpbmcoKTtcbiAgICAgIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCkge1xuICAgICAgICBkZWxldGUgdGhpcy50cmFja2VkUG9pbnRlcnNfW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT1cbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJET1dOKSB7XG4gICAgICAgIHRoaXMudHJhY2tlZFBvaW50ZXJzX1tpZF0gPSBldmVudDtcbiAgICAgIH0gZWxzZSBpZiAoaWQgaW4gdGhpcy50cmFja2VkUG9pbnRlcnNfKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBvbmx5IHdoZW4gdGhlcmUgd2FzIGEgcG9pbnRlcmRvd24gZXZlbnQgZm9yIHRoaXMgcG9pbnRlclxuICAgICAgICB0aGlzLnRyYWNrZWRQb2ludGVyc19baWRdID0gZXZlbnQ7XG4gICAgICB9XG4gICAgICB0aGlzLnRhcmdldFBvaW50ZXJzID0gZ2V0VmFsdWVzKHRoaXMudHJhY2tlZFBvaW50ZXJzXyk7XG4gICAgfVxuICB9XG5cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdD59IHBvaW50ZXJFdmVudHMgTGlzdCBvZiBldmVudHMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gQ2VudHJvaWQgcGl4ZWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZW50cm9pZChwb2ludGVyRXZlbnRzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHBvaW50ZXJFdmVudHMubGVuZ3RoO1xuICBsZXQgY2xpZW50WCA9IDA7XG4gIGxldCBjbGllbnRZID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNsaWVudFggKz0gcG9pbnRlckV2ZW50c1tpXS5jbGllbnRYO1xuICAgIGNsaWVudFkgKz0gcG9pbnRlckV2ZW50c1tpXS5jbGllbnRZO1xuICB9XG4gIHJldHVybiBbY2xpZW50WCAvIGxlbmd0aCwgY2xpZW50WSAvIGxlbmd0aF07XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL01hcEJyb3dzZXJQb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZXZlbnQgaXMgYSBwb2ludGVyZG93biwgcG9pbnRlcmRyYWdcbiAqICAgICBvciBwb2ludGVydXAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGlzUG9pbnRlckRyYWdnaW5nRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGNvbnN0IHR5cGUgPSBtYXBCcm93c2VyRXZlbnQudHlwZTtcbiAgcmV0dXJuIHR5cGUgPT09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04gfHxcbiAgICB0eXBlID09PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJEUkFHIHx8XG4gICAgdHlwZSA9PT0gTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSVVA7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUG9pbnRlckludGVyYWN0aW9uO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7QUFPQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUF2SkE7Ozs7Ozs7QUErSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///62\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/ol/geom/flat/reverse.js\n/**\n * @module ol/geom/flat/reverse\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nfunction coordinates(flatCoordinates, offset, end, stride) {\n  while (offset < end - stride) {\n    for (var i = 0; i < stride; ++i) {\n      var tmp = flatCoordinates[offset + i];\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n      flatCoordinates[end - stride + i] = tmp;\n    }\n\n    offset += stride;\n    end -= stride;\n  }\n}\n// CONCATENATED MODULE: ./node_modules/ol/geom/flat/orient.js\n/* unused harmony export linearRingIsClockwise */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return linearRingIsOriented; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return linearRingsAreOriented; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return orientLinearRings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return orientLinearRingsArray; });\n/**\n * @module ol/geom/flat/orient\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\n\nfunction linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // http://tinyurl.com/clockwise-method\n  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return edge > 0;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nfunction linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n\n    if (i === 0) {\n      if (right && isClockwise || !right && !isClockwise) {\n        return false;\n      }\n    } else {\n      if (right && !isClockwise || !right && isClockwise) {\n        return false;\n      }\n    }\n\n    offset = end;\n  }\n\n  return true;\n}\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\n\nfunction linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    if (!linearRingIsOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nfunction orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;\n\n    if (reverse) {\n      coordinates(flatCoordinates, offset, end, stride);\n    }\n\n    offset = end;\n  }\n\n  return offset;\n}\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\n\nfunction orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n\n  return offset;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9yZXZlcnNlLmpzPzk0MWQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9nZW9tL2ZsYXQvb3JpZW50LmpzP2JmNDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9yZXZlcnNlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgd2hpbGUgKG9mZnNldCA8IGVuZCAtIHN0cmlkZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyArK2kpIHtcbiAgICAgIGNvbnN0IHRtcCA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXTtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpXSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyBpXTtcbiAgICAgIGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyBpXSA9IHRtcDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICBlbmQgLT0gc3RyaWRlO1xuICB9XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L29yaWVudFxuICovXG5pbXBvcnQge2Nvb3JkaW5hdGVzIGFzIHJldmVyc2VDb29yZGluYXRlc30gZnJvbSAnLi9yZXZlcnNlLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBJcyBjbG9ja3dpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nSXNDbG9ja3dpc2UoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIC8vIGh0dHA6Ly90aW55dXJsLmNvbS9jbG9ja3dpc2UtbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9PU0dlby9nZGFsL2Jsb2IvdHJ1bmsvZ2RhbC9vZ3Ivb2dybGluZWFycmluZy5jcHBcbiAgbGV0IGVkZ2UgPSAwO1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZSArIDFdO1xuICBmb3IgKDsgb2Zmc2V0IDwgZW5kOyBvZmZzZXQgKz0gc3RyaWRlKSB7XG4gICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBlZGdlICs9ICh4MiAtIHgxKSAqICh5MiArIHkxKTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gIH1cbiAgcmV0dXJuIGVkZ2UgPiAwO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBsaW5lYXIgcmluZ3MgYXJlIG9yaWVudGVkLiAgQnkgZGVmYXVsdCwgbGVmdC1oYW5kIG9yaWVudGF0aW9uXG4gKiBpcyB0ZXN0ZWQgKGZpcnN0IHJpbmcgbXVzdCBiZSBjbG9ja3dpc2UsIHJlbWFpbmluZyByaW5ncyBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKiBUbyB0ZXN0IGZvciByaWdodC1oYW5kIG9yaWVudGF0aW9uLCB1c2UgdGhlIGBvcHRfcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBBcnJheSBvZiBlbmQgaW5kZXhlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IFRlc3QgZm9yIHJpZ2h0LWhhbmQgb3JpZW50YXRpb25cbiAqICAgICAoY291bnRlci1jbG9ja3dpc2UgZXh0ZXJpb3IgcmluZyBhbmQgY2xvY2t3aXNlIGludGVyaW9yIHJpbmdzKS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJpbmdzIGFyZSBjb3JyZWN0bHkgb3JpZW50ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nSXNPcmllbnRlZChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBvcHRfcmlnaHQpIHtcbiAgY29uc3QgcmlnaHQgPSBvcHRfcmlnaHQgIT09IHVuZGVmaW5lZCA/IG9wdF9yaWdodCA6IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgIGNvbnN0IGlzQ2xvY2t3aXNlID0gbGluZWFyUmluZ0lzQ2xvY2t3aXNlKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgaWYgKChyaWdodCAmJiBpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiAhaXNDbG9ja3dpc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChyaWdodCAmJiAhaXNDbG9ja3dpc2UpIHx8ICghcmlnaHQgJiYgaXNDbG9ja3dpc2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBsaW5lYXIgcmluZ3MgYXJlIG9yaWVudGVkLiAgQnkgZGVmYXVsdCwgbGVmdC1oYW5kIG9yaWVudGF0aW9uXG4gKiBpcyB0ZXN0ZWQgKGZpcnN0IHJpbmcgbXVzdCBiZSBjbG9ja3dpc2UsIHJlbWFpbmluZyByaW5ncyBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKiBUbyB0ZXN0IGZvciByaWdodC1oYW5kIG9yaWVudGF0aW9uLCB1c2UgdGhlIGBvcHRfcmlnaHRgIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGVuZHNzIEFycmF5IG9mIGFycmF5IG9mIGVuZCBpbmRleGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmlnaHQgVGVzdCBmb3IgcmlnaHQtaGFuZCBvcmllbnRhdGlvblxuICogICAgIChjb3VudGVyLWNsb2Nrd2lzZSBleHRlcmlvciByaW5nIGFuZCBjbG9ja3dpc2UgaW50ZXJpb3IgcmluZ3MpLlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmluZ3MgYXJlIGNvcnJlY3RseSBvcmllbnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzQXJlT3JpZW50ZWQoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIG9wdF9yaWdodCkge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgaWYgKCFsaW5lYXJSaW5nSXNPcmllbnRlZChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzc1tpXSwgc3RyaWRlLCBvcHRfcmlnaHQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogT3JpZW50IGNvb3JkaW5hdGVzIGluIGEgZmxhdCBhcnJheSBvZiBsaW5lYXIgcmluZ3MuICBCeSBkZWZhdWx0LCByaW5nc1xuICogYXJlIG9yaWVudGVkIGZvbGxvd2luZyB0aGUgbGVmdC1oYW5kIHJ1bGUgKGNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kXG4gKiBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLiAgVG8gb3JpZW50IGFjY29yZGluZyB0byB0aGVcbiAqIHJpZ2h0LWhhbmQgcnVsZSwgdXNlIHRoZSBgb3B0X3JpZ2h0YCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3JpZ2h0IEZvbGxvdyB0aGUgcmlnaHQtaGFuZCBydWxlIGZvciBvcmllbnRhdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb3JpZW50TGluZWFyUmluZ3MoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgb3B0X3JpZ2h0KSB7XG4gIGNvbnN0IHJpZ2h0ID0gb3B0X3JpZ2h0ICE9PSB1bmRlZmluZWQgPyBvcHRfcmlnaHQgOiBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBjb25zdCBpc0Nsb2Nrd2lzZSA9IGxpbmVhclJpbmdJc0Nsb2Nrd2lzZShcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSk7XG4gICAgY29uc3QgcmV2ZXJzZSA9IGkgPT09IDAgP1xuICAgICAgKHJpZ2h0ICYmIGlzQ2xvY2t3aXNlKSB8fCAoIXJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgOlxuICAgICAgKHJpZ2h0ICYmICFpc0Nsb2Nrd2lzZSkgfHwgKCFyaWdodCAmJiBpc0Nsb2Nrd2lzZSk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldmVyc2VDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpO1xuICAgIH1cbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuXG4vKipcbiAqIE9yaWVudCBjb29yZGluYXRlcyBpbiBhIGZsYXQgYXJyYXkgb2YgbGluZWFyIHJpbmdzLiAgQnkgZGVmYXVsdCwgcmluZ3NcbiAqIGFyZSBvcmllbnRlZCBmb2xsb3dpbmcgdGhlIGxlZnQtaGFuZCBydWxlIChjbG9ja3dpc2UgZm9yIGV4dGVyaW9yIGFuZFxuICogY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS4gIFRvIG9yaWVudCBhY2NvcmRpbmcgdG8gdGhlXG4gKiByaWdodC1oYW5kIHJ1bGUsIHVzZSB0aGUgYG9wdF9yaWdodGAgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgQXJyYXkgb2YgYXJyYXkgb2YgZW5kIGluZGV4ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yaWdodCBGb2xsb3cgdGhlIHJpZ2h0LWhhbmQgcnVsZSBmb3Igb3JpZW50YXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudExpbmVhclJpbmdzQXJyYXkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzLCBzdHJpZGUsIG9wdF9yaWdodCkge1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgb2Zmc2V0ID0gb3JpZW50TGluZWFyUmluZ3MoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3NbaV0sIHN0cmlkZSwgb3B0X3JpZ2h0KTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBOzs7Ozs7Ozs7QUFVQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///63\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/EventHandling\r\n */\n\n/**\r\n * @desc Class to provide event handling functionality\r\n * @public\r\n * @abstract\r\n * @class\r\n */\n\n\nvar EventHandling =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * @desc Create an instance of EventHandling\r\n   * @public\r\n   * @constructor\r\n   */\n  function EventHandling() {\n    _classCallCheck(this, EventHandling);\n\n    /**\r\n     * @private\r\n     * @type {Object<string, Array<EventHandling.Handler>>}\r\n     */\n    this.evtHdlrs = {};\n  }\n  /**\r\n   * @desc Connect a function to an event\r\n   * @public\r\n   * @method\r\n   * @param {string} eventName The name of the event to which the handler will be connected\r\n   * @param {function(Object)} evtHdlr The event handler function\r\n   * @param {Object=} hdlrScope The scope in which to invoke the event handler\r\n   */\n\n\n  _createClass(EventHandling, [{\n    key: "on",\n    value: function on(eventName, evtHdlr, hdlrScope) {\n      this.addHdlr(eventName, evtHdlr, hdlrScope);\n    }\n    /**\r\n     * @desc Connect a function to an event for a single invocation\r\n     * @public\r\n     * @method\r\n     * @param {string} eventName The name of the event to which the handler will be connected\r\n     * @param {function(Object)} evtHdlr The event handler function\r\n     * @param {Object=} hdlrScope The scope in which to invoke the event handler\r\n     */\n\n  }, {\n    key: "one",\n    value: function one(eventName, evtHdlr, hdlrScope) {\n      this.addHdlr(eventName, evtHdlr, hdlrScope, true);\n    }\n    /**\r\n     * @desc Trigger a named event with event data\r\n     * @public\r\n     * @method\r\n     * @param {string} eventName The name of the event to trigger\r\n     * @param {Object=} data The event data\r\n     */\n\n  }, {\n    key: "trigger",\n    value: function trigger(eventName, data) {\n      var handlers = this.evtHdlrs[eventName];\n      var remove = [];\n\n      if (handlers) {\n        handlers.forEach(function (hdlr) {\n          if (hdlr.scope) {\n            hdlr.handler.call(hdlr.scope, data);\n          } else {\n            hdlr.handler(data);\n          }\n\n          if (hdlr.remove) {\n            remove.push(hdlr);\n          }\n        });\n        remove.forEach(function (hdlr) {\n          handlers.splice(_jquery["default"].inArray(hdlr, handlers), 1);\n        });\n      }\n    }\n    /**\r\n     * @desc Remove a previously connected event handler\r\n     * @public\r\n     * @method\r\n     * @param {string} eventName The name of the event to which the handler will be connected\r\n     * @param {function(Object)} evtHdlr The event handler function\r\n     * @param {Object=} hdlrScope The scope in which to invoke the event handler\r\n     */\n\n  }, {\n    key: "off",\n    value: function off(eventName, evtHdlr, hdlrScope) {\n      var handlers = this.evtHdlrs[eventName];\n      handlers.forEach(function (hdlr, index) {\n        if (hdlr.handler === evtHdlr && hdlr.scope === hdlrScope) {\n          handlers.splice(index, 1);\n          return false;\n        }\n      });\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {string} eventName Name of the event\r\n     * @param {function(Object)} evtHdlr Event handler\r\n     * @param {Object} hdlrScope Scope of the handler\r\n     * @param {boolean} one Single handler or not\r\n     */\n\n  }, {\n    key: "addHdlr",\n    value: function addHdlr(eventName, evtHdlr, hdlrScope, one) {\n      this.evtHdlrs[eventName] = this.evtHdlrs[eventName] || [];\n      this.evtHdlrs[eventName].push({\n        handler: evtHdlr,\n        scope: hdlrScope,\n        remove: one\n      });\n    }\n  }]);\n\n  return EventHandling;\n}();\n/**\r\n * @desc Object type to hold event handlers\r\n * @private\r\n * @typedef {Object}\r\n * @property {function(Object)} handler The event handler\r\n * @property {Object} scope The event handler scope\r\n * @property {boolean} [remove=false] Remove after one execution\r\n */\n\n\nEventHandling.Handler;\nvar _default = EventHandling;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnljLWxpYi9ueWMvRXZlbnRIYW5kbGluZy5qcz8yNWQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9FdmVudEhhbmRsaW5nXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQ2xhc3MgdG8gcHJvdmlkZSBldmVudCBoYW5kbGluZyBmdW5jdGlvbmFsaXR5XHJcbiAqIEBwdWJsaWNcclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzc1xyXG4gKi9cbmNsYXNzIEV2ZW50SGFuZGxpbmcge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgRXZlbnRIYW5kbGluZ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIEFycmF5PEV2ZW50SGFuZGxpbmcuSGFuZGxlcj4+fVxyXG4gICAgICovXG4gICAgdGhpcy5ldnRIZGxycyA9IHt9O1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIENvbm5lY3QgYSBmdW5jdGlvbiB0byBhbiBldmVudFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gd2hpY2ggdGhlIGhhbmRsZXIgd2lsbCBiZSBjb25uZWN0ZWRcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCl9IGV2dEhkbHIgVGhlIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGhkbHJTY29wZSBUaGUgc2NvcGUgaW4gd2hpY2ggdG8gaW52b2tlIHRoZSBldmVudCBoYW5kbGVyXHJcbiAgICovXG5cblxuICBvbihldmVudE5hbWUsIGV2dEhkbHIsIGhkbHJTY29wZSkge1xuICAgIHRoaXMuYWRkSGRscihldmVudE5hbWUsIGV2dEhkbHIsIGhkbHJTY29wZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgQ29ubmVjdCBhIGZ1bmN0aW9uIHRvIGFuIGV2ZW50IGZvciBhIHNpbmdsZSBpbnZvY2F0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB3aGljaCB0aGUgaGFuZGxlciB3aWxsIGJlIGNvbm5lY3RlZFxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KX0gZXZ0SGRsciBUaGUgZXZlbnQgaGFuZGxlciBmdW5jdGlvblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gaGRsclNjb3BlIFRoZSBzY29wZSBpbiB3aGljaCB0byBpbnZva2UgdGhlIGV2ZW50IGhhbmRsZXJcclxuICAgKi9cblxuXG4gIG9uZShldmVudE5hbWUsIGV2dEhkbHIsIGhkbHJTY29wZSkge1xuICAgIHRoaXMuYWRkSGRscihldmVudE5hbWUsIGV2dEhkbHIsIGhkbHJTY29wZSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgVHJpZ2dlciBhIG5hbWVkIGV2ZW50IHdpdGggZXZlbnQgZGF0YVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlclxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gZGF0YSBUaGUgZXZlbnQgZGF0YVxyXG4gICAqL1xuXG5cbiAgdHJpZ2dlcihldmVudE5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuZXZ0SGRscnNbZXZlbnROYW1lXTtcbiAgICBjb25zdCByZW1vdmUgPSBbXTtcblxuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChoZGxyID0+IHtcbiAgICAgICAgaWYgKGhkbHIuc2NvcGUpIHtcbiAgICAgICAgICBoZGxyLmhhbmRsZXIuY2FsbChoZGxyLnNjb3BlLCBkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZGxyLmhhbmRsZXIoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGRsci5yZW1vdmUpIHtcbiAgICAgICAgICByZW1vdmUucHVzaChoZGxyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZW1vdmUuZm9yRWFjaChoZGxyID0+IHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKF9qcXVlcnkuZGVmYXVsdC5pbkFycmF5KGhkbHIsIGhhbmRsZXJzKSwgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgUmVtb3ZlIGEgcHJldmlvdXNseSBjb25uZWN0ZWQgZXZlbnQgaGFuZGxlclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gd2hpY2ggdGhlIGhhbmRsZXIgd2lsbCBiZSBjb25uZWN0ZWRcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCl9IGV2dEhkbHIgVGhlIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGhkbHJTY29wZSBUaGUgc2NvcGUgaW4gd2hpY2ggdG8gaW52b2tlIHRoZSBldmVudCBoYW5kbGVyXHJcbiAgICovXG5cblxuICBvZmYoZXZlbnROYW1lLCBldnRIZGxyLCBoZGxyU2NvcGUpIHtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuZXZ0SGRscnNbZXZlbnROYW1lXTtcbiAgICBoYW5kbGVycy5mb3JFYWNoKChoZGxyLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGhkbHIuaGFuZGxlciA9PT0gZXZ0SGRsciAmJiBoZGxyLnNjb3BlID09PSBoZGxyU2NvcGUpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiB0aGUgZXZlbnRcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCl9IGV2dEhkbHIgRXZlbnQgaGFuZGxlclxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoZGxyU2NvcGUgU2NvcGUgb2YgdGhlIGhhbmRsZXJcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9uZSBTaW5nbGUgaGFuZGxlciBvciBub3RcclxuICAgKi9cblxuXG4gIGFkZEhkbHIoZXZlbnROYW1lLCBldnRIZGxyLCBoZGxyU2NvcGUsIG9uZSkge1xuICAgIHRoaXMuZXZ0SGRscnNbZXZlbnROYW1lXSA9IHRoaXMuZXZ0SGRscnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICB0aGlzLmV2dEhkbHJzW2V2ZW50TmFtZV0ucHVzaCh7XG4gICAgICBoYW5kbGVyOiBldnRIZGxyLFxuICAgICAgc2NvcGU6IGhkbHJTY29wZSxcbiAgICAgIHJlbW92ZTogb25lXG4gICAgfSk7XG4gIH1cblxufVxuLyoqXHJcbiAqIEBkZXNjIE9iamVjdCB0eXBlIHRvIGhvbGQgZXZlbnQgaGFuZGxlcnNcclxuICogQHByaXZhdGVcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtmdW5jdGlvbihPYmplY3QpfSBoYW5kbGVyIFRoZSBldmVudCBoYW5kbGVyXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzY29wZSBUaGUgZXZlbnQgaGFuZGxlciBzY29wZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZW1vdmU9ZmFsc2VdIFJlbW92ZSBhZnRlciBvbmUgZXhlY3V0aW9uXHJcbiAqL1xuXG5cbkV2ZW50SGFuZGxpbmcuSGFuZGxlcjtcbnZhciBfZGVmYXVsdCA9IEV2ZW50SGFuZGxpbmc7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUlBOzs7Ozs7OztBQU1BOzs7QUFDQTs7Ozs7QUFLQTtBQUFBO0FBQ0E7QUFBQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOzs7OztBQUdBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///64\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DEFAULT_MAX_ZOOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return DEFAULT_TILE_SIZE; });\n/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nvar DEFAULT_MAX_ZOOM = 42;\n/**\n * Default tile size.\n * @type {number}\n */\n\nvar DEFAULT_TILE_SIZE = 256;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3RpbGVncmlkL2NvbW1vbi5qcz9hYzI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC90aWxlZ3JpZC9jb21tb25cbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgbWF4aW11bSB6b29tIGZvciBkZWZhdWx0IHRpbGUgZ3JpZHMuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9NQVhfWk9PTSA9IDQyO1xuXG4vKipcbiAqIERlZmF1bHQgdGlsZSBzaXplLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElMRV9TSVpFID0gMjU2O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7Ozs7Ozs7O0FBUUE7Ozs7OztBQU1BIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///65\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/extent/Corner\n */\n\n/**\n * Extent corner.\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  BOTTOM_LEFT: 'bottom-left',\n  BOTTOM_RIGHT: 'bottom-right',\n  TOP_LEFT: 'top-left',\n  TOP_RIGHT: 'top-right'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2V4dGVudC9Db3JuZXIuanM/ZWViNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZXh0ZW50L0Nvcm5lclxuICovXG5cbi8qKlxuICogRXh0ZW50IGNvcm5lci5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQk9UVE9NX0xFRlQ6ICdib3R0b20tbGVmdCcsXG4gIEJPVFRPTV9SSUdIVDogJ2JvdHRvbS1yaWdodCcsXG4gIFRPUF9MRUZUOiAndG9wLWxlZnQnLFxuICBUT1BfUklHSFQ6ICd0b3AtcmlnaHQnXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///66\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createOrUpdate; });\n/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nvar TileRange = function TileRange(minX, maxX, minY, maxY) {\n  /**\n   * @type {number}\n   */\n  this.minX = minX;\n  /**\n   * @type {number}\n   */\n\n  this.maxX = maxX;\n  /**\n   * @type {number}\n   */\n\n  this.minY = minY;\n  /**\n   * @type {number}\n   */\n\n  this.maxY = maxY;\n};\n/**\n * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @return {boolean} Contains tile coordinate.\n */\n\n\nTileRange.prototype.contains = function contains(tileCoord) {\n  return this.containsXY(tileCoord[1], tileCoord[2]);\n};\n/**\n * @param {TileRange} tileRange Tile range.\n * @return {boolean} Contains.\n */\n\n\nTileRange.prototype.containsTileRange = function containsTileRange(tileRange) {\n  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;\n};\n/**\n * @param {number} x Tile coordinate x.\n * @param {number} y Tile coordinate y.\n * @return {boolean} Contains coordinate.\n */\n\n\nTileRange.prototype.containsXY = function containsXY(x, y) {\n  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n};\n/**\n * @param {TileRange} tileRange Tile range.\n * @return {boolean} Equals.\n */\n\n\nTileRange.prototype.equals = function equals(tileRange) {\n  return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;\n};\n/**\n * @param {TileRange} tileRange Tile range.\n */\n\n\nTileRange.prototype.extend = function extend(tileRange) {\n  if (tileRange.minX < this.minX) {\n    this.minX = tileRange.minX;\n  }\n\n  if (tileRange.maxX > this.maxX) {\n    this.maxX = tileRange.maxX;\n  }\n\n  if (tileRange.minY < this.minY) {\n    this.minY = tileRange.minY;\n  }\n\n  if (tileRange.maxY > this.maxY) {\n    this.maxY = tileRange.maxY;\n  }\n};\n/**\n * @return {number} Height.\n */\n\n\nTileRange.prototype.getHeight = function getHeight() {\n  return this.maxY - this.minY + 1;\n};\n/**\n * @return {import("./size.js").Size} Size.\n */\n\n\nTileRange.prototype.getSize = function getSize() {\n  return [this.getWidth(), this.getHeight()];\n};\n/**\n * @return {number} Width.\n */\n\n\nTileRange.prototype.getWidth = function getWidth() {\n  return this.maxX - this.minX + 1;\n};\n/**\n * @param {TileRange} tileRange Tile range.\n * @return {boolean} Intersects.\n */\n\n\nTileRange.prototype.intersects = function intersects(tileRange) {\n  return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;\n};\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange=} tileRange TileRange.\n * @return {TileRange} Tile range.\n */\n\n\nfunction createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  } else {\n    return new TileRange(minX, maxX, minY, maxY);\n  }\n}\n/* harmony default export */ __webpack_exports__["b"] = (TileRange);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL1RpbGVSYW5nZS5qcz8xOThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlUmFuZ2VcbiAqL1xuXG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBjb250aWd1b3VzIGJsb2NrIG9mIHRpbGVzLiAgQSB0aWxlIHJhbmdlIGlzIHNwZWNpZmllZFxuICogYnkgaXRzIG1pbi9tYXggdGlsZSBjb29yZGluYXRlcyBhbmQgaXMgaW5jbHVzaXZlIG9mIGNvb3JkaW5hdGVzLlxuICovXG5jbGFzcyBUaWxlUmFuZ2Uge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWCBNaW5pbXVtIFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblkgTWluaW11bSBZLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4WSBNYXhpbXVtIFkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWCA9IG1pblg7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4WCA9IG1heFg7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluWSA9IG1pblk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4WSA9IG1heFk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgdGlsZSBjb29yZGluYXRlLlxuICAgKi9cbiAgY29udGFpbnModGlsZUNvb3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbnNYWSh0aWxlQ29vcmRbMV0sIHRpbGVDb29yZFsyXSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucy5cbiAgICovXG4gIGNvbnRhaW5zVGlsZVJhbmdlKHRpbGVSYW5nZSkge1xuICAgIHJldHVybiB0aGlzLm1pblggPD0gdGlsZVJhbmdlLm1pblggJiYgdGlsZVJhbmdlLm1heFggPD0gdGhpcy5tYXhYICYmXG4gICAgICAgdGhpcy5taW5ZIDw9IHRpbGVSYW5nZS5taW5ZICYmIHRpbGVSYW5nZS5tYXhZIDw9IHRoaXMubWF4WTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zIGNvb3JkaW5hdGUuXG4gICAqL1xuICBjb250YWluc1hZKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YIDw9IHggJiYgeCA8PSB0aGlzLm1heFggJiYgdGhpcy5taW5ZIDw9IHkgJiYgeSA8PSB0aGlzLm1heFk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUaWxlUmFuZ2V9IHRpbGVSYW5nZSBUaWxlIHJhbmdlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBFcXVhbHMuXG4gICAqL1xuICBlcXVhbHModGlsZVJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluWCA9PSB0aWxlUmFuZ2UubWluWCAmJiB0aGlzLm1pblkgPT0gdGlsZVJhbmdlLm1pblkgJiZcbiAgICAgICB0aGlzLm1heFggPT0gdGlsZVJhbmdlLm1heFggJiYgdGhpcy5tYXhZID09IHRpbGVSYW5nZS5tYXhZO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGlsZVJhbmdlfSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICovXG4gIGV4dGVuZCh0aWxlUmFuZ2UpIHtcbiAgICBpZiAodGlsZVJhbmdlLm1pblggPCB0aGlzLm1pblgpIHtcbiAgICAgIHRoaXMubWluWCA9IHRpbGVSYW5nZS5taW5YO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1heFggPiB0aGlzLm1heFgpIHtcbiAgICAgIHRoaXMubWF4WCA9IHRpbGVSYW5nZS5tYXhYO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1pblkgPCB0aGlzLm1pblkpIHtcbiAgICAgIHRoaXMubWluWSA9IHRpbGVSYW5nZS5taW5ZO1xuICAgIH1cbiAgICBpZiAodGlsZVJhbmdlLm1heFkgPiB0aGlzLm1heFkpIHtcbiAgICAgIHRoaXMubWF4WSA9IHRpbGVSYW5nZS5tYXhZO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodC5cbiAgICovXG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhZIC0gdGhpcy5taW5ZICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gU2l6ZS5cbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmdldFdpZHRoKCksIHRoaXMuZ2V0SGVpZ2h0KCldO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gV2lkdGguXG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhYIC0gdGhpcy5taW5YICsgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RpbGVSYW5nZX0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEludGVyc2VjdHMuXG4gICAqL1xuICBpbnRlcnNlY3RzKHRpbGVSYW5nZSkge1xuICAgIHJldHVybiB0aGlzLm1pblggPD0gdGlsZVJhbmdlLm1heFggJiZcbiAgICAgICB0aGlzLm1heFggPj0gdGlsZVJhbmdlLm1pblggJiZcbiAgICAgICB0aGlzLm1pblkgPD0gdGlsZVJhbmdlLm1heFkgJiZcbiAgICAgICB0aGlzLm1heFkgPj0gdGlsZVJhbmdlLm1pblk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5YIE1pbmltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYIE1heGltdW0gWC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5ZIE1pbmltdW0gWS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhZIE1heGltdW0gWS5cbiAqIEBwYXJhbSB7VGlsZVJhbmdlPX0gdGlsZVJhbmdlIFRpbGVSYW5nZS5cbiAqIEByZXR1cm4ge1RpbGVSYW5nZX0gVGlsZSByYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlKG1pblgsIG1heFgsIG1pblksIG1heFksIHRpbGVSYW5nZSkge1xuICBpZiAodGlsZVJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aWxlUmFuZ2UubWluWCA9IG1pblg7XG4gICAgdGlsZVJhbmdlLm1heFggPSBtYXhYO1xuICAgIHRpbGVSYW5nZS5taW5ZID0gbWluWTtcbiAgICB0aWxlUmFuZ2UubWF4WSA9IG1heFk7XG4gICAgcmV0dXJuIHRpbGVSYW5nZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFRpbGVSYW5nZShtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVSYW5nZTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7Ozs7Ozs7QUFRQTtBQVVBOzs7QUFHQTtBQUVBOzs7O0FBR0E7QUFFQTs7OztBQUdBO0FBRUE7Ozs7QUFHQTtBQUVBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBRUE7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBRUE7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///67\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/**\n * @module ol/style/Stroke\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} [color] A color, gradient or pattern.\n * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.\n * Default null; if null, the Canvas/renderer default black will be used.\n * @property {string} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.\n * @property {string} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.\n * @property {Array<number>} [lineDash] Line dash pattern. Default is `undefined` (no dash).\n * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on\n * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.\n * @property {number} [lineDashOffset=0] Line dash offset.\n * @property {number} [miterLimit=10] Miter limit.\n * @property {number} [width] Width.\n */\n\n/**\n * @classdesc\n * Set stroke style for vector features.\n * Note that the defaults given are the Canvas defaults, which will be used if\n * option is not defined. The `get` functions return whatever was entered in\n * the options; they will not return the default.\n * @api\n */\n\nvar Stroke = function Stroke(opt_options) {\n  var options = opt_options || {};\n  /**\n   * @private\n   * @type {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike}\n   */\n\n  this.color_ = options.color !== undefined ? options.color : null;\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n\n  this.lineCap_ = options.lineCap;\n  /**\n   * @private\n   * @type {Array<number>}\n   */\n\n  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n\n  this.lineDashOffset_ = options.lineDashOffset;\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n\n  this.lineJoin_ = options.lineJoin;\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n\n  this.miterLimit_ = options.miterLimit;\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n\n  this.width_ = options.width;\n  /**\n   * @private\n   * @type {string|undefined}\n   */\n\n  this.checksum_ = undefined;\n};\n/**\n * Clones the style.\n * @return {Stroke} The cloned style.\n * @api\n */\n\n\nStroke.prototype.clone = function clone() {\n  var color = this.getColor();\n  return new Stroke({\n    color: Array.isArray(color) ? color.slice() : color || undefined,\n    lineCap: this.getLineCap(),\n    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,\n    lineDashOffset: this.getLineDashOffset(),\n    lineJoin: this.getLineJoin(),\n    miterLimit: this.getMiterLimit(),\n    width: this.getWidth()\n  });\n};\n/**\n * Get the stroke color.\n * @return {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} Color.\n * @api\n */\n\n\nStroke.prototype.getColor = function getColor() {\n  return this.color_;\n};\n/**\n * Get the line cap type for the stroke.\n * @return {string|undefined} Line cap.\n * @api\n */\n\n\nStroke.prototype.getLineCap = function getLineCap() {\n  return this.lineCap_;\n};\n/**\n * Get the line dash style for the stroke.\n * @return {Array<number>} Line dash.\n * @api\n */\n\n\nStroke.prototype.getLineDash = function getLineDash() {\n  return this.lineDash_;\n};\n/**\n * Get the line dash offset for the stroke.\n * @return {number|undefined} Line dash offset.\n * @api\n */\n\n\nStroke.prototype.getLineDashOffset = function getLineDashOffset() {\n  return this.lineDashOffset_;\n};\n/**\n * Get the line join type for the stroke.\n * @return {string|undefined} Line join.\n * @api\n */\n\n\nStroke.prototype.getLineJoin = function getLineJoin() {\n  return this.lineJoin_;\n};\n/**\n * Get the miter limit for the stroke.\n * @return {number|undefined} Miter limit.\n * @api\n */\n\n\nStroke.prototype.getMiterLimit = function getMiterLimit() {\n  return this.miterLimit_;\n};\n/**\n * Get the stroke width.\n * @return {number|undefined} Width.\n * @api\n */\n\n\nStroke.prototype.getWidth = function getWidth() {\n  return this.width_;\n};\n/**\n * Set the color.\n *\n * @param {import(\"../color.js\").Color|import(\"../colorlike.js\").ColorLike} color Color.\n * @api\n */\n\n\nStroke.prototype.setColor = function setColor(color) {\n  this.color_ = color;\n  this.checksum_ = undefined;\n};\n/**\n * Set the line cap.\n *\n * @param {string|undefined} lineCap Line cap.\n * @api\n */\n\n\nStroke.prototype.setLineCap = function setLineCap(lineCap) {\n  this.lineCap_ = lineCap;\n  this.checksum_ = undefined;\n};\n/**\n * Set the line dash.\n *\n * Please note that Internet Explorer 10 and lower [do not support][mdn] the\n * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this\n * property will have no visual effect in these browsers.\n *\n * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility\n *\n * @param {Array<number>} lineDash Line dash.\n * @api\n */\n\n\nStroke.prototype.setLineDash = function setLineDash(lineDash) {\n  this.lineDash_ = lineDash;\n  this.checksum_ = undefined;\n};\n/**\n * Set the line dash offset.\n *\n * @param {number|undefined} lineDashOffset Line dash offset.\n * @api\n */\n\n\nStroke.prototype.setLineDashOffset = function setLineDashOffset(lineDashOffset) {\n  this.lineDashOffset_ = lineDashOffset;\n  this.checksum_ = undefined;\n};\n/**\n * Set the line join.\n *\n * @param {string|undefined} lineJoin Line join.\n * @api\n */\n\n\nStroke.prototype.setLineJoin = function setLineJoin(lineJoin) {\n  this.lineJoin_ = lineJoin;\n  this.checksum_ = undefined;\n};\n/**\n * Set the miter limit.\n *\n * @param {number|undefined} miterLimit Miter limit.\n * @api\n */\n\n\nStroke.prototype.setMiterLimit = function setMiterLimit(miterLimit) {\n  this.miterLimit_ = miterLimit;\n  this.checksum_ = undefined;\n};\n/**\n * Set the width.\n *\n * @param {number|undefined} width Width.\n * @api\n */\n\n\nStroke.prototype.setWidth = function setWidth(width) {\n  this.width_ = width;\n  this.checksum_ = undefined;\n};\n/**\n * @return {string} The checksum.\n */\n\n\nStroke.prototype.getChecksum = function getChecksum() {\n  if (this.checksum_ === undefined) {\n    this.checksum_ = 's';\n\n    if (this.color_) {\n      if (typeof this.color_ === 'string') {\n        this.checksum_ += this.color_;\n      } else {\n        this.checksum_ += Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* getUid */ \"c\"])(this.color_);\n      }\n    } else {\n      this.checksum_ += '-';\n    }\n\n    this.checksum_ += ',' + (this.lineCap_ !== undefined ? this.lineCap_.toString() : '-') + ',' + (this.lineDash_ ? this.lineDash_.toString() : '-') + ',' + (this.lineDashOffset_ !== undefined ? this.lineDashOffset_ : '-') + ',' + (this.lineJoin_ !== undefined ? this.lineJoin_ : '-') + ',' + (this.miterLimit_ !== undefined ? this.miterLimit_.toString() : '-') + ',' + (this.width_ !== undefined ? this.width_.toString() : '-');\n  }\n\n  return this.checksum_;\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Stroke);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL1N0cm9rZS5qcz85YTU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9TdHJva2VcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBbY29sb3JdIEEgY29sb3IsIGdyYWRpZW50IG9yIHBhdHRlcm4uXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9jb2xvcn5Db2xvcn0gYW5kIHtAbGluayBtb2R1bGU6b2wvY29sb3JsaWtlfkNvbG9yTGlrZX0gZm9yIHBvc3NpYmxlIGZvcm1hdHMuXG4gKiBEZWZhdWx0IG51bGw7IGlmIG51bGwsIHRoZSBDYW52YXMvcmVuZGVyZXIgZGVmYXVsdCBibGFjayB3aWxsIGJlIHVzZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVDYXA9J3JvdW5kJ10gTGluZSBjYXAgc3R5bGU6IGBidXR0YCwgYHJvdW5kYCwgb3IgYHNxdWFyZWAuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVKb2luPSdyb3VuZCddIExpbmUgam9pbiBzdHlsZTogYGJldmVsYCwgYHJvdW5kYCwgb3IgYG1pdGVyYC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW2xpbmVEYXNoXSBMaW5lIGRhc2ggcGF0dGVybi4gRGVmYXVsdCBpcyBgdW5kZWZpbmVkYCAobm8gZGFzaCkuXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IEludGVybmV0IEV4cGxvcmVyIDEwIGFuZCBsb3dlciBkbyBub3Qgc3VwcG9ydCB0aGUgYHNldExpbmVEYXNoYCBtZXRob2Qgb25cbiAqIHRoZSBgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEYCBhbmQgdGhlcmVmb3JlIHRoaXMgb3B0aW9uIHdpbGwgaGF2ZSBubyB2aXN1YWwgZWZmZWN0IGluIHRoZXNlIGJyb3dzZXJzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsaW5lRGFzaE9mZnNldD0wXSBMaW5lIGRhc2ggb2Zmc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaXRlckxpbWl0PTEwXSBNaXRlciBsaW1pdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIFdpZHRoLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgc3Ryb2tlIHN0eWxlIGZvciB2ZWN0b3IgZmVhdHVyZXMuXG4gKiBOb3RlIHRoYXQgdGhlIGRlZmF1bHRzIGdpdmVuIGFyZSB0aGUgQ2FudmFzIGRlZmF1bHRzLCB3aGljaCB3aWxsIGJlIHVzZWQgaWZcbiAqIG9wdGlvbiBpcyBub3QgZGVmaW5lZC4gVGhlIGBnZXRgIGZ1bmN0aW9ucyByZXR1cm4gd2hhdGV2ZXIgd2FzIGVudGVyZWQgaW5cbiAqIHRoZSBvcHRpb25zOyB0aGV5IHdpbGwgbm90IHJldHVybiB0aGUgZGVmYXVsdC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgU3Ryb2tlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J8aW1wb3J0KFwiLi4vY29sb3JsaWtlLmpzXCIpLkNvbG9yTGlrZX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IG9wdGlvbnMuY29sb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY29sb3IgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVDYXBfID0gb3B0aW9ucy5saW5lQ2FwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVEYXNoXyA9IG9wdGlvbnMubGluZURhc2ggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubGluZURhc2ggOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0XyA9IG9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubGluZUpvaW5fID0gb3B0aW9ucy5saW5lSm9pbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5taXRlckxpbWl0XyA9IG9wdGlvbnMubWl0ZXJMaW1pdDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy53aWR0aF8gPSBvcHRpb25zLndpZHRoO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtTdHJva2V9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5nZXRDb2xvcigpO1xuICAgIHJldHVybiBuZXcgU3Ryb2tlKHtcbiAgICAgIGNvbG9yOiBBcnJheS5pc0FycmF5KGNvbG9yKSA/IGNvbG9yLnNsaWNlKCkgOiBjb2xvciB8fCB1bmRlZmluZWQsXG4gICAgICBsaW5lQ2FwOiB0aGlzLmdldExpbmVDYXAoKSxcbiAgICAgIGxpbmVEYXNoOiB0aGlzLmdldExpbmVEYXNoKCkgPyB0aGlzLmdldExpbmVEYXNoKCkuc2xpY2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLmdldExpbmVEYXNoT2Zmc2V0KCksXG4gICAgICBsaW5lSm9pbjogdGhpcy5nZXRMaW5lSm9pbigpLFxuICAgICAgbWl0ZXJMaW1pdDogdGhpcy5nZXRNaXRlckxpbWl0KCksXG4gICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2UgY29sb3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfGltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IENvbG9yLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGNhcCB0eXBlIGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBMaW5lIGNhcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGluZUNhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lQ2FwXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpbmUgZGFzaCBzdHlsZSBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gTGluZSBkYXNoLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lRGFzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lRGFzaF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGRhc2ggb2Zmc2V0IGZvciB0aGUgc3Ryb2tlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBMaW5lIGRhc2ggb2Zmc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lRGFzaE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lRGFzaE9mZnNldF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaW5lIGpvaW4gdHlwZSBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gTGluZSBqb2luLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lSm9pbigpIHtcbiAgICByZXR1cm4gdGhpcy5saW5lSm9pbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaXRlciBsaW1pdCBmb3IgdGhlIHN0cm9rZS5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gTWl0ZXIgbGltaXQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pdGVyTGltaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWl0ZXJMaW1pdF87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugd2lkdGguXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFdpZHRoLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb2xvci5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxpbXBvcnQoXCIuLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSBjb2xvciBDb2xvci5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29sb3IoY29sb3IpIHtcbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuICAgIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGluZSBjYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gbGluZUNhcCBMaW5lIGNhcC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGluZUNhcChsaW5lQ2FwKSB7XG4gICAgdGhpcy5saW5lQ2FwXyA9IGxpbmVDYXA7XG4gICAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGRhc2guXG4gICAqXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgSW50ZXJuZXQgRXhwbG9yZXIgMTAgYW5kIGxvd2VyIFtkbyBub3Qgc3VwcG9ydF1bbWRuXSB0aGVcbiAgICogYHNldExpbmVEYXNoYCBtZXRob2Qgb24gdGhlIGBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGFuZCB0aGVyZWZvcmUgdGhpc1xuICAgKiBwcm9wZXJ0eSB3aWxsIGhhdmUgbm8gdmlzdWFsIGVmZmVjdCBpbiB0aGVzZSBicm93c2Vycy5cbiAgICpcbiAgICogW21kbl06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvc2V0TGluZURhc2gjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gbGluZURhc2ggTGluZSBkYXNoLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMaW5lRGFzaChsaW5lRGFzaCkge1xuICAgIHRoaXMubGluZURhc2hfID0gbGluZURhc2g7XG4gICAgdGhpcy5jaGVja3N1bV8gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaW5lIGRhc2ggb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IGxpbmVEYXNoT2Zmc2V0IExpbmUgZGFzaCBvZmZzZXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgdGhpcy5saW5lRGFzaE9mZnNldF8gPSBsaW5lRGFzaE9mZnNldDtcbiAgICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpbmUgam9pbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBsaW5lSm9pbiBMaW5lIGpvaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldExpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgdGhpcy5saW5lSm9pbl8gPSBsaW5lSm9pbjtcbiAgICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG1pdGVyIGxpbWl0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IG1pdGVyTGltaXQgTWl0ZXIgbGltaXQuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1pdGVyTGltaXQobWl0ZXJMaW1pdCkge1xuICAgIHRoaXMubWl0ZXJMaW1pdF8gPSBtaXRlckxpbWl0O1xuICAgIHRoaXMuY2hlY2tzdW1fID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgd2lkdGguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gd2lkdGggV2lkdGguXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgdGhpcy53aWR0aF8gPSB3aWR0aDtcbiAgICB0aGlzLmNoZWNrc3VtXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjaGVja3N1bS5cbiAgICovXG4gIGdldENoZWNrc3VtKCkge1xuICAgIGlmICh0aGlzLmNoZWNrc3VtXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNoZWNrc3VtXyA9ICdzJztcbiAgICAgIGlmICh0aGlzLmNvbG9yXykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29sb3JfID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuY2hlY2tzdW1fICs9IHRoaXMuY29sb3JfO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2hlY2tzdW1fICs9IGdldFVpZCh0aGlzLmNvbG9yXyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tzdW1fICs9ICctJztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tzdW1fICs9ICcsJyArXG4gICAgICAgICAgKHRoaXMubGluZUNhcF8gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzLmxpbmVDYXBfLnRvU3RyaW5nKCkgOiAnLScpICsgJywnICtcbiAgICAgICAgICAodGhpcy5saW5lRGFzaF8gP1xuICAgICAgICAgICAgdGhpcy5saW5lRGFzaF8udG9TdHJpbmcoKSA6ICctJykgKyAnLCcgK1xuICAgICAgICAgICh0aGlzLmxpbmVEYXNoT2Zmc2V0XyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMubGluZURhc2hPZmZzZXRfIDogJy0nKSArICcsJyArXG4gICAgICAgICAgKHRoaXMubGluZUpvaW5fICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGhpcy5saW5lSm9pbl8gOiAnLScpICsgJywnICtcbiAgICAgICAgICAodGhpcy5taXRlckxpbWl0XyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMubWl0ZXJMaW1pdF8udG9TdHJpbmcoKSA6ICctJykgKyAnLCcgK1xuICAgICAgICAgICh0aGlzLndpZHRoXyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRoaXMud2lkdGhfLnRvU3RyaW5nKCkgOiAnLScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNoZWNrc3VtXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdHJva2U7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBO0FBTUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _EventHandling = _interopRequireDefault(__webpack_require__(64));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/Container\r\n */\n\n/**\r\n  * @desc  An abstract class for accessing a control container and elements within it\r\n  * @public\r\n  * @abstract\r\n  * @class\r\n  * @extends module:nyc/EventHandling~EventHandling\r\n  */\n\n\nvar Container =\n/*#__PURE__*/\nfunction (_EventHandling$defaul) {\n  _inherits(Container, _EventHandling$defaul);\n\n  /**\r\n   * @desc Create an instance of Container\r\n   * @access protected\r\n   * @constructor\r\n   * @param {jQuery|Element|string} container The container node\r\n   */\n  function Container(container) {\n    var _this;\n\n    _classCallCheck(this, Container);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this));\n    _this.container = (0, _jquery["default"])(container);\n    return _this;\n  }\n  /**\r\n   * @desc A method to return a control container HTML element wrapped in a JQuery\r\n   * @public\r\n   * @method\r\n   * @return {jQuery} The the control container HTML element wrapped in a JQuery\r\n   */\n\n\n  _createClass(Container, [{\n    key: "getContainer",\n    value: function getContainer() {\n      return this.container;\n    }\n    /**\r\n     * @desc A method to return elements in the container\r\n     * @public\r\n     * @method\r\n     * @param {string} selector jQuery selector\r\n     * @return {jQuery} The element\r\n     */\n\n  }, {\n    key: "find",\n    value: function find(selector) {\n      return this.getContainer().find(selector);\n    }\n    /**\r\n     * @desc A method to prepend elements to the container\r\n     * @public\r\n     * @method\r\n     * @param {jQuery|Element|Array<Element>|string} elements The element to append\r\n     * @return {jQuery} The container\r\n     */\n\n  }, {\n    key: "prepend",\n    value: function prepend(elements) {\n      return this.getContainer().prepend((0, _jquery["default"])(elements));\n    }\n    /**\r\n     * @desc A method to append elements to the container\r\n     * @public\r\n     * @method\r\n     * @param {jQuery|Element|Array<Element>|string} elements The element to append\r\n     * @return {jQuery} The container\r\n     */\n\n  }, {\n    key: "append",\n    value: function append(elements) {\n      return this.getContainer().append((0, _jquery["default"])(elements));\n    }\n  }]);\n\n  return Container;\n}(_EventHandling["default"]);\n\nvar _default = Container;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnljLWxpYi9ueWMvQ29udGFpbmVyLmpzP2RkY2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfanF1ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwianF1ZXJ5XCIpKTtcblxudmFyIF9FdmVudEhhbmRsaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9FdmVudEhhbmRsaW5nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL0NvbnRhaW5lclxyXG4gKi9cblxuLyoqXHJcbiAgKiBAZGVzYyAgQW4gYWJzdHJhY3QgY2xhc3MgZm9yIGFjY2Vzc2luZyBhIGNvbnRyb2wgY29udGFpbmVyIGFuZCBlbGVtZW50cyB3aXRoaW4gaXRcclxuICAqIEBwdWJsaWNcclxuICAqIEBhYnN0cmFjdFxyXG4gICogQGNsYXNzXHJcbiAgKiBAZXh0ZW5kcyBtb2R1bGU6bnljL0V2ZW50SGFuZGxpbmd+RXZlbnRIYW5kbGluZ1xyXG4gICovXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBfRXZlbnRIYW5kbGluZy5kZWZhdWx0IHtcbiAgLyoqXHJcbiAgICogQGRlc2MgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIENvbnRhaW5lclxyXG4gICAqIEBhY2Nlc3MgcHJvdGVjdGVkXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHtqUXVlcnl8RWxlbWVudHxzdHJpbmd9IGNvbnRhaW5lciBUaGUgY29udGFpbmVyIG5vZGVcclxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGNvbnRhaW5lcik7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgQSBtZXRob2QgdG8gcmV0dXJuIGEgY29udHJvbCBjb250YWluZXIgSFRNTCBlbGVtZW50IHdyYXBwZWQgaW4gYSBKUXVlcnlcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEByZXR1cm4ge2pRdWVyeX0gVGhlIHRoZSBjb250cm9sIGNvbnRhaW5lciBIVE1MIGVsZW1lbnQgd3JhcHBlZCBpbiBhIEpRdWVyeVxyXG4gICAqL1xuXG5cbiAgZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBBIG1ldGhvZCB0byByZXR1cm4gZWxlbWVudHMgaW4gdGhlIGNvbnRhaW5lclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIGpRdWVyeSBzZWxlY3RvclxyXG4gICAqIEByZXR1cm4ge2pRdWVyeX0gVGhlIGVsZW1lbnRcclxuICAgKi9cblxuXG4gIGZpbmQoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb250YWluZXIoKS5maW5kKHNlbGVjdG9yKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBBIG1ldGhvZCB0byBwcmVwZW5kIGVsZW1lbnRzIHRvIHRoZSBjb250YWluZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5fEVsZW1lbnR8QXJyYXk8RWxlbWVudD58c3RyaW5nfSBlbGVtZW50cyBUaGUgZWxlbWVudCB0byBhcHBlbmRcclxuICAgKiBAcmV0dXJuIHtqUXVlcnl9IFRoZSBjb250YWluZXJcclxuICAgKi9cblxuXG4gIHByZXBlbmQoZWxlbWVudHMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb250YWluZXIoKS5wcmVwZW5kKCgwLCBfanF1ZXJ5LmRlZmF1bHQpKGVsZW1lbnRzKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgQSBtZXRob2QgdG8gYXBwZW5kIGVsZW1lbnRzIHRvIHRoZSBjb250YWluZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5fEVsZW1lbnR8QXJyYXk8RWxlbWVudD58c3RyaW5nfSBlbGVtZW50cyBUaGUgZWxlbWVudCB0byBhcHBlbmRcclxuICAgKiBAcmV0dXJuIHtqUXVlcnl9IFRoZSBjb250YWluZXJcclxuICAgKi9cblxuXG4gIGFwcGVuZChlbGVtZW50cykge1xuICAgIHJldHVybiB0aGlzLmdldENvbnRhaW5lcigpLmFwcGVuZCgoMCwgX2pxdWVyeS5kZWZhdWx0KShlbGVtZW50cykpO1xuICB9XG5cbn1cblxudmFyIF9kZWZhdWx0ID0gQ29udGFpbmVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBSUE7Ozs7Ozs7OztBQU9BOzs7OztBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUZBO0FBR0E7QUFDQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7OztBQXpEQTtBQUNBO0FBNERBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///69\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/**\n * @module ol/Disposable\n */\n\n/**\n * @classdesc\n * Objects that need to clean up after themselves.\n */\nvar Disposable = function Disposable() {\n  /**\n   * The object has already been disposed.\n   * @type {boolean}\n   * @private\n   */\n  this.disposed_ = false;\n};\n/**\n * Clean up.\n */\n\n\nDisposable.prototype.dispose = function dispose() {\n  if (!this.disposed_) {\n    this.disposed_ = true;\n    this.disposeInternal();\n  }\n};\n/**\n * Extension point for disposable objects.\n * @protected\n */\n\n\nDisposable.prototype.disposeInternal = function disposeInternal() {};\n\n/* harmony default export */ __webpack_exports__["a"] = (Disposable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL0Rpc3Bvc2FibGUuanM/YmU4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvRGlzcG9zYWJsZVxuICovXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogT2JqZWN0cyB0aGF0IG5lZWQgdG8gY2xlYW4gdXAgYWZ0ZXIgdGhlbXNlbHZlcy5cbiAqL1xuY2xhc3MgRGlzcG9zYWJsZSB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cC5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuICAgICAgdGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5zaW9uIHBvaW50IGZvciBkaXNwb3NhYmxlIG9iamVjdHMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERpc3Bvc2FibGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQVFBO0FBR0E7Ozs7O0FBS0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///70\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformWithOptions", function() { return transformWithOptions; });\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);\n/**\n * @module ol/format/Feature\n */\n\n\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import("../extent.js").Extent} [extent] Tile extent of the tile being read. This is only used and\n * required for {@link module:ol/format/MVT}.\n * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\n\nvar FeatureFormat = function FeatureFormat() {\n  /**\n   * @protected\n   * @type {import("../proj/Projection.js").default}\n   */\n  this.dataProjection = null;\n  /**\n   * @protected\n   * @type {import("../proj/Projection.js").default}\n   */\n\n  this.defaultFeatureProjection = null;\n};\n/**\n * Adds the data projection to the read options.\n * @param {Document|Node|Object|string} source Source.\n * @param {ReadOptions=} opt_options Options.\n * @return {ReadOptions|undefined} Options.\n * @protected\n */\n\n\nFeatureFormat.prototype.getReadOptions = function getReadOptions(source, opt_options) {\n  var options;\n\n  if (opt_options) {\n    options = {\n      dataProjection: opt_options.dataProjection ? opt_options.dataProjection : this.readProjection(source),\n      featureProjection: opt_options.featureProjection\n    };\n  }\n\n  return this.adaptOptions(options);\n};\n/**\n * Sets the `dataProjection` on the options, if no `dataProjection`\n * is set.\n * @param {WriteOptions|ReadOptions|undefined} options\n *   Options.\n * @protected\n * @return {WriteOptions|ReadOptions|undefined}\n *   Updated options.\n */\n\n\nFeatureFormat.prototype.adaptOptions = function adaptOptions(options) {\n  return Object(_obj_js__WEBPACK_IMPORTED_MODULE_0__[/* assign */ "a"])({\n    dataProjection: this.dataProjection,\n    featureProjection: this.defaultFeatureProjection\n  }, options);\n};\n/**\n * Get the extent from the source of the last {@link readFeatures} call.\n * @return {import("../extent.js").Extent} Tile extent.\n */\n\n\nFeatureFormat.prototype.getLastExtent = function getLastExtent() {\n  return null;\n};\n/**\n * @abstract\n * @return {import("./FormatType.js").default} Format.\n */\n\n\nFeatureFormat.prototype.getType = function getType() {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();\n};\n/**\n * Read a single feature from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {ReadOptions=} opt_options Read options.\n * @return {import("../Feature.js").FeatureLike} Feature.\n */\n\n\nFeatureFormat.prototype.readFeature = function readFeature(source, opt_options) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();\n};\n/**\n * Read all features from a source.\n *\n * @abstract\n * @param {Document|Node|ArrayBuffer|Object|string} source Source.\n * @param {ReadOptions=} opt_options Read options.\n * @return {Array<import("../Feature.js").FeatureLike>} Features.\n */\n\n\nFeatureFormat.prototype.readFeatures = function readFeatures(source, opt_options) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();\n};\n/**\n * Read a single geometry from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @param {ReadOptions=} opt_options Read options.\n * @return {import("../geom/Geometry.js").default} Geometry.\n */\n\n\nFeatureFormat.prototype.readGeometry = function readGeometry(source, opt_options) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();\n};\n/**\n * Read the projection from a source.\n *\n * @abstract\n * @param {Document|Node|Object|string} source Source.\n * @return {import("../proj/Projection.js").default} Projection.\n */\n\n\nFeatureFormat.prototype.readProjection = function readProjection(source) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();\n};\n/**\n * Encode a feature in this format.\n *\n * @abstract\n * @param {import("../Feature.js").default} feature Feature.\n * @param {WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n\n\nFeatureFormat.prototype.writeFeature = function writeFeature(feature, opt_options) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();\n};\n/**\n * Encode an array of features in this format.\n *\n * @abstract\n * @param {Array<import("../Feature.js").default>} features Features.\n * @param {WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n\n\nFeatureFormat.prototype.writeFeatures = function writeFeatures(features, opt_options) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();\n};\n/**\n * Write a single geometry in this format.\n *\n * @abstract\n * @param {import("../geom/Geometry.js").default} geometry Geometry.\n * @param {WriteOptions=} opt_options Write options.\n * @return {string} Result.\n */\n\n\nFeatureFormat.prototype.writeGeometry = function writeGeometry(geometry, opt_options) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_1__[/* abstract */ "b"])();\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (FeatureFormat);\n/**\n * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {(WriteOptions|ReadOptions)=} opt_options Options.\n * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent} Transformed geometry.\n */\n\nfunction transformWithOptions(geometry, write, opt_options) {\n  var featureProjection = opt_options ? Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["get"])(opt_options.featureProjection) : null;\n  var dataProjection = opt_options ? Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["get"])(opt_options.dataProjection) : null;\n  /**\n   * @type {import("../geom/Geometry.js").default|import("../extent.js").Extent}\n   */\n\n  var transformed;\n\n  if (featureProjection && dataProjection && !Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["equivalent"])(featureProjection, dataProjection)) {\n    if (Array.isArray(geometry)) {\n      // FIXME this is necessary because GML treats extents\n      // as geometries\n      transformed = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["transformExtent"])(geometry, dataProjection, featureProjection);\n    } else {\n      transformed = (write ?\n      /** @type {import("../geom/Geometry").default} */\n      geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);\n    }\n  } else {\n    transformed = geometry;\n  }\n\n  if (write && opt_options &&\n  /** @type {WriteOptions} */\n  opt_options.decimals !== undefined && !Array.isArray(transformed)) {\n    var power = Math.pow(10,\n    /** @type {WriteOptions} */\n    opt_options.decimals); // if decimals option on write, round each coordinate appropriately\n\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n\n    var transform = function transform(coordinates) {\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n\n      return coordinates;\n    };\n\n    if (transformed === geometry) {\n      transformed =\n      /** @type {import("../geom/Geometry").default} */\n      geometry.clone();\n    }\n\n    transformed.applyTransform(transform);\n  }\n\n  return transformed;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2Zvcm1hdC9GZWF0dXJlLmpzP2E0N2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2Zvcm1hdC9GZWF0dXJlXG4gKi9cbmltcG9ydCB7YXNzaWdufSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9uLCBlcXVpdmFsZW50IGFzIGVxdWl2YWxlbnRQcm9qZWN0aW9uLCB0cmFuc2Zvcm1FeHRlbnR9IGZyb20gJy4uL3Byb2ouanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW2RhdGFQcm9qZWN0aW9uXSBQcm9qZWN0aW9uIG9mIHRoZSBkYXRhIHdlIGFyZSByZWFkaW5nLlxuICogSWYgbm90IHByb3ZpZGVkLCB0aGUgcHJvamVjdGlvbiB3aWxsIGJlIGRlcml2ZWQgZnJvbSB0aGUgZGF0YSAod2hlcmUgcG9zc2libGUpIG9yXG4gKiB0aGUgYGRhdGFQcm9qZWN0aW9uYCBvZiB0aGUgZm9ybWF0IGlzIGFzc2lnbmVkICh3aGVyZSBzZXQpLiBJZiB0aGUgcHJvamVjdGlvblxuICogY2FuIG5vdCBiZSBkZXJpdmVkIGZyb20gdGhlIGRhdGEgYW5kIGlmIG5vIGBkYXRhUHJvamVjdGlvbmAgaXMgc2V0IGZvciBhIGZvcm1hdCxcbiAqIHRoZSBmZWF0dXJlcyB3aWxsIG5vdCBiZSByZXByb2plY3RlZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gW2V4dGVudF0gVGlsZSBleHRlbnQgb2YgdGhlIHRpbGUgYmVpbmcgcmVhZC4gVGhpcyBpcyBvbmx5IHVzZWQgYW5kXG4gKiByZXF1aXJlZCBmb3Ige0BsaW5rIG1vZHVsZTpvbC9mb3JtYXQvTVZUfS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW2ZlYXR1cmVQcm9qZWN0aW9uXSBQcm9qZWN0aW9uIG9mIHRoZSBmZWF0dXJlIGdlb21ldHJpZXNcbiAqIGNyZWF0ZWQgYnkgdGhlIGZvcm1hdCByZWFkZXIuIElmIG5vdCBwcm92aWRlZCwgZmVhdHVyZXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGVcbiAqIGBkYXRhUHJvamVjdGlvbmAuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdyaXRlT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbZGF0YVByb2plY3Rpb25dIFByb2plY3Rpb24gb2YgdGhlIGRhdGEgd2UgYXJlIHdyaXRpbmcuXG4gKiBJZiBub3QgcHJvdmlkZWQsIHRoZSBgZGF0YVByb2plY3Rpb25gIG9mIHRoZSBmb3JtYXQgaXMgYXNzaWduZWQgKHdoZXJlIHNldCkuXG4gKiBJZiBubyBgZGF0YVByb2plY3Rpb25gIGlzIHNldCBmb3IgYSBmb3JtYXQsIHRoZSBmZWF0dXJlcyB3aWxsIGJlIHJldHVybmVkXG4gKiBpbiB0aGUgYGZlYXR1cmVQcm9qZWN0aW9uYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW2ZlYXR1cmVQcm9qZWN0aW9uXSBQcm9qZWN0aW9uIG9mIHRoZSBmZWF0dXJlIGdlb21ldHJpZXNcbiAqIHRoYXQgd2lsbCBiZSBzZXJpYWxpemVkIGJ5IHRoZSBmb3JtYXQgd3JpdGVyLiBJZiBub3QgcHJvdmlkZWQsIGdlb21ldHJpZXMgYXJlIGFzc3VtZWRcbiAqIHRvIGJlIGluIHRoZSBgZGF0YVByb2plY3Rpb25gIGlmIHRoYXQgaXMgc2V0OyBpbiBvdGhlciB3b3JkcywgdGhleSBhcmUgbm90IHRyYW5zZm9ybWVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmlnaHRIYW5kZWRdIFdoZW4gd3JpdGluZyBnZW9tZXRyaWVzLCBmb2xsb3cgdGhlIHJpZ2h0LWhhbmRcbiAqIHJ1bGUgZm9yIGxpbmVhciByaW5nIG9yaWVudGF0aW9uLiAgVGhpcyBtZWFucyB0aGF0IHBvbHlnb25zIHdpbGwgaGF2ZSBjb3VudGVyLWNsb2Nrd2lzZVxuICogZXh0ZXJpb3IgcmluZ3MgYW5kIGNsb2Nrd2lzZSBpbnRlcmlvciByaW5ncy4gIEJ5IGRlZmF1bHQsIGNvb3JkaW5hdGVzIGFyZSBzZXJpYWxpemVkXG4gKiBhcyB0aGV5IGFyZSBwcm92aWRlZCBhdCBjb25zdHJ1Y3Rpb24uICBJZiBgdHJ1ZWAsIHRoZSByaWdodC1oYW5kIHJ1bGUgd2lsbFxuICogYmUgYXBwbGllZC4gIElmIGBmYWxzZWAsIHRoZSBsZWZ0LWhhbmQgcnVsZSB3aWxsIGJlIGFwcGxpZWQgKGNsb2Nrd2lzZSBmb3JcbiAqIGV4dGVyaW9yIGFuZCBjb3VudGVyLWNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLiAgTm90ZSB0aGF0IG5vdCBhbGxcbiAqIGZvcm1hdHMgc3VwcG9ydCB0aGlzLiAgVGhlIEdlb0pTT04gZm9ybWF0IGRvZXMgdXNlIHRoaXMgcHJvcGVydHkgd2hlbiB3cml0aW5nXG4gKiBnZW9tZXRyaWVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWNpbWFsc10gTWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGNvb3JkaW5hdGVzLlxuICogQ29vcmRpbmF0ZXMgYXJlIHN0b3JlZCBpbnRlcm5hbGx5IGFzIGZsb2F0cywgYnV0IGZsb2F0aW5nLXBvaW50IGFyaXRobWV0aWMgY2FuIGNyZWF0ZVxuICogY29vcmRpbmF0ZXMgd2l0aCBhIGxhcmdlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcywgbm90IGdlbmVyYWxseSB3YW50ZWQgb24gb3V0cHV0LlxuICogU2V0IGEgbnVtYmVyIGhlcmUgdG8gcm91bmQgY29vcmRpbmF0ZXMuIENhbiBhbHNvIGJlIHVzZWQgdG8gZW5zdXJlIHRoYXRcbiAqIGNvb3JkaW5hdGVzIHJlYWQgaW4gY2FuIGJlIHdyaXR0ZW4gYmFjayBvdXQgd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgZGVjaW1hbHMuXG4gKiBEZWZhdWx0IGlzIG5vIHJvdW5kaW5nLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciBmZWF0dXJlIGZvcm1hdHMuXG4gKiB7RmVhdHVyZUZvcm1hdH0gc3ViY2xhc3NlcyBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIGRlY29kZSBhbmQgZW5jb2RlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV+RmVhdHVyZX0gb2JqZWN0cyBmcm9tIGEgdmFyaWV0eSBvZiBjb21tb25seSB1c2VkIGdlb3NwYXRpYWxcbiAqIGZpbGUgZm9ybWF0cy4gIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBmb3JtYXQgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgRmVhdHVyZUZvcm1hdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGFQcm9qZWN0aW9uID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0RmVhdHVyZVByb2plY3Rpb24gPSBudWxsO1xuXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZGF0YSBwcm9qZWN0aW9uIHRvIHRoZSByZWFkIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8Tm9kZXxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcGFyYW0ge1JlYWRPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucy5cbiAgICogQHJldHVybiB7UmVhZE9wdGlvbnN8dW5kZWZpbmVkfSBPcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRSZWFkT3B0aW9ucyhzb3VyY2UsIG9wdF9vcHRpb25zKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKG9wdF9vcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBkYXRhUHJvamVjdGlvbjogb3B0X29wdGlvbnMuZGF0YVByb2plY3Rpb24gP1xuICAgICAgICAgIG9wdF9vcHRpb25zLmRhdGFQcm9qZWN0aW9uIDogdGhpcy5yZWFkUHJvamVjdGlvbihzb3VyY2UpLFxuICAgICAgICBmZWF0dXJlUHJvamVjdGlvbjogb3B0X29wdGlvbnMuZmVhdHVyZVByb2plY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFkYXB0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBgZGF0YVByb2plY3Rpb25gIG9uIHRoZSBvcHRpb25zLCBpZiBubyBgZGF0YVByb2plY3Rpb25gXG4gICAqIGlzIHNldC5cbiAgICogQHBhcmFtIHtXcml0ZU9wdGlvbnN8UmVhZE9wdGlvbnN8dW5kZWZpbmVkfSBvcHRpb25zXG4gICAqICAgICBPcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge1dyaXRlT3B0aW9uc3xSZWFkT3B0aW9uc3x1bmRlZmluZWR9XG4gICAqICAgICBVcGRhdGVkIG9wdGlvbnMuXG4gICAqL1xuICBhZGFwdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBhc3NpZ24oe1xuICAgICAgZGF0YVByb2plY3Rpb246IHRoaXMuZGF0YVByb2plY3Rpb24sXG4gICAgICBmZWF0dXJlUHJvamVjdGlvbjogdGhpcy5kZWZhdWx0RmVhdHVyZVByb2plY3Rpb25cbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBmcm9tIHRoZSBzb3VyY2Ugb2YgdGhlIGxhc3Qge0BsaW5rIHJlYWRGZWF0dXJlc30gY2FsbC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGlsZSBleHRlbnQuXG4gICAqL1xuICBnZXRMYXN0RXh0ZW50KCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0Zvcm1hdFR5cGUuanNcIikuZGVmYXVsdH0gRm9ybWF0LlxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2luZ2xlIGZlYXR1cmUgZnJvbSBhIHNvdXJjZS5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8Tm9kZXxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlLlxuICAgKiBAcGFyYW0ge1JlYWRPcHRpb25zPX0gb3B0X29wdGlvbnMgUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBGZWF0dXJlLlxuICAgKi9cbiAgcmVhZEZlYXR1cmUoc291cmNlLCBvcHRfb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYWxsIGZlYXR1cmVzIGZyb20gYSBzb3VyY2UuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0RvY3VtZW50fE5vZGV8QXJyYXlCdWZmZXJ8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtSZWFkT3B0aW9ucz19IG9wdF9vcHRpb25zIFJlYWQgb3B0aW9ucy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZT59IEZlYXR1cmVzLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVzKHNvdXJjZSwgb3B0X29wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2luZ2xlIGdlb21ldHJ5IGZyb20gYSBzb3VyY2UuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0RvY3VtZW50fE5vZGV8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtSZWFkT3B0aW9ucz19IG9wdF9vcHRpb25zIFJlYWQgb3B0aW9ucy5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBHZW9tZXRyeS5cbiAgICovXG4gIHJlYWRHZW9tZXRyeShzb3VyY2UsIG9wdF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgcHJvamVjdGlvbiBmcm9tIGEgc291cmNlLlxuICAgKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtEb2N1bWVudHxOb2RlfE9iamVjdHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBQcm9qZWN0aW9uLlxuICAgKi9cbiAgcmVhZFByb2plY3Rpb24oc291cmNlKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGEgZmVhdHVyZSBpbiB0aGlzIGZvcm1hdC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7V3JpdGVPcHRpb25zPX0gb3B0X29wdGlvbnMgV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHQuXG4gICAqL1xuICB3cml0ZUZlYXR1cmUoZmVhdHVyZSwgb3B0X29wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYW4gYXJyYXkgb2YgZmVhdHVyZXMgaW4gdGhpcyBmb3JtYXQuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIEZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge1dyaXRlT3B0aW9ucz19IG9wdF9vcHRpb25zIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0LlxuICAgKi9cbiAgd3JpdGVGZWF0dXJlcyhmZWF0dXJlcywgb3B0X29wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpbmdsZSBnZW9tZXRyeSBpbiB0aGlzIGZvcm1hdC5cbiAgICpcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtXcml0ZU9wdGlvbnM9fSBvcHRfb3B0aW9ucyBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdC5cbiAgICovXG4gIHdyaXRlR2VvbWV0cnkoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRmVhdHVyZUZvcm1hdDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gd3JpdGUgU2V0IHRvIHRydWUgZm9yIHdyaXRpbmcsIGZhbHNlIGZvciByZWFkaW5nLlxuICogQHBhcmFtIHsoV3JpdGVPcHRpb25zfFJlYWRPcHRpb25zKT19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVHJhbnNmb3JtZWQgZ2VvbWV0cnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1XaXRoT3B0aW9ucyhnZW9tZXRyeSwgd3JpdGUsIG9wdF9vcHRpb25zKSB7XG4gIGNvbnN0IGZlYXR1cmVQcm9qZWN0aW9uID0gb3B0X29wdGlvbnMgP1xuICAgIGdldFByb2plY3Rpb24ob3B0X29wdGlvbnMuZmVhdHVyZVByb2plY3Rpb24pIDogbnVsbDtcbiAgY29uc3QgZGF0YVByb2plY3Rpb24gPSBvcHRfb3B0aW9ucyA/XG4gICAgZ2V0UHJvamVjdGlvbihvcHRfb3B0aW9ucy5kYXRhUHJvamVjdGlvbikgOiBudWxsO1xuICAvKipcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgKi9cbiAgbGV0IHRyYW5zZm9ybWVkO1xuICBpZiAoZmVhdHVyZVByb2plY3Rpb24gJiYgZGF0YVByb2plY3Rpb24gJiZcbiAgICAgICFlcXVpdmFsZW50UHJvamVjdGlvbihmZWF0dXJlUHJvamVjdGlvbiwgZGF0YVByb2plY3Rpb24pKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VvbWV0cnkpKSB7XG4gICAgICAvLyBGSVhNRSB0aGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIEdNTCB0cmVhdHMgZXh0ZW50c1xuICAgICAgLy8gYXMgZ2VvbWV0cmllc1xuICAgICAgdHJhbnNmb3JtZWQgPSB0cmFuc2Zvcm1FeHRlbnQoXG4gICAgICAgIGdlb21ldHJ5LFxuICAgICAgICBkYXRhUHJvamVjdGlvbixcbiAgICAgICAgZmVhdHVyZVByb2plY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9ICh3cml0ZSA/IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeVwiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmNsb25lKCkgOiBnZW9tZXRyeSkudHJhbnNmb3JtKFxuICAgICAgICB3cml0ZSA/IGZlYXR1cmVQcm9qZWN0aW9uIDogZGF0YVByb2plY3Rpb24sXG4gICAgICAgIHdyaXRlID8gZGF0YVByb2plY3Rpb24gOiBmZWF0dXJlUHJvamVjdGlvbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRyYW5zZm9ybWVkID0gZ2VvbWV0cnk7XG4gIH1cbiAgaWYgKHdyaXRlICYmIG9wdF9vcHRpb25zICYmIC8qKiBAdHlwZSB7V3JpdGVPcHRpb25zfSAqLyAob3B0X29wdGlvbnMpLmRlY2ltYWxzICE9PSB1bmRlZmluZWQgJiZcbiAgICAhQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZCkpIHtcbiAgICBjb25zdCBwb3dlciA9IE1hdGgucG93KDEwLCAvKiogQHR5cGUge1dyaXRlT3B0aW9uc30gKi8gKG9wdF9vcHRpb25zKS5kZWNpbWFscyk7XG4gICAgLy8gaWYgZGVjaW1hbHMgb3B0aW9uIG9uIHdyaXRlLCByb3VuZCBlYWNoIGNvb3JkaW5hdGUgYXBwcm9wcmlhdGVseVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gVHJhbnNmb3JtZWQgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgY29uc3QgdHJhbnNmb3JtID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29vcmRpbmF0ZXNbaV0gPSBNYXRoLnJvdW5kKGNvb3JkaW5hdGVzW2ldICogcG93ZXIpIC8gcG93ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgfTtcbiAgICBpZiAodHJhbnNmb3JtZWQgPT09IGdlb21ldHJ5KSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeVwiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmNsb25lKCk7XG4gICAgfVxuICAgIHRyYW5zZm9ybWVkLmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zZm9ybWVkO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3REE7QUFHQTs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUhBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQVFBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFFQTs7O0FBR0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///71\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toFunction", function() { return toFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDefaultStyle", function() { return createDefaultStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEditingStyle", function() { return createEditingStyle; });\n/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var _Circle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(82);\n/* harmony import */ var _Fill_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(58);\n/* harmony import */ var _Stroke_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68);\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * @module ol/style/Style\n */\n\n/**\n * Feature styles.\n *\n * If no style is defined, the following default style is used:\n * ```js\n *  import {Fill, Stroke, Circle, Style} from \'ol/style\';\n *\n *  var fill = new Fill({\n *    color: \'rgba(255,255,255,0.4)\'\n *  });\n *  var stroke = new Stroke({\n *    color: \'#3399CC\',\n *    width: 1.25\n *  });\n *  var styles = [\n *    new Style({\n *      image: new Circle({\n *        fill: fill,\n *        stroke: stroke,\n *        radius: 5\n *      }),\n *      fill: fill,\n *      stroke: stroke\n *    })\n *  ];\n * ```\n *\n * A separate editing style has the following defaults:\n * ```js\n *  import {Fill, Stroke, Circle, Style} from \'ol/style\';\n *  import GeometryType from \'ol/geom/GeometryType\';\n *\n *  var white = [255, 255, 255, 1];\n *  var blue = [0, 153, 255, 1];\n *  var width = 3;\n *  styles[GeometryType.POLYGON] = [\n *    new Style({\n *      fill: new Fill({\n *        color: [255, 255, 255, 0.5]\n *      })\n *    })\n *  ];\n *  styles[GeometryType.MULTI_POLYGON] =\n *      styles[GeometryType.POLYGON];\n *  styles[GeometryType.LINE_STRING] = [\n *    new Style({\n *      stroke: new Stroke({\n *        color: white,\n *        width: width + 2\n *      })\n *    }),\n *    new Style({\n *      stroke: new Stroke({\n *        color: blue,\n *        width: width\n *      })\n *    })\n *  ];\n *  styles[GeometryType.MULTI_LINE_STRING] =\n *      styles[GeometryType.LINE_STRING];\n *  styles[GeometryType.POINT] = [\n *    new Style({\n *      image: new Circle({\n *        radius: width * 2,\n *        fill: new Fill({\n *          color: blue\n *        }),\n *        stroke: new Stroke({\n *          color: white,\n *          width: width / 2\n *        })\n *      }),\n *      zIndex: Infinity\n *    })\n *  ];\n *  styles[GeometryType.MULTI_POINT] =\n *      styles[GeometryType.POINT];\n *  styles[GeometryType.GEOMETRY_COLLECTION] =\n *      styles[GeometryType.POLYGON].concat(\n *          styles[GeometryType.LINE_STRING],\n *          styles[GeometryType.POINT]\n *      );\n * ```\n */\n\n\n\n\n\n/**\n * A function that takes an {@link module:ol/Feature} and a `{number}`\n * representing the view\'s resolution. The function should return a\n * {@link module:ol/style/Style} or an array of them. This way e.g. a\n * vector layer can be styled.\n *\n * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>)} StyleFunction\n */\n\n/**\n * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.\n * @typedef {Style|Array<Style>|StyleFunction} StyleLike\n */\n\n/**\n * A function that takes an {@link module:ol/Feature} as argument and returns an\n * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.\n *\n * @typedef {function(import("../Feature.js").FeatureLike):\n *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction\n */\n\n/**\n * Custom renderer function. Takes two arguments:\n *\n * 1. The pixel coordinates of the geometry in GeoJSON notation.\n * 2. The {@link module:ol/render~State} of the layer renderer.\n *\n * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State)}\n * RenderFunction\n */\n\n/**\n * @typedef {Object} Options\n * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry\n * or function returning a geometry to render for this style.\n * @property {import("./Fill.js").default} [fill] Fill style.\n * @property {import("./Image.js").default} [image] Image style.\n * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be\n * ignored, and the provided function will be called with each render frame for each geometry.\n * @property {import("./Stroke.js").default} [stroke] Stroke style.\n * @property {import("./Text.js").default} [text] Text style.\n * @property {number} [zIndex] Z index.\n */\n\n/**\n * @classdesc\n * Container for vector feature rendering styles. Any changes made to the style\n * or its children through `set*()` methods will not take effect until the\n * feature or layer that uses the style is re-rendered.\n * @api\n */\n\nvar Style = function Style(opt_options) {\n  var options = opt_options || {};\n  /**\n   * @private\n   * @type {string|import("../geom/Geometry.js").default|GeometryFunction}\n   */\n\n  this.geometry_ = null;\n  /**\n   * @private\n   * @type {!GeometryFunction}\n   */\n\n  this.geometryFunction_ = defaultGeometryFunction;\n\n  if (options.geometry !== undefined) {\n    this.setGeometry(options.geometry);\n  }\n  /**\n   * @private\n   * @type {import("./Fill.js").default}\n   */\n\n\n  this.fill_ = options.fill !== undefined ? options.fill : null;\n  /**\n     * @private\n     * @type {import("./Image.js").default}\n     */\n\n  this.image_ = options.image !== undefined ? options.image : null;\n  /**\n   * @private\n   * @type {RenderFunction|null}\n   */\n\n  this.renderer_ = options.renderer !== undefined ? options.renderer : null;\n  /**\n   * @private\n   * @type {import("./Stroke.js").default}\n   */\n\n  this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n  /**\n   * @private\n   * @type {import("./Text.js").default}\n   */\n\n  this.text_ = options.text !== undefined ? options.text : null;\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n\n  this.zIndex_ = options.zIndex;\n};\n/**\n * Clones the style.\n * @return {Style} The cloned style.\n * @api\n */\n\n\nStyle.prototype.clone = function clone() {\n  var geometry = this.getGeometry();\n\n  if (geometry && _typeof(geometry) === \'object\') {\n    geometry =\n    /** @type {import("../geom/Geometry.js").default} */\n    geometry.clone();\n  }\n\n  return new Style({\n    geometry: geometry,\n    fill: this.getFill() ? this.getFill().clone() : undefined,\n    image: this.getImage() ? this.getImage().clone() : undefined,\n    stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n    text: this.getText() ? this.getText().clone() : undefined,\n    zIndex: this.getZIndex()\n  });\n};\n/**\n * Get the custom renderer function that was configured with\n * {@link #setRenderer} or the `renderer` constructor option.\n * @return {RenderFunction|null} Custom renderer function.\n * @api\n */\n\n\nStyle.prototype.getRenderer = function getRenderer() {\n  return this.renderer_;\n};\n/**\n * Sets a custom renderer function for this style. When set, `fill`, `stroke`\n * and `image` options of the style will be ignored.\n * @param {RenderFunction|null} renderer Custom renderer function.\n * @api\n */\n\n\nStyle.prototype.setRenderer = function setRenderer(renderer) {\n  this.renderer_ = renderer;\n};\n/**\n * Get the geometry to be rendered.\n * @return {string|import("../geom/Geometry.js").default|GeometryFunction}\n * Feature property or geometry or function that returns the geometry that will\n * be rendered with this style.\n * @api\n */\n\n\nStyle.prototype.getGeometry = function getGeometry() {\n  return this.geometry_;\n};\n/**\n * Get the function used to generate a geometry for rendering.\n * @return {!GeometryFunction} Function that is called with a feature\n * and returns the geometry to render instead of the feature\'s geometry.\n * @api\n */\n\n\nStyle.prototype.getGeometryFunction = function getGeometryFunction() {\n  return this.geometryFunction_;\n};\n/**\n * Get the fill style.\n * @return {import("./Fill.js").default} Fill style.\n * @api\n */\n\n\nStyle.prototype.getFill = function getFill() {\n  return this.fill_;\n};\n/**\n * Set the fill style.\n * @param {import("./Fill.js").default} fill Fill style.\n * @api\n */\n\n\nStyle.prototype.setFill = function setFill(fill) {\n  this.fill_ = fill;\n};\n/**\n * Get the image style.\n * @return {import("./Image.js").default} Image style.\n * @api\n */\n\n\nStyle.prototype.getImage = function getImage() {\n  return this.image_;\n};\n/**\n * Set the image style.\n * @param {import("./Image.js").default} image Image style.\n * @api\n */\n\n\nStyle.prototype.setImage = function setImage(image) {\n  this.image_ = image;\n};\n/**\n * Get the stroke style.\n * @return {import("./Stroke.js").default} Stroke style.\n * @api\n */\n\n\nStyle.prototype.getStroke = function getStroke() {\n  return this.stroke_;\n};\n/**\n * Set the stroke style.\n * @param {import("./Stroke.js").default} stroke Stroke style.\n * @api\n */\n\n\nStyle.prototype.setStroke = function setStroke(stroke) {\n  this.stroke_ = stroke;\n};\n/**\n * Get the text style.\n * @return {import("./Text.js").default} Text style.\n * @api\n */\n\n\nStyle.prototype.getText = function getText() {\n  return this.text_;\n};\n/**\n * Set the text style.\n * @param {import("./Text.js").default} text Text style.\n * @api\n */\n\n\nStyle.prototype.setText = function setText(text) {\n  this.text_ = text;\n};\n/**\n * Get the z-index for the style.\n * @return {number|undefined} ZIndex.\n * @api\n */\n\n\nStyle.prototype.getZIndex = function getZIndex() {\n  return this.zIndex_;\n};\n/**\n * Set a geometry that is rendered instead of the feature\'s geometry.\n *\n * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry\n *   Feature property or geometry or function returning a geometry to render\n *   for this style.\n * @api\n */\n\n\nStyle.prototype.setGeometry = function setGeometry(geometry) {\n  if (typeof geometry === \'function\') {\n    this.geometryFunction_ = geometry;\n  } else if (typeof geometry === \'string\') {\n    this.geometryFunction_ = function (feature) {\n      return (\n        /** @type {import("../geom/Geometry.js").default} */\n        feature.get(geometry)\n      );\n    };\n  } else if (!geometry) {\n    this.geometryFunction_ = defaultGeometryFunction;\n  } else if (geometry !== undefined) {\n    this.geometryFunction_ = function () {\n      return (\n        /** @type {import("../geom/Geometry.js").default} */\n        geometry\n      );\n    };\n  }\n\n  this.geometry_ = geometry;\n};\n/**\n * Set the z-index.\n *\n * @param {number|undefined} zIndex ZIndex.\n * @api\n */\n\n\nStyle.prototype.setZIndex = function setZIndex(zIndex) {\n  this.zIndex_ = zIndex;\n};\n/**\n * Convert the provided object into a style function.  Functions passed through\n * unchanged.  Arrays of Style or single style objects wrapped in a\n * new style function.\n * @param {StyleFunction|Array<Style>|Style} obj\n *     A style function, a single style, or an array of styles.\n * @return {StyleFunction} A style function.\n */\n\n\nfunction toFunction(obj) {\n  var styleFunction;\n\n  if (typeof obj === \'function\') {\n    styleFunction = obj;\n  } else {\n    /**\n     * @type {Array<Style>}\n     */\n    var styles;\n\n    if (Array.isArray(obj)) {\n      styles = obj;\n    } else {\n      Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(typeof\n      /** @type {?} */\n      obj.getZIndex === \'function\', 41); // Expected an `Style` or an array of `Style`\n\n      var style =\n      /** @type {Style} */\n      obj;\n      styles = [style];\n    }\n\n    styleFunction = function styleFunction() {\n      return styles;\n    };\n  }\n\n  return styleFunction;\n}\n/**\n * @type {Array<Style>}\n */\n\nvar defaultStyles = null;\n/**\n * @param {import("../Feature.js").FeatureLike} feature Feature.\n * @param {number} resolution Resolution.\n * @return {Array<Style>} Style.\n */\n\nfunction createDefaultStyle(feature, resolution) {\n  // We don\'t use an immediately-invoked function\n  // and a closure so we don\'t get an error at script evaluation time in\n  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does\n  // canvas.getContext(\'2d\') at construction time, which will cause an.error\n  // in such browsers.)\n  if (!defaultStyles) {\n    var fill = new _Fill_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]({\n      color: \'rgba(255,255,255,0.4)\'\n    });\n    var stroke = new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]({\n      color: \'#3399CC\',\n      width: 1.25\n    });\n    defaultStyles = [new Style({\n      image: new _Circle_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({\n        fill: fill,\n        stroke: stroke,\n        radius: 5\n      }),\n      fill: fill,\n      stroke: stroke\n    })];\n  }\n\n  return defaultStyles;\n}\n/**\n * Default styles for editing features.\n * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles\n */\n\nfunction createEditingStyle() {\n  /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */\n  var styles = {};\n  var white = [255, 255, 255, 1];\n  var blue = [0, 153, 255, 1];\n  var width = 3;\n  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POLYGON] = [new Style({\n    fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]({\n      color: [255, 255, 255, 0.5]\n    })\n  })];\n  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_POLYGON] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POLYGON];\n  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINE_STRING] = [new Style({\n    stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]({\n      color: white,\n      width: width + 2\n    })\n  }), new Style({\n    stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]({\n      color: blue,\n      width: width\n    })\n  })];\n  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_LINE_STRING] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINE_STRING];\n  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].CIRCLE] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POLYGON].concat(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINE_STRING]);\n  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINT] = [new Style({\n    image: new _Circle_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({\n      radius: width * 2,\n      fill: new _Fill_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]({\n        color: blue\n      }),\n      stroke: new _Stroke_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]({\n        color: white,\n        width: width / 2\n      })\n    }),\n    zIndex: Infinity\n  })];\n  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_POINT] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINT];\n  styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].GEOMETRY_COLLECTION] = styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POLYGON].concat(styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINE_STRING], styles[_geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINT]);\n  return styles;\n}\n/**\n * Function that is called with a feature and returns its default geometry.\n * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.\n * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.\n */\n\nfunction defaultGeometryFunction(feature) {\n  return feature.getGeometry();\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (Style);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL1N0eWxlLmpzPzk0ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1N0eWxlXG4gKi9cblxuLyoqXG4gKiBGZWF0dXJlIHN0eWxlcy5cbiAqXG4gKiBJZiBubyBzdHlsZSBpcyBkZWZpbmVkLCB0aGUgZm9sbG93aW5nIGRlZmF1bHQgc3R5bGUgaXMgdXNlZDpcbiAqIGBgYGpzXG4gKiAgaW1wb3J0IHtGaWxsLCBTdHJva2UsIENpcmNsZSwgU3R5bGV9IGZyb20gJ29sL3N0eWxlJztcbiAqXG4gKiAgdmFyIGZpbGwgPSBuZXcgRmlsbCh7XG4gKiAgICBjb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC40KSdcbiAqICB9KTtcbiAqICB2YXIgc3Ryb2tlID0gbmV3IFN0cm9rZSh7XG4gKiAgICBjb2xvcjogJyMzMzk5Q0MnLFxuICogICAgd2lkdGg6IDEuMjVcbiAqICB9KTtcbiAqICB2YXIgc3R5bGVzID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgaW1hZ2U6IG5ldyBDaXJjbGUoe1xuICogICAgICAgIGZpbGw6IGZpbGwsXG4gKiAgICAgICAgc3Ryb2tlOiBzdHJva2UsXG4gKiAgICAgICAgcmFkaXVzOiA1XG4gKiAgICAgIH0pLFxuICogICAgICBmaWxsOiBmaWxsLFxuICogICAgICBzdHJva2U6IHN0cm9rZVxuICogICAgfSlcbiAqICBdO1xuICogYGBgXG4gKlxuICogQSBzZXBhcmF0ZSBlZGl0aW5nIHN0eWxlIGhhcyB0aGUgZm9sbG93aW5nIGRlZmF1bHRzOlxuICogYGBganNcbiAqICBpbXBvcnQge0ZpbGwsIFN0cm9rZSwgQ2lyY2xlLCBTdHlsZX0gZnJvbSAnb2wvc3R5bGUnO1xuICogIGltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnb2wvZ2VvbS9HZW9tZXRyeVR5cGUnO1xuICpcbiAqICB2YXIgd2hpdGUgPSBbMjU1LCAyNTUsIDI1NSwgMV07XG4gKiAgdmFyIGJsdWUgPSBbMCwgMTUzLCAyNTUsIDFdO1xuICogIHZhciB3aWR0aCA9IDM7XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAqICAgICAgICBjb2xvcjogWzI1NSwgMjU1LCAyNTUsIDAuNV1cbiAqICAgICAgfSlcbiAqICAgIH0pXG4gKiAgXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT05dID1cbiAqICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXSA9IFtcbiAqICAgIG5ldyBTdHlsZSh7XG4gKiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gKiAgICAgICAgY29sb3I6IHdoaXRlLFxuICogICAgICAgIHdpZHRoOiB3aWR0aCArIDJcbiAqICAgICAgfSlcbiAqICAgIH0pLFxuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAqICAgICAgICBjb2xvcjogYmx1ZSxcbiAqICAgICAgICB3aWR0aDogd2lkdGhcbiAqICAgICAgfSlcbiAqICAgIH0pXG4gKiAgXTtcbiAqICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HXSA9XG4gKiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddO1xuICogIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9JTlRdID0gW1xuICogICAgbmV3IFN0eWxlKHtcbiAqICAgICAgaW1hZ2U6IG5ldyBDaXJjbGUoe1xuICogICAgICAgIHJhZGl1czogd2lkdGggKiAyLFxuICogICAgICAgIGZpbGw6IG5ldyBGaWxsKHtcbiAqICAgICAgICAgIGNvbG9yOiBibHVlXG4gKiAgICAgICAgfSksXG4gKiAgICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAqICAgICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAqICAgICAgICAgIHdpZHRoOiB3aWR0aCAvIDJcbiAqICAgICAgICB9KVxuICogICAgICB9KSxcbiAqICAgICAgekluZGV4OiBJbmZpbml0eVxuICogICAgfSlcbiAqICBdO1xuICogIHN0eWxlc1tHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlRdID1cbiAqICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF07XG4gKiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OXSA9XG4gKiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0uY29uY2F0KFxuICogICAgICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10sXG4gKiAgICAgICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPSU5UXVxuICogICAgICApO1xuICogYGBgXG4gKi9cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IENpcmNsZVN0eWxlIGZyb20gJy4vQ2lyY2xlLmpzJztcbmltcG9ydCBGaWxsIGZyb20gJy4vRmlsbC5qcyc7XG5pbXBvcnQgU3Ryb2tlIGZyb20gJy4vU3Ryb2tlLmpzJztcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmV9IGFuZCBhIGB7bnVtYmVyfWBcbiAqIHJlcHJlc2VudGluZyB0aGUgdmlldydzIHJlc29sdXRpb24uIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvU3R5bGV9IG9yIGFuIGFycmF5IG9mIHRoZW0uIFRoaXMgd2F5IGUuZy4gYVxuICogdmVjdG9yIGxheWVyIGNhbiBiZSBzdHlsZWQuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIG51bWJlcik6KFN0eWxlfEFycmF5PFN0eWxlPil9IFN0eWxlRnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEge0BsaW5rIFN0eWxlfSwgYW4gYXJyYXkgb2Yge0BsaW5rIFN0eWxlfSwgb3IgYSB7QGxpbmsgU3R5bGVGdW5jdGlvbn0uXG4gKiBAdHlwZWRlZiB7U3R5bGV8QXJyYXk8U3R5bGU+fFN0eWxlRnVuY3Rpb259IFN0eWxlTGlrZVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvRmVhdHVyZX0gYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9HZW9tZXRyeX0gdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGFuZCBzdHlsZWQgZm9yIHRoZSBmZWF0dXJlLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlKTpcbiAqICAgICAoaW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL3JlbmRlci9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkKX0gR2VvbWV0cnlGdW5jdGlvblxuICovXG5cblxuLyoqXG4gKiBDdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24uIFRha2VzIHR3byBhcmd1bWVudHM6XG4gKlxuICogMS4gVGhlIHBpeGVsIGNvb3JkaW5hdGVzIG9mIHRoZSBnZW9tZXRyeSBpbiBHZW9KU09OIG5vdGF0aW9uLlxuICogMi4gVGhlIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyflN0YXRlfSBvZiB0aGUgbGF5ZXIgcmVuZGVyZXIuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+PiksaW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLlN0YXRlKX1cbiAqIFJlbmRlckZ1bmN0aW9uXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufSBbZ2VvbWV0cnldIEZlYXR1cmUgcHJvcGVydHkgb3IgZ2VvbWV0cnlcbiAqIG9yIGZ1bmN0aW9uIHJldHVybmluZyBhIGdlb21ldHJ5IHRvIHJlbmRlciBmb3IgdGhpcyBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtmaWxsXSBGaWxsIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9IFtpbWFnZV0gSW1hZ2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge1JlbmRlckZ1bmN0aW9ufSBbcmVuZGVyZXJdIEN1c3RvbSByZW5kZXJlci4gV2hlbiBjb25maWd1cmVkLCBgZmlsbGAsIGBzdHJva2VgIGFuZCBgaW1hZ2VgIHdpbGwgYmVcbiAqIGlnbm9yZWQsIGFuZCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCBlYWNoIHJlbmRlciBmcmFtZSBmb3IgZWFjaCBnZW9tZXRyeS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gW3RleHRdIFRleHQgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gWiBpbmRleC5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENvbnRhaW5lciBmb3IgdmVjdG9yIGZlYXR1cmUgcmVuZGVyaW5nIHN0eWxlcy4gQW55IGNoYW5nZXMgbWFkZSB0byB0aGUgc3R5bGVcbiAqIG9yIGl0cyBjaGlsZHJlbiB0aHJvdWdoIGBzZXQqKClgIG1ldGhvZHMgd2lsbCBub3QgdGFrZSBlZmZlY3QgdW50aWwgdGhlXG4gKiBmZWF0dXJlIG9yIGxheWVyIHRoYXQgdXNlcyB0aGUgc3R5bGUgaXMgcmUtcmVuZGVyZWQuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIFN0eWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFHZW9tZXRyeUZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBkZWZhdWx0R2VvbWV0cnlGdW5jdGlvbjtcblxuICAgIGlmIChvcHRpb25zLmdlb21ldHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0R2VvbWV0cnkob3B0aW9ucy5nZW9tZXRyeSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0ltYWdlLmpzXCIpLmRlZmF1bHR9XG4gICAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG9wdGlvbnMuaW1hZ2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaW1hZ2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UmVuZGVyRnVuY3Rpb258bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IG9wdGlvbnMucmVuZGVyZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyZXIgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50ZXh0XyA9IG9wdGlvbnMudGV4dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50ZXh0IDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy56SW5kZXhfID0gb3B0aW9ucy56SW5kZXg7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtTdHlsZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgbGV0IGdlb21ldHJ5ID0gdGhpcy5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSAmJiB0eXBlb2YgZ2VvbWV0cnkgPT09ICdvYmplY3QnKSB7XG4gICAgICBnZW9tZXRyeSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3R5bGUoe1xuICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgaW1hZ2U6IHRoaXMuZ2V0SW1hZ2UoKSA/IHRoaXMuZ2V0SW1hZ2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgdGV4dDogdGhpcy5nZXRUZXh0KCkgPyB0aGlzLmdldFRleHQoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgekluZGV4OiB0aGlzLmdldFpJbmRleCgpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXN0b20gcmVuZGVyZXIgZnVuY3Rpb24gdGhhdCB3YXMgY29uZmlndXJlZCB3aXRoXG4gICAqIHtAbGluayAjc2V0UmVuZGVyZXJ9IG9yIHRoZSBgcmVuZGVyZXJgIGNvbnN0cnVjdG9yIG9wdGlvbi5cbiAgICogQHJldHVybiB7UmVuZGVyRnVuY3Rpb258bnVsbH0gQ3VzdG9tIHJlbmRlcmVyIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl87XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGN1c3RvbSByZW5kZXJlciBmdW5jdGlvbiBmb3IgdGhpcyBzdHlsZS4gV2hlbiBzZXQsIGBmaWxsYCwgYHN0cm9rZWBcbiAgICogYW5kIGBpbWFnZWAgb3B0aW9ucyBvZiB0aGUgc3R5bGUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge1JlbmRlckZ1bmN0aW9ufG51bGx9IHJlbmRlcmVyIEN1c3RvbSByZW5kZXJlciBmdW5jdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICB0aGlzLnJlbmRlcmVyXyA9IHJlbmRlcmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZ2VvbWV0cnkgdG8gYmUgcmVuZGVyZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ3xpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8R2VvbWV0cnlGdW5jdGlvbn1cbiAgICogRmVhdHVyZSBwcm9wZXJ0eSBvciBnZW9tZXRyeSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGdlb21ldHJ5IHRoYXQgd2lsbFxuICAgKiBiZSByZW5kZXJlZCB3aXRoIHRoaXMgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5XztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgYSBnZW9tZXRyeSBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcmV0dXJuIHshR2VvbWV0cnlGdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBhIGZlYXR1cmVcbiAgICogYW5kIHJldHVybnMgdGhlIGdlb21ldHJ5IHRvIHJlbmRlciBpbnN0ZWFkIG9mIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEdlb21ldHJ5RnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxsXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGZpbGwgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IGZpbGwgRmlsbCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RmlsbChmaWxsKSB7XG4gICAgdGhpcy5maWxsXyA9IGZpbGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBzdHlsZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBJbWFnZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW1hZ2Ugc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9JbWFnZS5qc1wiKS5kZWZhdWx0fSBpbWFnZSBJbWFnZSBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0SW1hZ2UoaW1hZ2UpIHtcbiAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3Ryb2tlIHN0eWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJva2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3Ryb2tlIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IHN0cm9rZSBTdHJva2Ugc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFN0cm9rZShzdHJva2UpIHtcbiAgICB0aGlzLnN0cm9rZV8gPSBzdHJva2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0ZXh0IHN0eWxlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RleHQuanNcIikuZGVmYXVsdH0gVGV4dCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0XztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRleHQgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UZXh0LmpzXCIpLmRlZmF1bHR9IHRleHQgVGV4dCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VGV4dCh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0XyA9IHRleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB6LWluZGV4IGZvciB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFpJbmRleC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0WkluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnpJbmRleF87XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgZ2VvbWV0cnkgdGhhdCBpcyByZW5kZXJlZCBpbnN0ZWFkIG9mIHRoZSBmZWF0dXJlJ3MgZ2VvbWV0cnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxHZW9tZXRyeUZ1bmN0aW9ufSBnZW9tZXRyeVxuICAgKiAgICAgRmVhdHVyZSBwcm9wZXJ0eSBvciBnZW9tZXRyeSBvciBmdW5jdGlvbiByZXR1cm5pbmcgYSBnZW9tZXRyeSB0byByZW5kZXJcbiAgICogICAgIGZvciB0aGlzIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGlmICh0eXBlb2YgZ2VvbWV0cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBnZW9tZXRyeTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBnZW9tZXRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnlGdW5jdGlvbl8gPSBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChmZWF0dXJlLmdldChnZW9tZXRyeSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWdlb21ldHJ5KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb247XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5RnVuY3Rpb25fID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZ2VvbWV0cnlfID0gZ2VvbWV0cnk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB6LWluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHpJbmRleCBaSW5kZXguXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFpJbmRleCh6SW5kZXgpIHtcbiAgICB0aGlzLnpJbmRleF8gPSB6SW5kZXg7XG4gIH1cbn1cblxuXG4vKipcbiAqIENvbnZlcnQgdGhlIHByb3ZpZGVkIG9iamVjdCBpbnRvIGEgc3R5bGUgZnVuY3Rpb24uICBGdW5jdGlvbnMgcGFzc2VkIHRocm91Z2hcbiAqIHVuY2hhbmdlZC4gIEFycmF5cyBvZiBTdHlsZSBvciBzaW5nbGUgc3R5bGUgb2JqZWN0cyB3cmFwcGVkIGluIGFcbiAqIG5ldyBzdHlsZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3R5bGVGdW5jdGlvbnxBcnJheTxTdHlsZT58U3R5bGV9IG9ialxuICogICAgIEEgc3R5bGUgZnVuY3Rpb24sIGEgc2luZ2xlIHN0eWxlLCBvciBhbiBhcnJheSBvZiBzdHlsZXMuXG4gKiBAcmV0dXJuIHtTdHlsZUZ1bmN0aW9ufSBBIHN0eWxlIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9GdW5jdGlvbihvYmopIHtcbiAgbGV0IHN0eWxlRnVuY3Rpb247XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHlsZUZ1bmN0aW9uID0gb2JqO1xuICB9IGVsc2Uge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdHlsZT59XG4gICAgICovXG4gICAgbGV0IHN0eWxlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICBzdHlsZXMgPSBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCh0eXBlb2YgLyoqIEB0eXBlIHs/fSAqLyAob2JqKS5nZXRaSW5kZXggPT09ICdmdW5jdGlvbicsXG4gICAgICAgIDQxKTsgLy8gRXhwZWN0ZWQgYW4gYFN0eWxlYCBvciBhbiBhcnJheSBvZiBgU3R5bGVgXG4gICAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7U3R5bGV9ICovIChvYmopO1xuICAgICAgc3R5bGVzID0gW3N0eWxlXTtcbiAgICB9XG4gICAgc3R5bGVGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdHlsZUZ1bmN0aW9uO1xufVxuXG5cbi8qKlxuICogQHR5cGUge0FycmF5PFN0eWxlPn1cbiAqL1xubGV0IGRlZmF1bHRTdHlsZXMgPSBudWxsO1xuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICogQHJldHVybiB7QXJyYXk8U3R5bGU+fSBTdHlsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTdHlsZShmZWF0dXJlLCByZXNvbHV0aW9uKSB7XG4gIC8vIFdlIGRvbid0IHVzZSBhbiBpbW1lZGlhdGVseS1pbnZva2VkIGZ1bmN0aW9uXG4gIC8vIGFuZCBhIGNsb3N1cmUgc28gd2UgZG9uJ3QgZ2V0IGFuIGVycm9yIGF0IHNjcmlwdCBldmFsdWF0aW9uIHRpbWUgaW5cbiAgLy8gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBDYW52YXMuIChpbXBvcnQoXCIuL0NpcmNsZS5qc1wiKS5DaXJjbGVTdHlsZSBkb2VzXG4gIC8vIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGF0IGNvbnN0cnVjdGlvbiB0aW1lLCB3aGljaCB3aWxsIGNhdXNlIGFuLmVycm9yXG4gIC8vIGluIHN1Y2ggYnJvd3NlcnMuKVxuICBpZiAoIWRlZmF1bHRTdHlsZXMpIHtcbiAgICBjb25zdCBmaWxsID0gbmV3IEZpbGwoe1xuICAgICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNCknXG4gICAgfSk7XG4gICAgY29uc3Qgc3Ryb2tlID0gbmV3IFN0cm9rZSh7XG4gICAgICBjb2xvcjogJyMzMzk5Q0MnLFxuICAgICAgd2lkdGg6IDEuMjVcbiAgICB9KTtcbiAgICBkZWZhdWx0U3R5bGVzID0gW1xuICAgICAgbmV3IFN0eWxlKHtcbiAgICAgICAgaW1hZ2U6IG5ldyBDaXJjbGVTdHlsZSh7XG4gICAgICAgICAgZmlsbDogZmlsbCxcbiAgICAgICAgICBzdHJva2U6IHN0cm9rZSxcbiAgICAgICAgICByYWRpdXM6IDVcbiAgICAgICAgfSksXG4gICAgICAgIGZpbGw6IGZpbGwsXG4gICAgICAgIHN0cm9rZTogc3Ryb2tlXG4gICAgICB9KVxuICAgIF07XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRTdHlsZXM7XG59XG5cblxuLyoqXG4gKiBEZWZhdWx0IHN0eWxlcyBmb3IgZWRpdGluZyBmZWF0dXJlcy5cbiAqIEByZXR1cm4ge09iamVjdDxpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5VHlwZS5qc1wiKS5kZWZhdWx0LCBBcnJheTxTdHlsZT4+fSBTdHlsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVkaXRpbmdTdHlsZSgpIHtcbiAgLyoqIEB0eXBlIHtPYmplY3Q8aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanNcIikuZGVmYXVsdCwgQXJyYXk8U3R5bGU+Pn0gKi9cbiAgY29uc3Qgc3R5bGVzID0ge307XG4gIGNvbnN0IHdoaXRlID0gWzI1NSwgMjU1LCAyNTUsIDFdO1xuICBjb25zdCBibHVlID0gWzAsIDE1MywgMjU1LCAxXTtcbiAgY29uc3Qgd2lkdGggPSAzO1xuICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPTFlHT05dID0gW1xuICAgIG5ldyBTdHlsZSh7XG4gICAgICBmaWxsOiBuZXcgRmlsbCh7XG4gICAgICAgIGNvbG9yOiBbMjU1LCAyNTUsIDI1NSwgMC41XVxuICAgICAgfSlcbiAgICB9KVxuICBdO1xuICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT05dID1cbiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl07XG5cbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5MSU5FX1NUUklOR10gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIHN0cm9rZTogbmV3IFN0cm9rZSh7XG4gICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgMlxuICAgICAgfSlcbiAgICB9KSxcbiAgICBuZXcgU3R5bGUoe1xuICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtcbiAgICAgICAgY29sb3I6IGJsdWUsXG4gICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgfSlcbiAgICB9KVxuICBdO1xuICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HXSA9XG4gICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXTtcblxuICBzdHlsZXNbR2VvbWV0cnlUeXBlLkNJUkNMRV0gPVxuICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0xZR09OXS5jb25jYXQoXG4gICAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuTElORV9TVFJJTkddXG4gICAgICApO1xuXG5cbiAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF0gPSBbXG4gICAgbmV3IFN0eWxlKHtcbiAgICAgIGltYWdlOiBuZXcgQ2lyY2xlU3R5bGUoe1xuICAgICAgICByYWRpdXM6IHdpZHRoICogMixcbiAgICAgICAgZmlsbDogbmV3IEZpbGwoe1xuICAgICAgICAgIGNvbG9yOiBibHVlXG4gICAgICAgIH0pLFxuICAgICAgICBzdHJva2U6IG5ldyBTdHJva2Uoe1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZSxcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyAyXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIHpJbmRleDogSW5maW5pdHlcbiAgICB9KVxuICBdO1xuICBzdHlsZXNbR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UXSA9XG4gICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLlBPSU5UXTtcblxuICBzdHlsZXNbR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT05dID1cbiAgICAgIHN0eWxlc1tHZW9tZXRyeVR5cGUuUE9MWUdPTl0uY29uY2F0KFxuICAgICAgICBzdHlsZXNbR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HXSxcbiAgICAgICAgc3R5bGVzW0dlb21ldHJ5VHlwZS5QT0lOVF1cbiAgICAgICk7XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuXG4vKipcbiAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggYSBmZWF0dXJlIGFuZCByZXR1cm5zIGl0cyBkZWZhdWx0IGdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUgdG8gZ2V0IHRoZSBnZW9tZXRyeSBmb3IuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vcmVuZGVyL0ZlYXR1cmUuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IEdlb21ldHJ5IHRvIHJlbmRlci5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEdlb21ldHJ5RnVuY3Rpb24oZmVhdHVyZSkge1xuICByZXR1cm4gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdHlsZTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5REE7QUFNQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFNQTs7Ozs7OztBQVFBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFEQTtBQU1BO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBR0E7QUFNQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBVUE7QUFYQTtBQWNBO0FBR0E7QUFNQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* unused harmony export CLASS_HIDDEN */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CLASS_SELECTABLE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return CLASS_UNSELECTABLE; });\n/* unused harmony export CLASS_UNSUPPORTED */\n/* unused harmony export CLASS_CONTROL */\n/* unused harmony export CLASS_COLLAPSED */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return getFontFamilies; });\n/**\n * @module ol/css\n */\n\n/**\n * The CSS class for hidden feature.\n *\n * @const\n * @type {string}\n */\nvar CLASS_HIDDEN = 'ol-hidden';\n/**\n * The CSS class that we'll give the DOM elements to have them selectable.\n *\n * @const\n * @type {string}\n */\n\nvar CLASS_SELECTABLE = 'ol-selectable';\n/**\n * The CSS class that we'll give the DOM elements to have them unselectable.\n *\n * @const\n * @type {string}\n */\n\nvar CLASS_UNSELECTABLE = 'ol-unselectable';\n/**\n * The CSS class for unsupported feature.\n *\n * @const\n * @type {string}\n */\n\nvar CLASS_UNSUPPORTED = 'ol-unsupported';\n/**\n * The CSS class for controls.\n *\n * @const\n * @type {string}\n */\n\nvar CLASS_CONTROL = 'ol-control';\n/**\n * The CSS class that we'll give the DOM elements that are collapsed, i.e.\n * to those elements which usually can be expanded.\n *\n * @const\n * @type {string}\n */\n\nvar CLASS_COLLAPSED = 'ol-collapsed';\n/**\n * Get the list of font families from a font spec.  Note that this doesn't work\n * for font families that have commas in them.\n * @param {string} The CSS font property.\n * @return {Object<string>} The font families (or null if the input spec is invalid).\n */\n\nvar getFontFamilies = function () {\n  var style;\n  var cache = {};\n  return function (font) {\n    if (!style) {\n      style = document.createElement('div').style;\n    }\n\n    if (!(font in cache)) {\n      style.font = font;\n      var family = style.fontFamily;\n      style.font = '';\n\n      if (!family) {\n        return null;\n      }\n\n      cache[font] = family.split(/,\\s?/);\n    }\n\n    return cache[font];\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2Nzcy5qcz8wNDU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9jc3NcbiAqL1xuXG5cbi8qKlxuICogVGhlIENTUyBjbGFzcyBmb3IgaGlkZGVuIGZlYXR1cmUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfSElEREVOID0gJ29sLWhpZGRlbic7XG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRoYXQgd2UnbGwgZ2l2ZSB0aGUgRE9NIGVsZW1lbnRzIHRvIGhhdmUgdGhlbSBzZWxlY3RhYmxlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTX1NFTEVDVEFCTEUgPSAnb2wtc2VsZWN0YWJsZSc7XG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRoYXQgd2UnbGwgZ2l2ZSB0aGUgRE9NIGVsZW1lbnRzIHRvIGhhdmUgdGhlbSB1bnNlbGVjdGFibGUuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfVU5TRUxFQ1RBQkxFID0gJ29sLXVuc2VsZWN0YWJsZSc7XG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIGZvciB1bnN1cHBvcnRlZCBmZWF0dXJlLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTX1VOU1VQUE9SVEVEID0gJ29sLXVuc3VwcG9ydGVkJztcblxuXG4vKipcbiAqIFRoZSBDU1MgY2xhc3MgZm9yIGNvbnRyb2xzLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IENMQVNTX0NPTlRST0wgPSAnb2wtY29udHJvbCc7XG5cblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRoYXQgd2UnbGwgZ2l2ZSB0aGUgRE9NIGVsZW1lbnRzIHRoYXQgYXJlIGNvbGxhcHNlZCwgaS5lLlxuICogdG8gdGhvc2UgZWxlbWVudHMgd2hpY2ggdXN1YWxseSBjYW4gYmUgZXhwYW5kZWQuXG4gKlxuICogQGNvbnN0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgQ0xBU1NfQ09MTEFQU0VEID0gJ29sLWNvbGxhcHNlZCc7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGxpc3Qgb2YgZm9udCBmYW1pbGllcyBmcm9tIGEgZm9udCBzcGVjLiAgTm90ZSB0aGF0IHRoaXMgZG9lc24ndCB3b3JrXG4gKiBmb3IgZm9udCBmYW1pbGllcyB0aGF0IGhhdmUgY29tbWFzIGluIHRoZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIENTUyBmb250IHByb3BlcnR5LlxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZz59IFRoZSBmb250IGZhbWlsaWVzIChvciBudWxsIGlmIHRoZSBpbnB1dCBzcGVjIGlzIGludmFsaWQpLlxuICovXG5leHBvcnQgY29uc3QgZ2V0Rm9udEZhbWlsaWVzID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgc3R5bGU7XG4gIGNvbnN0IGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbihmb250KSB7XG4gICAgaWYgKCFzdHlsZSkge1xuICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgICB9XG4gICAgaWYgKCEoZm9udCBpbiBjYWNoZSkpIHtcbiAgICAgIHN0eWxlLmZvbnQgPSBmb250O1xuICAgICAgY29uc3QgZmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgICAgIHN0eWxlLmZvbnQgPSAnJztcbiAgICAgIGlmICghZmFtaWx5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY2FjaGVbZm9udF0gPSBmYW1pbHkuc3BsaXQoLyxcXHM/Lyk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZVtmb250XTtcbiAgfTtcbn0pKCk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7QUFXQTs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///73\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = rbush;\nmodule.exports[\"default\"] = rbush;\n\nvar quickselect = __webpack_require__(125);\n\nfunction rbush(maxEntries, format) {\n  if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance\n\n  this._maxEntries = Math.max(4, maxEntries || 9);\n  this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n  if (format) {\n    this._initFormat(format);\n  }\n\n  this.clear();\n}\n\nrbush.prototype = {\n  all: function all() {\n    return this._all(this.data, []);\n  },\n  search: function search(bbox) {\n    var node = this.data,\n        result = [],\n        toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return result;\n    var nodesToSearch = [],\n        i,\n        len,\n        child,\n        childBBox;\n\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  },\n  collides: function collides(bbox) {\n    var node = this.data,\n        toBBox = this.toBBox;\n    if (!intersects(bbox, node)) return false;\n    var nodesToSearch = [],\n        i,\n        len,\n        child,\n        childBBox;\n\n    while (node) {\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        childBBox = node.leaf ? toBBox(child) : child;\n\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) return true;\n          nodesToSearch.push(child);\n        }\n      }\n\n      node = nodesToSearch.pop();\n    }\n\n    return false;\n  },\n  load: function load(data) {\n    if (!(data && data.length)) return this;\n\n    if (data.length < this._minEntries) {\n      for (var i = 0, len = data.length; i < len; i++) {\n        this.insert(data[i]);\n      }\n\n      return this;\n    } // recursively build the tree with the given data from scratch using OMT algorithm\n\n\n    var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        var tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      } // insert the small tree into the large tree at appropriate level\n\n\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n\n    return this;\n  },\n  insert: function insert(item) {\n    if (item) this._insert(item, this.data.height - 1);\n    return this;\n  },\n  clear: function clear() {\n    this.data = createNode([]);\n    return this;\n  },\n  remove: function remove(item, equalsFn) {\n    if (!item) return this;\n    var node = this.data,\n        bbox = this.toBBox(item),\n        path = [],\n        indexes = [],\n        i,\n        parent,\n        index,\n        goingUp; // depth-first iterative tree traversal\n\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n\n      if (node.leaf) {\n        // check current node\n        index = findItem(item, node.children, equalsFn);\n\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n\n          this._condense(path);\n\n          return this;\n        }\n      }\n\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else node = null; // nothing found\n\n    }\n\n    return this;\n  },\n  toBBox: function toBBox(item) {\n    return item;\n  },\n  compareMinX: compareNodeMinX,\n  compareMinY: compareNodeMinY,\n  toJSON: function toJSON() {\n    return this.data;\n  },\n  fromJSON: function fromJSON(data) {\n    this.data = data;\n    return this;\n  },\n  _all: function _all(node, result) {\n    var nodesToSearch = [];\n\n    while (node) {\n      if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);\n      node = nodesToSearch.pop();\n    }\n\n    return result;\n  },\n  _build: function _build(items, left, right, height) {\n    var N = right - left + 1,\n        M = this._maxEntries,\n        node;\n\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization\n\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height; // split the items into M mostly square tiles\n\n    var N2 = Math.ceil(N / M),\n        N1 = N2 * Math.ceil(Math.sqrt(M)),\n        i,\n        j,\n        right2,\n        right3;\n    multiSelect(items, left, right, N1, this.compareMinX);\n\n    for (i = left; i <= right; i += N1) {\n      right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n\n      for (j = i; j <= right2; j += N2) {\n        right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively\n\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n\n    calcBBox(node, this.toBBox);\n    return node;\n  },\n  _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {\n    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n    while (true) {\n      path.push(node);\n      if (node.leaf || path.length - 1 === level) break;\n      minArea = minEnlargement = Infinity;\n\n      for (i = 0, len = node.children.length; i < len; i++) {\n        child = node.children[i];\n        area = bboxArea(child);\n        enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement\n\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n\n      node = targetNode || node.children[0];\n    }\n\n    return node;\n  },\n  _insert: function _insert(item, level, isNode) {\n    var toBBox = this.toBBox,\n        bbox = isNode ? item : toBBox(item),\n        insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too\n\n    var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node\n\n\n    node.children.push(item);\n    extend(node, bbox); // split on node overflow; propagate upwards if necessary\n\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n\n        level--;\n      } else break;\n    } // adjust bboxes along the insertion path\n\n\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  },\n  // split overflowed node into two\n  _split: function _split(insertPath, level) {\n    var node = insertPath[level],\n        M = node.children.length,\n        m = this._minEntries;\n\n    this._chooseSplitAxis(node, m, M);\n\n    var splitIndex = this._chooseSplitIndex(node, m, M);\n\n    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n  },\n  _splitRoot: function _splitRoot(node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  },\n  _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {\n    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n    minOverlap = minArea = Infinity;\n\n    for (i = m; i <= M - m; i++) {\n      bbox1 = distBBox(node, 0, i, this.toBBox);\n      bbox2 = distBBox(node, i, M, this.toBBox);\n      overlap = intersectionArea(bbox1, bbox2);\n      area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap\n\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n\n    return index;\n  },\n  // sorts node children by the best axis for split\n  _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {\n    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n        xMargin = this._allDistMargin(node, m, M, compareMinX),\n        yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n\n\n    if (xMargin < yMargin) node.children.sort(compareMinX);\n  },\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin: function _allDistMargin(node, m, M, compare) {\n    node.children.sort(compare);\n    var toBBox = this.toBBox,\n        leftBBox = distBBox(node, 0, m, toBBox),\n        rightBBox = distBBox(node, M - m, M, toBBox),\n        margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n        i,\n        child;\n\n    for (i = m; i < M - m; i++) {\n      child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n\n    for (i = M - m - 1; i >= m; i--) {\n      child = node.children[i];\n      extend(rightBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(rightBBox);\n    }\n\n    return margin;\n  },\n  _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (var i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  },\n  _condense: function _condense(path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (var i = path.length - 1, siblings; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else this.clear();\n      } else calcBBox(path[i], this.toBBox);\n    }\n  },\n  _initFormat: function _initFormat(format) {\n    // data format (minX, minY, maxX, maxY accessors)\n    // uses eval-type function compilation instead of just accepting a toBBox function\n    // because the algorithms are very sensitive to sorting functions performance,\n    // so they should be dead simple and without inner calls\n    var compareArr = ['return a', ' - b', ';'];\n    this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n    this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n    this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');\n  }\n};\n\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn) return items.indexOf(item);\n\n  for (var i = 0; i < items.length; i++) {\n    if (equalsFn(item, items[i])) return i;\n  }\n\n  return -1;\n} // calculate node's bbox from bboxes of its children\n\n\nfunction calcBBox(node, toBBox) {\n  distBBox(node, 0, node.children.length, toBBox, node);\n} // min bounding rectangle of node children from k to p-1\n\n\nfunction distBBox(node, k, p, toBBox, destNode) {\n  if (!destNode) destNode = createNode(null);\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n\n  for (var i = k, child; i < p; i++) {\n    child = node.children[i];\n    extend(destNode, node.leaf ? toBBox(child) : child);\n  }\n\n  return destNode;\n}\n\nfunction extend(a, b) {\n  a.minX = Math.min(a.minX, b.minX);\n  a.minY = Math.min(a.minY, b.minY);\n  a.maxX = Math.max(a.maxX, b.maxX);\n  a.maxY = Math.max(a.maxY, b.maxY);\n  return a;\n}\n\nfunction compareNodeMinX(a, b) {\n  return a.minX - b.minX;\n}\n\nfunction compareNodeMinY(a, b) {\n  return a.minY - b.minY;\n}\n\nfunction bboxArea(a) {\n  return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\n\nfunction bboxMargin(a) {\n  return a.maxX - a.minX + (a.maxY - a.minY);\n}\n\nfunction enlargedArea(a, b) {\n  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n  var minX = Math.max(a.minX, b.minX),\n      minY = Math.max(a.minY, b.minY),\n      maxX = Math.min(a.maxX, b.maxX),\n      maxY = Math.min(a.maxY, b.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n  return {\n    children: children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n} // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\n\nfunction multiSelect(arr, left, right, n, compare) {\n  var stack = [left, right],\n      mid;\n\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n    if (right - left <= n) continue;\n    mid = left + Math.ceil((right - left) / n / 2) * n;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanM/MDM1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmJ1c2g7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcmJ1c2g7XG5cbnZhciBxdWlja3NlbGVjdCA9IHJlcXVpcmUoJ3F1aWNrc2VsZWN0Jyk7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgY29sbGlkZXM6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHNjcmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRm4pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGNvbXBhcmVOb2RlTWluWCxcbiAgICBjb21wYXJlTWluWTogY29tcGFyZU5vZGVNaW5ZLFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSk7XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgbm9kZS5sZWFmID0gZmFsc2U7XG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBpLCBqLCByaWdodDIsIHJpZ2h0MztcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtIDogdG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfSxcblxuICAgIF9zcGxpdFJvb3Q6IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJyxcbiAgICAgICAgICAgICdyZXR1cm4ge21pblg6IGEnICsgZm9ybWF0WzBdICtcbiAgICAgICAgICAgICcsIG1pblk6IGEnICsgZm9ybWF0WzFdICtcbiAgICAgICAgICAgICcsIG1heFg6IGEnICsgZm9ybWF0WzJdICtcbiAgICAgICAgICAgICcsIG1heFk6IGEnICsgZm9ybWF0WzNdICsgJ307Jyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIGEubWluWSA9IE1hdGgubWluKGEubWluWSwgYi5taW5ZKTtcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSArIChhLm1heFkgLSBhLm1pblkpOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYS5taW5YLCBiLm1pblgpLFxuICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpLFxuICAgICAgICBtYXhZID0gTWF0aC5taW4oYS5tYXhZLCBiLm1heFkpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPD0gYi5taW5YICYmXG4gICAgICAgICAgIGEubWluWSA8PSBiLm1pblkgJiZcbiAgICAgICAgICAgYi5tYXhYIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1heFkgPD0gYS5tYXhZO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1pblkgPD0gYS5tYXhZICYmXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShjaGlsZHJlbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXG4gICAgICAgIG1pZDtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUdBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBbGJBO0FBQ0E7QUFvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return linearRing; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return linearRings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return linearRingss; });\n/**\n * @module ol/geom/flat/area\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nfunction linearRing(flatCoordinates, offset, end, stride) {\n  var twiceArea = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return twiceArea / 2;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\n\nfunction linearRings(flatCoordinates, offset, ends, stride) {\n  var area = 0;\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    area += linearRing(flatCoordinates, offset, end, stride);\n    offset = end;\n  }\n\n  return area;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\n\nfunction linearRingss(flatCoordinates, offset, endss, stride) {\n  var area = 0;\n\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    area += linearRings(flatCoordinates, offset, ends, stride);\n    offset = ends[ends.length - 1];\n  }\n\n  return area;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9hcmVhLmpzPzkyNGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9hcmVhXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5nKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBsZXQgdHdpY2VBcmVhID0gMDtcbiAgbGV0IHgxID0gZmxhdENvb3JkaW5hdGVzW2VuZCAtIHN0cmlkZV07XG4gIGxldCB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgY29uc3QgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgdHdpY2VBcmVhICs9IHkxICogeDIgLSB4MSAqIHkyO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gdHdpY2VBcmVhIC8gMjtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFyZWEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJSaW5ncyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gIGxldCBhcmVhID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICBhcmVhICs9IGxpbmVhclJpbmcoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgICBvZmZzZXQgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIGFyZWE7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBlbmRzcyBFbmRzcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ3NzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlKSB7XG4gIGxldCBhcmVhID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBhcmVhICs9IGxpbmVhclJpbmdzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpO1xuICAgIG9mZnNldCA9IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///75\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/MapEventType\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  /**\n   * Triggered after a map frame is rendered.\n   * @event module:ol/MapEvent~MapEvent#postrender\n   * @api\n   */\n  POSTRENDER: 'postrender',\n\n  /**\n   * Triggered when the map starts moving.\n   * @event module:ol/MapEvent~MapEvent#movestart\n   * @api\n   */\n  MOVESTART: 'movestart',\n\n  /**\n   * Triggered after the map is moved.\n   * @event module:ol/MapEvent~MapEvent#moveend\n   * @api\n   */\n  MOVEEND: 'moveend'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL01hcEV2ZW50VHlwZS5qcz9hMjMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9NYXBFdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIGFmdGVyIGEgbWFwIGZyYW1lIGlzIHJlbmRlcmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I3Bvc3RyZW5kZXJcbiAgICogQGFwaVxuICAgKi9cbiAgUE9TVFJFTkRFUjogJ3Bvc3RyZW5kZXInLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgbWFwIHN0YXJ0cyBtb3ZpbmcuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvTWFwRXZlbnR+TWFwRXZlbnQjbW92ZXN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIE1PVkVTVEFSVDogJ21vdmVzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBhZnRlciB0aGUgbWFwIGlzIG1vdmVkLlxuICAgKiBAZXZlbnQgbW9kdWxlOm9sL01hcEV2ZW50fk1hcEV2ZW50I21vdmVlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgTU9WRUVORDogJ21vdmVlbmQnXG5cbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBT0E7Ozs7OztBQU9BO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7OztBQU1BO0FBckJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(11);\n\n// EXTERNAL MODULE: ./node_modules/ol/Feature.js\nvar Feature = __webpack_require__(59);\n\n// EXTERNAL MODULE: ./node_modules/ol/format/Feature.js\nvar format_Feature = __webpack_require__(71);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/format/FormatType.js\nvar FormatType = __webpack_require__(57);\n\n// CONCATENATED MODULE: ./node_modules/ol/format/JSONFeature.js\n/**\n * @module ol/format/JSONFeature\n */\n\n\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @abstract\n */\n\nvar JSONFeature_JSONFeature =\n/*@__PURE__*/\nfunction (FeatureFormat) {\n  function JSONFeature() {\n    FeatureFormat.call(this);\n  }\n\n  if (FeatureFormat) JSONFeature.__proto__ = FeatureFormat;\n  JSONFeature.prototype = Object.create(FeatureFormat && FeatureFormat.prototype);\n  JSONFeature.prototype.constructor = JSONFeature;\n  /**\n   * @inheritDoc\n   */\n\n  JSONFeature.prototype.getType = function getType() {\n    return FormatType["default"].JSON;\n  };\n  /**\n   * Read a feature.  Only works for a single feature. Use `readFeatures` to\n   * read a feature collection.\n   *\n   * @param {ArrayBuffer|Document|Node|Object|string} source Source.\n   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.\n   * @return {import("../Feature.js").default} Feature.\n   * @api\n   */\n\n\n  JSONFeature.prototype.readFeature = function readFeature(source, opt_options) {\n    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));\n  };\n  /**\n   * Read all features.  Works with both a single feature and a feature\n   * collection.\n   *\n   * @param {ArrayBuffer|Document|Node|Object|string} source Source.\n   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.\n   * @return {Array<import("../Feature.js").default>} Features.\n   * @api\n   */\n\n\n  JSONFeature.prototype.readFeatures = function readFeatures(source, opt_options) {\n    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));\n  };\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {import("../Feature.js").default} Feature.\n   */\n\n\n  JSONFeature.prototype.readFeatureFromObject = function readFeatureFromObject(object, opt_options) {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {Array<import("../Feature.js").default>} Features.\n   */\n\n\n  JSONFeature.prototype.readFeaturesFromObject = function readFeaturesFromObject(object, opt_options) {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * Read a geometry.\n   *\n   * @param {ArrayBuffer|Document|Node|Object|string} source Source.\n   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.\n   * @return {import("../geom/Geometry.js").default} Geometry.\n   * @api\n   */\n\n\n  JSONFeature.prototype.readGeometry = function readGeometry(source, opt_options) {\n    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));\n  };\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.\n   * @protected\n   * @return {import("../geom/Geometry.js").default} Geometry.\n   */\n\n\n  JSONFeature.prototype.readGeometryFromObject = function readGeometryFromObject(object, opt_options) {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * Read the projection.\n   *\n   * @param {ArrayBuffer|Document|Node|Object|string} source Source.\n   * @return {import("../proj/Projection.js").default} Projection.\n   * @api\n   */\n\n\n  JSONFeature.prototype.readProjection = function readProjection(source) {\n    return this.readProjectionFromObject(getObject(source));\n  };\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {import("../proj/Projection.js").default} Projection.\n   */\n\n\n  JSONFeature.prototype.readProjectionFromObject = function readProjectionFromObject(object) {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import("../Feature.js").default} feature Feature.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {string} Encoded feature.\n   * @api\n   */\n\n\n  JSONFeature.prototype.writeFeature = function writeFeature(feature, opt_options) {\n    return JSON.stringify(this.writeFeatureObject(feature, opt_options));\n  };\n  /**\n   * @abstract\n   * @param {import("../Feature.js").default} feature Feature.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {Object} Object.\n   */\n\n\n  JSONFeature.prototype.writeFeatureObject = function writeFeatureObject(feature, opt_options) {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import("../Feature.js").default>} features Features.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {string} Encoded features.\n   * @api\n   */\n\n\n  JSONFeature.prototype.writeFeatures = function writeFeatures(features, opt_options) {\n    return JSON.stringify(this.writeFeaturesObject(features, opt_options));\n  };\n  /**\n   * @abstract\n   * @param {Array<import("../Feature.js").default>} features Features.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {Object} Object.\n   */\n\n\n  JSONFeature.prototype.writeFeaturesObject = function writeFeaturesObject(features, opt_options) {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import("../geom/Geometry.js").default} geometry Geometry.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {string} Encoded geometry.\n   * @api\n   */\n\n\n  JSONFeature.prototype.writeGeometry = function writeGeometry(geometry, opt_options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, opt_options));\n  };\n  /**\n   * @abstract\n   * @param {import("../geom/Geometry.js").default} geometry Geometry.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {Object} Object.\n   */\n\n\n  JSONFeature.prototype.writeGeometryObject = function writeGeometryObject(geometry, opt_options) {\n    return Object(util["b" /* abstract */])();\n  };\n\n  return JSONFeature;\n}(format_Feature["default"]);\n/**\n * @param {Document|Node|Object|string} source Source.\n * @return {Object} Object.\n */\n\n\nfunction getObject(source) {\n  if (typeof source === \'string\') {\n    var object = JSON.parse(source);\n    return object ?\n    /** @type {Object} */\n    object : null;\n  } else if (source !== null) {\n    return source;\n  } else {\n    return null;\n  }\n}\n\n/* harmony default export */ var format_JSONFeature = (JSONFeature_JSONFeature);\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar EventType = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/Geometry.js\nvar geom_Geometry = __webpack_require__(88);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js\nvar GeometryType = __webpack_require__(3);\n\n// EXTERNAL MODULE: ./node_modules/ol/obj.js\nvar obj = __webpack_require__(12);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/GeometryCollection.js\n/**\n * @module ol/geom/GeometryCollection\n */\n\n\n\n\n\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry} objects.\n *\n * @api\n */\n\nvar GeometryCollection_GeometryCollection =\n/*@__PURE__*/\nfunction (Geometry) {\n  function GeometryCollection(opt_geometries) {\n    Geometry.call(this);\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n\n    this.geometries_ = opt_geometries ? opt_geometries : null;\n    this.listenGeometriesChange_();\n  }\n\n  if (Geometry) GeometryCollection.__proto__ = Geometry;\n  GeometryCollection.prototype = Object.create(Geometry && Geometry.prototype);\n  GeometryCollection.prototype.constructor = GeometryCollection;\n  /**\n   * @private\n   */\n\n  GeometryCollection.prototype.unlistenGeometriesChange_ = function unlistenGeometriesChange_() {\n    if (!this.geometries_) {\n      return;\n    }\n\n    for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {\n      Object(events["c" /* unlisten */])(this.geometries_[i], EventType["a" /* default */].CHANGE, this.changed, this);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  GeometryCollection.prototype.listenGeometriesChange_ = function listenGeometriesChange_() {\n    if (!this.geometries_) {\n      return;\n    }\n\n    for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {\n      Object(events["a" /* listen */])(this.geometries_[i], EventType["a" /* default */].CHANGE, this.changed, this);\n    }\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @override\n   * @api\n   */\n\n\n  GeometryCollection.prototype.clone = function clone() {\n    var geometryCollection = new GeometryCollection(null);\n    geometryCollection.setGeometries(this.geometries_);\n    return geometryCollection;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GeometryCollection.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < Object(ol_extent["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    var geometries = this.geometries_;\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);\n    }\n\n    return minSquaredDistance;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GeometryCollection.prototype.containsXY = function containsXY(x, y) {\n    var geometries = this.geometries_;\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GeometryCollection.prototype.computeExtent = function computeExtent(extent) {\n    Object(ol_extent["createOrUpdateEmpty"])(extent);\n    var geometries = this.geometries_;\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      Object(ol_extent["extend"])(extent, geometries[i].getExtent());\n    }\n\n    return extent;\n  };\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n\n\n  GeometryCollection.prototype.getGeometries = function getGeometries() {\n    return cloneGeometries(this.geometries_);\n  };\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n\n\n  GeometryCollection.prototype.getGeometriesArray = function getGeometriesArray() {\n    return this.geometries_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GeometryCollection.prototype.getSimplifiedGeometry = function getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision != this.getRevision()) {\n      Object(obj["b" /* clear */])(this.simplifiedGeometryCache);\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n\n    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {\n      return this;\n    }\n\n    var key = squaredTolerance.toString();\n\n    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n      return this.simplifiedGeometryCache[key];\n    } else {\n      var simplifiedGeometries = [];\n      var geometries = this.geometries_;\n      var simplified = false;\n\n      for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometry = geometries[i];\n        var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n        simplifiedGeometries.push(simplifiedGeometry);\n\n        if (simplifiedGeometry !== geometry) {\n          simplified = true;\n        }\n      }\n\n      if (simplified) {\n        var simplifiedGeometryCollection = new GeometryCollection(null);\n        simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n        this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;\n        return simplifiedGeometryCollection;\n      } else {\n        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n        return this;\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  GeometryCollection.prototype.getType = function getType() {\n    return GeometryType["a" /* default */].GEOMETRY_COLLECTION;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  GeometryCollection.prototype.intersectsExtent = function intersectsExtent(extent) {\n    var geometries = this.geometries_;\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * @return {boolean} Is empty.\n   */\n\n\n  GeometryCollection.prototype.isEmpty = function isEmpty() {\n    return this.geometries_.length === 0;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  GeometryCollection.prototype.rotate = function rotate(angle, anchor) {\n    var geometries = this.geometries_;\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  GeometryCollection.prototype.scale = function scale(sx, opt_sy, opt_anchor) {\n    var anchor = opt_anchor;\n\n    if (!anchor) {\n      anchor = Object(ol_extent["getCenter"])(this.getExtent());\n    }\n\n    var geometries = this.geometries_;\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, opt_sy, anchor);\n    }\n\n    this.changed();\n  };\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n\n\n  GeometryCollection.prototype.setGeometries = function setGeometries(geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  };\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n\n\n  GeometryCollection.prototype.setGeometriesArray = function setGeometriesArray(geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  GeometryCollection.prototype.applyTransform = function applyTransform(transformFn) {\n    var geometries = this.geometries_;\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  GeometryCollection.prototype.translate = function translate(deltaX, deltaY) {\n    var geometries = this.geometries_;\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GeometryCollection.prototype.disposeInternal = function disposeInternal() {\n    this.unlistenGeometriesChange_();\n    Geometry.prototype.disposeInternal.call(this);\n  };\n\n  return GeometryCollection;\n}(geom_Geometry["a" /* default */]);\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\n\n\nfunction cloneGeometries(geometries) {\n  var clonedGeometries = [];\n\n  for (var i = 0, ii = geometries.length; i < ii; ++i) {\n    clonedGeometries.push(geometries[i].clone());\n  }\n\n  return clonedGeometries;\n}\n\n/* harmony default export */ var geom_GeometryCollection = (GeometryCollection_GeometryCollection);\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(13);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryLayout.js\nvar GeometryLayout = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/SimpleGeometry.js\nvar geom_SimpleGeometry = __webpack_require__(31);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/closest.js\nvar closest = __webpack_require__(35);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/deflate.js\nvar deflate = __webpack_require__(36);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js\nvar inflate = __webpack_require__(32);\n\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/flat/interpolate.js\n/**\n * @module ol/geom/flat/interpolate\n */\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination.\n */\n\nfunction interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n\n    var target = fraction * length;\n    var index = Object(array["a" /* binarySearch */])(cumulativeLengths, target);\n\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = Object(math["c" /* lerp */])(flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = Object(math["c" /* lerp */])(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import("../../coordinate.js").Coordinate} Coordinate.\n */\n\nfunction lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n\n  var coordinate;\n\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } // FIXME use O(1) search\n\n\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n\n  var lo = offset / stride;\n  var hi = end / stride;\n\n  while (lo < hi) {\n    var mid = lo + hi >> 1;\n\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n\n  var m0 = flatCoordinates[lo * stride - 1];\n\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(Object(math["c" /* lerp */])(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));\n  }\n\n  coordinate.push(m);\n  return coordinate;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import("../../coordinate.js").Coordinate} Coordinate.\n */\n\nfunction lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n\n  var coordinate;\n\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n\n    if (offset == end) {\n      continue;\n    }\n\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);\n    }\n\n    offset = end;\n  }\n\n  return null;\n}\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/intersectsextent.js\nvar intersectsextent = __webpack_require__(61);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/length.js\nvar flat_length = __webpack_require__(96);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/segments.js\nvar segments = __webpack_require__(95);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js\nvar simplify = __webpack_require__(46);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/LineString.js\n/**\n * @module ol/geom/LineString\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\n\nvar LineString_LineString =\n/*@__PURE__*/\nfunction (SimpleGeometry) {\n  function LineString(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    /**\n     * @private\n     * @type {import("../coordinate.js").Coordinate}\n     */\n\n    this.flatMidpoint_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.flatMidpointRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout,\n      /** @type {Array<number>} */\n      coordinates);\n    } else {\n      this.setCoordinates(\n      /** @type {Array<import("../coordinate.js").Coordinate>} */\n      coordinates, opt_layout);\n    }\n  }\n\n  if (SimpleGeometry) LineString.__proto__ = SimpleGeometry;\n  LineString.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  LineString.prototype.constructor = LineString;\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @api\n   */\n\n  LineString.prototype.appendCoordinate = function appendCoordinate(coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      Object(array["c" /* extend */])(this.flatCoordinates, coordinate);\n    }\n\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @override\n   * @api\n   */\n\n\n  LineString.prototype.clone = function clone() {\n    return new LineString(this.flatCoordinates.slice(), this.layout);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LineString.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < Object(ol_extent["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(Object(closest["e" /* maxSquaredDelta */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return Object(closest["d" /* assignClosestPoint */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function\n   *     called for each segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n\n\n  LineString.prototype.forEachSegment = function forEachSegment$1(callback) {\n    return Object(segments["a" /* forEach */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n  };\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @return {import("../coordinate.js").Coordinate} Coordinate.\n   * @api\n   */\n\n\n  LineString.prototype.getCoordinateAtM = function getCoordinateAtM(m, opt_extrapolate) {\n    if (this.layout != GeometryLayout["a" /* default */].XYM && this.layout != GeometryLayout["a" /* default */].XYZM) {\n      return null;\n    }\n\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);\n  };\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  LineString.prototype.getCoordinates = function getCoordinates() {\n    return Object(inflate["a" /* inflateCoordinates */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n\n\n  LineString.prototype.getCoordinateAt = function getCoordinateAt(fraction, opt_dest) {\n    return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest);\n  };\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n\n\n  LineString.prototype.getLength = function getLength() {\n    return Object(flat_length["a" /* lineStringLength */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n\n\n  LineString.prototype.getFlatMidpoint = function getFlatMidpoint() {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n\n    return this.flatMidpoint_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = Object(simplify["a" /* douglasPeucker */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LineString(simplifiedFlatCoordinates, GeometryLayout["a" /* default */].XY);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  LineString.prototype.getType = function getType() {\n    return GeometryType["a" /* default */].LINE_STRING;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  LineString.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return Object(intersectsextent["a" /* intersectsLineString */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n\n\n  LineString.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    this.flatCoordinates.length = Object(deflate["b" /* deflateCoordinates */])(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return LineString;\n}(geom_SimpleGeometry["a" /* default */]);\n\n/* harmony default export */ var geom_LineString = (LineString_LineString);\n// CONCATENATED MODULE: ./node_modules/ol/geom/MultiLineString.js\n/**\n * @module ol/geom/MultiLineString\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\n\nvar MultiLineString_MultiLineString =\n/*@__PURE__*/\nfunction (SimpleGeometry) {\n  function MultiLineString(coordinates, opt_layout, opt_ends) {\n    SimpleGeometry.call(this);\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n\n    this.ends_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(\n      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */\n      coordinates, opt_layout);\n    } else if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout,\n      /** @type {Array<number>} */\n      coordinates);\n      this.ends_ = opt_ends;\n    } else {\n      var layout = this.getLayout();\n      var lineStrings =\n      /** @type {Array<LineString>} */\n      coordinates;\n      var flatCoordinates = [];\n      var ends = [];\n\n      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n        var lineString = lineStrings[i];\n\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n\n        Object(array["c" /* extend */])(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n  }\n\n  if (SimpleGeometry) MultiLineString.__proto__ = SimpleGeometry;\n  MultiLineString.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  MultiLineString.prototype.constructor = MultiLineString;\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n\n  MultiLineString.prototype.appendLineString = function appendLineString(lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      Object(array["c" /* extend */])(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @override\n   * @api\n   */\n\n\n  MultiLineString.prototype.clone = function clone() {\n    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MultiLineString.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < Object(ol_extent["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(Object(closest["a" /* arrayMaxSquaredDelta */])(this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return Object(closest["b" /* assignClosestArrayPoint */])(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n   * @return {import("../coordinate.js").Coordinate} Coordinate.\n   * @api\n   */\n\n\n  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM(m, opt_extrapolate, opt_interpolate) {\n    if (this.layout != GeometryLayout["a" /* default */].XYM && this.layout != GeometryLayout["a" /* default */].XYZM || this.flatCoordinates.length === 0) {\n      return null;\n    }\n\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);\n  };\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  MultiLineString.prototype.getCoordinates = function getCoordinates() {\n    return Object(inflate["b" /* inflateCoordinatesArray */])(this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n  /**\n   * @return {Array<number>} Ends.\n   */\n\n\n  MultiLineString.prototype.getEnds = function getEnds() {\n    return this.ends_;\n  };\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n\n\n  MultiLineString.prototype.getLineString = function getLineString(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n\n    return new geom_LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n\n\n  MultiLineString.prototype.getLineStrings = function getLineStrings() {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    /** @type {Array<LineString>} */\n\n    var lineStrings = [];\n    var offset = 0;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var lineString = new geom_LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n\n    return lineStrings;\n  };\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n\n\n  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints() {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);\n      Object(array["c" /* extend */])(midpoints, midpoint);\n      offset = end;\n    }\n\n    return midpoints;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = Object(simplify["b" /* douglasPeuckerArray */])(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout["a" /* default */].XY, simplifiedEnds);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MultiLineString.prototype.getType = function getType() {\n    return GeometryType["a" /* default */].MULTI_LINE_STRING;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MultiLineString.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return Object(intersectsextent["b" /* intersectsLineStringArray */])(this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n\n\n  MultiLineString.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    var ends = Object(deflate["c" /* deflateCoordinatesArray */])(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return MultiLineString;\n}(geom_SimpleGeometry["a" /* default */]);\n\n/* harmony default export */ var geom_MultiLineString = (MultiLineString_MultiLineString);\n// EXTERNAL MODULE: ./node_modules/ol/geom/Point.js\nvar Point = __webpack_require__(52);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/MultiPoint.js\n/**\n * @module ol/geom/MultiPoint\n */\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\n\nvar MultiPoint_MultiPoint =\n/*@__PURE__*/\nfunction (SimpleGeometry) {\n  function MultiPoint(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n\n    if (opt_layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout,\n      /** @type {Array<number>} */\n      coordinates);\n    } else {\n      this.setCoordinates(\n      /** @type {Array<import("../coordinate.js").Coordinate>} */\n      coordinates, opt_layout);\n    }\n  }\n\n  if (SimpleGeometry) MultiPoint.__proto__ = SimpleGeometry;\n  MultiPoint.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  MultiPoint.prototype.constructor = MultiPoint;\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n\n  MultiPoint.prototype.appendPoint = function appendPoint(point) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = point.getFlatCoordinates().slice();\n    } else {\n      Object(array["c" /* extend */])(this.flatCoordinates, point.getFlatCoordinates());\n    }\n\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @override\n   * @api\n   */\n\n\n  MultiPoint.prototype.clone = function clone() {\n    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n    return multiPoint;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MultiPoint.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < Object(ol_extent["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var squaredDistance = Object(math["f" /* squaredDistance */])(x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n\n        for (var j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n\n        closestPoint.length = stride;\n      }\n    }\n\n    return minSquaredDistance;\n  };\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  MultiPoint.prototype.getCoordinates = function getCoordinates() {\n    return Object(inflate["a" /* inflateCoordinates */])(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n\n\n  MultiPoint.prototype.getPoint = function getPoint(index) {\n    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\n\n    if (index < 0 || n <= index) {\n      return null;\n    }\n\n    return new Point["default"](this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);\n  };\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n\n\n  MultiPoint.prototype.getPoints = function getPoints() {\n    var flatCoordinates = this.flatCoordinates;\n    var layout = this.layout;\n    var stride = this.stride;\n    /** @type {Array<Point>} */\n\n    var points = [];\n\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var point = new Point["default"](flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n\n    return points;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MultiPoint.prototype.getType = function getType() {\n    return GeometryType["a" /* default */].MULTI_POINT;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MultiPoint.prototype.intersectsExtent = function intersectsExtent(extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n\n      if (Object(ol_extent["containsXY"])(extent, x, y)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.\n   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.\n   * @override\n   * @api\n   */\n\n\n  MultiPoint.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    this.flatCoordinates.length = Object(deflate["b" /* deflateCoordinates */])(this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return MultiPoint;\n}(geom_SimpleGeometry["a" /* default */]);\n\n/* harmony default export */ var geom_MultiPoint = (MultiPoint_MultiPoint);\n// EXTERNAL MODULE: ./node_modules/ol/geom/Polygon.js + 1 modules\nvar Polygon = __webpack_require__(47);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/area.js\nvar flat_area = __webpack_require__(75);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/flat/center.js\n/**\n * @module ol/geom/flat/center\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\n\nfunction linearRingss(flatCoordinates, offset, endss, stride) {\n  var flatCenters = [];\n  var extent = Object(ol_extent["createEmpty"])();\n\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    extent = Object(ol_extent["createOrUpdateFromFlatCoordinates"])(flatCoordinates, offset, ends[0], stride);\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n\n  return flatCenters;\n}\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/contains.js\nvar contains = __webpack_require__(48);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/interiorpoint.js\nvar interiorpoint = __webpack_require__(97);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/orient.js + 1 modules\nvar orient = __webpack_require__(63);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/MultiPolygon.js\n/**\n * @module ol/geom/MultiPolygon\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\n\nvar MultiPolygon_MultiPolygon =\n/*@__PURE__*/\nfunction (SimpleGeometry) {\n  function MultiPolygon(coordinates, opt_layout, opt_endss) {\n    SimpleGeometry.call(this);\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n\n    this.endss_ = [];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.flatInteriorPointsRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.flatInteriorPoints_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDelta_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxDeltaRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.orientedRevision_ = -1;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.orientedFlatCoordinates_ = null;\n\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      var layout = this.getLayout();\n      var polygons =\n      /** @type {Array<Polygon>} */\n      coordinates;\n      var flatCoordinates = [];\n      var endss = [];\n\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n\n        Object(array["c" /* extend */])(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n\n    if (opt_layout !== undefined && opt_endss) {\n      this.setFlatCoordinates(opt_layout,\n      /** @type {Array<number>} */\n      coordinates);\n      this.endss_ = opt_endss;\n    } else {\n      this.setCoordinates(\n      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */\n      coordinates, opt_layout);\n    }\n  }\n\n  if (SimpleGeometry) MultiPolygon.__proto__ = SimpleGeometry;\n  MultiPolygon.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  MultiPolygon.prototype.constructor = MultiPolygon;\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n\n  MultiPolygon.prototype.appendPolygon = function appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    var ends;\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      Object(array["c" /* extend */])(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n\n    this.endss_.push(ends);\n    this.changed();\n  };\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @override\n   * @api\n   */\n\n\n  MultiPolygon.prototype.clone = function clone() {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    return new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MultiPolygon.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < Object(ol_extent["closestSquaredDistanceXY"])(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(Object(closest["f" /* multiArrayMaxSquaredDelta */])(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n\n    return Object(closest["c" /* assignClosestMultiArrayPoint */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MultiPolygon.prototype.containsXY = function containsXY(x, y) {\n    return Object(contains["d" /* linearRingssContainsXY */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n\n\n  MultiPolygon.prototype.getArea = function getArea() {\n    return Object(flat_area["c" /* linearRingss */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.\n   * @override\n   * @api\n   */\n\n\n  MultiPolygon.prototype.getCoordinates = function getCoordinates(opt_right) {\n    var flatCoordinates;\n\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      Object(orient["d" /* orientLinearRingsArray */])(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return Object(inflate["c" /* inflateMultiCoordinatesArray */])(flatCoordinates, 0, this.endss_, this.stride);\n  };\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n\n\n  MultiPolygon.prototype.getEndss = function getEndss() {\n    return this.endss_;\n  };\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n\n\n  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = Object(interiorpoint["b" /* getInteriorPointsOfMultiArray */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n\n    return this.flatInteriorPoints_;\n  };\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n\n\n  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints() {\n    return new geom_MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout["a" /* default */].XYM);\n  };\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n\n\n  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n\n      if (Object(orient["b" /* linearRingsAreOriented */])(flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = Object(orient["d" /* orientLinearRingsArray */])(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n\n      this.orientedRevision_ = this.getRevision();\n    }\n\n    return this.orientedFlatCoordinates_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = Object(simplify["d" /* quantizeMultiArray */])(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout["a" /* default */].XY, simplifiedEndss);\n  };\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n\n\n  MultiPolygon.prototype.getPolygon = function getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n\n    var offset;\n\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n\n    if (offset !== 0) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n\n    return new Polygon["b" /* default */](this.flatCoordinates.slice(offset, end), this.layout, ends);\n  };\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n\n\n  MultiPolygon.prototype.getPolygons = function getPolygons() {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n\n      if (offset !== 0) {\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n\n      var polygon = new Polygon["b" /* default */](flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n\n    return polygons;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MultiPolygon.prototype.getType = function getType() {\n    return GeometryType["a" /* default */].MULTI_POLYGON;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  MultiPolygon.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return Object(intersectsextent["d" /* intersectsLinearRingMultiArray */])(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n\n\n  MultiPolygon.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n\n    var endss = Object(deflate["d" /* deflateMultiCoordinatesArray */])(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n\n    this.changed();\n  };\n\n  return MultiPolygon;\n}(geom_SimpleGeometry["a" /* default */]);\n\n/* harmony default export */ var geom_MultiPolygon = (MultiPolygon_MultiPolygon);\n// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules\nvar proj = __webpack_require__(10);\n\n// CONCATENATED MODULE: ./node_modules/ol/format/GeoJSON.js\n/**\n * @module ol/format/GeoJSON\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {import("geojson").GeoJSON} GeoJSONObject\n * @typedef {import("geojson").Feature} GeoJSONFeature\n * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import("geojson").Geometry} GeoJSONGeometry\n * @typedef {import("geojson").Point} GeoJSONPoint\n * @typedef {import("geojson").LineString} GeoJSONLineString\n * @typedef {import("geojson").Polygon} GeoJSONPolygon\n * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint\n * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString\n * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection\n */\n\n/**\n * @typedef {Object} Options\n * @property {import("../proj.js").ProjectionLike} [dataProjection=\'EPSG:4326\'] Default data projection.\n * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n  * @api\n */\n\nvar GeoJSON_GeoJSON =\n/*@__PURE__*/\nfunction (JSONFeature) {\n  function GeoJSON(opt_options) {\n    var options = opt_options ? opt_options : {};\n    JSONFeature.call(this);\n    /**\n     * @inheritDoc\n     */\n\n    this.dataProjection = Object(proj["get"])(options.dataProjection ? options.dataProjection : \'EPSG:4326\');\n\n    if (options.featureProjection) {\n      this.defaultFeatureProjection = Object(proj["get"])(options.featureProjection);\n    }\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n\n\n    this.geometryName_ = options.geometryName;\n    /**\n     * Look for the geometry name in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */\n\n    this.extractGeometryName_ = options.extractGeometryName;\n  }\n\n  if (JSONFeature) GeoJSON.__proto__ = JSONFeature;\n  GeoJSON.prototype = Object.create(JSONFeature && JSONFeature.prototype);\n  GeoJSON.prototype.constructor = GeoJSON;\n  /**\n   * @inheritDoc\n   */\n\n  GeoJSON.prototype.readFeatureFromObject = function readFeatureFromObject(object, opt_options) {\n    /**\n     * @type {GeoJSONFeature}\n     */\n    var geoJSONFeature = null;\n\n    if (object[\'type\'] === \'Feature\') {\n      geoJSONFeature =\n      /** @type {GeoJSONFeature} */\n      object;\n    } else {\n      geoJSONFeature = {\n        \'type\': \'Feature\',\n        \'geometry\':\n        /** @type {GeoJSONGeometry} */\n        object,\n        \'properties\': null\n      };\n    }\n\n    var geometry = readGeometry(geoJSONFeature[\'geometry\'], opt_options);\n    var feature = new Feature["default"]();\n\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    } else if (this.extractGeometryName_ && \'geometry_name\' in geoJSONFeature !== undefined) {\n      feature.setGeometryName(geoJSONFeature[\'geometry_name\']);\n    }\n\n    feature.setGeometry(geometry);\n\n    if (\'id\' in geoJSONFeature) {\n      feature.setId(geoJSONFeature[\'id\']);\n    }\n\n    if (geoJSONFeature[\'properties\']) {\n      feature.setProperties(geoJSONFeature[\'properties\']);\n    }\n\n    return feature;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GeoJSON.prototype.readFeaturesFromObject = function readFeaturesFromObject(object, opt_options) {\n    var geoJSONObject =\n    /** @type {GeoJSONObject} */\n    object;\n    /** @type {Array<import("../Feature.js").default>} */\n\n    var features = null;\n\n    if (geoJSONObject[\'type\'] === \'FeatureCollection\') {\n      var geoJSONFeatureCollection =\n      /** @type {GeoJSONFeatureCollection} */\n      object;\n      features = [];\n      var geoJSONFeatures = geoJSONFeatureCollection[\'features\'];\n\n      for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n        features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, opt_options)];\n    }\n\n    return features;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GeoJSON.prototype.readGeometryFromObject = function readGeometryFromObject(object, opt_options) {\n    return readGeometry(\n    /** @type {GeoJSONGeometry} */\n    object, opt_options);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GeoJSON.prototype.readProjectionFromObject = function readProjectionFromObject(object) {\n    var crs = object[\'crs\'];\n    var projection;\n\n    if (crs) {\n      if (crs[\'type\'] == \'name\') {\n        projection = Object(proj["get"])(crs[\'properties\'][\'name\']);\n      } else {\n        Object(asserts["a" /* assert */])(false, 36); // Unknown SRS type\n      }\n    } else {\n      projection = this.dataProjection;\n    }\n\n    return (\n      /** @type {import("../proj/Projection.js").default} */\n      projection\n    );\n  };\n  /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {import("../Feature.js").default} feature Feature.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {GeoJSONFeature} Object.\n   * @override\n   * @api\n   */\n\n\n  GeoJSON.prototype.writeFeatureObject = function writeFeatureObject(feature, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    /** @type {GeoJSONFeature} */\n\n    var object = {\n      \'type\': \'Feature\',\n      geometry: null,\n      properties: null\n    };\n    var id = feature.getId();\n\n    if (id !== undefined) {\n      object.id = id;\n    }\n\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      object.geometry = writeGeometry(geometry, opt_options);\n    }\n\n    var properties = feature.getProperties();\n    delete properties[feature.getGeometryName()];\n\n    if (!Object(obj["d" /* isEmpty */])(properties)) {\n      object.properties = properties;\n    }\n\n    return object;\n  };\n  /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array<import("../Feature.js").default>} features Features.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @override\n   * @api\n   */\n\n\n  GeoJSON.prototype.writeFeaturesObject = function writeFeaturesObject(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    var objects = [];\n\n    for (var i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], opt_options));\n    }\n\n    return {\n      type: \'FeatureCollection\',\n      features: objects\n    };\n  };\n  /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {import("../geom/Geometry.js").default} geometry Geometry.\n   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @override\n   * @api\n   */\n\n\n  GeoJSON.prototype.writeGeometryObject = function writeGeometryObject(geometry, opt_options) {\n    return writeGeometry(geometry, this.adaptOptions(opt_options));\n  };\n\n  return GeoJSON;\n}(format_JSONFeature);\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import("./Feature.js").ReadOptions=} opt_options Read options.\n * @return {import("../geom/Geometry.js").default} Geometry.\n */\n\n\nfunction readGeometry(object, opt_options) {\n  if (!object) {\n    return null;\n  }\n  /**\n   * @type {import("../geom/Geometry.js").default}\n   */\n\n\n  var geometry;\n\n  switch (object[\'type\']) {\n    case GeometryType["a" /* default */].POINT:\n      {\n        geometry = readPointGeometry(\n        /** @type {GeoJSONPoint} */\n        object);\n        break;\n      }\n\n    case GeometryType["a" /* default */].LINE_STRING:\n      {\n        geometry = readLineStringGeometry(\n        /** @type {GeoJSONLineString} */\n        object);\n        break;\n      }\n\n    case GeometryType["a" /* default */].POLYGON:\n      {\n        geometry = readPolygonGeometry(\n        /** @type {GeoJSONPolygon} */\n        object);\n        break;\n      }\n\n    case GeometryType["a" /* default */].MULTI_POINT:\n      {\n        geometry = readMultiPointGeometry(\n        /** @type {GeoJSONMultiPoint} */\n        object);\n        break;\n      }\n\n    case GeometryType["a" /* default */].MULTI_LINE_STRING:\n      {\n        geometry = readMultiLineStringGeometry(\n        /** @type {GeoJSONMultiLineString} */\n        object);\n        break;\n      }\n\n    case GeometryType["a" /* default */].MULTI_POLYGON:\n      {\n        geometry = readMultiPolygonGeometry(\n        /** @type {GeoJSONMultiPolygon} */\n        object);\n        break;\n      }\n\n    case GeometryType["a" /* default */].GEOMETRY_COLLECTION:\n      {\n        geometry = readGeometryCollectionGeometry(\n        /** @type {GeoJSONGeometryCollection} */\n        object);\n        break;\n      }\n\n    default:\n      {\n        throw new Error(\'Unsupported GeoJSON type: \' + object.type);\n      }\n  }\n\n  return (\n    /** @type {import("../geom/Geometry.js").default} */\n    Object(format_Feature["transformWithOptions"])(geometry, false, opt_options)\n  );\n}\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import("./Feature.js").ReadOptions=} opt_options Read options.\n * @return {GeometryCollection} Geometry collection.\n */\n\n\nfunction readGeometryCollectionGeometry(object, opt_options) {\n  var geometries = object[\'geometries\'].map(\n  /**\n   * @param {GeoJSONGeometry} geometry Geometry.\n   * @return {import("../geom/Geometry.js").default} geometry Geometry.\n   */\n  function (geometry) {\n    return readGeometry(geometry, opt_options);\n  });\n  return new geom_GeometryCollection(geometries);\n}\n/**\n * @param {GeoJSONPoint} object Object.\n * @return {Point} Point.\n */\n\n\nfunction readPointGeometry(object) {\n  return new Point["default"](object[\'coordinates\']);\n}\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {LineString} LineString.\n */\n\n\nfunction readLineStringGeometry(object) {\n  return new geom_LineString(object[\'coordinates\']);\n}\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {MultiLineString} MultiLineString.\n */\n\n\nfunction readMultiLineStringGeometry(object) {\n  return new geom_MultiLineString(object[\'coordinates\']);\n}\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {MultiPoint} MultiPoint.\n */\n\n\nfunction readMultiPointGeometry(object) {\n  return new geom_MultiPoint(object[\'coordinates\']);\n}\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {MultiPolygon} MultiPolygon.\n */\n\n\nfunction readMultiPolygonGeometry(object) {\n  return new geom_MultiPolygon(object[\'coordinates\']);\n}\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {Polygon} Polygon.\n */\n\n\nfunction readPolygonGeometry(object) {\n  return new Polygon["b" /* default */](object[\'coordinates\']);\n}\n/**\n * @param {import("../geom/Geometry.js").default} geometry Geometry.\n * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n\n\nfunction writeGeometry(geometry, opt_options) {\n  geometry =\n  /** @type {import("../geom/Geometry.js").default} */\n  Object(format_Feature["transformWithOptions"])(geometry, true, opt_options);\n  var type = geometry.getType();\n  /** @type {GeoJSONGeometry} */\n\n  var geoJSON;\n\n  switch (type) {\n    case GeometryType["a" /* default */].POINT:\n      {\n        geoJSON = writePointGeometry(\n        /** @type {Point} */\n        geometry, opt_options);\n        break;\n      }\n\n    case GeometryType["a" /* default */].LINE_STRING:\n      {\n        geoJSON = writeLineStringGeometry(\n        /** @type {LineString} */\n        geometry, opt_options);\n        break;\n      }\n\n    case GeometryType["a" /* default */].POLYGON:\n      {\n        geoJSON = writePolygonGeometry(\n        /** @type {Polygon} */\n        geometry, opt_options);\n        break;\n      }\n\n    case GeometryType["a" /* default */].MULTI_POINT:\n      {\n        geoJSON = writeMultiPointGeometry(\n        /** @type {MultiPoint} */\n        geometry, opt_options);\n        break;\n      }\n\n    case GeometryType["a" /* default */].MULTI_LINE_STRING:\n      {\n        geoJSON = writeMultiLineStringGeometry(\n        /** @type {MultiLineString} */\n        geometry, opt_options);\n        break;\n      }\n\n    case GeometryType["a" /* default */].MULTI_POLYGON:\n      {\n        geoJSON = writeMultiPolygonGeometry(\n        /** @type {MultiPolygon} */\n        geometry, opt_options);\n        break;\n      }\n\n    case GeometryType["a" /* default */].GEOMETRY_COLLECTION:\n      {\n        geoJSON = writeGeometryCollectionGeometry(\n        /** @type {GeometryCollection} */\n        geometry, opt_options);\n        break;\n      }\n\n    case GeometryType["a" /* default */].CIRCLE:\n      {\n        geoJSON = {\n          type: \'GeometryCollection\',\n          geometries: []\n        };\n        break;\n      }\n\n    default:\n      {\n        throw new Error(\'Unsupported geometry type: \' + type);\n      }\n  }\n\n  return geoJSON;\n}\n/**\n * @param {GeometryCollection} geometry Geometry.\n * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\n\n\nfunction writeGeometryCollectionGeometry(geometry, opt_options) {\n  var geometries = geometry.getGeometriesArray().map(function (geometry) {\n    var options = Object(obj["a" /* assign */])({}, opt_options);\n    delete options.featureProjection;\n    return writeGeometry(geometry, options);\n  });\n  return {\n    type: \'GeometryCollection\',\n    geometries: geometries\n  };\n}\n/**\n * @param {LineString} geometry Geometry.\n * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n\n\nfunction writeLineStringGeometry(geometry, opt_options) {\n  return {\n    type: \'LineString\',\n    coordinates: geometry.getCoordinates()\n  };\n}\n/**\n * @param {MultiLineString} geometry Geometry.\n * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n\n\nfunction writeMultiLineStringGeometry(geometry, opt_options) {\n  return {\n    type: \'MultiLineString\',\n    coordinates: geometry.getCoordinates()\n  };\n}\n/**\n * @param {MultiPoint} geometry Geometry.\n * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n\n\nfunction writeMultiPointGeometry(geometry, opt_options) {\n  return {\n    type: \'MultiPoint\',\n    coordinates: geometry.getCoordinates()\n  };\n}\n/**\n * @param {MultiPolygon} geometry Geometry.\n * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n\n\nfunction writeMultiPolygonGeometry(geometry, opt_options) {\n  var right;\n\n  if (opt_options) {\n    right = opt_options.rightHanded;\n  }\n\n  return {\n    type: \'MultiPolygon\',\n    coordinates: geometry.getCoordinates(right)\n  };\n}\n/**\n * @param {Point} geometry Geometry.\n * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n\n\nfunction writePointGeometry(geometry, opt_options) {\n  return {\n    type: \'Point\',\n    coordinates: geometry.getCoordinates()\n  };\n}\n/**\n * @param {Polygon} geometry Geometry.\n * @param {import("./Feature.js").WriteOptions=} opt_options Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\n\n\nfunction writePolygonGeometry(geometry, opt_options) {\n  var right;\n\n  if (opt_options) {\n    right = opt_options.rightHanded;\n  }\n\n  return {\n    type: \'Polygon\',\n    coordinates: geometry.getCoordinates(right)\n  };\n}\n\n/* harmony default export */ var format_GeoJSON = __webpack_exports__["default"] = (GeoJSON_GeoJSON);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2Zvcm1hdC9KU09ORmVhdHVyZS5qcz82MjNmIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanM/ZTllMiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9pbnRlcnBvbGF0ZS5qcz9kZjMyIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvZ2VvbS9MaW5lU3RyaW5nLmpzP2JlZGEiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9nZW9tL011bHRpTGluZVN0cmluZy5qcz83YzViIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvZ2VvbS9NdWx0aVBvaW50LmpzPzAyYWYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9nZW9tL2ZsYXQvY2VudGVyLmpzPzRkY2IiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9nZW9tL011bHRpUG9seWdvbi5qcz9lYTU4Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvZm9ybWF0L0dlb0pTT04uanM/ODk4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L0pTT05GZWF0dXJlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEZlYXR1cmVGb3JtYXQgZnJvbSAnLi9GZWF0dXJlLmpzJztcbmltcG9ydCBGb3JtYXRUeXBlIGZyb20gJy4vRm9ybWF0VHlwZS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogQmFzZSBjbGFzcyBmb3IgSlNPTiBmZWF0dXJlIGZvcm1hdHMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEpTT05GZWF0dXJlIGV4dGVuZHMgRmVhdHVyZUZvcm1hdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdFR5cGUuSlNPTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgZmVhdHVyZS4gIE9ubHkgd29ya3MgZm9yIGEgc2luZ2xlIGZlYXR1cmUuIFVzZSBgcmVhZEZlYXR1cmVzYCB0b1xuICAgKiByZWFkIGEgZmVhdHVyZSBjb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfERvY3VtZW50fE5vZGV8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnM9fSBvcHRfb3B0aW9ucyBSZWFkIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gRmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZEZlYXR1cmUoc291cmNlLCBvcHRfb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlYWRGZWF0dXJlRnJvbU9iamVjdChcbiAgICAgIGdldE9iamVjdChzb3VyY2UpLCB0aGlzLmdldFJlYWRPcHRpb25zKHNvdXJjZSwgb3B0X29wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGFsbCBmZWF0dXJlcy4gIFdvcmtzIHdpdGggYm90aCBhIHNpbmdsZSBmZWF0dXJlIGFuZCBhIGZlYXR1cmVcbiAgICogY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcnxEb2N1bWVudHxOb2RlfE9iamVjdHxzdHJpbmd9IHNvdXJjZSBTb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zPX0gb3B0X29wdGlvbnMgUmVhZCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBGZWF0dXJlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVhZEZlYXR1cmVzKHNvdXJjZSwgb3B0X29wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkRmVhdHVyZXNGcm9tT2JqZWN0KFxuICAgICAgZ2V0T2JqZWN0KHNvdXJjZSksIHRoaXMuZ2V0UmVhZE9wdGlvbnMoc291cmNlLCBvcHRfb3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE9iamVjdC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnM9fSBvcHRfb3B0aW9ucyBSZWFkIG9wdGlvbnMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBGZWF0dXJlLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVGcm9tT2JqZWN0KG9iamVjdCwgb3B0X29wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zPX0gb3B0X29wdGlvbnMgUmVhZCBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IEZlYXR1cmVzLlxuICAgKi9cbiAgcmVhZEZlYXR1cmVzRnJvbU9iamVjdChvYmplY3QsIG9wdF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIGdlb21ldHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfERvY3VtZW50fE5vZGV8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuUmVhZE9wdGlvbnM9fSBvcHRfb3B0aW9ucyBSZWFkIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRHZW9tZXRyeShzb3VyY2UsIG9wdF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEdlb21ldHJ5RnJvbU9iamVjdChcbiAgICAgIGdldE9iamVjdChzb3VyY2UpLCB0aGlzLmdldFJlYWRPcHRpb25zKHNvdXJjZSwgb3B0X29wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zPX0gb3B0X29wdGlvbnMgUmVhZCBvcHRpb25zLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICAqL1xuICByZWFkR2VvbWV0cnlGcm9tT2JqZWN0KG9iamVjdCwgb3B0X29wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBwcm9qZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfERvY3VtZW50fE5vZGV8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IFByb2plY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHJlYWRQcm9qZWN0aW9uKHNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLnJlYWRQcm9qZWN0aW9uRnJvbU9iamVjdChnZXRPYmplY3Qoc291cmNlKSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBQcm9qZWN0aW9uLlxuICAgKi9cbiAgcmVhZFByb2plY3Rpb25Gcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIGZlYXR1cmUgYXMgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnM9fSBvcHRfb3B0aW9ucyBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgZmVhdHVyZS5cbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlKGZlYXR1cmUsIG9wdF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMud3JpdGVGZWF0dXJlT2JqZWN0KGZlYXR1cmUsIG9wdF9vcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9ucz19IG9wdF9vcHRpb25zIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0LlxuICAgKi9cbiAgd3JpdGVGZWF0dXJlT2JqZWN0KGZlYXR1cmUsIG9wdF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGFzIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zPX0gb3B0X29wdGlvbnMgV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBFbmNvZGVkIGZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICB3cml0ZUZlYXR1cmVzKGZlYXR1cmVzLCBvcHRfb3B0aW9ucykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLndyaXRlRmVhdHVyZXNPYmplY3QoZmVhdHVyZXMsIG9wdF9vcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gZmVhdHVyZXMgRmVhdHVyZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9ucz19IG9wdF9vcHRpb25zIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0LlxuICAgKi9cbiAgd3JpdGVGZWF0dXJlc09iamVjdChmZWF0dXJlcywgb3B0X29wdGlvbnMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBnZW9tZXRyeSBhcyBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zPX0gb3B0X29wdGlvbnMgV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBFbmNvZGVkIGdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqL1xuICB3cml0ZUdlb21ldHJ5KGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLndyaXRlR2VvbWV0cnlPYmplY3QoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zPX0gb3B0X29wdGlvbnMgV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QuXG4gICAqL1xuICB3cml0ZUdlb21ldHJ5T2JqZWN0KGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50fE5vZGV8T2JqZWN0fHN0cmluZ30gc291cmNlIFNvdXJjZS5cbiAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRPYmplY3Qoc291cmNlKSB7XG4gIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IG9iamVjdCA9IEpTT04ucGFyc2Uoc291cmNlKTtcbiAgICByZXR1cm4gb2JqZWN0ID8gLyoqIEB0eXBlIHtPYmplY3R9ICovIChvYmplY3QpIDogbnVsbDtcbiAgfSBlbHNlIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc291cmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgSlNPTkZlYXR1cmU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb25cbiAqL1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGVFbXB0eSwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZLCBleHRlbmQsIGdldENlbnRlcn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeSBmcm9tICcuL0dlb21ldHJ5LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbiBhcnJheSBvZiB7QGxpbmsgbW9kdWxlOm9sL2dlb20vR2VvbWV0cnl9IG9iamVjdHMuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBHZW9tZXRyeUNvbGxlY3Rpb24gZXh0ZW5kcyBHZW9tZXRyeSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8R2VvbWV0cnk+PX0gb3B0X2dlb21ldHJpZXMgR2VvbWV0cmllcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9nZW9tZXRyaWVzKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8R2VvbWV0cnk+fVxuICAgICAqL1xuICAgIHRoaXMuZ2VvbWV0cmllc18gPSBvcHRfZ2VvbWV0cmllcyA/IG9wdF9nZW9tZXRyaWVzIDogbnVsbDtcblxuICAgIHRoaXMubGlzdGVuR2VvbWV0cmllc0NoYW5nZV8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5saXN0ZW5HZW9tZXRyaWVzQ2hhbmdlXygpIHtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cmllc18pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGhpcy5nZW9tZXRyaWVzXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3RlbihcbiAgICAgICAgdGhpcy5nZW9tZXRyaWVzX1tpXSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgdGhpcy5jaGFuZ2VkLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxpc3Rlbkdlb21ldHJpZXNDaGFuZ2VfKCkge1xuICAgIGlmICghdGhpcy5nZW9tZXRyaWVzXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmdlb21ldHJpZXNfLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGxpc3RlbihcbiAgICAgICAgdGhpcy5nZW9tZXRyaWVzX1tpXSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgdGhpcy5jaGFuZ2VkLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshR2VvbWV0cnlDb2xsZWN0aW9ufSBDbG9uZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGdlb21ldHJ5Q29sbGVjdGlvbiA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCk7XG4gICAgZ2VvbWV0cnlDb2xsZWN0aW9uLnNldEdlb21ldHJpZXModGhpcy5nZW9tZXRyaWVzXyk7XG4gICAgcmV0dXJuIGdlb21ldHJ5Q29sbGVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzXztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IGdlb21ldHJpZXNbaV0uY2xvc2VzdFBvaW50WFkoXG4gICAgICAgIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgY29udGFpbnNYWSh4LCB5KSB7XG4gICAgY29uc3QgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllc187XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBpZiAoZ2VvbWV0cmllc1tpXS5jb250YWluc1hZKHgsIHkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNvbXB1dGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgY3JlYXRlT3JVcGRhdGVFbXB0eShleHRlbnQpO1xuICAgIGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXNfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZXh0ZW5kKGV4dGVudCwgZ2VvbWV0cmllc1tpXS5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBnZW9tZXRyaWVzIHRoYXQgbWFrZSB1cCB0aGlzIGdlb21ldHJ5IGNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm4ge0FycmF5PEdlb21ldHJ5Pn0gR2VvbWV0cmllcy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0R2VvbWV0cmllcygpIHtcbiAgICByZXR1cm4gY2xvbmVHZW9tZXRyaWVzKHRoaXMuZ2VvbWV0cmllc18pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEdlb21ldHJ5Pn0gR2VvbWV0cmllcy5cbiAgICovXG4gIGdldEdlb21ldHJpZXNBcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyaWVzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHNxdWFyZWRUb2xlcmFuY2UpIHtcbiAgICBpZiAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlSZXZpc2lvbiAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIGNsZWFyKHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGUpO1xuICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gMDtcbiAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5UmV2aXNpb24gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIGlmIChzcXVhcmVkVG9sZXJhbmNlIDwgMCB8fFxuICAgICAgICAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlICE9PSAwICYmXG4gICAgICAgICBzcXVhcmVkVG9sZXJhbmNlIDwgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHNxdWFyZWRUb2xlcmFuY2UudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlDYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlDYWNoZVtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzaW1wbGlmaWVkR2VvbWV0cmllcyA9IFtdO1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllc187XG4gICAgICBsZXQgc2ltcGxpZmllZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZEdlb21ldHJ5ID0gZ2VvbWV0cnkuZ2V0U2ltcGxpZmllZEdlb21ldHJ5KHNxdWFyZWRUb2xlcmFuY2UpO1xuICAgICAgICBzaW1wbGlmaWVkR2VvbWV0cmllcy5wdXNoKHNpbXBsaWZpZWRHZW9tZXRyeSk7XG4gICAgICAgIGlmIChzaW1wbGlmaWVkR2VvbWV0cnkgIT09IGdlb21ldHJ5KSB7XG4gICAgICAgICAgc2ltcGxpZmllZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaW1wbGlmaWVkKSB7XG4gICAgICAgIGNvbnN0IHNpbXBsaWZpZWRHZW9tZXRyeUNvbGxlY3Rpb24gPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpO1xuICAgICAgICBzaW1wbGlmaWVkR2VvbWV0cnlDb2xsZWN0aW9uLnNldEdlb21ldHJpZXNBcnJheShzaW1wbGlmaWVkR2VvbWV0cmllcyk7XG4gICAgICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGVba2V5XSA9IHNpbXBsaWZpZWRHZW9tZXRyeUNvbGxlY3Rpb247XG4gICAgICAgIHJldHVybiBzaW1wbGlmaWVkR2VvbWV0cnlDb2xsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaW1wbGlmaWVkR2VvbWV0cnlNYXhNaW5TcXVhcmVkVG9sZXJhbmNlID0gc3F1YXJlZFRvbGVyYW5jZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgY29uc3QgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllc187XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBpZiAoZ2VvbWV0cmllc1tpXS5pbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cmllc18ubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIHJvdGF0ZShhbmdsZSwgYW5jaG9yKSB7XG4gICAgY29uc3QgZ2VvbWV0cmllcyA9IHRoaXMuZ2VvbWV0cmllc187XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBnZW9tZXRyaWVzW2ldLnJvdGF0ZShhbmdsZSwgYW5jaG9yKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgc2NhbGUoc3gsIG9wdF9zeSwgb3B0X2FuY2hvcikge1xuICAgIGxldCBhbmNob3IgPSBvcHRfYW5jaG9yO1xuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICBhbmNob3IgPSBnZXRDZW50ZXIodGhpcy5nZXRFeHRlbnQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJpZXMgPSB0aGlzLmdlb21ldHJpZXNfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgZ2VvbWV0cmllc1tpXS5zY2FsZShzeCwgb3B0X3N5LCBhbmNob3IpO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGdlb21ldHJpZXMgdGhhdCBtYWtlIHVwIHRoaXMgZ2VvbWV0cnkgY29sbGVjdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheTxHZW9tZXRyeT59IGdlb21ldHJpZXMgR2VvbWV0cmllcy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0R2VvbWV0cmllcyhnZW9tZXRyaWVzKSB7XG4gICAgdGhpcy5zZXRHZW9tZXRyaWVzQXJyYXkoY2xvbmVHZW9tZXRyaWVzKGdlb21ldHJpZXMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEdlb21ldHJ5Pn0gZ2VvbWV0cmllcyBHZW9tZXRyaWVzLlxuICAgKi9cbiAgc2V0R2VvbWV0cmllc0FycmF5KGdlb21ldHJpZXMpIHtcbiAgICB0aGlzLnVubGlzdGVuR2VvbWV0cmllc0NoYW5nZV8oKTtcbiAgICB0aGlzLmdlb21ldHJpZXNfID0gZ2VvbWV0cmllcztcbiAgICB0aGlzLmxpc3Rlbkdlb21ldHJpZXNDaGFuZ2VfKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtRm4pIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzXztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGdlb21ldHJpZXNbaV0uYXBwbHlUcmFuc2Zvcm0odHJhbnNmb3JtRm4pO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICB0cmFuc2xhdGUoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gdGhpcy5nZW9tZXRyaWVzXztcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGdlb21ldHJpZXNbaV0udHJhbnNsYXRlKGRlbHRhWCwgZGVsdGFZKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICB0aGlzLnVubGlzdGVuR2VvbWV0cmllc0NoYW5nZV8oKTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxHZW9tZXRyeT59IGdlb21ldHJpZXMgR2VvbWV0cmllcy5cbiAqIEByZXR1cm4ge0FycmF5PEdlb21ldHJ5Pn0gQ2xvbmVkIGdlb21ldHJpZXMuXG4gKi9cbmZ1bmN0aW9uIGNsb25lR2VvbWV0cmllcyhnZW9tZXRyaWVzKSB7XG4gIGNvbnN0IGNsb25lZEdlb21ldHJpZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgY2xvbmVkR2VvbWV0cmllcy5wdXNoKGdlb21ldHJpZXNbaV0uY2xvbmUoKSk7XG4gIH1cbiAgcmV0dXJuIGNsb25lZEdlb21ldHJpZXM7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgR2VvbWV0cnlDb2xsZWN0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcnBvbGF0ZVxuICovXG5pbXBvcnQge2JpbmFyeVNlYXJjaH0gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtsZXJwfSBmcm9tICcuLi8uLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJhY3Rpb24gRnJhY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj49fSBvcHRfZGVzdCBEZXN0aW5hdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IERlc3RpbmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwb2xhdGVQb2ludChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGZyYWN0aW9uLCBvcHRfZGVzdCkge1xuICBsZXQgcG9pbnRYID0gTmFOO1xuICBsZXQgcG9pbnRZID0gTmFOO1xuICBjb25zdCBuID0gKGVuZCAtIG9mZnNldCkgLyBzdHJpZGU7XG4gIGlmIChuID09PSAxKSB7XG4gICAgcG9pbnRYID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF07XG4gICAgcG9pbnRZID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICB9IGVsc2UgaWYgKG4gPT0gMikge1xuICAgIHBvaW50WCA9ICgxIC0gZnJhY3Rpb24pICogZmxhdENvb3JkaW5hdGVzW29mZnNldF0gK1xuICAgICAgICBmcmFjdGlvbiAqIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGVdO1xuICAgIHBvaW50WSA9ICgxIC0gZnJhY3Rpb24pICogZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdICtcbiAgICAgICAgZnJhY3Rpb24gKiBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlICsgMV07XG4gIH0gZWxzZSBpZiAobiAhPT0gMCkge1xuICAgIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgIGxldCB5MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBjb25zdCBjdW11bGF0aXZlTGVuZ3RocyA9IFswXTtcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0ICsgc3RyaWRlOyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgY29uc3QgeDIgPSBmbGF0Q29vcmRpbmF0ZXNbaV07XG4gICAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gICAgICBjdW11bGF0aXZlTGVuZ3Rocy5wdXNoKGxlbmd0aCk7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZnJhY3Rpb24gKiBsZW5ndGg7XG4gICAgY29uc3QgaW5kZXggPSBiaW5hcnlTZWFyY2goY3VtdWxhdGl2ZUxlbmd0aHMsIHRhcmdldCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgY29uc3QgdCA9ICh0YXJnZXQgLSBjdW11bGF0aXZlTGVuZ3Roc1staW5kZXggLSAyXSkgL1xuICAgICAgICAgIChjdW11bGF0aXZlTGVuZ3Roc1staW5kZXggLSAxXSAtIGN1bXVsYXRpdmVMZW5ndGhzWy1pbmRleCAtIDJdKTtcbiAgICAgIGNvbnN0IG8gPSBvZmZzZXQgKyAoLWluZGV4IC0gMikgKiBzdHJpZGU7XG4gICAgICBwb2ludFggPSBsZXJwKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbb10sIGZsYXRDb29yZGluYXRlc1tvICsgc3RyaWRlXSwgdCk7XG4gICAgICBwb2ludFkgPSBsZXJwKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXNbbyArIDFdLCBmbGF0Q29vcmRpbmF0ZXNbbyArIHN0cmlkZSArIDFdLCB0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRYID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIGluZGV4ICogc3RyaWRlXTtcbiAgICAgIHBvaW50WSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBpbmRleCAqIHN0cmlkZSArIDFdO1xuICAgIH1cbiAgfVxuICBpZiAob3B0X2Rlc3QpIHtcbiAgICBvcHRfZGVzdFswXSA9IHBvaW50WDtcbiAgICBvcHRfZGVzdFsxXSA9IHBvaW50WTtcbiAgICByZXR1cm4gb3B0X2Rlc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtwb2ludFgsIHBvaW50WV07XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICogQHBhcmFtIHtib29sZWFufSBleHRyYXBvbGF0ZSBFeHRyYXBvbGF0ZS5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ29vcmRpbmF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgbSwgZXh0cmFwb2xhdGUpIHtcbiAgaWYgKGVuZCA9PSBvZmZzZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgY29vcmRpbmF0ZTtcbiAgaWYgKG0gPCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlIC0gMV0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzdHJpZGUpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZsYXRDb29yZGluYXRlc1tlbmQgLSAxXSA8IG0pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGUpIHtcbiAgICAgIGNvb3JkaW5hdGUgPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoZW5kIC0gc3RyaWRlLCBlbmQpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8vIEZJWE1FIHVzZSBPKDEpIHNlYXJjaFxuICBpZiAobSA9PSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgc3RyaWRlIC0gMV0pIHtcbiAgICByZXR1cm4gZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3RyaWRlKTtcbiAgfVxuICBsZXQgbG8gPSBvZmZzZXQgLyBzdHJpZGU7XG4gIGxldCBoaSA9IGVuZCAvIHN0cmlkZTtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICBjb25zdCBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAobSA8IGZsYXRDb29yZGluYXRlc1sobWlkICsgMSkgKiBzdHJpZGUgLSAxXSkge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbTAgPSBmbGF0Q29vcmRpbmF0ZXNbbG8gKiBzdHJpZGUgLSAxXTtcbiAgaWYgKG0gPT0gbTApIHtcbiAgICByZXR1cm4gZmxhdENvb3JkaW5hdGVzLnNsaWNlKChsbyAtIDEpICogc3RyaWRlLCAobG8gLSAxKSAqIHN0cmlkZSArIHN0cmlkZSk7XG4gIH1cbiAgY29uc3QgbTEgPSBmbGF0Q29vcmRpbmF0ZXNbKGxvICsgMSkgKiBzdHJpZGUgLSAxXTtcbiAgY29uc3QgdCA9IChtIC0gbTApIC8gKG0xIC0gbTApO1xuICBjb29yZGluYXRlID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlIC0gMTsgKytpKSB7XG4gICAgY29vcmRpbmF0ZS5wdXNoKGxlcnAoZmxhdENvb3JkaW5hdGVzWyhsbyAtIDEpICogc3RyaWRlICsgaV0sXG4gICAgICBmbGF0Q29vcmRpbmF0ZXNbbG8gKiBzdHJpZGUgKyBpXSwgdCkpO1xuICB9XG4gIGNvb3JkaW5hdGUucHVzaChtKTtcbiAgcmV0dXJuIGNvb3JkaW5hdGU7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG0gTS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXh0cmFwb2xhdGUgRXh0cmFwb2xhdGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludGVycG9sYXRlIEludGVycG9sYXRlLlxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZVN0cmluZ3NDb29yZGluYXRlQXRNKFxuICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSwgaW50ZXJwb2xhdGUpIHtcbiAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbZW5kcy5sZW5ndGggLSAxXSwgc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSk7XG4gIH1cbiAgbGV0IGNvb3JkaW5hdGU7XG4gIGlmIChtIDwgZmxhdENvb3JkaW5hdGVzW3N0cmlkZSAtIDFdKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlKSB7XG4gICAgICBjb29yZGluYXRlID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKDAsIHN0cmlkZSk7XG4gICAgICBjb29yZGluYXRlW3N0cmlkZSAtIDFdID0gbTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKGZsYXRDb29yZGluYXRlc1tmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0gPCBtKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlKSB7XG4gICAgICBjb29yZGluYXRlID0gZmxhdENvb3JkaW5hdGVzLnNsaWNlKGZsYXRDb29yZGluYXRlcy5sZW5ndGggLSBzdHJpZGUpO1xuICAgICAgY29vcmRpbmF0ZVtzdHJpZGUgLSAxXSA9IG07XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbaV07XG4gICAgaWYgKG9mZnNldCA9PSBlbmQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobSA8IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgLSAxXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChtIDw9IGZsYXRDb29yZGluYXRlc1tlbmQgLSAxXSkge1xuICAgICAgcmV0dXJuIGxpbmVTdHJpbmdDb29yZGluYXRlQXRNKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIG0sIGZhbHNlKTtcbiAgICB9XG4gICAgb2Zmc2V0ID0gZW5kO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTGluZVN0cmluZ1xuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdFBvaW50LCBtYXhTcXVhcmVkRGVsdGF9IGZyb20gJy4vZmxhdC9jbG9zZXN0LmpzJztcbmltcG9ydCB7ZGVmbGF0ZUNvb3JkaW5hdGVzfSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2luZmxhdGUuanMnO1xuaW1wb3J0IHtpbnRlcnBvbGF0ZVBvaW50LCBsaW5lU3RyaW5nQ29vcmRpbmF0ZUF0TX0gZnJvbSAnLi9mbGF0L2ludGVycG9sYXRlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVTdHJpbmd9IGZyb20gJy4vZmxhdC9pbnRlcnNlY3RzZXh0ZW50LmpzJztcbmltcG9ydCB7bGluZVN0cmluZ0xlbmd0aH0gZnJvbSAnLi9mbGF0L2xlbmd0aC5qcyc7XG5pbXBvcnQge2ZvckVhY2ggYXMgZm9yRWFjaFNlZ21lbnR9IGZyb20gJy4vZmxhdC9zZWdtZW50cy5qcyc7XG5pbXBvcnQge2RvdWdsYXNQZXVja2VyfSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIExpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBMaW5lU3RyaW5nIGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqICAgICBGb3IgaW50ZXJuYWwgdXNlLCBmbGF0IGNvb3JkaW5hdGVzIGluIGNvbWJpbmF0aW9uIHdpdGggYG9wdF9sYXlvdXRgIGFyZSBhbHNvIGFjY2VwdGVkLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZsYXRNaWRwb2ludF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdE1pZHBvaW50UmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICBpZiAob3B0X2xheW91dCAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcygvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovIChjb29yZGluYXRlcyksIG9wdF9sYXlvdXQpO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIGNvb3JkaW5hdGUgdG8gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBhcHBlbmRDb29yZGluYXRlKGNvb3JkaW5hdGUpIHtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IGNvb3JkaW5hdGUuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBjb29yZGluYXRlKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGdlb21ldHJ5LlxuICAgKiBAcmV0dXJuIHshTGluZVN0cmluZ30gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKSwgdGhpcy5sYXlvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQobWF4U3F1YXJlZERlbHRhKFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSwgMCkpO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgdGhpcy5tYXhEZWx0YV8sIGZhbHNlLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggc2VnbWVudCwgY2FsbGluZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAqIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRoYXRcbiAgICogdmFsdWUgaW1tZWRpYXRlbHkuIE90aGVyd2lzZSB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSwgaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlKTogVH0gY2FsbGJhY2sgRnVuY3Rpb25cbiAgICogICAgIGNhbGxlZCBmb3IgZWFjaCBzZWdtZW50LlxuICAgKiBAcmV0dXJuIHtUfGJvb2xlYW59IFZhbHVlLlxuICAgKiBAdGVtcGxhdGUgVCxTXG4gICAqIEBhcGlcbiAgICovXG4gIGZvckVhY2hTZWdtZW50KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZvckVhY2hTZWdtZW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZSBhdCBgbWAgdXNpbmcgbGluZWFyIGludGVycG9sYXRpb24sIG9yIGBudWxsYCBpZiBub1xuICAgKiBzdWNoIGNvb3JkaW5hdGUgZXhpc3RzLlxuICAgKlxuICAgKiBgb3B0X2V4dHJhcG9sYXRlYCBjb250cm9scyBleHRyYXBvbGF0aW9uIGJleW9uZCB0aGUgcmFuZ2Ugb2YgTXMgaW4gdGhlXG4gICAqIE11bHRpTGluZVN0cmluZy4gSWYgYG9wdF9leHRyYXBvbGF0ZWAgaXMgYHRydWVgIHRoZW4gTXMgbGVzcyB0aGFuIHRoZSBmaXJzdFxuICAgKiBNIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjb29yZGluYXRlIGFuZCBNcyBncmVhdGVyIHRoYW4gdGhlIGxhc3QgTSB3aWxsXG4gICAqIHJldHVybiB0aGUgbGFzdCBjb29yZGluYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbSBNLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfZXh0cmFwb2xhdGUgRXh0cmFwb2xhdGUuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlQXRNKG0sIG9wdF9leHRyYXBvbGF0ZSkge1xuICAgIGlmICh0aGlzLmxheW91dCAhPSBHZW9tZXRyeUxheW91dC5YWU0gJiZcbiAgICAgICAgdGhpcy5sYXlvdXQgIT0gR2VvbWV0cnlMYXlvdXQuWFlaTSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhcG9sYXRlID0gb3B0X2V4dHJhcG9sYXRlICE9PSB1bmRlZmluZWQgPyBvcHRfZXh0cmFwb2xhdGUgOiBmYWxzZTtcbiAgICByZXR1cm4gbGluZVN0cmluZ0Nvb3JkaW5hdGVBdE0odGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gQ29vcmRpbmF0ZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlcygpIHtcbiAgICByZXR1cm4gaW5mbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSBhdCB0aGUgcHJvdmlkZWQgZnJhY3Rpb24gYWxvbmcgdGhlIGxpbmVzdHJpbmcuXG4gICAqIFRoZSBgZnJhY3Rpb25gIGlzIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSwgd2hlcmUgMCBpcyB0aGUgc3RhcnQgb2YgdGhlXG4gICAqIGxpbmVzdHJpbmcgYW5kIDEgaXMgdGhlIGVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyYWN0aW9uIEZyYWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9kZXN0IE9wdGlvbmFsIGNvb3JkaW5hdGUgd2hvc2UgdmFsdWVzIHdpbGxcbiAgICogICAgIGJlIG1vZGlmaWVkLiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IGNvb3JkaW5hdGUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlIG9mIHRoZSBpbnRlcnBvbGF0ZWQgcG9pbnQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVBdChmcmFjdGlvbiwgb3B0X2Rlc3QpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgZnJhY3Rpb24sIG9wdF9kZXN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgbGluZXN0cmluZyBvbiBwcm9qZWN0ZWQgcGxhbmUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTGVuZ3RoIChvbiBwcm9qZWN0ZWQgcGxhbmUpLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdMZW5ndGgoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBtaWRwb2ludC5cbiAgICovXG4gIGdldEZsYXRNaWRwb2ludCgpIHtcbiAgICBpZiAodGhpcy5mbGF0TWlkcG9pbnRSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICB0aGlzLmZsYXRNaWRwb2ludF8gPSB0aGlzLmdldENvb3JkaW5hdGVBdCgwLjUsIHRoaXMuZmxhdE1pZHBvaW50Xyk7XG4gICAgICB0aGlzLmZsYXRNaWRwb2ludFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmxhdE1pZHBvaW50XztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0U2ltcGxpZmllZEdlb21ldHJ5SW50ZXJuYWwoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIGNvbnN0IHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGRvdWdsYXNQZXVja2VyKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgdGhpcy5zdHJpZGUsXG4gICAgICBzcXVhcmVkVG9sZXJhbmNlLCBzaW1wbGlmaWVkRmxhdENvb3JkaW5hdGVzLCAwKTtcbiAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcoc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RzTGluZVN0cmluZyhcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHRoaXMuc3RyaWRlLFxuICAgICAgZXh0ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBAcGFyYW0geyFBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtHZW9tZXRyeUxheW91dD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBMaW5lU3RyaW5nO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vTXVsdGlMaW5lU3RyaW5nXG4gKi9cbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Nsb3Nlc3RTcXVhcmVkRGlzdGFuY2VYWX0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeUxheW91dCBmcm9tICcuL0dlb21ldHJ5TGF5b3V0LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IExpbmVTdHJpbmcgZnJvbSAnLi9MaW5lU3RyaW5nLmpzJztcbmltcG9ydCBTaW1wbGVHZW9tZXRyeSBmcm9tICcuL1NpbXBsZUdlb21ldHJ5LmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdEFycmF5UG9pbnQsIGFycmF5TWF4U3F1YXJlZERlbHRhfSBmcm9tICcuL2ZsYXQvY2xvc2VzdC5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2ludGVycG9sYXRlUG9pbnQsIGxpbmVTdHJpbmdzQ29vcmRpbmF0ZUF0TX0gZnJvbSAnLi9mbGF0L2ludGVycG9sYXRlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVTdHJpbmdBcnJheX0gZnJvbSAnLi9mbGF0L2ludGVyc2VjdHNleHRlbnQuanMnO1xuaW1wb3J0IHtkb3VnbGFzUGV1Y2tlckFycmF5fSBmcm9tICcuL2ZsYXQvc2ltcGxpZnkuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIE11bHRpLWxpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBNdWx0aUxpbmVTdHJpbmcgZXh0ZW5kcyBTaW1wbGVHZW9tZXRyeSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPnxMaW5lU3RyaW5nPnxBcnJheTxudW1iZXI+fSBjb29yZGluYXRlc1xuICAgKiAgICAgQ29vcmRpbmF0ZXMgb3IgTGluZVN0cmluZyBnZW9tZXRyaWVzLiAoRm9yIGludGVybmFsIHVzZSwgZmxhdCBjb29yZGluYXRlcyBpblxuICAgKiAgICAgY29tYmluYXRpb24gd2l0aCBgb3B0X2xheW91dGAgYW5kIGBvcHRfZW5kc2AgYXJlIGFsc28gYWNjZXB0ZWQuKVxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9lbmRzIEZsYXQgY29vcmRpbmF0ZSBlbmRzIGZvciBpbnRlcm5hbCB1c2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlcywgb3B0X2xheW91dCwgb3B0X2VuZHMpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZW5kc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSAtMTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcygvKiogQHR5cGUge0FycmF5PEFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT4+fSAqLyAoY29vcmRpbmF0ZXMpLCBvcHRfbGF5b3V0KTtcbiAgICB9IGVsc2UgaWYgKG9wdF9sYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRfZW5kcykge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICAgIHRoaXMuZW5kc18gPSBvcHRfZW5kcztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxheW91dCA9IHRoaXMuZ2V0TGF5b3V0KCk7XG4gICAgICBjb25zdCBsaW5lU3RyaW5ncyA9IC8qKiBAdHlwZSB7QXJyYXk8TGluZVN0cmluZz59ICovIChjb29yZGluYXRlcyk7XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgIGNvbnN0IGVuZHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVTdHJpbmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY29uc3QgbGluZVN0cmluZyA9IGxpbmVTdHJpbmdzW2ldO1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGxheW91dCA9IGxpbmVTdHJpbmcuZ2V0TGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kKGZsYXRDb29yZGluYXRlcywgbGluZVN0cmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICAgIGVuZHMucHVzaChmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0RmxhdENvb3JkaW5hdGVzKGxheW91dCwgZmxhdENvb3JkaW5hdGVzKTtcbiAgICAgIHRoaXMuZW5kc18gPSBlbmRzO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIGxpbmVzdHJpbmcgdG8gdGhlIG11bHRpbGluZXN0cmluZy5cbiAgICogQHBhcmFtIHtMaW5lU3RyaW5nfSBsaW5lU3RyaW5nIExpbmVTdHJpbmcuXG4gICAqIEBhcGlcbiAgICovXG4gIGFwcGVuZExpbmVTdHJpbmcobGluZVN0cmluZykge1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gbGluZVN0cmluZy5nZXRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQodGhpcy5mbGF0Q29vcmRpbmF0ZXMsIGxpbmVTdHJpbmcuZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKSk7XG4gICAgfVxuICAgIHRoaXMuZW5kc18ucHVzaCh0aGlzLmZsYXRDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IU11bHRpTGluZVN0cmluZ30gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE11bHRpTGluZVN0cmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCwgdGhpcy5lbmRzXy5zbGljZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXhEZWx0YVJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMubWF4RGVsdGFfID0gTWF0aC5zcXJ0KGFycmF5TWF4U3F1YXJlZERlbHRhKFxuICAgICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIDApKTtcbiAgICAgIHRoaXMubWF4RGVsdGFSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NpZ25DbG9zZXN0QXJyYXlQb2ludChcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNfLCB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLCBmYWxzZSwgeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgYG1gIHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLCBvciBgbnVsbGAgaWYgbm9cbiAgICogc3VjaCBjb29yZGluYXRlIGV4aXN0cy5cbiAgICpcbiAgICogYG9wdF9leHRyYXBvbGF0ZWAgY29udHJvbHMgZXh0cmFwb2xhdGlvbiBiZXlvbmQgdGhlIHJhbmdlIG9mIE1zIGluIHRoZVxuICAgKiBNdWx0aUxpbmVTdHJpbmcuIElmIGBvcHRfZXh0cmFwb2xhdGVgIGlzIGB0cnVlYCB0aGVuIE1zIGxlc3MgdGhhbiB0aGUgZmlyc3RcbiAgICogTSB3aWxsIHJldHVybiB0aGUgZmlyc3QgY29vcmRpbmF0ZSBhbmQgTXMgZ3JlYXRlciB0aGFuIHRoZSBsYXN0IE0gd2lsbFxuICAgKiByZXR1cm4gdGhlIGxhc3QgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogYG9wdF9pbnRlcnBvbGF0ZWAgY29udHJvbHMgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGNvbnNlY3V0aXZlIExpbmVTdHJpbmdzXG4gICAqIHdpdGhpbiB0aGUgTXVsdGlMaW5lU3RyaW5nLiBJZiBgb3B0X2ludGVycG9sYXRlYCBpcyBgdHJ1ZWAgdGhlIGNvb3JkaW5hdGVzXG4gICAqIHdpbGwgYmUgbGluZWFybHkgaW50ZXJwb2xhdGVkIGJldHdlZW4gdGhlIGxhc3QgY29vcmRpbmF0ZSBvZiBvbmUgTGluZVN0cmluZ1xuICAgKiBhbmQgdGhlIGZpcnN0IGNvb3JkaW5hdGUgb2YgdGhlIG5leHQgTGluZVN0cmluZy4gIElmIGBvcHRfaW50ZXJwb2xhdGVgIGlzXG4gICAqIGBmYWxzZWAgdGhlbiB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gYG51bGxgIGZvciBNcyBmYWxsaW5nIGJldHdlZW5cbiAgICogTGluZVN0cmluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtIE0uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9leHRyYXBvbGF0ZSBFeHRyYXBvbGF0ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaW50ZXJwb2xhdGUgSW50ZXJwb2xhdGUuIERlZmF1bHQgaXMgYGZhbHNlYC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBDb29yZGluYXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlQXRNKG0sIG9wdF9leHRyYXBvbGF0ZSwgb3B0X2ludGVycG9sYXRlKSB7XG4gICAgaWYgKCh0aGlzLmxheW91dCAhPSBHZW9tZXRyeUxheW91dC5YWU0gJiZcbiAgICAgICAgIHRoaXMubGF5b3V0ICE9IEdlb21ldHJ5TGF5b3V0LlhZWk0pIHx8XG4gICAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhcG9sYXRlID0gb3B0X2V4dHJhcG9sYXRlICE9PSB1bmRlZmluZWQgPyBvcHRfZXh0cmFwb2xhdGUgOiBmYWxzZTtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZSA9IG9wdF9pbnRlcnBvbGF0ZSAhPT0gdW5kZWZpbmVkID8gb3B0X2ludGVycG9sYXRlIDogZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVTdHJpbmdzQ29vcmRpbmF0ZUF0TSh0aGlzLmZsYXRDb29yZGluYXRlcywgMCxcbiAgICAgIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBtLCBleHRyYXBvbGF0ZSwgaW50ZXJwb2xhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj59IENvb3JkaW5hdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZXMoKSB7XG4gICAgcmV0dXJuIGluZmxhdGVDb29yZGluYXRlc0FycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBFbmRzLlxuICAgKi9cbiAgZ2V0RW5kcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpbmVzdHJpbmcgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4LlxuICAgKiBAcmV0dXJuIHtMaW5lU3RyaW5nfSBMaW5lU3RyaW5nLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lU3RyaW5nKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLmVuZHNfLmxlbmd0aCA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGluZVN0cmluZyh0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZShcbiAgICAgIGluZGV4ID09PSAwID8gMCA6IHRoaXMuZW5kc19baW5kZXggLSAxXSwgdGhpcy5lbmRzX1tpbmRleF0pLCB0aGlzLmxheW91dCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaW5lc3RyaW5ncyBvZiB0aGlzIG11bHRpbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7QXJyYXk8TGluZVN0cmluZz59IExpbmVTdHJpbmdzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRMaW5lU3RyaW5ncygpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBlbmRzID0gdGhpcy5lbmRzXztcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAvKiogQHR5cGUge0FycmF5PExpbmVTdHJpbmc+fSAqL1xuICAgIGNvbnN0IGxpbmVTdHJpbmdzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgICAgY29uc3QgbGluZVN0cmluZyA9IG5ldyBMaW5lU3RyaW5nKGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIGVuZCksIGxheW91dCk7XG4gICAgICBsaW5lU3RyaW5ncy5wdXNoKGxpbmVTdHJpbmcpO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gbGluZVN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRmxhdCBtaWRwb2ludHMuXG4gICAqL1xuICBnZXRGbGF0TWlkcG9pbnRzKCkge1xuICAgIGNvbnN0IG1pZHBvaW50cyA9IFtdO1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGVuZHMgPSB0aGlzLmVuZHNfO1xuICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICAgIGNvbnN0IG1pZHBvaW50ID0gaW50ZXJwb2xhdGVQb2ludChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCAwLjUpO1xuICAgICAgZXh0ZW5kKG1pZHBvaW50cywgbWlkcG9pbnQpO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gbWlkcG9pbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzID0gW107XG4gICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcy5sZW5ndGggPSBkb3VnbGFzUGV1Y2tlckFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc18sIHRoaXMuc3RyaWRlLCBzcXVhcmVkVG9sZXJhbmNlLFxuICAgICAgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgMCwgc2ltcGxpZmllZEVuZHMpO1xuICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIEdlb21ldHJ5TGF5b3V0LlhZLCBzaW1wbGlmaWVkRW5kcyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdHNMaW5lU3RyaW5nQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5lbmRzXywgdGhpcy5zdHJpZGUsIGV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbXVsdGlsaW5lc3RyaW5nLlxuICAgKiBAcGFyYW0geyFBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlMYXlvdXQ9fSBvcHRfbGF5b3V0IExheW91dC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENvb3JkaW5hdGVzKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0KSB7XG4gICAgdGhpcy5zZXRMYXlvdXQob3B0X2xheW91dCwgY29vcmRpbmF0ZXMsIDIpO1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgfVxuICAgIGNvbnN0IGVuZHMgPSBkZWZsYXRlQ29vcmRpbmF0ZXNBcnJheShcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgdGhpcy5zdHJpZGUsIHRoaXMuZW5kc18pO1xuICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGVuZHMubGVuZ3RoID09PSAwID8gMCA6IGVuZHNbZW5kcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE11bHRpTGluZVN0cmluZztcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL011bHRpUG9pbnRcbiAqL1xuaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCB7Y2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZLCBjb250YWluc1hZfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQgUG9pbnQgZnJvbSAnLi9Qb2ludC5qcyc7XG5pbXBvcnQgU2ltcGxlR2VvbWV0cnkgZnJvbSAnLi9TaW1wbGVHZW9tZXRyeS5qcyc7XG5pbXBvcnQge2RlZmxhdGVDb29yZGluYXRlc30gZnJvbSAnLi9mbGF0L2RlZmxhdGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXN9IGZyb20gJy4vZmxhdC9pbmZsYXRlLmpzJztcbmltcG9ydCB7c3F1YXJlZERpc3RhbmNlIGFzIHNxdWFyZWREeH0gZnJvbSAnLi4vbWF0aC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTXVsdGktcG9pbnQgZ2VvbWV0cnkuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBNdWx0aVBvaW50IGV4dGVuZHMgU2ltcGxlR2VvbWV0cnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXMuXG4gICAqICAgICBGb3IgaW50ZXJuYWwgdXNlLCBmbGF0IGNvb3JkaW5hdGVzIGluIGNvbWJpbmF0aW9uIHdpdGggYG9wdF9sYXlvdXRgIGFyZSBhbHNvIGFjY2VwdGVkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnlMYXlvdXQuanNcIikuZGVmYXVsdD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChvcHRfbGF5b3V0ICYmICFBcnJheS5pc0FycmF5KGNvb3JkaW5hdGVzWzBdKSkge1xuICAgICAgdGhpcy5zZXRGbGF0Q29vcmRpbmF0ZXMob3B0X2xheW91dCwgLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoY29vcmRpbmF0ZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb29yZGluYXRlcygvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59ICovIChjb29yZGluYXRlcyksIG9wdF9sYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIHBhc3NlZCBwb2ludCB0byB0aGlzIG11bHRpcG9pbnQuXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFBvaW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBhcHBlbmRQb2ludChwb2ludCkge1xuICAgIGlmICghdGhpcy5mbGF0Q29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzID0gcG9pbnQuZ2V0RmxhdENvb3JkaW5hdGVzKCkuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBwb2ludC5nZXRGbGF0Q29vcmRpbmF0ZXMoKSk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IU11bHRpUG9pbnR9IENsb25lLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbXVsdGlQb2ludCA9IG5ldyBNdWx0aVBvaW50KHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKCksIHRoaXMubGF5b3V0KTtcbiAgICByZXR1cm4gbXVsdGlQb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgY2xvc2VzdFBvaW50WFkoeCwgeSwgY2xvc2VzdFBvaW50LCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgY2xvc2VzdFNxdWFyZWREaXN0YW5jZVhZKHRoaXMuZ2V0RXh0ZW50KCksIHgsIHkpKSB7XG4gICAgICByZXR1cm4gbWluU3F1YXJlZERpc3RhbmNlO1xuICAgIH1cbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCBzcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRHgoXG4gICAgICAgIHgsIHksIGZsYXRDb29yZGluYXRlc1tpXSwgZmxhdENvb3JkaW5hdGVzW2kgKyAxXSk7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHJpZGU7ICsraikge1xuICAgICAgICAgIGNsb3Nlc3RQb2ludFtqXSA9IGZsYXRDb29yZGluYXRlc1tpICsgal07XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VzdFBvaW50Lmxlbmd0aCA9IHN0cmlkZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pblNxdWFyZWREaXN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBtdWx0aXBvaW50LlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSBDb29yZGluYXRlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvb3JkaW5hdGVzKCkge1xuICAgIHJldHVybiBpbmZsYXRlQ29vcmRpbmF0ZXMoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCB0aGlzLnN0cmlkZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwb2ludCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXguXG4gICAqIEByZXR1cm4ge1BvaW50fSBQb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9pbnQoaW5kZXgpIHtcbiAgICBjb25zdCBuID0gIXRoaXMuZmxhdENvb3JkaW5hdGVzID8gMCA6IHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCAvIHRoaXMuc3RyaWRlO1xuICAgIGlmIChpbmRleCA8IDAgfHwgbiA8PSBpbmRleCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5mbGF0Q29vcmRpbmF0ZXMuc2xpY2UoXG4gICAgICBpbmRleCAqIHRoaXMuc3RyaWRlLCAoaW5kZXggKyAxKSAqIHRoaXMuc3RyaWRlKSwgdGhpcy5sYXlvdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcG9pbnRzIG9mIHRoaXMgbXVsdGlwb2ludC5cbiAgICogQHJldHVybiB7QXJyYXk8UG9pbnQ+fSBQb2ludHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvaW50cygpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSB0aGlzLmZsYXRDb29yZGluYXRlcztcbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICBjb25zdCBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAvKiogQHR5cGUge0FycmF5PFBvaW50Pn0gKi9cbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludChmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoaSwgaSArIHN0cmlkZSksIGxheW91dCk7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIGludGVyc2VjdHNFeHRlbnQoZXh0ZW50KSB7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IHN0cmlkZSkge1xuICAgICAgY29uc3QgeCA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIGNvbnN0IHkgPSBmbGF0Q29vcmRpbmF0ZXNbaSArIDFdO1xuICAgICAgaWYgKGNvbnRhaW5zWFkoZXh0ZW50LCB4LCB5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG11bHRpcG9pbnQuXG4gICAqIEBwYXJhbSB7IUFycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vR2VvbWV0cnlMYXlvdXQuanNcIikuZGVmYXVsdD19IG9wdF9sYXlvdXQgTGF5b3V0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Q29vcmRpbmF0ZXMoY29vcmRpbmF0ZXMsIG9wdF9sYXlvdXQpIHtcbiAgICB0aGlzLnNldExheW91dChvcHRfbGF5b3V0LCBjb29yZGluYXRlcywgMSk7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gZGVmbGF0ZUNvb3JkaW5hdGVzKFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCB0aGlzLnN0cmlkZSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aVBvaW50O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9jZW50ZXJcbiAqL1xuaW1wb3J0IHtjcmVhdGVFbXB0eSwgY3JlYXRlT3JVcGRhdGVGcm9tRmxhdENvb3JkaW5hdGVzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IEZsYXQgY2VudGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclJpbmdzcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3MsIHN0cmlkZSkge1xuICBjb25zdCBmbGF0Q2VudGVycyA9IFtdO1xuICBsZXQgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBleHRlbnQgPSBjcmVhdGVPclVwZGF0ZUZyb21GbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbMF0sIHN0cmlkZSk7XG4gICAgZmxhdENlbnRlcnMucHVzaCgoZXh0ZW50WzBdICsgZXh0ZW50WzJdKSAvIDIsIChleHRlbnRbMV0gKyBleHRlbnRbM10pIC8gMik7XG4gICAgb2Zmc2V0ID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBmbGF0Q2VudGVycztcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL011bHRpUG9seWdvblxuICovXG5pbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFl9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlMYXlvdXQgZnJvbSAnLi9HZW9tZXRyeUxheW91dC5qcyc7XG5pbXBvcnQgR2VvbWV0cnlUeXBlIGZyb20gJy4vR2VvbWV0cnlUeXBlLmpzJztcbmltcG9ydCBNdWx0aVBvaW50IGZyb20gJy4vTXVsdGlQb2ludC5qcyc7XG5pbXBvcnQgUG9seWdvbiBmcm9tICcuL1BvbHlnb24uanMnO1xuaW1wb3J0IFNpbXBsZUdlb21ldHJ5IGZyb20gJy4vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc3MgYXMgbGluZWFyUmluZ3NzQXJlYX0gZnJvbSAnLi9mbGF0L2FyZWEuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc3MgYXMgbGluZWFyUmluZ3NzQ2VudGVyfSBmcm9tICcuL2ZsYXQvY2VudGVyLmpzJztcbmltcG9ydCB7YXNzaWduQ2xvc2VzdE11bHRpQXJyYXlQb2ludCwgbXVsdGlBcnJheU1heFNxdWFyZWREZWx0YX0gZnJvbSAnLi9mbGF0L2Nsb3Nlc3QuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc3NDb250YWluc1hZfSBmcm9tICcuL2ZsYXQvY29udGFpbnMuanMnO1xuaW1wb3J0IHtkZWZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5fSBmcm9tICcuL2ZsYXQvZGVmbGF0ZS5qcyc7XG5pbXBvcnQge2luZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXl9IGZyb20gJy4vZmxhdC9pbmZsYXRlLmpzJztcbmltcG9ydCB7Z2V0SW50ZXJpb3JQb2ludHNPZk11bHRpQXJyYXl9IGZyb20gJy4vZmxhdC9pbnRlcmlvcnBvaW50LmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c0xpbmVhclJpbmdNdWx0aUFycmF5fSBmcm9tICcuL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyc7XG5pbXBvcnQge2xpbmVhclJpbmdzQXJlT3JpZW50ZWQsIG9yaWVudExpbmVhclJpbmdzQXJyYXl9IGZyb20gJy4vZmxhdC9vcmllbnQuanMnO1xuaW1wb3J0IHtxdWFudGl6ZU11bHRpQXJyYXl9IGZyb20gJy4vZmxhdC9zaW1wbGlmeS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTXVsdGktcG9seWdvbiBnZW9tZXRyeS5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIE11bHRpUG9seWdvbiBleHRlbmRzIFNpbXBsZUdlb21ldHJ5IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+PnxQb2x5Z29uPnxBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBDb29yZGluYXRlcy5cbiAgICogICAgIEZvciBpbnRlcm5hbCB1c2UsIGZsYXQgY29vcmRpbmF0ZXMgaW4gY29tYmluYXRpb24gd2l0aCBgb3B0X2xheW91dGAgYW5kIGBvcHRfZW5kc3NgIGFyZSBhbHNvIGFjY2VwdGVkLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj49fSBvcHRfZW5kc3MgQXJyYXkgb2YgZW5kcyBmb3IgaW50ZXJuYWwgdXNlIHdpdGggZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGVzLCBvcHRfbGF5b3V0LCBvcHRfZW5kc3MpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmVuZHNzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhEZWx0YV8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heERlbHRhUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5vcmllbnRlZFJldmlzaW9uXyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWVudGVkRmxhdENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICBpZiAoIW9wdF9lbmRzcyAmJiAhQXJyYXkuaXNBcnJheShjb29yZGluYXRlc1swXSkpIHtcbiAgICAgIGxldCBsYXlvdXQgPSB0aGlzLmdldExheW91dCgpO1xuICAgICAgY29uc3QgcG9seWdvbnMgPSAvKiogQHR5cGUge0FycmF5PFBvbHlnb24+fSAqLyAoY29vcmRpbmF0ZXMpO1xuICAgICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gW107XG4gICAgICBjb25zdCBlbmRzcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb25zdCBwb2x5Z29uID0gcG9seWdvbnNbaV07XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgbGF5b3V0ID0gcG9seWdvbi5nZXRMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbmRzID0gcG9seWdvbi5nZXRFbmRzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGVuZHMubGVuZ3RoOyBqIDwgamo7ICsraikge1xuICAgICAgICAgIGVuZHNbal0gKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuZChmbGF0Q29vcmRpbmF0ZXMsIHBvbHlnb24uZ2V0RmxhdENvb3JkaW5hdGVzKCkpO1xuICAgICAgICBlbmRzcy5wdXNoKGVuZHMpO1xuICAgICAgfVxuICAgICAgb3B0X2xheW91dCA9IGxheW91dDtcbiAgICAgIGNvb3JkaW5hdGVzID0gZmxhdENvb3JkaW5hdGVzO1xuICAgICAgb3B0X2VuZHNzID0gZW5kc3M7XG4gICAgfVxuICAgIGlmIChvcHRfbGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0X2VuZHNzKSB7XG4gICAgICB0aGlzLnNldEZsYXRDb29yZGluYXRlcyhvcHRfbGF5b3V0LCAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovIChjb29yZGluYXRlcykpO1xuICAgICAgdGhpcy5lbmRzc18gPSBvcHRfZW5kc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMoLyoqIEB0eXBlIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59ICovIChjb29yZGluYXRlcyksXG4gICAgICAgIG9wdF9sYXlvdXQpO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCB0aGUgcGFzc2VkIHBvbHlnb24gdG8gdGhpcyBtdWx0aXBvbHlnb24uXG4gICAqIEBwYXJhbSB7UG9seWdvbn0gcG9seWdvbiBQb2x5Z29uLlxuICAgKiBAYXBpXG4gICAqL1xuICBhcHBlbmRQb2x5Z29uKHBvbHlnb24pIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgbGV0IGVuZHM7XG4gICAgaWYgKCF0aGlzLmZsYXRDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMgPSBwb2x5Z29uLmdldEZsYXRDb29yZGluYXRlcygpLnNsaWNlKCk7XG4gICAgICBlbmRzID0gcG9seWdvbi5nZXRFbmRzKCkuc2xpY2UoKTtcbiAgICAgIHRoaXMuZW5kc3NfLnB1c2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgZXh0ZW5kKHRoaXMuZmxhdENvb3JkaW5hdGVzLCBwb2x5Z29uLmdldEZsYXRDb29yZGluYXRlcygpKTtcbiAgICAgIGVuZHMgPSBwb2x5Z29uLmdldEVuZHMoKS5zbGljZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGVuZHNbaV0gKz0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVuZHNzXy5wdXNoKGVuZHMpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQHJldHVybiB7IU11bHRpUG9seWdvbn0gQ2xvbmUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmVuZHNzXy5sZW5ndGg7XG4gICAgY29uc3QgbmV3RW5kc3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBuZXdFbmRzc1tpXSA9IHRoaXMuZW5kc3NfW2ldLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24oXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcy5zbGljZSgpLCB0aGlzLmxheW91dCwgbmV3RW5kc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIGlmIChtaW5TcXVhcmVkRGlzdGFuY2UgPCBjbG9zZXN0U3F1YXJlZERpc3RhbmNlWFkodGhpcy5nZXRFeHRlbnQoKSwgeCwgeSkpIHtcbiAgICAgIHJldHVybiBtaW5TcXVhcmVkRGlzdGFuY2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm1heERlbHRhUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgdGhpcy5tYXhEZWx0YV8gPSBNYXRoLnNxcnQobXVsdGlBcnJheU1heFNxdWFyZWREZWx0YShcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSwgMCkpO1xuICAgICAgdGhpcy5tYXhEZWx0YVJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc2lnbkNsb3Nlc3RNdWx0aUFycmF5UG9pbnQoXG4gICAgICB0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSxcbiAgICAgIHRoaXMubWF4RGVsdGFfLCB0cnVlLCB4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xuICAgIHJldHVybiBsaW5lYXJSaW5nc3NDb250YWluc1hZKHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSwgMCwgdGhpcy5lbmRzc18sIHRoaXMuc3RyaWRlLCB4LCB5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGFyZWEgb2YgdGhlIG11bHRpcG9seWdvbiBvbiBwcm9qZWN0ZWQgcGxhbmUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQXJlYSAob24gcHJvamVjdGVkIHBsYW5lKS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QXJlYSgpIHtcbiAgICByZXR1cm4gbGluZWFyUmluZ3NzQXJlYSh0aGlzLmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb29yZGluYXRlIGFycmF5IGZvciB0aGlzIGdlb21ldHJ5LiAgVGhpcyBhcnJheSBoYXMgdGhlIHN0cnVjdHVyZVxuICAgKiBvZiBhIEdlb0pTT04gY29vcmRpbmF0ZSBhcnJheSBmb3IgbXVsdGktcG9seWdvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9yaWdodCBPcmllbnQgY29vcmRpbmF0ZXMgYWNjb3JkaW5nIHRvIHRoZSByaWdodC1oYW5kXG4gICAqICAgICBydWxlIChjb3VudGVyLWNsb2Nrd2lzZSBmb3IgZXh0ZXJpb3IgYW5kIGNsb2Nrd2lzZSBmb3IgaW50ZXJpb3IgcmluZ3MpLlxuICAgKiAgICAgSWYgYGZhbHNlYCwgY29vcmRpbmF0ZXMgd2lsbCBiZSBvcmllbnRlZCBhY2NvcmRpbmcgdG8gdGhlIGxlZnQtaGFuZCBydWxlXG4gICAqICAgICAoY2xvY2t3aXNlIGZvciBleHRlcmlvciBhbmQgY291bnRlci1jbG9ja3dpc2UgZm9yIGludGVyaW9yIHJpbmdzKS5cbiAgICogICAgIEJ5IGRlZmF1bHQsIGNvb3JkaW5hdGUgb3JpZW50YXRpb24gd2lsbCBkZXBlbmQgb24gaG93IHRoZSBnZW9tZXRyeSB3YXNcbiAgICogICAgIGNvbnN0cnVjdGVkLlxuICAgKiBAcmV0dXJuIHtBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59IENvb3JkaW5hdGVzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q29vcmRpbmF0ZXMob3B0X3JpZ2h0KSB7XG4gICAgbGV0IGZsYXRDb29yZGluYXRlcztcbiAgICBpZiAob3B0X3JpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKS5zbGljZSgpO1xuICAgICAgb3JpZW50TGluZWFyUmluZ3NBcnJheShcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsIG9wdF9yaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9IHRoaXMuZmxhdENvb3JkaW5hdGVzO1xuICAgIH1cblxuICAgIHJldHVybiBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5KFxuICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEFycmF5PG51bWJlcj4+fSBFbmRzcy5cbiAgICovXG4gIGdldEVuZHNzKCkge1xuICAgIHJldHVybiB0aGlzLmVuZHNzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBGbGF0IGludGVyaW9yIHBvaW50cy5cbiAgICovXG4gIGdldEZsYXRJbnRlcmlvclBvaW50cygpIHtcbiAgICBpZiAodGhpcy5mbGF0SW50ZXJpb3JQb2ludHNSZXZpc2lvbl8gIT0gdGhpcy5nZXRSZXZpc2lvbigpKSB7XG4gICAgICBjb25zdCBmbGF0Q2VudGVycyA9IGxpbmVhclJpbmdzc0NlbnRlcihcbiAgICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSk7XG4gICAgICB0aGlzLmZsYXRJbnRlcmlvclBvaW50c18gPSBnZXRJbnRlcmlvclBvaW50c09mTXVsdGlBcnJheShcbiAgICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsXG4gICAgICAgIGZsYXRDZW50ZXJzKTtcbiAgICAgIHRoaXMuZmxhdEludGVyaW9yUG9pbnRzUmV2aXNpb25fID0gdGhpcy5nZXRSZXZpc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbGF0SW50ZXJpb3JQb2ludHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaW50ZXJpb3IgcG9pbnRzIGFzIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9NdWx0aVBvaW50IG11bHRpcG9pbnR9LlxuICAgKiBAcmV0dXJuIHtNdWx0aVBvaW50fSBJbnRlcmlvciBwb2ludHMgYXMgWFlNIGNvb3JkaW5hdGVzLCB3aGVyZSBNIGlzXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEludGVyaW9yUG9pbnRzKCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2ludCh0aGlzLmdldEZsYXRJbnRlcmlvclBvaW50cygpLnNsaWNlKCksIEdlb21ldHJ5TGF5b3V0LlhZTSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gT3JpZW50ZWQgZmxhdCBjb29yZGluYXRlcy5cbiAgICovXG4gIGdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCkge1xuICAgIGlmICh0aGlzLm9yaWVudGVkUmV2aXNpb25fICE9IHRoaXMuZ2V0UmV2aXNpb24oKSkge1xuICAgICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgICBpZiAobGluZWFyUmluZ3NBcmVPcmllbnRlZChcbiAgICAgICAgZmxhdENvb3JkaW5hdGVzLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUpKSB7XG4gICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfID0gZmxhdENvb3JkaW5hdGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18gPSBmbGF0Q29vcmRpbmF0ZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5vcmllbnRlZEZsYXRDb29yZGluYXRlc18ubGVuZ3RoID1cbiAgICAgICAgICAgIG9yaWVudExpbmVhclJpbmdzQXJyYXkoXG4gICAgICAgICAgICAgIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcmllbnRlZFJldmlzaW9uXyA9IHRoaXMuZ2V0UmV2aXNpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnlJbnRlcm5hbChzcXVhcmVkVG9sZXJhbmNlKSB7XG4gICAgY29uc3Qgc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIGNvbnN0IHNpbXBsaWZpZWRFbmRzcyA9IFtdO1xuICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gcXVhbnRpemVNdWx0aUFycmF5KFxuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMsIDAsIHRoaXMuZW5kc3NfLCB0aGlzLnN0cmlkZSxcbiAgICAgIE1hdGguc3FydChzcXVhcmVkVG9sZXJhbmNlKSxcbiAgICAgIHNpbXBsaWZpZWRGbGF0Q29vcmRpbmF0ZXMsIDAsIHNpbXBsaWZpZWRFbmRzcyk7XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24oc2ltcGxpZmllZEZsYXRDb29yZGluYXRlcywgR2VvbWV0cnlMYXlvdXQuWFksIHNpbXBsaWZpZWRFbmRzcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwb2x5Z29uIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleC5cbiAgICogQHJldHVybiB7UG9seWdvbn0gUG9seWdvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9seWdvbihpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgdGhpcy5lbmRzc18ubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IG9mZnNldDtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZFbmRzID0gdGhpcy5lbmRzc19baW5kZXggLSAxXTtcbiAgICAgIG9mZnNldCA9IHByZXZFbmRzW3ByZXZFbmRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBlbmRzID0gdGhpcy5lbmRzc19baW5kZXhdLnNsaWNlKCk7XG4gICAgY29uc3QgZW5kID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChvZmZzZXQgIT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBlbmRzW2ldIC09IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHRoaXMuZmxhdENvb3JkaW5hdGVzLnNsaWNlKG9mZnNldCwgZW5kKSwgdGhpcy5sYXlvdXQsIGVuZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcG9seWdvbnMgb2YgdGhpcyBtdWx0aXBvbHlnb24uXG4gICAqIEByZXR1cm4ge0FycmF5PFBvbHlnb24+fSBQb2x5Z29ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9seWdvbnMoKSB7XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gdGhpcy5mbGF0Q29vcmRpbmF0ZXM7XG4gICAgY29uc3QgZW5kc3MgPSB0aGlzLmVuZHNzXztcbiAgICBjb25zdCBwb2x5Z29ucyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGVuZHNzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXS5zbGljZSgpO1xuICAgICAgY29uc3QgZW5kID0gZW5kc1tlbmRzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgamogPSBlbmRzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICBlbmRzW2pdIC09IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcG9seWdvbiA9IG5ldyBQb2x5Z29uKGZsYXRDb29yZGluYXRlcy5zbGljZShvZmZzZXQsIGVuZCksIGxheW91dCwgZW5kcyk7XG4gICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbiAgICByZXR1cm4gcG9seWdvbnM7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT047XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0V4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0c0xpbmVhclJpbmdNdWx0aUFycmF5KFxuICAgICAgdGhpcy5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpLCAwLCB0aGlzLmVuZHNzXywgdGhpcy5zdHJpZGUsIGV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbXVsdGlwb2x5Z29uLlxuICAgKiBAcGFyYW0geyFBcnJheTxBcnJheTxBcnJheTxpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+Pj59IGNvb3JkaW5hdGVzIENvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5TGF5b3V0PX0gb3B0X2xheW91dCBMYXlvdXQuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRDb29yZGluYXRlcyhjb29yZGluYXRlcywgb3B0X2xheW91dCkge1xuICAgIHRoaXMuc2V0TGF5b3V0KG9wdF9sYXlvdXQsIGNvb3JkaW5hdGVzLCAzKTtcbiAgICBpZiAoIXRoaXMuZmxhdENvb3JkaW5hdGVzKSB7XG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBlbmRzcyA9IGRlZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXkoXG4gICAgICB0aGlzLmZsYXRDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIHRoaXMuc3RyaWRlLCB0aGlzLmVuZHNzXyk7XG4gICAgaWYgKGVuZHNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5mbGF0Q29vcmRpbmF0ZXMubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdEVuZHMgPSBlbmRzc1tlbmRzcy5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMuZmxhdENvb3JkaW5hdGVzLmxlbmd0aCA9IGxhc3RFbmRzLmxlbmd0aCA9PT0gMCA/XG4gICAgICAgIDAgOiBsYXN0RW5kc1tsYXN0RW5kcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBNdWx0aVBvbHlnb247XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvZm9ybWF0L0dlb0pTT05cbiAqL1xuXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQgRmVhdHVyZSBmcm9tICcuLi9GZWF0dXJlLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtV2l0aE9wdGlvbnN9IGZyb20gJy4vRmVhdHVyZS5qcyc7XG5pbXBvcnQgSlNPTkZlYXR1cmUgZnJvbSAnLi9KU09ORmVhdHVyZS5qcyc7XG5pbXBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGZyb20gJy4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzJztcbmltcG9ydCBMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTGluZVN0cmluZy5qcyc7XG5pbXBvcnQgTXVsdGlMaW5lU3RyaW5nIGZyb20gJy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzJztcbmltcG9ydCBNdWx0aVBvaW50IGZyb20gJy4uL2dlb20vTXVsdGlQb2ludC5qcyc7XG5pbXBvcnQgTXVsdGlQb2x5Z29uIGZyb20gJy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzJztcbmltcG9ydCBQb2ludCBmcm9tICcuLi9nZW9tL1BvaW50LmpzJztcbmltcG9ydCBQb2x5Z29uIGZyb20gJy4uL2dlb20vUG9seWdvbi5qcyc7XG5pbXBvcnQge2Fzc2lnbiwgaXNFbXB0eX0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IEdlb21ldHJ5VHlwZSBmcm9tICcuLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydChcImdlb2pzb25cIikuR2VvSlNPTn0gR2VvSlNPTk9iamVjdFxuICogQHR5cGVkZWYge2ltcG9ydChcImdlb2pzb25cIikuRmVhdHVyZX0gR2VvSlNPTkZlYXR1cmVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLkZlYXR1cmVDb2xsZWN0aW9ufSBHZW9KU09ORmVhdHVyZUNvbGxlY3Rpb25cbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLkdlb21ldHJ5fSBHZW9KU09OR2VvbWV0cnlcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLlBvaW50fSBHZW9KU09OUG9pbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLkxpbmVTdHJpbmd9IEdlb0pTT05MaW5lU3RyaW5nXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiZ2VvanNvblwiKS5Qb2x5Z29ufSBHZW9KU09OUG9seWdvblxuICogQHR5cGVkZWYge2ltcG9ydChcImdlb2pzb25cIikuTXVsdGlQb2ludH0gR2VvSlNPTk11bHRpUG9pbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoXCJnZW9qc29uXCIpLk11bHRpTGluZVN0cmluZ30gR2VvSlNPTk11bHRpTGluZVN0cmluZ1xuICogQHR5cGVkZWYge2ltcG9ydChcImdlb2pzb25cIikuTXVsdGlQb2x5Z29ufSBHZW9KU09OTXVsdGlQb2x5Z29uXG4gKiBAdHlwZWRlZiB7aW1wb3J0KFwiZ2VvanNvblwiKS5HZW9tZXRyeUNvbGxlY3Rpb259IEdlb0pTT05HZW9tZXRyeUNvbGxlY3Rpb25cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbZGF0YVByb2plY3Rpb249J0VQU0c6NDMyNiddIERlZmF1bHQgZGF0YSBwcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbZmVhdHVyZVByb2plY3Rpb25dIFByb2plY3Rpb24gZm9yIGZlYXR1cmVzIHJlYWQgb3JcbiAqIHdyaXR0ZW4gYnkgdGhlIGZvcm1hdC4gIE9wdGlvbnMgcGFzc2VkIHRvIHJlYWQgb3Igd3JpdGUgbWV0aG9kcyB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2VvbWV0cnlOYW1lXSBHZW9tZXRyeSBuYW1lIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGZlYXR1cmVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZXh0cmFjdEdlb21ldHJ5TmFtZT1mYWxzZV0gQ2VydGFpbiBHZW9KU09OIHByb3ZpZGVycyBpbmNsdWRlXG4gKiB0aGUgZ2VvbWV0cnlfbmFtZSBmaWVsZCBpbiB0aGUgZmVhdHVyZSBHZW9KU09OLiBJZiBzZXQgdG8gYHRydWVgIHRoZSBHZW9KU09OIHJlYWRlclxuICogd2lsbCBsb29rIGZvciB0aGF0IGZpZWxkIHRvIHNldCB0aGUgZ2VvbWV0cnkgbmFtZS4gSWYgYm90aCB0aGlzIGZpZWxkIGlzIHNldCB0byBgdHJ1ZWBcbiAqIGFuZCBhIGBnZW9tZXRyeU5hbWVgIGlzIHByb3ZpZGVkLCB0aGUgYGdlb21ldHJ5TmFtZWAgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZlYXR1cmUgZm9ybWF0IGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGRhdGEgaW4gdGhlIEdlb0pTT04gZm9ybWF0LlxuICpcbiAgKiBAYXBpXG4gKi9cbmNsYXNzIEdlb0pTT04gZXh0ZW5kcyBKU09ORmVhdHVyZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIHRoaXMuZGF0YVByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKFxuICAgICAgb3B0aW9ucy5kYXRhUHJvamVjdGlvbiA/XG4gICAgICAgIG9wdGlvbnMuZGF0YVByb2plY3Rpb24gOiAnRVBTRzo0MzI2Jyk7XG5cbiAgICBpZiAob3B0aW9ucy5mZWF0dXJlUHJvamVjdGlvbikge1xuICAgICAgdGhpcy5kZWZhdWx0RmVhdHVyZVByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKG9wdGlvbnMuZmVhdHVyZVByb2plY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGdlb21ldHJ5IGF0dHJpYnV0ZSBmb3IgZmVhdHVyZXMuXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmdlb21ldHJ5TmFtZV8gPSBvcHRpb25zLmdlb21ldHJ5TmFtZTtcblxuICAgIC8qKlxuICAgICAqIExvb2sgZm9yIHRoZSBnZW9tZXRyeSBuYW1lIGluIHRoZSBmZWF0dXJlIEdlb0pTT05cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmV4dHJhY3RHZW9tZXRyeU5hbWVfID0gb3B0aW9ucy5leHRyYWN0R2VvbWV0cnlOYW1lO1xuXG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHJlYWRGZWF0dXJlRnJvbU9iamVjdChvYmplY3QsIG9wdF9vcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0dlb0pTT05GZWF0dXJlfVxuICAgICAqL1xuICAgIGxldCBnZW9KU09ORmVhdHVyZSA9IG51bGw7XG4gICAgaWYgKG9iamVjdFsndHlwZSddID09PSAnRmVhdHVyZScpIHtcbiAgICAgIGdlb0pTT05GZWF0dXJlID0gLyoqIEB0eXBlIHtHZW9KU09ORmVhdHVyZX0gKi8gKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb0pTT05GZWF0dXJlID0ge1xuICAgICAgICAndHlwZSc6ICdGZWF0dXJlJyxcbiAgICAgICAgJ2dlb21ldHJ5JzogLyoqIEB0eXBlIHtHZW9KU09OR2VvbWV0cnl9ICovIChvYmplY3QpLFxuICAgICAgICAncHJvcGVydGllcyc6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZ2VvbWV0cnkgPSByZWFkR2VvbWV0cnkoZ2VvSlNPTkZlYXR1cmVbJ2dlb21ldHJ5J10sIG9wdF9vcHRpb25zKTtcbiAgICBjb25zdCBmZWF0dXJlID0gbmV3IEZlYXR1cmUoKTtcbiAgICBpZiAodGhpcy5nZW9tZXRyeU5hbWVfKSB7XG4gICAgICBmZWF0dXJlLnNldEdlb21ldHJ5TmFtZSh0aGlzLmdlb21ldHJ5TmFtZV8pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5leHRyYWN0R2VvbWV0cnlOYW1lXyAmJiAnZ2VvbWV0cnlfbmFtZScgaW4gZ2VvSlNPTkZlYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZmVhdHVyZS5zZXRHZW9tZXRyeU5hbWUoZ2VvSlNPTkZlYXR1cmVbJ2dlb21ldHJ5X25hbWUnXSk7XG4gICAgfVxuICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkoZ2VvbWV0cnkpO1xuXG4gICAgaWYgKCdpZCcgaW4gZ2VvSlNPTkZlYXR1cmUpIHtcbiAgICAgIGZlYXR1cmUuc2V0SWQoZ2VvSlNPTkZlYXR1cmVbJ2lkJ10pO1xuICAgIH1cblxuICAgIGlmIChnZW9KU09ORmVhdHVyZVsncHJvcGVydGllcyddKSB7XG4gICAgICBmZWF0dXJlLnNldFByb3BlcnRpZXMoZ2VvSlNPTkZlYXR1cmVbJ3Byb3BlcnRpZXMnXSk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICByZWFkRmVhdHVyZXNGcm9tT2JqZWN0KG9iamVjdCwgb3B0X29wdGlvbnMpIHtcbiAgICBjb25zdCBnZW9KU09OT2JqZWN0ID0gLyoqIEB0eXBlIHtHZW9KU09OT2JqZWN0fSAqLyAob2JqZWN0KTtcbiAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59ICovXG4gICAgbGV0IGZlYXR1cmVzID0gbnVsbDtcbiAgICBpZiAoZ2VvSlNPTk9iamVjdFsndHlwZSddID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICBjb25zdCBnZW9KU09ORmVhdHVyZUNvbGxlY3Rpb24gPSAvKiogQHR5cGUge0dlb0pTT05GZWF0dXJlQ29sbGVjdGlvbn0gKi8gKG9iamVjdCk7XG4gICAgICBmZWF0dXJlcyA9IFtdO1xuICAgICAgY29uc3QgZ2VvSlNPTkZlYXR1cmVzID0gZ2VvSlNPTkZlYXR1cmVDb2xsZWN0aW9uWydmZWF0dXJlcyddO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvSlNPTkZlYXR1cmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaCh0aGlzLnJlYWRGZWF0dXJlRnJvbU9iamVjdChnZW9KU09ORmVhdHVyZXNbaV0sIG9wdF9vcHRpb25zKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZlYXR1cmVzID0gW3RoaXMucmVhZEZlYXR1cmVGcm9tT2JqZWN0KG9iamVjdCwgb3B0X29wdGlvbnMpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICByZWFkR2VvbWV0cnlGcm9tT2JqZWN0KG9iamVjdCwgb3B0X29wdGlvbnMpIHtcbiAgICByZXR1cm4gcmVhZEdlb21ldHJ5KC8qKiBAdHlwZSB7R2VvSlNPTkdlb21ldHJ5fSAqLyAob2JqZWN0KSwgb3B0X29wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICByZWFkUHJvamVjdGlvbkZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgY29uc3QgY3JzID0gb2JqZWN0WydjcnMnXTtcbiAgICBsZXQgcHJvamVjdGlvbjtcbiAgICBpZiAoY3JzKSB7XG4gICAgICBpZiAoY3JzWyd0eXBlJ10gPT0gJ25hbWUnKSB7XG4gICAgICAgIHByb2plY3Rpb24gPSBnZXRQcm9qZWN0aW9uKGNyc1sncHJvcGVydGllcyddWyduYW1lJ10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAzNik7IC8vIFVua25vd24gU1JTIHR5cGVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvamVjdGlvbiA9IHRoaXMuZGF0YVByb2plY3Rpb247XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSAqLyAocHJvamVjdGlvbilcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIGZlYXR1cmUgYXMgYSBHZW9KU09OIEZlYXR1cmUgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnM9fSBvcHRfb3B0aW9ucyBXcml0ZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtHZW9KU09ORmVhdHVyZX0gT2JqZWN0LlxuICAgKiBAb3ZlcnJpZGVcbiAgICogQGFwaVxuICAgKi9cbiAgd3JpdGVGZWF0dXJlT2JqZWN0KGZlYXR1cmUsIG9wdF9vcHRpb25zKSB7XG4gICAgb3B0X29wdGlvbnMgPSB0aGlzLmFkYXB0T3B0aW9ucyhvcHRfb3B0aW9ucyk7XG5cbiAgICAvKiogQHR5cGUge0dlb0pTT05GZWF0dXJlfSAqL1xuICAgIGNvbnN0IG9iamVjdCA9IHtcbiAgICAgICd0eXBlJzogJ0ZlYXR1cmUnLFxuICAgICAgZ2VvbWV0cnk6IG51bGwsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsXG4gICAgfTtcblxuICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYmplY3QuaWQgPSBpZDtcbiAgICB9XG5cbiAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICBpZiAoZ2VvbWV0cnkpIHtcbiAgICAgIG9iamVjdC5nZW9tZXRyeSA9IHdyaXRlR2VvbWV0cnkoZ2VvbWV0cnksIG9wdF9vcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gZmVhdHVyZS5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgZGVsZXRlIHByb3BlcnRpZXNbZmVhdHVyZS5nZXRHZW9tZXRyeU5hbWUoKV07XG4gICAgaWYgKCFpc0VtcHR5KHByb3BlcnRpZXMpKSB7XG4gICAgICBvYmplY3QucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IG9mIGZlYXR1cmVzIGFzIGEgR2VvSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gZmVhdHVyZXMgRmVhdHVyZXMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9ucz19IG9wdF9vcHRpb25zIFdyaXRlIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0dlb0pTT05GZWF0dXJlQ29sbGVjdGlvbn0gR2VvSlNPTiBPYmplY3QuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICB3cml0ZUZlYXR1cmVzT2JqZWN0KGZlYXR1cmVzLCBvcHRfb3B0aW9ucykge1xuICAgIG9wdF9vcHRpb25zID0gdGhpcy5hZGFwdE9wdGlvbnMob3B0X29wdGlvbnMpO1xuICAgIGNvbnN0IG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvYmplY3RzLnB1c2godGhpcy53cml0ZUZlYXR1cmVPYmplY3QoZmVhdHVyZXNbaV0sIG9wdF9vcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgZmVhdHVyZXM6IG9iamVjdHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIGdlb21ldHJ5IGFzIGEgR2VvSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zPX0gb3B0X29wdGlvbnMgV3JpdGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7R2VvSlNPTkdlb21ldHJ5fEdlb0pTT05HZW9tZXRyeUNvbGxlY3Rpb259IE9iamVjdC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIHdyaXRlR2VvbWV0cnlPYmplY3QoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSB7XG4gICAgcmV0dXJuIHdyaXRlR2VvbWV0cnkoZ2VvbWV0cnksIHRoaXMuYWRhcHRPcHRpb25zKG9wdF9vcHRpb25zKSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7R2VvSlNPTkdlb21ldHJ5fEdlb0pTT05HZW9tZXRyeUNvbGxlY3Rpb259IG9iamVjdCBPYmplY3QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5SZWFkT3B0aW9ucz19IG9wdF9vcHRpb25zIFJlYWQgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRHZW9tZXRyeShvYmplY3QsIG9wdF9vcHRpb25zKSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH1cbiAgICovXG4gIGxldCBnZW9tZXRyeTtcbiAgc3dpdGNoIChvYmplY3RbJ3R5cGUnXSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOiB7XG4gICAgICBnZW9tZXRyeSA9IHJlYWRQb2ludEdlb21ldHJ5KC8qKiBAdHlwZSB7R2VvSlNPTlBvaW50fSAqLyAob2JqZWN0KSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6IHtcbiAgICAgIGdlb21ldHJ5ID0gcmVhZExpbmVTdHJpbmdHZW9tZXRyeSgvKiogQHR5cGUge0dlb0pTT05MaW5lU3RyaW5nfSAqLyAob2JqZWN0KSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjoge1xuICAgICAgZ2VvbWV0cnkgPSByZWFkUG9seWdvbkdlb21ldHJ5KC8qKiBAdHlwZSB7R2VvSlNPTlBvbHlnb259ICovIChvYmplY3QpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDoge1xuICAgICAgZ2VvbWV0cnkgPSByZWFkTXVsdGlQb2ludEdlb21ldHJ5KC8qKiBAdHlwZSB7R2VvSlNPTk11bHRpUG9pbnR9ICovIChvYmplY3QpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9MSU5FX1NUUklORzoge1xuICAgICAgZ2VvbWV0cnkgPSByZWFkTXVsdGlMaW5lU3RyaW5nR2VvbWV0cnkoLyoqIEB0eXBlIHtHZW9KU09OTXVsdGlMaW5lU3RyaW5nfSAqLyAob2JqZWN0KSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTjoge1xuICAgICAgZ2VvbWV0cnkgPSByZWFkTXVsdGlQb2x5Z29uR2VvbWV0cnkoLyoqIEB0eXBlIHtHZW9KU09OTXVsdGlQb2x5Z29ufSAqLyAob2JqZWN0KSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTjoge1xuICAgICAgZ2VvbWV0cnkgPSByZWFkR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkoLyoqIEB0eXBlIHtHZW9KU09OR2VvbWV0cnlDb2xsZWN0aW9ufSAqLyAob2JqZWN0KSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBHZW9KU09OIHR5cGU6ICcgKyBvYmplY3QudHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKHRyYW5zZm9ybVdpdGhPcHRpb25zKGdlb21ldHJ5LCBmYWxzZSwgb3B0X29wdGlvbnMpKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7R2VvSlNPTkdlb21ldHJ5Q29sbGVjdGlvbn0gb2JqZWN0IE9iamVjdC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLlJlYWRPcHRpb25zPX0gb3B0X29wdGlvbnMgUmVhZCBvcHRpb25zLlxuICogQHJldHVybiB7R2VvbWV0cnlDb2xsZWN0aW9ufSBHZW9tZXRyeSBjb2xsZWN0aW9uLlxuICovXG5mdW5jdGlvbiByZWFkR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkob2JqZWN0LCBvcHRfb3B0aW9ucykge1xuICBjb25zdCBnZW9tZXRyaWVzID0gb2JqZWN0WydnZW9tZXRyaWVzJ10ubWFwKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7R2VvSlNPTkdlb21ldHJ5fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICByZXR1cm4gcmVhZEdlb21ldHJ5KGdlb21ldHJ5LCBvcHRfb3B0aW9ucyk7XG4gICAgfSk7XG4gIHJldHVybiBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtHZW9KU09OUG9pbnR9IG9iamVjdCBPYmplY3QuXG4gKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRQb2ludEdlb21ldHJ5KG9iamVjdCkge1xuICByZXR1cm4gbmV3IFBvaW50KG9iamVjdFsnY29vcmRpbmF0ZXMnXSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0dlb0pTT05MaW5lU3RyaW5nfSBvYmplY3QgT2JqZWN0LlxuICogQHJldHVybiB7TGluZVN0cmluZ30gTGluZVN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVhZExpbmVTdHJpbmdHZW9tZXRyeShvYmplY3QpIHtcbiAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKG9iamVjdFsnY29vcmRpbmF0ZXMnXSk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0dlb0pTT05NdWx0aUxpbmVTdHJpbmd9IG9iamVjdCBPYmplY3QuXG4gKiBAcmV0dXJuIHtNdWx0aUxpbmVTdHJpbmd9IE11bHRpTGluZVN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcmVhZE11bHRpTGluZVN0cmluZ0dlb21ldHJ5KG9iamVjdCkge1xuICByZXR1cm4gbmV3IE11bHRpTGluZVN0cmluZyhvYmplY3RbJ2Nvb3JkaW5hdGVzJ10pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtHZW9KU09OTXVsdGlQb2ludH0gb2JqZWN0IE9iamVjdC5cbiAqIEByZXR1cm4ge011bHRpUG9pbnR9IE11bHRpUG9pbnQuXG4gKi9cbmZ1bmN0aW9uIHJlYWRNdWx0aVBvaW50R2VvbWV0cnkob2JqZWN0KSB7XG4gIHJldHVybiBuZXcgTXVsdGlQb2ludChvYmplY3RbJ2Nvb3JkaW5hdGVzJ10pO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtHZW9KU09OTXVsdGlQb2x5Z29ufSBvYmplY3QgT2JqZWN0LlxuICogQHJldHVybiB7TXVsdGlQb2x5Z29ufSBNdWx0aVBvbHlnb24uXG4gKi9cbmZ1bmN0aW9uIHJlYWRNdWx0aVBvbHlnb25HZW9tZXRyeShvYmplY3QpIHtcbiAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ob2JqZWN0Wydjb29yZGluYXRlcyddKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7R2VvSlNPTlBvbHlnb259IG9iamVjdCBPYmplY3QuXG4gKiBAcmV0dXJuIHtQb2x5Z29ufSBQb2x5Z29uLlxuICovXG5mdW5jdGlvbiByZWFkUG9seWdvbkdlb21ldHJ5KG9iamVjdCkge1xuICByZXR1cm4gbmV3IFBvbHlnb24ob2JqZWN0Wydjb29yZGluYXRlcyddKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9ucz19IG9wdF9vcHRpb25zIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnl9IEdlb0pTT04gZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlR2VvbWV0cnkoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSB7XG4gIGdlb21ldHJ5ID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR9ICovICh0cmFuc2Zvcm1XaXRoT3B0aW9ucyhnZW9tZXRyeSwgdHJ1ZSwgb3B0X29wdGlvbnMpKTtcbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcblxuICAvKiogQHR5cGUge0dlb0pTT05HZW9tZXRyeX0gKi9cbiAgbGV0IGdlb0pTT047XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOiB7XG4gICAgICBnZW9KU09OID0gd3JpdGVQb2ludEdlb21ldHJ5KC8qKiBAdHlwZSB7UG9pbnR9ICovIChnZW9tZXRyeSksIG9wdF9vcHRpb25zKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5MSU5FX1NUUklORzoge1xuICAgICAgZ2VvSlNPTiA9IHdyaXRlTGluZVN0cmluZ0dlb21ldHJ5KC8qKiBAdHlwZSB7TGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KSwgb3B0X29wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046IHtcbiAgICAgIGdlb0pTT04gPSB3cml0ZVBvbHlnb25HZW9tZXRyeSgvKiogQHR5cGUge1BvbHlnb259ICovIChnZW9tZXRyeSksIG9wdF9vcHRpb25zKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0lOVDoge1xuICAgICAgZ2VvSlNPTiA9IHdyaXRlTXVsdGlQb2ludEdlb21ldHJ5KC8qKiBAdHlwZSB7TXVsdGlQb2ludH0gKi8gKGdlb21ldHJ5KSwgb3B0X29wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX0xJTkVfU1RSSU5HOiB7XG4gICAgICBnZW9KU09OID0gd3JpdGVNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSgvKiogQHR5cGUge011bHRpTGluZVN0cmluZ30gKi8gKGdlb21ldHJ5KSwgb3B0X29wdGlvbnMpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046IHtcbiAgICAgIGdlb0pTT04gPSB3cml0ZU11bHRpUG9seWdvbkdlb21ldHJ5KC8qKiBAdHlwZSB7TXVsdGlQb2x5Z29ufSAqLyAoZ2VvbWV0cnkpLCBvcHRfb3B0aW9ucyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTjoge1xuICAgICAgZ2VvSlNPTiA9IHdyaXRlR2VvbWV0cnlDb2xsZWN0aW9uR2VvbWV0cnkoLyoqIEB0eXBlIHtHZW9tZXRyeUNvbGxlY3Rpb259ICovIChnZW9tZXRyeSksIG9wdF9vcHRpb25zKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5DSVJDTEU6IHtcbiAgICAgIGdlb0pTT04gPSB7XG4gICAgICAgIHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICAgICAgICBnZW9tZXRyaWVzOiBbXVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb0pTT047XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0dlb21ldHJ5Q29sbGVjdGlvbn0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnM9fSBvcHRfb3B0aW9ucyBXcml0ZSBvcHRpb25zLlxuICogQHJldHVybiB7R2VvSlNPTkdlb21ldHJ5Q29sbGVjdGlvbn0gR2VvSlNPTiBnZW9tZXRyeSBjb2xsZWN0aW9uLlxuICovXG5mdW5jdGlvbiB3cml0ZUdlb21ldHJ5Q29sbGVjdGlvbkdlb21ldHJ5KGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICBjb25zdCBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCkubWFwKGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0X29wdGlvbnMpO1xuICAgIGRlbGV0ZSBvcHRpb25zLmZlYXR1cmVQcm9qZWN0aW9uO1xuICAgIHJldHVybiB3cml0ZUdlb21ldHJ5KGdlb21ldHJ5LCBvcHRpb25zKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbicsXG4gICAgZ2VvbWV0cmllczogZ2VvbWV0cmllc1xuICB9O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtMaW5lU3RyaW5nfSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9ucz19IG9wdF9vcHRpb25zIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnl9IEdlb0pTT04gZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTGluZVN0cmluZ0dlb21ldHJ5KGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICBjb29yZGluYXRlczogZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKVxuICB9O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtNdWx0aUxpbmVTdHJpbmd9IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zPX0gb3B0X29wdGlvbnMgV3JpdGUgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0dlb0pTT05HZW9tZXRyeX0gR2VvSlNPTiBnZW9tZXRyeS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVNdWx0aUxpbmVTdHJpbmdHZW9tZXRyeShnZW9tZXRyeSwgb3B0X29wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICBjb29yZGluYXRlczogZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKVxuICB9O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtNdWx0aVBvaW50fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9ucz19IG9wdF9vcHRpb25zIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnl9IEdlb0pTT04gZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlTXVsdGlQb2ludEdlb21ldHJ5KGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNdWx0aVBvaW50JyxcbiAgICBjb29yZGluYXRlczogZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKVxuICB9O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtNdWx0aVBvbHlnb259IGdlb21ldHJ5IEdlb21ldHJ5LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuV3JpdGVPcHRpb25zPX0gb3B0X29wdGlvbnMgV3JpdGUgb3B0aW9ucy5cbiAqIEByZXR1cm4ge0dlb0pTT05HZW9tZXRyeX0gR2VvSlNPTiBnZW9tZXRyeS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVNdWx0aVBvbHlnb25HZW9tZXRyeShnZW9tZXRyeSwgb3B0X29wdGlvbnMpIHtcbiAgbGV0IHJpZ2h0O1xuICBpZiAob3B0X29wdGlvbnMpIHtcbiAgICByaWdodCA9IG9wdF9vcHRpb25zLnJpZ2h0SGFuZGVkO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgY29vcmRpbmF0ZXM6IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKHJpZ2h0KVxuICB9O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtQb2ludH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5Xcml0ZU9wdGlvbnM9fSBvcHRfb3B0aW9ucyBXcml0ZSBvcHRpb25zLlxuICogQHJldHVybiB7R2VvSlNPTkdlb21ldHJ5fSBHZW9KU09OIGdlb21ldHJ5LlxuICovXG5mdW5jdGlvbiB3cml0ZVBvaW50R2VvbWV0cnkoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1BvaW50JyxcbiAgICBjb29yZGluYXRlczogZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKVxuICB9O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtQb2x5Z29ufSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLldyaXRlT3B0aW9ucz19IG9wdF9vcHRpb25zIFdyaXRlIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtHZW9KU09OR2VvbWV0cnl9IEdlb0pTT04gZ2VvbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlUG9seWdvbkdlb21ldHJ5KGdlb21ldHJ5LCBvcHRfb3B0aW9ucykge1xuICBsZXQgcmlnaHQ7XG4gIGlmIChvcHRfb3B0aW9ucykge1xuICAgIHJpZ2h0ID0gb3B0X29wdGlvbnMucmlnaHRIYW5kZWQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgY29vcmRpbmF0ZXM6IGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKHJpZ2h0KVxuICB9O1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEdlb0pTT047XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7OztBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUVBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7QUE1S0E7Ozs7Ozs7QUFtTEE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5TUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUFBO0FBQUE7QUFLQTtBQUVBOzs7Ozs7QUFNQTtBQUVBOzs7OztBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdFFBOzs7Ozs7O0FBNlFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdFNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQWFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNoTEE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQUE7QUFBQTtBQU9BO0FBRUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUdBOzs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUdBOzs7Ozs7OztBQU9BO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFHQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7O0FBeE5BO0FBQ0E7QUEwTkE7O0FDbFBBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBU0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFFQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUF6UEE7QUFDQTtBQTJQQTs7Ozs7QUNsUkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7OztBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7QUFySkE7QUFDQTtBQXVKQTs7Ozs7Ozs7QUMxS0E7OztBQUdBOzs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUN2QkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBUUE7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7Ozs7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUExVkE7QUFDQTtBQTRWQTs7Ozs7QUN4WEE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0E7QUFBQTtBQUFBO0FBS0E7QUFFQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7Ozs7Ozs7QUFPQTs7Ozs7QUFFQTs7Ozs7QUFLQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFHQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBOztBQWhNQTs7Ozs7Ozs7QUF3TUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQS9CQTtBQUNBO0FBZ0NBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQXRDQTtBQUNBO0FBdUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///77\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nvar _Locator = _interopRequireDefault(__webpack_require__(103));\n\nvar _Geocoder = _interopRequireDefault(__webpack_require__(111));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\r\n * @module nyc/Geoclient\r\n */\n\n\nvar proj4 = _[\"default\"].proj4;\n/**\r\n * @desc A class for geocoding using the New York City Geoclient API\r\n * @public\r\n * @class\r\n * @extends module:nyc/Geocoder~Geocoder\r\n * @fires module:nyc/Locator~Locator#geocoded\r\n * @fires module:nyc/Locator~Locator#geolocated\r\n * @fires module:nyc/Locator~Locator#ambiguous\r\n * @fires module:nyc/Locator~Locator#error\r\n * @see https://developer.cityofnewyork.us/api/geoclient-api\r\n */\n\nvar Geoclient =\n/*#__PURE__*/\nfunction (_Geocoder$default) {\n  _inherits(Geoclient, _Geocoder$default);\n\n  /**\r\n   * @desc Create an instance of Geoclient\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/Geoclient~Geoclient.Options} options Constructor options\r\n   */\n  function Geoclient(options) {\n    var _this;\n\n    _classCallCheck(this, Geoclient);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Geoclient).call(this, options));\n    /**\r\n     * @private\r\n     * @member {string}\r\n     */\n\n    _this.url = \"\".concat(options.url, \"&input=\");\n    /**\r\n     * @desc The epsg code\r\n     * @public\r\n     * @member {string}\r\n     */\n\n    _this.projection = options.projection || 'EPSG:3857';\n    return _this;\n  }\n  /**\r\n   * @desc Geocode an input string representing a location\r\n   * @public\r\n   * @override\r\n   * @method\r\n   * @param {string} input The value to geocode\r\n   * @returns {Promise<module:nyc/Locator~Locator.Result|module:nyc/Locator~Locator.Ambiguous>} The result of the search request\r\n   */\n\n\n  _createClass(Geoclient, [{\n    key: \"search\",\n    value: function search(input) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        input = input.trim();\n\n        if (input.length === 5 && !isNaN(input)) {\n          _this2.resolveZip(input, resolve);\n        } else if (input.length) {\n          input = input.replace(/\"/g, '').replace(/'/g, '').replace(/&/g, ' and ');\n          fetch(\"\".concat(_this2.url).concat(input)).then(function (response) {\n            return response.json();\n          }).then(function (json) {\n            _this2.geoclient(json, resolve);\n          })[\"catch\"](function (error) {\n            _this2.error(error, reject);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"resolveZip\",\n    value: function resolveZip(input, resolve) {\n      var p = this.project(Geoclient.ZIP_CODE_POINTS[input]);\n      var result;\n\n      if (p) {\n        result = {\n          coordinate: p,\n          accuracy: _Locator[\"default\"].Accuracy.ZIP_CODE,\n          type: 'geocoded',\n          zip: true,\n          name: input\n        };\n        resolve(result);\n        this.trigger('geocoded', result);\n      } else {\n        result = {\n          input: input,\n          type: 'ambiguous',\n          possible: []\n        };\n        resolve(result);\n        this.trigger('ambiguous', result);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Array<number>} coordinate Coordinate\r\n     * @return {Array<number>} Reprojected coordinate\r\n     */\n\n  }, {\n    key: \"project\",\n    value: function project(coordinate) {\n      if (coordinate && this.projection !== 'EPSG:2263') {\n        return proj4('EPSG:2263', this.projection, coordinate);\n      }\n\n      return coordinate;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} response Response object\r\n     * @param {function} resolve Resolve\r\n     */\n\n  }, {\n    key: \"geoclient\",\n    value: function geoclient(response, resolve) {\n      var results = response.results;\n      var nothing = {\n        type: 'ambiguous',\n        input: response.input,\n        possible: []\n      };\n\n      if (response.status === 'OK') {\n        if (results.length === 1) {\n          var result = results[0];\n          var location = this.parse(result);\n\n          if (location) {\n            location.type = 'geocoded';\n            resolve(location);\n            this.trigger('geocoded', location);\n          } else {\n            resolve(nothing);\n            this.trigger('ambiguous', nothing);\n          }\n        } else {\n          var ambiguous = {\n            type: 'ambiguous',\n            input: response.input,\n            possible: this.possible(results)\n          };\n          resolve(ambiguous);\n          this.trigger('ambiguous', ambiguous);\n        }\n      } else {\n        resolve(nothing);\n        this.trigger('ambiguous', nothing);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Array<module:nyc.Locator~Locator.Ambiguous>} results Results\r\n     * @returns {Array} Possible results\r\n     */\n\n  }, {\n    key: \"possible\",\n    value: function possible(results) {\n      var _this3 = this;\n\n      var possible = [];\n      results.forEach(function (result) {\n        var location = _this3.parse(result);\n\n        if (location) {\n          possible.push(location);\n        }\n      });\n      return possible;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} result Result\r\n     * @return {Locator.Result} Locator result\r\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(result) {\n      var typ = result.request.split(' ')[0],\n          r = result.response;\n      var ln1, p, a;\n\n      if (typ === 'intersection') {\n        ln1 = \"\".concat(r.streetName1, \" and \").concat(r.streetName2);\n        p = [r.xCoordinate * 1, r.yCoordinate * 1];\n        a = _Locator[\"default\"].Accuracy.MEDIUM;\n      } else if (typ === 'blockface') {\n        ln1 = r.firstStreetNameNormalized + ' btwn ' + r.secondStreetNameNormalized + ' & ' + r.thirdStreetNameNormalized;\n        p = [(r.fromXCoordinate * 1 + r.toXCoordinate * 1) / 2, (r.fromYCoordinate * 1 + r.toYCoordinate * 1) / 2];\n        a = _Locator[\"default\"].Accuracy.LOW;\n      } else {\n        /* address, bbl, bin, place */\n        var x = r.internalLabelXCoordinate;\n        var y = r.internalLabelYCoordinate;\n        ln1 = (r.houseNumber ? r.houseNumber + ' ' : '') + (r.firstStreetNameNormalized || r.giStreetName1);\n        p = [(x && y ? x : r.xCoordinate) * 1, (x && y ? y : r.yCoordinate) * 1];\n        a = x && y ? _Locator[\"default\"].Accuracy.HIGH : _Locator[\"default\"].Accuracy.MEDIUM;\n      }\n\n      try {\n        return {\n          type: 'geocoded',\n          coordinate: this.project(p),\n          data: r,\n          accuracy: a,\n\n          /* approximation */\n          name: _[\"default\"].capitalize(\"\".concat(ln1.replace(/  +/g, ' '), \", \").concat(r.firstBoroughName)) + \", NY \".concat(r.zipCode || r.leftSegmentZipCode || '')\n        };\n      } catch (badCoord) {\n        console.warn('No coordinate', result);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} error Resolve\r\n     * @param {function} reject Resolve\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(_error, reject) {\n      console.error('Geoclient error', _error);\n      reject({\n        type: 'error',\n        error: _error\n      });\n      this.trigger('error', _error);\n    }\n  }]);\n\n  return Geoclient;\n}(_Geocoder[\"default\"]);\n/**\r\n * @desc Constructor options for {@link module:nyc/Geoclient~Geoclient}\r\n * @public\r\n * @typedef {Object}\r\n * @property {string} url The URL for accessing the Geoclient API (see {@link https://developer.cityofnewyork.us/api/geoclient-api})\r\n * @property {string} [projection=EPSG:3857] The EPSG code of the projection for output geometries (i.e. EPSG:2263)\r\n */\n\n\nGeoclient.Options;\n/**\r\n * @private\r\n * @const\r\n * @type {Object<string, Array<number>>}\r\n */\n\nGeoclient.ZIP_CODE_POINTS = {\n  '10474': [1018466, 233787],\n  '10455': [1007889, 236616],\n  '10037': [1001661, 235627],\n  '10024': [991450, 225457],\n  '10454': [1007449, 232863],\n  '10026': [997179, 231835],\n  '10025': [993331, 230012],\n  '10035': [1006595, 228454],\n  '11101': [1001319, 211034],\n  '11364': [1051553, 211923],\n  '10018': [984278, 215509],\n  '10020': [990012, 215729],\n  '11005': [1064789, 214295],\n  '10017': [991869, 213252],\n  '10001': [983613, 213360],\n  '10011': [982781, 210664],\n  '10016': [990291, 210665],\n  '11104': [1006224, 210564],\n  '11109': [996054, 210740],\n  '10010': [988989, 208515],\n  '11367': [1032392, 205392],\n  '10014': [982449, 206620],\n  '10003': [987465, 205563],\n  '11222': [998773, 204620],\n  '11379': [1017432, 200740],\n  '11429': [1056859, 198057],\n  '11435': [1036960, 195018],\n  '11415': [1031798, 197376],\n  '11418': [1031001, 193330],\n  '11433': [1043368, 193721],\n  '11451': [1039899, 194697],\n  '11221': [1004438, 191873],\n  '11421': [1023878, 191241],\n  '11372': [1016528, 213126],\n  '11004': [1065606, 210363],\n  '11040': [1065956, 213534],\n  '10002': [988242, 200171],\n  '10314': [939259, 155728],\n  '11228': [980891, 164066],\n  '11209': [976172, 165379],\n  '10304': [962458, 165679],\n  '10456': [1007883, 242372],\n  '10472': [1021444, 241624],\n  '10031': [998088, 239814],\n  '10039': [1001519, 240436],\n  '10459': [1013835, 240084],\n  '10451': [1005368, 238290],\n  '10473': [1022475, 237217],\n  '10030': [1000193, 237302],\n  '10027': [999088, 234131],\n  '10461': [1028296, 247902],\n  '10457': [1012388, 247405],\n  '10460': [1015132, 243510],\n  '10032': [1000382, 244917],\n  '10452': [1005446, 244483],\n  '11414': [1027256, 178677],\n  '11232': [983612, 177801],\n  '10034': [1005713, 255122],\n  '10033': [1001707, 248780],\n  '10462': [1020685, 249420],\n  '10040': [1003863, 251914],\n  '10453': [1008152, 249805],\n  '11102': [1004636, 220364],\n  '10021': [997020, 219120],\n  '11361': [1047797, 217779],\n  '11358': [1040709, 216377],\n  '11362': [1057749, 215220],\n  '10044': [996385, 214347],\n  '11369': [1019957, 217722],\n  '11103': [1008295, 217197],\n  '11106': [1001397, 217519],\n  '11368': [1024870, 212082],\n  '11377': [1010574, 210678],\n  '10036': [985413, 216821],\n  '11355': [1033762, 213010],\n  '10302': [945946, 169124],\n  '10465': [1031495, 239091],\n  '11691': [1053783, 158810],\n  '11096': [1054217, 162199],\n  '11223': [991665, 156781],\n  '11208': [1019700, 184749],\n  '11207': [1013544, 183721],\n  '11413': [1053380, 183328],\n  '11217': [989547, 187967],\n  '11238': [994291, 186584],\n  '11231': [983057, 186217],\n  '11422': [1057272, 180607],\n  '11420': [1036899, 184708],\n  '11417': [1027410, 185709],\n  '11215': [989882, 181773],\n  '11357': [1036533, 225804],\n  '10029': [999950, 227538],\n  '00083': [991590, 220538],\n  '11356': [1028115, 225277],\n  '11359': [1046026, 228012],\n  '10303': [933820, 171004],\n  '11234': [1004323, 163783],\n  '11360': [1044984, 223892],\n  '11105': [1011836, 221755],\n  '10128': [997765, 224257],\n  '11371': [1022003, 220457],\n  '10023': [988765, 222068],\n  '11363': [1055047, 220385],\n  '10028': [995910, 222872],\n  '11354': [1032198, 219054],\n  '11216': [998312, 187241],\n  '11416': [1025796, 188584],\n  '11233': [1006523, 186300],\n  '11436': [1040697, 185554],\n  '11213': [1000284, 183308],\n  '11212': [1008387, 180764],\n  '11225': [997345, 180829],\n  '11218': [990799, 173649],\n  '11226': [995711, 174598],\n  '11219': [985166, 169604],\n  '11210': [999101, 167896],\n  '11230': [993494, 166072],\n  '11419': [1033365, 190202],\n  '11434': [1046577, 185969],\n  '11204': [987887, 164576],\n  '10471': [1012587, 266570],\n  '10470': [1024748, 268409],\n  '10466': [1024313, 263999],\n  '10467': [1019786, 258782],\n  '11430': [1043607, 175068],\n  '11203': [1002509, 175950],\n  '10469': [1026678, 255623],\n  '10468': [1013897, 258046],\n  '10458': [1015534, 253712],\n  '11378': [1009641, 202115],\n  '10009': [990043, 203961],\n  '10012': [984832, 203596],\n  '10013': [982892, 201665],\n  '10007': [982504, 199552],\n  '11237': [1004600, 197083],\n  '11385': [1011367, 195195],\n  '10038': [983418, 197803],\n  '11206': [1000221, 195003],\n  '10006': [980563, 197293],\n  '11412': [1050773, 193231],\n  '10005': [981339, 197038],\n  '11251': [993428, 194599],\n  '11411': [1057763, 192413],\n  '11201': [986968, 192156],\n  '10004': [972576, 193652],\n  '11205': [995897, 192159],\n  '10305': [963310, 156060],\n  '11229': [999717, 158278],\n  '11214': [984000, 159330],\n  '10306': [950937, 145144],\n  '11694': [1025530, 149310],\n  '11224': [984306, 149092],\n  '10308': [942704, 140020],\n  '10282': [979981, 200244],\n  '11211': [999857, 199848],\n  '11249': [993704, 198278],\n  '11370': [1016758, 227518],\n  '10065': [994666, 217698],\n  '10075': [995301, 221633],\n  '10069': [987047, 221849],\n  '10281': [980036, 198787],\n  '11373': [1017948, 208465],\n  '10279': [981949, 198823],\n  '10165': [990124, 213288],\n  '10168': [990733, 212960],\n  '10105': [990067, 217259],\n  '10118': [988212, 211939],\n  '10176': [990123, 214490],\n  '10162': [997739, 219667],\n  '10170': [990955, 213470],\n  '10112': [989735, 215947],\n  '10122': [986550, 213178],\n  '10107': [989098, 218425],\n  '10103': [990705, 216275],\n  '10174': [991094, 213106],\n  '10166': [990733, 213798],\n  '10169': [990872, 214089],\n  '10167': [991259, 214199],\n  '10177': [990927, 214381],\n  '10172': [991398, 214417],\n  '10171': [991426, 214709],\n  '10270': [982060, 196710],\n  '10104': [990123, 216312],\n  '10271': [981339, 197293],\n  '10110': [989486, 213943],\n  '10175': [989847, 214016],\n  '10151': [991702, 217332],\n  '10173': [990040, 213907],\n  '10178': [990429, 212814],\n  '10119': [986217, 213068],\n  '10121': [986439, 212486],\n  '10123': [986827, 213032],\n  '10106': [989624, 218024],\n  '10158': [991177, 212122],\n  '10041': [981727, 195435],\n  '10120': [987242, 212449],\n  '10278': [983113, 199880],\n  '10155': [993143, 216531],\n  '10043': [982337, 195836],\n  '10081': [981838, 197074],\n  '10096': [989071, 214235],\n  '10097': [988461, 216931],\n  '10196': [989458, 214963],\n  '10275': [980368, 196382],\n  '10265': [982060, 196164],\n  '10045': [981866, 197329],\n  '10047': [988047, 208660],\n  '10080': [980785, 198167],\n  '10203': [981062, 196965],\n  '10259': [981478, 197439],\n  '10260': [981921, 196564],\n  '10285': [980147, 199224],\n  '10286': [981727, 196637],\n  '10463': [1007644, 260043],\n  '10475': [1030489, 258509],\n  '10464': [1036131, 258338],\n  '10309': [923594, 132955],\n  '10307': [916899, 124411],\n  '10280': [979509, 197257],\n  '10048': [980812, 198532],\n  '10055': [991564, 215802],\n  '10019': [989652, 217477],\n  '10111': [990483, 215838],\n  '10153': [991896, 217478],\n  '10154': [991896, 215328],\n  '10152': [991979, 215584],\n  '10115': [994299, 234675],\n  '10022': [993087, 215620],\n  '11235': [1000973, 149936],\n  '11693': [1036606, 153266],\n  '11692': [1041045, 155461],\n  '11697': [1009230, 143240],\n  '10312': [935583, 136827],\n  '11239': [1021573, 175899],\n  '11236': [1011642, 172461],\n  '11220': [979421, 172519],\n  '10301': [961077, 172967],\n  '10310': [950582, 169591],\n  '11426': [1060737, 207724],\n  '11365': [1041364, 208618],\n  '11001': [1065508, 206646],\n  '11375': [1026883, 201848],\n  '11427': [1053373, 205042],\n  '11374': [1022389, 203771],\n  '11366': [1039491, 203659],\n  '11423': [1048812, 200621],\n  '11428': [1055655, 202207],\n  '11432': [1041634, 200093]\n};\nvar _default = Geoclient;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnljLWxpYi9ueWMvR2VvY2xpZW50LmpzP2FkYjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9cIikpO1xuXG52YXIgX0xvY2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0xvY2F0b3JcIikpO1xuXG52YXIgX0dlb2NvZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9HZW9jb2RlclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9HZW9jbGllbnRcclxuICovXG5jb25zdCBwcm9qNCA9IF8uZGVmYXVsdC5wcm9qNDtcbi8qKlxyXG4gKiBAZGVzYyBBIGNsYXNzIGZvciBnZW9jb2RpbmcgdXNpbmcgdGhlIE5ldyBZb3JrIENpdHkgR2VvY2xpZW50IEFQSVxyXG4gKiBAcHVibGljXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBtb2R1bGU6bnljL0dlb2NvZGVyfkdlb2NvZGVyXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNnZW9jb2RlZFxyXG4gKiBAZmlyZXMgbW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IjZ2VvbG9jYXRlZFxyXG4gKiBAZmlyZXMgbW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IjYW1iaWd1b3VzXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNlcnJvclxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmNpdHlvZm5ld3lvcmsudXMvYXBpL2dlb2NsaWVudC1hcGlcclxuICovXG5cbmNsYXNzIEdlb2NsaWVudCBleHRlbmRzIF9HZW9jb2Rlci5kZWZhdWx0IHtcbiAgLyoqXHJcbiAgICogQGRlc2MgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEdlb2NsaWVudFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvR2VvY2xpZW50fkdlb2NsaWVudC5PcHRpb25zfSBvcHRpb25zIENvbnN0cnVjdG9yIG9wdGlvbnNcclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xuXG4gICAgdGhpcy51cmwgPSBgJHtvcHRpb25zLnVybH0maW5wdXQ9YDtcbiAgICAvKipcclxuICAgICAqIEBkZXNjIFRoZSBlcHNnIGNvZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gb3B0aW9ucy5wcm9qZWN0aW9uIHx8ICdFUFNHOjM4NTcnO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIEdlb2NvZGUgYW4gaW5wdXQgc3RyaW5nIHJlcHJlc2VudGluZyBhIGxvY2F0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIHZhbHVlIHRvIGdlb2NvZGVcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5SZXN1bHR8bW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IuQW1iaWd1b3VzPn0gVGhlIHJlc3VsdCBvZiB0aGUgc2VhcmNoIHJlcXVlc3RcclxuICAgKi9cblxuXG4gIHNlYXJjaChpbnB1dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpbnB1dCA9IGlucHV0LnRyaW0oKTtcblxuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gNSAmJiAhaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZVppcChpbnB1dCwgcmVzb2x2ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1wiL2csICcnKS5yZXBsYWNlKC8nL2csICcnKS5yZXBsYWNlKC8mL2csICcgYW5kICcpO1xuICAgICAgICBmZXRjaChgJHt0aGlzLnVybH0ke2lucHV0fWApLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0pLnRoZW4oanNvbiA9PiB7XG4gICAgICAgICAgdGhpcy5nZW9jbGllbnQoanNvbiwgcmVzb2x2ZSk7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLmVycm9yKGVycm9yLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlc29sdmVaaXAoaW5wdXQsIHJlc29sdmUpIHtcbiAgICBjb25zdCBwID0gdGhpcy5wcm9qZWN0KEdlb2NsaWVudC5aSVBfQ09ERV9QT0lOVFNbaW5wdXRdKTtcbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgaWYgKHApIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgY29vcmRpbmF0ZTogcCxcbiAgICAgICAgYWNjdXJhY3k6IF9Mb2NhdG9yLmRlZmF1bHQuQWNjdXJhY3kuWklQX0NPREUsXG4gICAgICAgIHR5cGU6ICdnZW9jb2RlZCcsXG4gICAgICAgIHppcDogdHJ1ZSxcbiAgICAgICAgbmFtZTogaW5wdXRcbiAgICAgIH07XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2dlb2NvZGVkJywgcmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgIHR5cGU6ICdhbWJpZ3VvdXMnLFxuICAgICAgICBwb3NzaWJsZTogW11cbiAgICAgIH07XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2FtYmlndW91cycsIHJlc3VsdCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZSBDb29yZGluYXRlXHJcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUmVwcm9qZWN0ZWQgY29vcmRpbmF0ZVxyXG4gICAqL1xuXG5cbiAgcHJvamVjdChjb29yZGluYXRlKSB7XG4gICAgaWYgKGNvb3JkaW5hdGUgJiYgdGhpcy5wcm9qZWN0aW9uICE9PSAnRVBTRzoyMjYzJykge1xuICAgICAgcmV0dXJuIHByb2o0KCdFUFNHOjIyNjMnLCB0aGlzLnByb2plY3Rpb24sIGNvb3JkaW5hdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZGluYXRlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBSZXNwb25zZSBvYmplY3RcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlIFJlc29sdmVcclxuICAgKi9cblxuXG4gIGdlb2NsaWVudChyZXNwb25zZSwgcmVzb2x2ZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSByZXNwb25zZS5yZXN1bHRzO1xuICAgIGNvbnN0IG5vdGhpbmcgPSB7XG4gICAgICB0eXBlOiAnYW1iaWd1b3VzJyxcbiAgICAgIGlucHV0OiByZXNwb25zZS5pbnB1dCxcbiAgICAgIHBvc3NpYmxlOiBbXVxuICAgIH07XG5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAnT0snKSB7XG4gICAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0c1swXTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnBhcnNlKHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgbG9jYXRpb24udHlwZSA9ICdnZW9jb2RlZCc7XG4gICAgICAgICAgcmVzb2x2ZShsb2NhdGlvbik7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdnZW9jb2RlZCcsIGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG5vdGhpbmcpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignYW1iaWd1b3VzJywgbm90aGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFtYmlndW91cyA9IHtcbiAgICAgICAgICB0eXBlOiAnYW1iaWd1b3VzJyxcbiAgICAgICAgICBpbnB1dDogcmVzcG9uc2UuaW5wdXQsXG4gICAgICAgICAgcG9zc2libGU6IHRoaXMucG9zc2libGUocmVzdWx0cylcbiAgICAgICAgfTtcbiAgICAgICAgcmVzb2x2ZShhbWJpZ3VvdXMpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2FtYmlndW91cycsIGFtYmlndW91cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUobm90aGluZyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2FtYmlndW91cycsIG5vdGhpbmcpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge0FycmF5PG1vZHVsZTpueWMuTG9jYXRvcn5Mb2NhdG9yLkFtYmlndW91cz59IHJlc3VsdHMgUmVzdWx0c1xyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUG9zc2libGUgcmVzdWx0c1xyXG4gICAqL1xuXG5cbiAgcG9zc2libGUocmVzdWx0cykge1xuICAgIGNvbnN0IHBvc3NpYmxlID0gW107XG4gICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMucGFyc2UocmVzdWx0KTtcblxuICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgIHBvc3NpYmxlLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwb3NzaWJsZTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFJlc3VsdFxyXG4gICAqIEByZXR1cm4ge0xvY2F0b3IuUmVzdWx0fSBMb2NhdG9yIHJlc3VsdFxyXG4gICAqL1xuXG5cbiAgcGFyc2UocmVzdWx0KSB7XG4gICAgY29uc3QgdHlwID0gcmVzdWx0LnJlcXVlc3Quc3BsaXQoJyAnKVswXSxcbiAgICAgICAgICByID0gcmVzdWx0LnJlc3BvbnNlO1xuICAgIGxldCBsbjEsIHAsIGE7XG5cbiAgICBpZiAodHlwID09PSAnaW50ZXJzZWN0aW9uJykge1xuICAgICAgbG4xID0gYCR7ci5zdHJlZXROYW1lMX0gYW5kICR7ci5zdHJlZXROYW1lMn1gO1xuICAgICAgcCA9IFtyLnhDb29yZGluYXRlICogMSwgci55Q29vcmRpbmF0ZSAqIDFdO1xuICAgICAgYSA9IF9Mb2NhdG9yLmRlZmF1bHQuQWNjdXJhY3kuTUVESVVNO1xuICAgIH0gZWxzZSBpZiAodHlwID09PSAnYmxvY2tmYWNlJykge1xuICAgICAgbG4xID0gci5maXJzdFN0cmVldE5hbWVOb3JtYWxpemVkICsgJyBidHduICcgKyByLnNlY29uZFN0cmVldE5hbWVOb3JtYWxpemVkICsgJyAmICcgKyByLnRoaXJkU3RyZWV0TmFtZU5vcm1hbGl6ZWQ7XG4gICAgICBwID0gWyhyLmZyb21YQ29vcmRpbmF0ZSAqIDEgKyByLnRvWENvb3JkaW5hdGUgKiAxKSAvIDIsIChyLmZyb21ZQ29vcmRpbmF0ZSAqIDEgKyByLnRvWUNvb3JkaW5hdGUgKiAxKSAvIDJdO1xuICAgICAgYSA9IF9Mb2NhdG9yLmRlZmF1bHQuQWNjdXJhY3kuTE9XO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBhZGRyZXNzLCBiYmwsIGJpbiwgcGxhY2UgKi9cbiAgICAgIGNvbnN0IHggPSByLmludGVybmFsTGFiZWxYQ29vcmRpbmF0ZTtcbiAgICAgIGNvbnN0IHkgPSByLmludGVybmFsTGFiZWxZQ29vcmRpbmF0ZTtcbiAgICAgIGxuMSA9IChyLmhvdXNlTnVtYmVyID8gci5ob3VzZU51bWJlciArICcgJyA6ICcnKSArIChyLmZpcnN0U3RyZWV0TmFtZU5vcm1hbGl6ZWQgfHwgci5naVN0cmVldE5hbWUxKTtcbiAgICAgIHAgPSBbKHggJiYgeSA/IHggOiByLnhDb29yZGluYXRlKSAqIDEsICh4ICYmIHkgPyB5IDogci55Q29vcmRpbmF0ZSkgKiAxXTtcbiAgICAgIGEgPSB4ICYmIHkgPyBfTG9jYXRvci5kZWZhdWx0LkFjY3VyYWN5LkhJR0ggOiBfTG9jYXRvci5kZWZhdWx0LkFjY3VyYWN5Lk1FRElVTTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2dlb2NvZGVkJyxcbiAgICAgICAgY29vcmRpbmF0ZTogdGhpcy5wcm9qZWN0KHApLFxuICAgICAgICBkYXRhOiByLFxuICAgICAgICBhY2N1cmFjeTogYSxcblxuICAgICAgICAvKiBhcHByb3hpbWF0aW9uICovXG4gICAgICAgIG5hbWU6IF8uZGVmYXVsdC5jYXBpdGFsaXplKGAke2xuMS5yZXBsYWNlKC8gICsvZywgJyAnKX0sICR7ci5maXJzdEJvcm91Z2hOYW1lfWApICsgYCwgTlkgJHtyLnppcENvZGUgfHwgci5sZWZ0U2VnbWVudFppcENvZGUgfHwgJyd9YFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChiYWRDb29yZCkge1xuICAgICAgY29uc29sZS53YXJuKCdObyBjb29yZGluYXRlJywgcmVzdWx0KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIFJlc29sdmVcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWplY3QgUmVzb2x2ZVxyXG4gICAqL1xuXG5cbiAgZXJyb3IoZXJyb3IsIHJlamVjdCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0dlb2NsaWVudCBlcnJvcicsIGVycm9yKTtcbiAgICByZWplY3Qoe1xuICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcignZXJyb3InLCBlcnJvcik7XG4gIH1cblxufVxuLyoqXHJcbiAqIEBkZXNjIENvbnN0cnVjdG9yIG9wdGlvbnMgZm9yIHtAbGluayBtb2R1bGU6bnljL0dlb2NsaWVudH5HZW9jbGllbnR9XHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVybCBUaGUgVVJMIGZvciBhY2Nlc3NpbmcgdGhlIEdlb2NsaWVudCBBUEkgKHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIuY2l0eW9mbmV3eW9yay51cy9hcGkvZ2VvY2xpZW50LWFwaX0pXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvamVjdGlvbj1FUFNHOjM4NTddIFRoZSBFUFNHIGNvZGUgb2YgdGhlIHByb2plY3Rpb24gZm9yIG91dHB1dCBnZW9tZXRyaWVzIChpLmUuIEVQU0c6MjI2MylcclxuICovXG5cblxuR2VvY2xpZW50Lk9wdGlvbnM7XG4vKipcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBBcnJheTxudW1iZXI+Pn1cclxuICovXG5cbkdlb2NsaWVudC5aSVBfQ09ERV9QT0lOVFMgPSB7XG4gICcxMDQ3NCc6IFsxMDE4NDY2LCAyMzM3ODddLFxuICAnMTA0NTUnOiBbMTAwNzg4OSwgMjM2NjE2XSxcbiAgJzEwMDM3JzogWzEwMDE2NjEsIDIzNTYyN10sXG4gICcxMDAyNCc6IFs5OTE0NTAsIDIyNTQ1N10sXG4gICcxMDQ1NCc6IFsxMDA3NDQ5LCAyMzI4NjNdLFxuICAnMTAwMjYnOiBbOTk3MTc5LCAyMzE4MzVdLFxuICAnMTAwMjUnOiBbOTkzMzMxLCAyMzAwMTJdLFxuICAnMTAwMzUnOiBbMTAwNjU5NSwgMjI4NDU0XSxcbiAgJzExMTAxJzogWzEwMDEzMTksIDIxMTAzNF0sXG4gICcxMTM2NCc6IFsxMDUxNTUzLCAyMTE5MjNdLFxuICAnMTAwMTgnOiBbOTg0Mjc4LCAyMTU1MDldLFxuICAnMTAwMjAnOiBbOTkwMDEyLCAyMTU3MjldLFxuICAnMTEwMDUnOiBbMTA2NDc4OSwgMjE0Mjk1XSxcbiAgJzEwMDE3JzogWzk5MTg2OSwgMjEzMjUyXSxcbiAgJzEwMDAxJzogWzk4MzYxMywgMjEzMzYwXSxcbiAgJzEwMDExJzogWzk4Mjc4MSwgMjEwNjY0XSxcbiAgJzEwMDE2JzogWzk5MDI5MSwgMjEwNjY1XSxcbiAgJzExMTA0JzogWzEwMDYyMjQsIDIxMDU2NF0sXG4gICcxMTEwOSc6IFs5OTYwNTQsIDIxMDc0MF0sXG4gICcxMDAxMCc6IFs5ODg5ODksIDIwODUxNV0sXG4gICcxMTM2Nyc6IFsxMDMyMzkyLCAyMDUzOTJdLFxuICAnMTAwMTQnOiBbOTgyNDQ5LCAyMDY2MjBdLFxuICAnMTAwMDMnOiBbOTg3NDY1LCAyMDU1NjNdLFxuICAnMTEyMjInOiBbOTk4NzczLCAyMDQ2MjBdLFxuICAnMTEzNzknOiBbMTAxNzQzMiwgMjAwNzQwXSxcbiAgJzExNDI5JzogWzEwNTY4NTksIDE5ODA1N10sXG4gICcxMTQzNSc6IFsxMDM2OTYwLCAxOTUwMThdLFxuICAnMTE0MTUnOiBbMTAzMTc5OCwgMTk3Mzc2XSxcbiAgJzExNDE4JzogWzEwMzEwMDEsIDE5MzMzMF0sXG4gICcxMTQzMyc6IFsxMDQzMzY4LCAxOTM3MjFdLFxuICAnMTE0NTEnOiBbMTAzOTg5OSwgMTk0Njk3XSxcbiAgJzExMjIxJzogWzEwMDQ0MzgsIDE5MTg3M10sXG4gICcxMTQyMSc6IFsxMDIzODc4LCAxOTEyNDFdLFxuICAnMTEzNzInOiBbMTAxNjUyOCwgMjEzMTI2XSxcbiAgJzExMDA0JzogWzEwNjU2MDYsIDIxMDM2M10sXG4gICcxMTA0MCc6IFsxMDY1OTU2LCAyMTM1MzRdLFxuICAnMTAwMDInOiBbOTg4MjQyLCAyMDAxNzFdLFxuICAnMTAzMTQnOiBbOTM5MjU5LCAxNTU3MjhdLFxuICAnMTEyMjgnOiBbOTgwODkxLCAxNjQwNjZdLFxuICAnMTEyMDknOiBbOTc2MTcyLCAxNjUzNzldLFxuICAnMTAzMDQnOiBbOTYyNDU4LCAxNjU2NzldLFxuICAnMTA0NTYnOiBbMTAwNzg4MywgMjQyMzcyXSxcbiAgJzEwNDcyJzogWzEwMjE0NDQsIDI0MTYyNF0sXG4gICcxMDAzMSc6IFs5OTgwODgsIDIzOTgxNF0sXG4gICcxMDAzOSc6IFsxMDAxNTE5LCAyNDA0MzZdLFxuICAnMTA0NTknOiBbMTAxMzgzNSwgMjQwMDg0XSxcbiAgJzEwNDUxJzogWzEwMDUzNjgsIDIzODI5MF0sXG4gICcxMDQ3Myc6IFsxMDIyNDc1LCAyMzcyMTddLFxuICAnMTAwMzAnOiBbMTAwMDE5MywgMjM3MzAyXSxcbiAgJzEwMDI3JzogWzk5OTA4OCwgMjM0MTMxXSxcbiAgJzEwNDYxJzogWzEwMjgyOTYsIDI0NzkwMl0sXG4gICcxMDQ1Nyc6IFsxMDEyMzg4LCAyNDc0MDVdLFxuICAnMTA0NjAnOiBbMTAxNTEzMiwgMjQzNTEwXSxcbiAgJzEwMDMyJzogWzEwMDAzODIsIDI0NDkxN10sXG4gICcxMDQ1Mic6IFsxMDA1NDQ2LCAyNDQ0ODNdLFxuICAnMTE0MTQnOiBbMTAyNzI1NiwgMTc4Njc3XSxcbiAgJzExMjMyJzogWzk4MzYxMiwgMTc3ODAxXSxcbiAgJzEwMDM0JzogWzEwMDU3MTMsIDI1NTEyMl0sXG4gICcxMDAzMyc6IFsxMDAxNzA3LCAyNDg3ODBdLFxuICAnMTA0NjInOiBbMTAyMDY4NSwgMjQ5NDIwXSxcbiAgJzEwMDQwJzogWzEwMDM4NjMsIDI1MTkxNF0sXG4gICcxMDQ1Myc6IFsxMDA4MTUyLCAyNDk4MDVdLFxuICAnMTExMDInOiBbMTAwNDYzNiwgMjIwMzY0XSxcbiAgJzEwMDIxJzogWzk5NzAyMCwgMjE5MTIwXSxcbiAgJzExMzYxJzogWzEwNDc3OTcsIDIxNzc3OV0sXG4gICcxMTM1OCc6IFsxMDQwNzA5LCAyMTYzNzddLFxuICAnMTEzNjInOiBbMTA1Nzc0OSwgMjE1MjIwXSxcbiAgJzEwMDQ0JzogWzk5NjM4NSwgMjE0MzQ3XSxcbiAgJzExMzY5JzogWzEwMTk5NTcsIDIxNzcyMl0sXG4gICcxMTEwMyc6IFsxMDA4Mjk1LCAyMTcxOTddLFxuICAnMTExMDYnOiBbMTAwMTM5NywgMjE3NTE5XSxcbiAgJzExMzY4JzogWzEwMjQ4NzAsIDIxMjA4Ml0sXG4gICcxMTM3Nyc6IFsxMDEwNTc0LCAyMTA2NzhdLFxuICAnMTAwMzYnOiBbOTg1NDEzLCAyMTY4MjFdLFxuICAnMTEzNTUnOiBbMTAzMzc2MiwgMjEzMDEwXSxcbiAgJzEwMzAyJzogWzk0NTk0NiwgMTY5MTI0XSxcbiAgJzEwNDY1JzogWzEwMzE0OTUsIDIzOTA5MV0sXG4gICcxMTY5MSc6IFsxMDUzNzgzLCAxNTg4MTBdLFxuICAnMTEwOTYnOiBbMTA1NDIxNywgMTYyMTk5XSxcbiAgJzExMjIzJzogWzk5MTY2NSwgMTU2NzgxXSxcbiAgJzExMjA4JzogWzEwMTk3MDAsIDE4NDc0OV0sXG4gICcxMTIwNyc6IFsxMDEzNTQ0LCAxODM3MjFdLFxuICAnMTE0MTMnOiBbMTA1MzM4MCwgMTgzMzI4XSxcbiAgJzExMjE3JzogWzk4OTU0NywgMTg3OTY3XSxcbiAgJzExMjM4JzogWzk5NDI5MSwgMTg2NTg0XSxcbiAgJzExMjMxJzogWzk4MzA1NywgMTg2MjE3XSxcbiAgJzExNDIyJzogWzEwNTcyNzIsIDE4MDYwN10sXG4gICcxMTQyMCc6IFsxMDM2ODk5LCAxODQ3MDhdLFxuICAnMTE0MTcnOiBbMTAyNzQxMCwgMTg1NzA5XSxcbiAgJzExMjE1JzogWzk4OTg4MiwgMTgxNzczXSxcbiAgJzExMzU3JzogWzEwMzY1MzMsIDIyNTgwNF0sXG4gICcxMDAyOSc6IFs5OTk5NTAsIDIyNzUzOF0sXG4gICcwMDA4Myc6IFs5OTE1OTAsIDIyMDUzOF0sXG4gICcxMTM1Nic6IFsxMDI4MTE1LCAyMjUyNzddLFxuICAnMTEzNTknOiBbMTA0NjAyNiwgMjI4MDEyXSxcbiAgJzEwMzAzJzogWzkzMzgyMCwgMTcxMDA0XSxcbiAgJzExMjM0JzogWzEwMDQzMjMsIDE2Mzc4M10sXG4gICcxMTM2MCc6IFsxMDQ0OTg0LCAyMjM4OTJdLFxuICAnMTExMDUnOiBbMTAxMTgzNiwgMjIxNzU1XSxcbiAgJzEwMTI4JzogWzk5Nzc2NSwgMjI0MjU3XSxcbiAgJzExMzcxJzogWzEwMjIwMDMsIDIyMDQ1N10sXG4gICcxMDAyMyc6IFs5ODg3NjUsIDIyMjA2OF0sXG4gICcxMTM2Myc6IFsxMDU1MDQ3LCAyMjAzODVdLFxuICAnMTAwMjgnOiBbOTk1OTEwLCAyMjI4NzJdLFxuICAnMTEzNTQnOiBbMTAzMjE5OCwgMjE5MDU0XSxcbiAgJzExMjE2JzogWzk5ODMxMiwgMTg3MjQxXSxcbiAgJzExNDE2JzogWzEwMjU3OTYsIDE4ODU4NF0sXG4gICcxMTIzMyc6IFsxMDA2NTIzLCAxODYzMDBdLFxuICAnMTE0MzYnOiBbMTA0MDY5NywgMTg1NTU0XSxcbiAgJzExMjEzJzogWzEwMDAyODQsIDE4MzMwOF0sXG4gICcxMTIxMic6IFsxMDA4Mzg3LCAxODA3NjRdLFxuICAnMTEyMjUnOiBbOTk3MzQ1LCAxODA4MjldLFxuICAnMTEyMTgnOiBbOTkwNzk5LCAxNzM2NDldLFxuICAnMTEyMjYnOiBbOTk1NzExLCAxNzQ1OThdLFxuICAnMTEyMTknOiBbOTg1MTY2LCAxNjk2MDRdLFxuICAnMTEyMTAnOiBbOTk5MTAxLCAxNjc4OTZdLFxuICAnMTEyMzAnOiBbOTkzNDk0LCAxNjYwNzJdLFxuICAnMTE0MTknOiBbMTAzMzM2NSwgMTkwMjAyXSxcbiAgJzExNDM0JzogWzEwNDY1NzcsIDE4NTk2OV0sXG4gICcxMTIwNCc6IFs5ODc4ODcsIDE2NDU3Nl0sXG4gICcxMDQ3MSc6IFsxMDEyNTg3LCAyNjY1NzBdLFxuICAnMTA0NzAnOiBbMTAyNDc0OCwgMjY4NDA5XSxcbiAgJzEwNDY2JzogWzEwMjQzMTMsIDI2Mzk5OV0sXG4gICcxMDQ2Nyc6IFsxMDE5Nzg2LCAyNTg3ODJdLFxuICAnMTE0MzAnOiBbMTA0MzYwNywgMTc1MDY4XSxcbiAgJzExMjAzJzogWzEwMDI1MDksIDE3NTk1MF0sXG4gICcxMDQ2OSc6IFsxMDI2Njc4LCAyNTU2MjNdLFxuICAnMTA0NjgnOiBbMTAxMzg5NywgMjU4MDQ2XSxcbiAgJzEwNDU4JzogWzEwMTU1MzQsIDI1MzcxMl0sXG4gICcxMTM3OCc6IFsxMDA5NjQxLCAyMDIxMTVdLFxuICAnMTAwMDknOiBbOTkwMDQzLCAyMDM5NjFdLFxuICAnMTAwMTInOiBbOTg0ODMyLCAyMDM1OTZdLFxuICAnMTAwMTMnOiBbOTgyODkyLCAyMDE2NjVdLFxuICAnMTAwMDcnOiBbOTgyNTA0LCAxOTk1NTJdLFxuICAnMTEyMzcnOiBbMTAwNDYwMCwgMTk3MDgzXSxcbiAgJzExMzg1JzogWzEwMTEzNjcsIDE5NTE5NV0sXG4gICcxMDAzOCc6IFs5ODM0MTgsIDE5NzgwM10sXG4gICcxMTIwNic6IFsxMDAwMjIxLCAxOTUwMDNdLFxuICAnMTAwMDYnOiBbOTgwNTYzLCAxOTcyOTNdLFxuICAnMTE0MTInOiBbMTA1MDc3MywgMTkzMjMxXSxcbiAgJzEwMDA1JzogWzk4MTMzOSwgMTk3MDM4XSxcbiAgJzExMjUxJzogWzk5MzQyOCwgMTk0NTk5XSxcbiAgJzExNDExJzogWzEwNTc3NjMsIDE5MjQxM10sXG4gICcxMTIwMSc6IFs5ODY5NjgsIDE5MjE1Nl0sXG4gICcxMDAwNCc6IFs5NzI1NzYsIDE5MzY1Ml0sXG4gICcxMTIwNSc6IFs5OTU4OTcsIDE5MjE1OV0sXG4gICcxMDMwNSc6IFs5NjMzMTAsIDE1NjA2MF0sXG4gICcxMTIyOSc6IFs5OTk3MTcsIDE1ODI3OF0sXG4gICcxMTIxNCc6IFs5ODQwMDAsIDE1OTMzMF0sXG4gICcxMDMwNic6IFs5NTA5MzcsIDE0NTE0NF0sXG4gICcxMTY5NCc6IFsxMDI1NTMwLCAxNDkzMTBdLFxuICAnMTEyMjQnOiBbOTg0MzA2LCAxNDkwOTJdLFxuICAnMTAzMDgnOiBbOTQyNzA0LCAxNDAwMjBdLFxuICAnMTAyODInOiBbOTc5OTgxLCAyMDAyNDRdLFxuICAnMTEyMTEnOiBbOTk5ODU3LCAxOTk4NDhdLFxuICAnMTEyNDknOiBbOTkzNzA0LCAxOTgyNzhdLFxuICAnMTEzNzAnOiBbMTAxNjc1OCwgMjI3NTE4XSxcbiAgJzEwMDY1JzogWzk5NDY2NiwgMjE3Njk4XSxcbiAgJzEwMDc1JzogWzk5NTMwMSwgMjIxNjMzXSxcbiAgJzEwMDY5JzogWzk4NzA0NywgMjIxODQ5XSxcbiAgJzEwMjgxJzogWzk4MDAzNiwgMTk4Nzg3XSxcbiAgJzExMzczJzogWzEwMTc5NDgsIDIwODQ2NV0sXG4gICcxMDI3OSc6IFs5ODE5NDksIDE5ODgyM10sXG4gICcxMDE2NSc6IFs5OTAxMjQsIDIxMzI4OF0sXG4gICcxMDE2OCc6IFs5OTA3MzMsIDIxMjk2MF0sXG4gICcxMDEwNSc6IFs5OTAwNjcsIDIxNzI1OV0sXG4gICcxMDExOCc6IFs5ODgyMTIsIDIxMTkzOV0sXG4gICcxMDE3Nic6IFs5OTAxMjMsIDIxNDQ5MF0sXG4gICcxMDE2Mic6IFs5OTc3MzksIDIxOTY2N10sXG4gICcxMDE3MCc6IFs5OTA5NTUsIDIxMzQ3MF0sXG4gICcxMDExMic6IFs5ODk3MzUsIDIxNTk0N10sXG4gICcxMDEyMic6IFs5ODY1NTAsIDIxMzE3OF0sXG4gICcxMDEwNyc6IFs5ODkwOTgsIDIxODQyNV0sXG4gICcxMDEwMyc6IFs5OTA3MDUsIDIxNjI3NV0sXG4gICcxMDE3NCc6IFs5OTEwOTQsIDIxMzEwNl0sXG4gICcxMDE2Nic6IFs5OTA3MzMsIDIxMzc5OF0sXG4gICcxMDE2OSc6IFs5OTA4NzIsIDIxNDA4OV0sXG4gICcxMDE2Nyc6IFs5OTEyNTksIDIxNDE5OV0sXG4gICcxMDE3Nyc6IFs5OTA5MjcsIDIxNDM4MV0sXG4gICcxMDE3Mic6IFs5OTEzOTgsIDIxNDQxN10sXG4gICcxMDE3MSc6IFs5OTE0MjYsIDIxNDcwOV0sXG4gICcxMDI3MCc6IFs5ODIwNjAsIDE5NjcxMF0sXG4gICcxMDEwNCc6IFs5OTAxMjMsIDIxNjMxMl0sXG4gICcxMDI3MSc6IFs5ODEzMzksIDE5NzI5M10sXG4gICcxMDExMCc6IFs5ODk0ODYsIDIxMzk0M10sXG4gICcxMDE3NSc6IFs5ODk4NDcsIDIxNDAxNl0sXG4gICcxMDE1MSc6IFs5OTE3MDIsIDIxNzMzMl0sXG4gICcxMDE3Myc6IFs5OTAwNDAsIDIxMzkwN10sXG4gICcxMDE3OCc6IFs5OTA0MjksIDIxMjgxNF0sXG4gICcxMDExOSc6IFs5ODYyMTcsIDIxMzA2OF0sXG4gICcxMDEyMSc6IFs5ODY0MzksIDIxMjQ4Nl0sXG4gICcxMDEyMyc6IFs5ODY4MjcsIDIxMzAzMl0sXG4gICcxMDEwNic6IFs5ODk2MjQsIDIxODAyNF0sXG4gICcxMDE1OCc6IFs5OTExNzcsIDIxMjEyMl0sXG4gICcxMDA0MSc6IFs5ODE3MjcsIDE5NTQzNV0sXG4gICcxMDEyMCc6IFs5ODcyNDIsIDIxMjQ0OV0sXG4gICcxMDI3OCc6IFs5ODMxMTMsIDE5OTg4MF0sXG4gICcxMDE1NSc6IFs5OTMxNDMsIDIxNjUzMV0sXG4gICcxMDA0Myc6IFs5ODIzMzcsIDE5NTgzNl0sXG4gICcxMDA4MSc6IFs5ODE4MzgsIDE5NzA3NF0sXG4gICcxMDA5Nic6IFs5ODkwNzEsIDIxNDIzNV0sXG4gICcxMDA5Nyc6IFs5ODg0NjEsIDIxNjkzMV0sXG4gICcxMDE5Nic6IFs5ODk0NTgsIDIxNDk2M10sXG4gICcxMDI3NSc6IFs5ODAzNjgsIDE5NjM4Ml0sXG4gICcxMDI2NSc6IFs5ODIwNjAsIDE5NjE2NF0sXG4gICcxMDA0NSc6IFs5ODE4NjYsIDE5NzMyOV0sXG4gICcxMDA0Nyc6IFs5ODgwNDcsIDIwODY2MF0sXG4gICcxMDA4MCc6IFs5ODA3ODUsIDE5ODE2N10sXG4gICcxMDIwMyc6IFs5ODEwNjIsIDE5Njk2NV0sXG4gICcxMDI1OSc6IFs5ODE0NzgsIDE5NzQzOV0sXG4gICcxMDI2MCc6IFs5ODE5MjEsIDE5NjU2NF0sXG4gICcxMDI4NSc6IFs5ODAxNDcsIDE5OTIyNF0sXG4gICcxMDI4Nic6IFs5ODE3MjcsIDE5NjYzN10sXG4gICcxMDQ2Myc6IFsxMDA3NjQ0LCAyNjAwNDNdLFxuICAnMTA0NzUnOiBbMTAzMDQ4OSwgMjU4NTA5XSxcbiAgJzEwNDY0JzogWzEwMzYxMzEsIDI1ODMzOF0sXG4gICcxMDMwOSc6IFs5MjM1OTQsIDEzMjk1NV0sXG4gICcxMDMwNyc6IFs5MTY4OTksIDEyNDQxMV0sXG4gICcxMDI4MCc6IFs5Nzk1MDksIDE5NzI1N10sXG4gICcxMDA0OCc6IFs5ODA4MTIsIDE5ODUzMl0sXG4gICcxMDA1NSc6IFs5OTE1NjQsIDIxNTgwMl0sXG4gICcxMDAxOSc6IFs5ODk2NTIsIDIxNzQ3N10sXG4gICcxMDExMSc6IFs5OTA0ODMsIDIxNTgzOF0sXG4gICcxMDE1Myc6IFs5OTE4OTYsIDIxNzQ3OF0sXG4gICcxMDE1NCc6IFs5OTE4OTYsIDIxNTMyOF0sXG4gICcxMDE1Mic6IFs5OTE5NzksIDIxNTU4NF0sXG4gICcxMDExNSc6IFs5OTQyOTksIDIzNDY3NV0sXG4gICcxMDAyMic6IFs5OTMwODcsIDIxNTYyMF0sXG4gICcxMTIzNSc6IFsxMDAwOTczLCAxNDk5MzZdLFxuICAnMTE2OTMnOiBbMTAzNjYwNiwgMTUzMjY2XSxcbiAgJzExNjkyJzogWzEwNDEwNDUsIDE1NTQ2MV0sXG4gICcxMTY5Nyc6IFsxMDA5MjMwLCAxNDMyNDBdLFxuICAnMTAzMTInOiBbOTM1NTgzLCAxMzY4MjddLFxuICAnMTEyMzknOiBbMTAyMTU3MywgMTc1ODk5XSxcbiAgJzExMjM2JzogWzEwMTE2NDIsIDE3MjQ2MV0sXG4gICcxMTIyMCc6IFs5Nzk0MjEsIDE3MjUxOV0sXG4gICcxMDMwMSc6IFs5NjEwNzcsIDE3Mjk2N10sXG4gICcxMDMxMCc6IFs5NTA1ODIsIDE2OTU5MV0sXG4gICcxMTQyNic6IFsxMDYwNzM3LCAyMDc3MjRdLFxuICAnMTEzNjUnOiBbMTA0MTM2NCwgMjA4NjE4XSxcbiAgJzExMDAxJzogWzEwNjU1MDgsIDIwNjY0Nl0sXG4gICcxMTM3NSc6IFsxMDI2ODgzLCAyMDE4NDhdLFxuICAnMTE0MjcnOiBbMTA1MzM3MywgMjA1MDQyXSxcbiAgJzExMzc0JzogWzEwMjIzODksIDIwMzc3MV0sXG4gICcxMTM2Nic6IFsxMDM5NDkxLCAyMDM2NTldLFxuICAnMTE0MjMnOiBbMTA0ODgxMiwgMjAwNjIxXSxcbiAgJzExNDI4JzogWzEwNTU2NTUsIDIwMjIwN10sXG4gICcxMTQzMic6IFsxMDQxNjM0LCAyMDAwOTNdXG59O1xudmFyIF9kZWZhdWx0ID0gR2VvY2xpZW50O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7Ozs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7O0FBTUE7QUFkQTtBQWVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOzs7O0FBcE5BO0FBdU5BOzs7Ozs7Ozs7QUFTQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4UEE7QUEwUEE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///78\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export DEFAULT_RADIUS */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getDistance; });\n/* unused harmony export getLength */\n/* unused harmony export getArea */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return offset; });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);\n/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/**\n * @license\n * Latitude/longitude spherical geodesy formulae taken from\n * http://www.movable-type.co.uk/scripts/latlong.html\n * Licensed under CC-BY-3.0.\n */\n\n/**\n * @module ol/sphere\n */\n\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import("./proj.js").ProjectionLike} [projection=\'EPSG:3857\']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the\n * earth is used (Clarke 1866 Authalic Sphere).\n */\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\n\nvar DEFAULT_RADIUS = 6371008.8;\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth\'s\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\n\nfunction getDistance(c1, c2, opt_radius) {\n  var radius = opt_radius || DEFAULT_RADIUS;\n  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "i"])(c1[1]);\n  var lat2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "i"])(c2[1]);\n  var deltaLatBy2 = (lat2 - lat1) / 2;\n  var deltaLonBy2 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "i"])(c2[0] - c1[0]) / 2;\n  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\n\nfunction getLengthInternal(coordinates, radius) {\n  var length = 0;\n\n  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n\n  return length;\n}\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import("./geom/Geometry.js").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the\n * length calculation.  By default, geometries are assumed to be in \'EPSG:3857\'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\n\n\nfunction getLength(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || DEFAULT_RADIUS;\n  var projection = options.projection || \'EPSG:3857\';\n  var type = geometry.getType();\n\n  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].GEOMETRY_COLLECTION) {\n    geometry = geometry.clone().transform(projection, \'EPSG:4326\');\n  }\n\n  var length = 0;\n  var coordinates, coords, i, ii, j, jj;\n\n  switch (type) {\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINT:\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_POINT:\n      {\n        break;\n      }\n\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINE_STRING:\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINEAR_RING:\n      {\n        coordinates =\n        /** @type {import("./geom/SimpleGeometry.js").default} */\n        geometry.getCoordinates();\n        length = getLengthInternal(coordinates, radius);\n        break;\n      }\n\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_LINE_STRING:\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POLYGON:\n      {\n        coordinates =\n        /** @type {import("./geom/SimpleGeometry.js").default} */\n        geometry.getCoordinates();\n\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          length += getLengthInternal(coordinates[i], radius);\n        }\n\n        break;\n      }\n\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_POLYGON:\n      {\n        coordinates =\n        /** @type {import("./geom/SimpleGeometry.js").default} */\n        geometry.getCoordinates();\n\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n\n          for (j = 0, jj = coords.length; j < jj; ++j) {\n            length += getLengthInternal(coords[j], radius);\n          }\n        }\n\n        break;\n      }\n\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].GEOMETRY_COLLECTION:\n      {\n        var geometries =\n        /** @type {import("./geom/GeometryCollection.js").default} */\n        geometry.getGeometries();\n\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          length += getLength(geometries[i], opt_options);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        throw new Error(\'Unsupported geometry type: \' + type);\n      }\n  }\n\n  return length;\n}\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for\n * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\n\nfunction getAreaInternal(coordinates, radius) {\n  var area = 0;\n  var len = coordinates.length;\n  var x1 = coordinates[len - 1][0];\n  var y1 = coordinates[len - 1][1];\n\n  for (var i = 0; i < len; i++) {\n    var x2 = coordinates[i][0];\n    var y2 = coordinates[i][1];\n    area += Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "i"])(x2 - x1) * (2 + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "i"])(y1)) + Math.sin(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "i"])(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return area * radius * radius / 2.0;\n}\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import("./geom/Geometry.js").default} geometry A geometry.\n * @param {SphereMetricOptions=} opt_options Options for the area\n *     calculation.  By default, geometries are assumed to be in \'EPSG:3857\'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\n\n\nfunction getArea(geometry, opt_options) {\n  var options = opt_options || {};\n  var radius = options.radius || DEFAULT_RADIUS;\n  var projection = options.projection || \'EPSG:3857\';\n  var type = geometry.getType();\n\n  if (type !== _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].GEOMETRY_COLLECTION) {\n    geometry = geometry.clone().transform(projection, \'EPSG:4326\');\n  }\n\n  var area = 0;\n  var coordinates, coords, i, ii, j, jj;\n\n  switch (type) {\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POINT:\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_POINT:\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINE_STRING:\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_LINE_STRING:\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LINEAR_RING:\n      {\n        break;\n      }\n\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].POLYGON:\n      {\n        coordinates =\n        /** @type {import("./geom/Polygon.js").default} */\n        geometry.getCoordinates();\n        area = Math.abs(getAreaInternal(coordinates[0], radius));\n\n        for (i = 1, ii = coordinates.length; i < ii; ++i) {\n          area -= Math.abs(getAreaInternal(coordinates[i], radius));\n        }\n\n        break;\n      }\n\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].MULTI_POLYGON:\n      {\n        coordinates =\n        /** @type {import("./geom/SimpleGeometry.js").default} */\n        geometry.getCoordinates();\n\n        for (i = 0, ii = coordinates.length; i < ii; ++i) {\n          coords = coordinates[i];\n          area += Math.abs(getAreaInternal(coords[0], radius));\n\n          for (j = 1, jj = coords.length; j < jj; ++j) {\n            area -= Math.abs(getAreaInternal(coords[j], radius));\n          }\n        }\n\n        break;\n      }\n\n    case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].GEOMETRY_COLLECTION:\n      {\n        var geometries =\n        /** @type {import("./geom/GeometryCollection.js").default} */\n        geometry.getGeometries();\n\n        for (i = 0, ii = geometries.length; i < ii; ++i) {\n          area += getArea(geometries[i], opt_options);\n        }\n\n        break;\n      }\n\n    default:\n      {\n        throw new Error(\'Unsupported geometry type: \' + type);\n      }\n  }\n\n  return area;\n}\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth\'s\n *     mean radius using the WGS84 ellipsoid.\n * @return {import("./coordinate.js").Coordinate} The target point.\n */\n\nfunction offset(c1, distance, bearing, opt_radius) {\n  var radius = opt_radius || DEFAULT_RADIUS;\n  var lat1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "i"])(c1[1]);\n  var lon1 = Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toRadians */ "i"])(c1[0]);\n  var dByR = distance / radius;\n  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));\n  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));\n  return [Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toDegrees */ "h"])(lon), Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[/* toDegrees */ "h"])(lat)];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL3NwaGVyZS5qcz85ZTBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIExhdGl0dWRlL2xvbmdpdHVkZSBzcGhlcmljYWwgZ2VvZGVzeSBmb3JtdWxhZSB0YWtlbiBmcm9tXG4gKiBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxuICogTGljZW5zZWQgdW5kZXIgQ0MtQlktMy4wLlxuICovXG5cbi8qKlxuICogQG1vZHVsZSBvbC9zcGhlcmVcbiAqL1xuaW1wb3J0IHt0b1JhZGlhbnMsIHRvRGVncmVlc30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBPYmplY3QgbGl0ZXJhbCB3aXRoIG9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgZ2V0TGVuZ3RofSBvciB7QGxpbmsgZ2V0QXJlYX1cbiAqIGZ1bmN0aW9ucy5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNwaGVyZU1ldHJpY09wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J11cbiAqIFByb2plY3Rpb24gb2YgdGhlICBnZW9tZXRyeS4gIEJ5IGRlZmF1bHQsIHRoZSBnZW9tZXRyeSBpcyBhc3N1bWVkIHRvIGJlIGluXG4gKiBXZWIgTWVyY2F0b3IuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1cz02MzcxMDA4LjhdIFNwaGVyZSByYWRpdXMuICBCeSBkZWZhdWx0LCB0aGUgcmFkaXVzIG9mIHRoZVxuICogZWFydGggaXMgdXNlZCAoQ2xhcmtlIDE4NjYgQXV0aGFsaWMgU3BoZXJlKS5cbiAqL1xuXG5cbi8qKlxuICogVGhlIG1lYW4gRWFydGggcmFkaXVzICgxLzMgKiAoMmEgKyBiKSkgZm9yIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FYXJ0aF9yYWRpdXMjTWVhbl9yYWRpdXNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX1JBRElVUyA9IDYzNzEwMDguODtcblxuXG4vKipcbiAqIEdldCB0aGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIChpbiBtZXRlcnMpIGJldHdlZW4gdHdvIGdlb2dyYXBoaWMgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge0FycmF5fSBjMSBTdGFydGluZyBjb29yZGluYXRlLlxuICogQHBhcmFtIHtBcnJheX0gYzIgRW5kaW5nIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9yYWRpdXMgVGhlIHNwaGVyZSByYWRpdXMgdG8gdXNlLiAgRGVmYXVsdHMgdG8gdGhlIEVhcnRoJ3NcbiAqICAgICBtZWFuIHJhZGl1cyB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ3JlYXQgY2lyY2xlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50cyAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGMxLCBjMiwgb3B0X3JhZGl1cykge1xuICBjb25zdCByYWRpdXMgPSBvcHRfcmFkaXVzIHx8IERFRkFVTFRfUkFESVVTO1xuICBjb25zdCBsYXQxID0gdG9SYWRpYW5zKGMxWzFdKTtcbiAgY29uc3QgbGF0MiA9IHRvUmFkaWFucyhjMlsxXSk7XG4gIGNvbnN0IGRlbHRhTGF0QnkyID0gKGxhdDIgLSBsYXQxKSAvIDI7XG4gIGNvbnN0IGRlbHRhTG9uQnkyID0gdG9SYWRpYW5zKGMyWzBdIC0gYzFbMF0pIC8gMjtcbiAgY29uc3QgYSA9IE1hdGguc2luKGRlbHRhTGF0QnkyKSAqIE1hdGguc2luKGRlbHRhTGF0QnkyKSArXG4gICAgICBNYXRoLnNpbihkZWx0YUxvbkJ5MikgKiBNYXRoLnNpbihkZWx0YUxvbkJ5MikgKlxuICAgICAgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgcmV0dXJuIDIgKiByYWRpdXMgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1bXVsYXRpdmUgZ3JlYXQgY2lyY2xlIGxlbmd0aCBvZiBsaW5lc3RyaW5nIGNvb3JkaW5hdGVzIChnZW9ncmFwaGljKS5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkaW5hdGVzIExpbmVzdHJpbmcgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzIHRvIHVzZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxlbmd0aCAoaW4gbWV0ZXJzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cykge1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWkgLSAxOyArK2kpIHtcbiAgICBsZW5ndGggKz0gZ2V0RGlzdGFuY2UoY29vcmRpbmF0ZXNbaV0sIGNvb3JkaW5hdGVzW2kgKyAxXSwgcmFkaXVzKTtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgbGVuZ3RoIG9mIGEgZ2VvbWV0cnkuICBUaGlzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZVxuICogZ3JlYXQgY2lyY2xlIGRpc3RhbmNlcyBiZXR3ZWVuIGNvb3JkaW5hdGVzLiAgRm9yIHBvbHlnb25zLCB0aGUgbGVuZ3RoIGlzXG4gKiB0aGUgc3VtIG9mIGFsbCByaW5ncy4gIEZvciBwb2ludHMsIHRoZSBsZW5ndGggaXMgemVyby4gIEZvciBtdWx0aS1wYXJ0XG4gKiBnZW9tZXRyaWVzLCB0aGUgbGVuZ3RoIGlzIHRoZSBzdW0gb2YgdGhlIGxlbmd0aCBvZiBlYWNoIHBhcnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBBIGdlb21ldHJ5LlxuICogQHBhcmFtIHtTcGhlcmVNZXRyaWNPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucyBmb3IgdGhlXG4gKiBsZW5ndGggY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogWW91IGNhbiBjaGFuZ2UgdGhpcyBieSBwcm92aWRpbmcgYSBgcHJvamVjdGlvbmAgb3B0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3BoZXJpY2FsIGxlbmd0aCAoaW4gbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExlbmd0aChnZW9tZXRyeSwgb3B0X29wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbiB8fCAnRVBTRzozODU3JztcbiAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgaWYgKHR5cGUgIT09IEdlb21ldHJ5VHlwZS5HRU9NRVRSWV9DT0xMRUNUSU9OKSB7XG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpLnRyYW5zZm9ybShwcm9qZWN0aW9uLCAnRVBTRzo0MzI2Jyk7XG4gIH1cbiAgbGV0IGxlbmd0aCA9IDA7XG4gIGxldCBjb29yZGluYXRlcywgY29vcmRzLCBpLCBpaSwgaiwgamo7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPSU5UOlxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UOiB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORUFSX1JJTkc6IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgbGVuZ3RoID0gZ2V0TGVuZ3RoSW50ZXJuYWwoY29vcmRpbmF0ZXMsIHJhZGl1cyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9MWUdPTjoge1xuICAgICAgY29vcmRpbmF0ZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3JkaW5hdGVzW2ldLCByYWRpdXMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGdldExlbmd0aEludGVybmFsKGNvb3Jkc1tqXSwgcmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT046IHtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBsZW5ndGggKz0gZ2V0TGVuZ3RoKGdlb21ldHJpZXNbaV0sIG9wdF9vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGU6ICcgKyB0eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aDtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNwaGVyaWNhbCBhcmVhIGZvciBhIGxpc3Qgb2YgY29vcmRpbmF0ZXMuXG4gKlxuICogW1JlZmVyZW5jZV0oaHR0cHM6Ly90cnMtbmV3LmpwbC5uYXNhLmdvdi9oYW5kbGUvMjAxNC80MDQwOSlcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogTGFib3JhdG9yeSwgUGFzYWRlbmEsIENBLCBKdW5lIDIwMDdcbiAqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gY29vcmRpbmF0ZXMgTGlzdCBvZiBjb29yZGluYXRlcyBvZiBhIGxpbmVhclxuICogcmluZy4gSWYgdGhlIHJpbmcgaXMgb3JpZW50ZWQgY2xvY2t3aXNlLCB0aGUgYXJlYSB3aWxsIGJlIHBvc2l0aXZlLFxuICogb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIFRoZSBzcGhlcmUgcmFkaXVzLlxuICogQHJldHVybiB7bnVtYmVyfSBBcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJlYUludGVybmFsKGNvb3JkaW5hdGVzLCByYWRpdXMpIHtcbiAgbGV0IGFyZWEgPSAwO1xuICBjb25zdCBsZW4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIGxldCB4MSA9IGNvb3JkaW5hdGVzW2xlbiAtIDFdWzBdO1xuICBsZXQgeTEgPSBjb29yZGluYXRlc1tsZW4gLSAxXVsxXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHgyID0gY29vcmRpbmF0ZXNbaV1bMF07XG4gICAgY29uc3QgeTIgPSBjb29yZGluYXRlc1tpXVsxXTtcbiAgICBhcmVhICs9IHRvUmFkaWFucyh4MiAtIHgxKSAqXG4gICAgICAgICgyICsgTWF0aC5zaW4odG9SYWRpYW5zKHkxKSkgK1xuICAgICAgICBNYXRoLnNpbih0b1JhZGlhbnMoeTIpKSk7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIHJldHVybiBhcmVhICogcmFkaXVzICogcmFkaXVzIC8gMi4wO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBzcGhlcmljYWwgYXJlYSBvZiBhIGdlb21ldHJ5LiAgVGhpcyBpcyB0aGUgYXJlYSAoaW4gbWV0ZXJzKSBhc3N1bWluZ1xuICogdGhhdCBwb2x5Z29uIGVkZ2VzIGFyZSBzZWdtZW50cyBvZiBncmVhdCBjaXJjbGVzIG9uIGEgc3BoZXJlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgQSBnZW9tZXRyeS5cbiAqIEBwYXJhbSB7U3BoZXJlTWV0cmljT3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBhcmVhXG4gKiAgICAgY2FsY3VsYXRpb24uICBCeSBkZWZhdWx0LCBnZW9tZXRyaWVzIGFyZSBhc3N1bWVkIHRvIGJlIGluICdFUFNHOjM4NTcnLlxuICogICAgIFlvdSBjYW4gY2hhbmdlIHRoaXMgYnkgcHJvdmlkaW5nIGEgYHByb2plY3Rpb25gIG9wdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNwaGVyaWNhbCBhcmVhIChpbiBzcXVhcmUgbWV0ZXJzKS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyZWEoZ2VvbWV0cnksIG9wdF9vcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgREVGQVVMVF9SQURJVVM7XG4gIGNvbnN0IHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gfHwgJ0VQU0c6Mzg1Nyc7XG4gIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gIGlmICh0eXBlICE9PSBHZW9tZXRyeVR5cGUuR0VPTUVUUllfQ09MTEVDVElPTikge1xuICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKS50cmFuc2Zvcm0ocHJvamVjdGlvbiwgJ0VQU0c6NDMyNicpO1xuICB9XG4gIGxldCBhcmVhID0gMDtcbiAgbGV0IGNvb3JkaW5hdGVzLCBjb29yZHMsIGksIGlpLCBqLCBqajtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuUE9JTlQ6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORUFSX1JJTkc6IHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0xZR09OOiB7XG4gICAgICBjb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgYXJlYSA9IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZGluYXRlc1swXSwgcmFkaXVzKSk7XG4gICAgICBmb3IgKGkgPSAxLCBpaSA9IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgYXJlYSAtPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRpbmF0ZXNbaV0sIHJhZGl1cykpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046IHtcbiAgICAgIGNvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvb3JkcyA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBhcmVhICs9IE1hdGguYWJzKGdldEFyZWFJbnRlcm5hbChjb29yZHNbMF0sIHJhZGl1cykpO1xuICAgICAgICBmb3IgKGogPSAxLCBqaiA9IGNvb3Jkcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgYXJlYSAtPSBNYXRoLmFicyhnZXRBcmVhSW50ZXJuYWwoY29vcmRzW2pdLCByYWRpdXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT046IHtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9HZW9tZXRyeUNvbGxlY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRHZW9tZXRyaWVzKCk7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBhcmVhICs9IGdldEFyZWEoZ2VvbWV0cmllc1tpXSwgb3B0X29wdGlvbnMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZTogJyArIHR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJlYTtcbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGUgYXQgdGhlIGdpdmVuIGRpc3RhbmNlIGFuZCBiZWFyaW5nIGZyb20gYGMxYC5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjMSBUaGUgb3JpZ2luIHBvaW50IChgW2xvbiwgbGF0XWAgaW4gZGVncmVlcykuXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgVGhlIGdyZWF0LWNpcmNsZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBvcmlnaW5cbiAqICAgICBwb2ludCBhbmQgdGhlIHRhcmdldCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIFRoZSBiZWFyaW5nIChpbiByYWRpYW5zKS5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3JhZGl1cyBUaGUgc3BoZXJlIHJhZGl1cyB0byB1c2UuICBEZWZhdWx0cyB0byB0aGUgRWFydGgnc1xuICogICAgIG1lYW4gcmFkaXVzIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gVGhlIHRhcmdldCBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChjMSwgZGlzdGFuY2UsIGJlYXJpbmcsIG9wdF9yYWRpdXMpIHtcbiAgY29uc3QgcmFkaXVzID0gb3B0X3JhZGl1cyB8fCBERUZBVUxUX1JBRElVUztcbiAgY29uc3QgbGF0MSA9IHRvUmFkaWFucyhjMVsxXSk7XG4gIGNvbnN0IGxvbjEgPSB0b1JhZGlhbnMoYzFbMF0pO1xuICBjb25zdCBkQnlSID0gZGlzdGFuY2UgLyByYWRpdXM7XG4gIGNvbnN0IGxhdCA9IE1hdGguYXNpbihcbiAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGRCeVIpICtcbiAgICAgIE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhiZWFyaW5nKSk7XG4gIGNvbnN0IGxvbiA9IGxvbjEgKyBNYXRoLmF0YW4yKFxuICAgIE1hdGguc2luKGJlYXJpbmcpICogTWF0aC5zaW4oZEJ5UikgKiBNYXRoLmNvcyhsYXQxKSxcbiAgICBNYXRoLmNvcyhkQnlSKSAtIE1hdGguc2luKGxhdDEpICogTWF0aC5zaW4obGF0KSk7XG4gIHJldHVybiBbdG9EZWdyZWVzKGxvbiksIHRvRGVncmVlcyhsYXQpXTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUF0Q0E7QUFDQTtBQXVDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBcENBO0FBQ0E7QUFxQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///79\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shared; });\n/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);\n/**\n * @module ol/style/IconImageCache\n */\n\n/**\n * @classdesc\n * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.\n */\n\nvar IconImageCache = function IconImageCache() {\n  /**\n  * @type {!Object<string, import("./IconImage.js").default>}\n  * @private\n  */\n  this.cache_ = {};\n  /**\n  * @type {number}\n  * @private\n  */\n\n  this.cacheSize_ = 0;\n  /**\n  * @type {number}\n  * @private\n  */\n\n  this.maxCacheSize_ = 32;\n};\n/**\n* FIXME empty description for jsdoc\n*/\n\n\nIconImageCache.prototype.clear = function clear() {\n  this.cache_ = {};\n  this.cacheSize_ = 0;\n};\n/**\n* FIXME empty description for jsdoc\n*/\n\n\nIconImageCache.prototype.expire = function expire() {\n  if (this.cacheSize_ > this.maxCacheSize_) {\n    var i = 0;\n\n    for (var key in this.cache_) {\n      var iconImage = this.cache_[key];\n\n      if ((i++ & 3) === 0 && !iconImage.hasListener()) {\n        delete this.cache_[key];\n        --this.cacheSize_;\n      }\n    }\n  }\n};\n/**\n* @param {string} src Src.\n* @param {?string} crossOrigin Cross origin.\n* @param {import("../color.js").Color} color Color.\n* @return {import("./IconImage.js").default} Icon image.\n*/\n\n\nIconImageCache.prototype.get = function get(src, crossOrigin, color) {\n  var key = getKey(src, crossOrigin, color);\n  return key in this.cache_ ? this.cache_[key] : null;\n};\n/**\n* @param {string} src Src.\n* @param {?string} crossOrigin Cross origin.\n* @param {import("../color.js").Color} color Color.\n* @param {import("./IconImage.js").default} iconImage Icon image.\n*/\n\n\nIconImageCache.prototype.set = function set(src, crossOrigin, color, iconImage) {\n  var key = getKey(src, crossOrigin, color);\n  this.cache_[key] = iconImage;\n  ++this.cacheSize_;\n};\n/**\n* Set the cache size of the icon cache. Default is `32`. Change this value when\n* your map uses more than 32 different icon images and you are not caching icon\n* styles on the application level.\n* @param {number} maxCacheSize Cache max size.\n* @api\n*/\n\n\nIconImageCache.prototype.setSize = function setSize(maxCacheSize) {\n  this.maxCacheSize_ = maxCacheSize;\n  this.expire();\n};\n/**\n * @param {string} src Src.\n * @param {?string} crossOrigin Cross origin.\n * @param {import("../color.js").Color} color Color.\n * @return {string} Cache key.\n */\n\n\nfunction getKey(src, crossOrigin, color) {\n  var colorString = color ? Object(_color_js__WEBPACK_IMPORTED_MODULE_0__[/* asString */ "b"])(color) : \'null\';\n  return crossOrigin + \':\' + src + \':\' + colorString;\n}\n\n/* unused harmony default export */ var _unused_webpack_default_export = (IconImageCache);\n/**\n * The {@link module:ol/style/IconImageCache~IconImageCache} for\n * {@link module:ol/style/Icon~Icon} images.\n * @api\n */\n\nvar shared = new IconImageCache();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL0ljb25JbWFnZUNhY2hlLmpzPzgzNzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ljb25JbWFnZUNhY2hlXG4gKi9cbmltcG9ydCB7YXNTdHJpbmd9IGZyb20gJy4uL2NvbG9yLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTaW5nbGV0b24gY2xhc3MuIEF2YWlsYWJsZSB0aHJvdWdoIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbkltYWdlQ2FjaGV+c2hhcmVkfS5cbiAqL1xuY2xhc3MgSWNvbkltYWdlQ2FjaGUge1xuICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIC8qKlxuICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL0ljb25JbWFnZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLmNhY2hlXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuY2FjaGVTaXplXyA9IDA7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5tYXhDYWNoZVNpemVfID0gMzI7XG4gIH1cblxuICAvKipcbiAgKiBGSVhNRSBlbXB0eSBkZXNjcmlwdGlvbiBmb3IganNkb2NcbiAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jYWNoZV8gPSB7fTtcbiAgICB0aGlzLmNhY2hlU2l6ZV8gPSAwO1xuICB9XG5cbiAgLyoqXG4gICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICovXG4gIGV4cGlyZSgpIHtcbiAgICBpZiAodGhpcy5jYWNoZVNpemVfID4gdGhpcy5tYXhDYWNoZVNpemVfKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNhY2hlXykge1xuICAgICAgICBjb25zdCBpY29uSW1hZ2UgPSB0aGlzLmNhY2hlX1trZXldO1xuICAgICAgICBpZiAoKGkrKyAmIDMpID09PSAwICYmICFpY29uSW1hZ2UuaGFzTGlzdGVuZXIoKSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlX1trZXldO1xuICAgICAgICAgIC0tdGhpcy5jYWNoZVNpemVfO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTcmMuXG4gICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi9JY29uSW1hZ2UuanNcIikuZGVmYXVsdH0gSWNvbiBpbWFnZS5cbiAgKi9cbiAgZ2V0KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKTtcbiAgICByZXR1cm4ga2V5IGluIHRoaXMuY2FjaGVfID8gdGhpcy5jYWNoZV9ba2V5XSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAgKiBAcGFyYW0gez9zdHJpbmd9IGNyb3NzT3JpZ2luIENyb3NzIG9yaWdpbi5cbiAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiAgKiBAcGFyYW0ge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR9IGljb25JbWFnZSBJY29uIGltYWdlLlxuICAqL1xuICBzZXQoc3JjLCBjcm9zc09yaWdpbiwgY29sb3IsIGljb25JbWFnZSkge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcik7XG4gICAgdGhpcy5jYWNoZV9ba2V5XSA9IGljb25JbWFnZTtcbiAgICArK3RoaXMuY2FjaGVTaXplXztcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgY2FjaGUgc2l6ZSBvZiB0aGUgaWNvbiBjYWNoZS4gRGVmYXVsdCBpcyBgMzJgLiBDaGFuZ2UgdGhpcyB2YWx1ZSB3aGVuXG4gICogeW91ciBtYXAgdXNlcyBtb3JlIHRoYW4gMzIgZGlmZmVyZW50IGljb24gaW1hZ2VzIGFuZCB5b3UgYXJlIG5vdCBjYWNoaW5nIGljb25cbiAgKiBzdHlsZXMgb24gdGhlIGFwcGxpY2F0aW9uIGxldmVsLlxuICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDYWNoZVNpemUgQ2FjaGUgbWF4IHNpemUuXG4gICogQGFwaVxuICAqL1xuICBzZXRTaXplKG1heENhY2hlU2l6ZSkge1xuICAgIHRoaXMubWF4Q2FjaGVTaXplXyA9IG1heENhY2hlU2l6ZTtcbiAgICB0aGlzLmV4cGlyZSgpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNyYy5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IENhY2hlIGtleS5cbiAqL1xuZnVuY3Rpb24gZ2V0S2V5KHNyYywgY3Jvc3NPcmlnaW4sIGNvbG9yKSB7XG4gIGNvbnN0IGNvbG9yU3RyaW5nID0gY29sb3IgPyBhc1N0cmluZyhjb2xvcikgOiAnbnVsbCc7XG4gIHJldHVybiBjcm9zc09yaWdpbiArICc6JyArIHNyYyArICc6JyArIGNvbG9yU3RyaW5nO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEljb25JbWFnZUNhY2hlO1xuXG5cbi8qKlxuICogVGhlIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvSWNvbkltYWdlQ2FjaGV+SWNvbkltYWdlQ2FjaGV9IGZvclxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZS9JY29ufkljb259IGltYWdlcy5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYXJlZCA9IG5ldyBJY29uSW1hZ2VDYWNoZSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7OztBQUdBOzs7Ozs7QUFNQTtBQUdBOzs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQVFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///80\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(13);\n\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/transform.js\nvar flat_transform = __webpack_require__(34);\n\n// EXTERNAL MODULE: ./node_modules/ol/obj.js\nvar obj = __webpack_require__(12);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./node_modules/ol/render/ReplayGroup.js\n/**\n * @module ol/render/ReplayGroup\n */\n\n/**\n * Base class for replay groups.\n */\n\nvar ReplayGroup_ReplayGroup = function ReplayGroup() {};\n\nReplayGroup_ReplayGroup.prototype.getReplay = function getReplay(zIndex, replayType) {\n  return Object(util["b" /* abstract */])();\n};\n/**\n * @abstract\n * @return {boolean} Is empty.\n */\n\n\nReplayGroup_ReplayGroup.prototype.isEmpty = function isEmpty() {\n  return Object(util["b" /* abstract */])();\n};\n/**\n * @abstract\n * @param {boolean} group Group with previous replay\n * @return {Array<*>} The resulting instruction group\n */\n\n\nReplayGroup_ReplayGroup.prototype.addDeclutter = function addDeclutter(group) {\n  return Object(util["b" /* abstract */])();\n};\n\n/* harmony default export */ var render_ReplayGroup = (ReplayGroup_ReplayGroup);\n// EXTERNAL MODULE: ./node_modules/ol/render/ReplayType.js\nvar ReplayType = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./node_modules/ol/colorlike.js\nvar colorlike = __webpack_require__(39);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent/Relationship.js\nvar Relationship = __webpack_require__(25);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js\nvar GeometryType = __webpack_require__(3);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js\nvar inflate = __webpack_require__(32);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/length.js\nvar flat_length = __webpack_require__(96);\n\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./node_modules/ol/geom/flat/textpath.js\n/**\n * @module ol/geom/flat/textpath\n */\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {function(string):number} measure Measure function returning the\n * width of the character passed as 1st argument.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @return {Array<Array<*>>} The result array of null if `maxAngle` was\n * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\n */\n\nfunction drawTextOnPath(flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\n  var result = []; // Keep text upright\n\n  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n  var numChars = text.length;\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var segmentM = 0;\n  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  var chunk = \'\';\n  var chunkLength = 0;\n  var data, index, previousAngle;\n\n  for (var i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n\n    var _char = text.charAt(index);\n\n    chunk = reverse ? _char + chunk : chunk + _char;\n    var charLength = measure(chunk) - chunkLength;\n    chunkLength += charLength;\n    var charM = startM + charLength / 2;\n\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n\n    var segmentPos = charM - segmentM;\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;\n\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n\n    var interpolate = segmentPos / segmentLength;\n    var x = Object(math["c" /* lerp */])(x1, x2, interpolate);\n    var y = Object(math["c" /* lerp */])(y1, y2, interpolate);\n\n    if (previousAngle == angle) {\n      if (reverse) {\n        data[0] = x;\n        data[1] = y;\n        data[2] = charLength / 2;\n      }\n\n      data[4] = chunk;\n    } else {\n      chunk = _char;\n      chunkLength = charLength;\n      data = [x, y, charLength / 2, angle, chunk];\n\n      if (reverse) {\n        result.unshift(data);\n      } else {\n        result.push(data);\n      }\n\n      previousAngle = angle;\n    }\n\n    startM += charLength;\n  }\n\n  return result;\n}\n// EXTERNAL MODULE: ./node_modules/ol/has.js\nvar has = __webpack_require__(19);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/VectorContext.js\nvar render_VectorContext = __webpack_require__(99);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js\nvar render_canvas = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Instruction.js\n/**\n * @module ol/render/canvas/Instruction\n */\n\n/**\n * @enum {number}\n */\nvar Instruction = {\n  BEGIN_GEOMETRY: 0,\n  BEGIN_PATH: 1,\n  CIRCLE: 2,\n  CLOSE_PATH: 3,\n  CUSTOM: 4,\n  DRAW_CHARS: 5,\n  DRAW_IMAGE: 6,\n  END_GEOMETRY: 7,\n  FILL: 8,\n  MOVE_TO_LINE_TO: 9,\n  SET_FILL_STYLE: 10,\n  SET_STROKE_STYLE: 11,\n  STROKE: 12\n};\n/**\n * @type {Array<Instruction>}\n */\n\nvar Instruction_fillInstruction = [Instruction.FILL];\n/**\n * @type {Array<Instruction>}\n */\n\nvar Instruction_strokeInstruction = [Instruction.STROKE];\n/**\n * @type {Array<Instruction>}\n */\n\nvar beginPathInstruction = [Instruction.BEGIN_PATH];\n/**\n * @type {Array<Instruction>}\n */\n\nvar closePathInstruction = [Instruction.CLOSE_PATH];\n/* harmony default export */ var canvas_Instruction = (Instruction);\n// EXTERNAL MODULE: ./node_modules/ol/render/replay.js\nvar render_replay = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./node_modules/ol/transform.js\nvar ol_transform = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./node_modules/ol/render/canvas/Replay.js\n/**\n * @module ol/render/canvas/Replay\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @type {import("../../extent.js").Extent}\n */\n\nvar tmpExtent = Object(ol_extent["createEmpty"])();\n/**\n * @type {!import("../../transform.js").Transform}\n */\n\nvar tmpTransform = Object(ol_transform["c" /* create */])();\n\nvar Replay_CanvasReplay =\n/*@__PURE__*/\nfunction (VectorContext) {\n  function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    VectorContext.call(this);\n    /**\n     * @type {?}\n     */\n\n    this.declutterTree = declutterTree;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.tolerance = tolerance;\n    /**\n     * @protected\n     * @const\n     * @type {import("../../extent.js").Extent}\n     */\n\n    this.maxExtent = maxExtent;\n    /**\n     * @protected\n     * @type {boolean}\n     */\n\n    this.overlaps = overlaps;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.pixelRatio = pixelRatio;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.maxLineWidth = 0;\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n\n    this.resolution = resolution;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.alignFill_;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    this.beginGeometryInstruction1_ = null;\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n\n    this.beginGeometryInstruction2_ = null;\n    /**\n     * @private\n     * @type {import("../../extent.js").Extent}\n     */\n\n    this.bufferedMaxExtent_ = null;\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.instructions = [];\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n\n    this.coordinates = [];\n    /**\n     * @private\n     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}\n     */\n\n    this.coordinateCache_ = {};\n    /**\n     * @private\n     * @type {!import("../../transform.js").Transform}\n     */\n\n    this.renderedTransform_ = Object(ol_transform["c" /* create */])();\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n\n    this.hitDetectionInstructions = [];\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.pixelCoordinates_ = null;\n    /**\n     * @protected\n     * @type {import("../canvas.js").FillStrokeState}\n     */\n\n    this.state =\n    /** @type {import("../canvas.js").FillStrokeState} */\n    {};\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.viewRotation_ = 0;\n  }\n\n  if (VectorContext) CanvasReplay.__proto__ = VectorContext;\n  CanvasReplay.prototype = Object.create(VectorContext && VectorContext.prototype);\n  CanvasReplay.prototype.constructor = CanvasReplay;\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.\n   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.\n   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.\n   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n\n  CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n\n    if (fillInstruction) {\n      this.alignFill_ =\n      /** @type {boolean} */\n      fillInstruction[2];\n      this.fill_(context);\n    }\n\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context,\n      /** @type {Array<*>} */\n      strokeInstruction);\n      context.stroke();\n    }\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {number} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array<number>} padding Padding.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n\n\n  CanvasReplay.prototype.replayImage_ = function replayImage_(context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n    var fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale;\n    anchorY *= scale;\n    x -= anchorX;\n    y -= anchorY;\n    var w = width + originX > image.width ? image.width - originX : width;\n    var h = height + originY > image.height ? image.height - originY : height;\n    var boxW = padding[3] + w * scale + padding[1];\n    var boxH = padding[0] + h * scale + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n    /** @type {import("../../coordinate.js").Coordinate} */\n\n    var p1;\n    /** @type {import("../../coordinate.js").Coordinate} */\n\n    var p2;\n    /** @type {import("../../coordinate.js").Coordinate} */\n\n    var p3;\n    /** @type {import("../../coordinate.js").Coordinate} */\n\n    var p4;\n\n    if (fillStroke || rotation !== 0) {\n      p1 = [boxX, boxY];\n      p2 = [boxX + boxW, boxY];\n      p3 = [boxX + boxW, boxY + boxH];\n      p4 = [boxX, boxY + boxH];\n    }\n\n    var transform = null;\n\n    if (rotation !== 0) {\n      var centerX = x + anchorX;\n      var centerY = y + anchorY;\n      transform = Object(ol_transform["b" /* compose */])(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      Object(ol_extent["createOrUpdateEmpty"])(tmpExtent);\n      Object(ol_extent["extendCoordinate"])(tmpExtent, Object(ol_transform["a" /* apply */])(tmpTransform, p1));\n      Object(ol_extent["extendCoordinate"])(tmpExtent, Object(ol_transform["a" /* apply */])(tmpTransform, p2));\n      Object(ol_extent["extendCoordinate"])(tmpExtent, Object(ol_transform["a" /* apply */])(tmpTransform, p3));\n      Object(ol_extent["extendCoordinate"])(tmpExtent, Object(ol_transform["a" /* apply */])(tmpTransform, p4));\n    } else {\n      Object(ol_extent["createOrUpdate"])(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * scale / 2 : 0;\n    var intersects = tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 && tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[4] == 1) {\n        return;\n      }\n\n      Object(ol_extent["extend"])(declutterGroup, tmpExtent);\n      var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;\n\n      if (declutterArgs && fillStroke) {\n        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\n      }\n\n      declutterGroup.push(declutterArgs);\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4,\n        /** @type {Array<*>} */\n        fillInstruction,\n        /** @type {Array<*>} */\n        strokeInstruction);\n      }\n\n      Object(render_canvas["n" /* drawImage */])(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n    }\n  };\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n\n\n  CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio(dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n\n\n  CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var myEnd = this.coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n\n    if (skipFirst) {\n      offset += stride;\n    }\n\n    var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    var nextCoord = [NaN, NaN];\n    var skipped = true;\n    var i, lastRel, nextRel;\n\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = Object(ol_extent["coordinateRelationship"])(extent, nextCoord);\n\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this.coordinates[myEnd++] = lastCoord[0];\n          this.coordinates[myEnd++] = lastCoord[1];\n        }\n\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === Relationship["a" /* default */].INTERSECTING) {\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n\n      lastCoord[0] = nextCoord[0];\n      lastCoord[1] = nextCoord[1];\n      lastRel = nextRel;\n    } // Last coordinate equals first or only one point to append:\n\n\n    if (closed && skipped || i === offset + stride) {\n      this.coordinates[myEnd++] = lastCoord[0];\n      this.coordinates[myEnd++] = lastCoord[1];\n    }\n\n    return myEnd;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} replayEnds Replay ends.\n   * @return {number} Offset.\n   */\n\n\n  CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_(flatCoordinates, offset, ends, stride, replayEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      replayEnds.push(replayEnd);\n      offset = end;\n    }\n\n    return offset;\n  };\n  /**\n   * @inheritDoc.\n   */\n\n\n  CanvasReplay.prototype.drawCustom = function drawCustom(geometry, feature, renderer) {\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var replayBegin = this.coordinates.length;\n    var flatCoordinates, replayEnd, replayEnds, replayEndss;\n    var offset;\n\n    if (type == GeometryType["a" /* default */].MULTI_POLYGON) {\n      geometry =\n      /** @type {import("../../geom/MultiPolygon.js").default} */\n      geometry;\n      flatCoordinates = geometry.getOrientedFlatCoordinates();\n      replayEndss = [];\n      var endss = geometry.getEndss();\n      offset = 0;\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var myEnds = [];\n        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n        replayEndss.push(myEnds);\n      }\n\n      this.instructions.push([canvas_Instruction.CUSTOM, replayBegin, replayEndss, geometry, renderer, inflate["c" /* inflateMultiCoordinatesArray */]]);\n    } else if (type == GeometryType["a" /* default */].POLYGON || type == GeometryType["a" /* default */].MULTI_LINE_STRING) {\n      replayEnds = [];\n      flatCoordinates = type == GeometryType["a" /* default */].POLYGON ?\n      /** @type {import("../../geom/Polygon.js").default} */\n      geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n      /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */\n      geometry.getEnds(), stride, replayEnds);\n      this.instructions.push([canvas_Instruction.CUSTOM, replayBegin, replayEnds, geometry, renderer, inflate["b" /* inflateCoordinatesArray */]]);\n    } else if (type == GeometryType["a" /* default */].LINE_STRING || type == GeometryType["a" /* default */].MULTI_POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      this.instructions.push([canvas_Instruction.CUSTOM, replayBegin, replayEnd, geometry, renderer, inflate["a" /* inflateCoordinates */]]);\n    } else if (type == GeometryType["a" /* default */].POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      replayEnd = this.coordinates.length;\n      this.instructions.push([canvas_Instruction.CUSTOM, replayBegin, replayEnd, geometry, renderer]);\n    }\n\n    this.endGeometry(geometry, feature);\n  };\n  /**\n   * @protected\n   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.\n   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.\n   */\n\n\n  CanvasReplay.prototype.beginGeometry = function beginGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_ = [canvas_Instruction.BEGIN_GEOMETRY, feature, 0];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [canvas_Instruction.BEGIN_GEOMETRY, feature, 0];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n  /**\n   * FIXME empty description for jsdoc\n   */\n\n\n  CanvasReplay.prototype.finish = function finish() {};\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n\n\n  CanvasReplay.prototype.fill_ = function fill_(context) {\n    if (this.alignFill_) {\n      var origin = Object(ol_transform["a" /* apply */])(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n\n    context.fill();\n\n    if (this.alignFill_) {\n      context.setTransform.apply(context, render_canvas["r" /* resetTransform */]);\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n\n\n  CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_(context, instruction) {\n    context.strokeStyle =\n    /** @type {import("../../colorlike.js").ColorLike} */\n    instruction[1];\n    context.lineWidth =\n    /** @type {number} */\n    instruction[2];\n    context.lineCap =\n    /** @type {CanvasLineCap} */\n    instruction[3];\n    context.lineJoin =\n    /** @type {CanvasLineJoin} */\n    instruction[4];\n    context.miterLimit =\n    /** @type {number} */\n    instruction[5];\n\n    if (has["a" /* CANVAS_LINE_DASH */]) {\n      context.lineDashOffset =\n      /** @type {number} */\n      instruction[7];\n      context.setLineDash(\n      /** @type {Array<number>} */\n      instruction[6]);\n    }\n  };\n  /**\n   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.\n   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.\n   */\n\n\n  CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_(declutterGroup, feature) {\n    if (declutterGroup && declutterGroup.length > 5) {\n      var groupCount = declutterGroup[4];\n\n      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n        /** @type {import("../../structs/RBush.js").Entry} */\n        var box = {\n          minX:\n          /** @type {number} */\n          declutterGroup[0],\n          minY:\n          /** @type {number} */\n          declutterGroup[1],\n          maxX:\n          /** @type {number} */\n          declutterGroup[2],\n          maxY:\n          /** @type {number} */\n          declutterGroup[3],\n          value: feature\n        };\n\n        if (!this.declutterTree.collides(box)) {\n          this.declutterTree.insert(box);\n\n          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\n            var declutterData =\n            /** @type {Array} */\n            declutterGroup[j];\n\n            if (declutterData) {\n              if (declutterData.length > 11) {\n                this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);\n              }\n\n              render_canvas["n" /* drawImage */].apply(undefined, declutterData);\n            }\n          }\n        }\n\n        declutterGroup.length = 5;\n        Object(ol_extent["createOrUpdateEmpty"])(declutterGroup);\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../transform.js").Transform} transform Transform.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T|undefined} featureCallback Feature callback.\n   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  CanvasReplay.prototype.replay_ = function replay_(context, transform, skippedFeaturesHash, instructions, snapToPixel, featureCallback, opt_hitExtent) {\n    /** @type {Array<number>} */\n    var pixelCoordinates;\n\n    if (this.pixelCoordinates_ && Object(array["b" /* equals */])(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n\n      pixelCoordinates = Object(flat_transform["c" /* transform2D */])(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      Object(ol_transform["g" /* setFromArray */])(this.renderedTransform_, transform);\n    }\n\n    var skipFeatures = !Object(obj["d" /* isEmpty */])(skippedFeaturesHash);\n    var i = 0; // instruction index\n\n    var ii = instructions.length; // end of instructions\n\n    var d = 0; // data index\n\n    var dd; // end of per-instruction data\n\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var state =\n    /** @type {import("../../render.js").State} */\n    {\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    }; // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var\n    /** @type {import("../../Feature.js").default|import("../Feature.js").default} */\n    feature;\n    var x, y;\n\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type =\n      /** @type {CanvasInstruction} */\n      instruction[0];\n\n      switch (type) {\n        case canvas_Instruction.BEGIN_GEOMETRY:\n          feature =\n          /** @type {import("../../Feature.js").default|import("../Feature.js").default} */\n          instruction[1];\n\n          if (skipFeatures && skippedFeaturesHash[Object(util["c" /* getUid */])(feature)] || !feature.getGeometry()) {\n            i =\n            /** @type {number} */\n            instruction[2];\n          } else if (opt_hitExtent !== undefined && !Object(ol_extent["intersects"])(opt_hitExtent, feature.getGeometry().getExtent())) {\n            i =\n            /** @type {number} */\n            instruction[2] + 1;\n          } else {\n            ++i;\n          }\n\n          break;\n\n        case canvas_Instruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = prevY = NaN;\n          }\n\n          ++i;\n          break;\n\n        case canvas_Instruction.CIRCLE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n\n        case canvas_Instruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n\n        case canvas_Instruction.CUSTOM:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd = instruction[2];\n          var geometry =\n          /** @type {import("../../geom/SimpleGeometry.js").default} */\n          instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n\n          var coords = coordinateCache[i];\n\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n\n          renderer(coords, state);\n          ++i;\n          break;\n\n        case canvas_Instruction.DRAW_IMAGE:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          image =\n          /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n          instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order\n\n          anchorX =\n          /** @type {number} */\n          instruction[4];\n          anchorY =\n          /** @type {number} */\n          instruction[5];\n          declutterGroup = featureCallback ? null :\n          /** @type {import("../canvas.js").DeclutterGroup} */\n          instruction[6];\n          var height =\n          /** @type {number} */\n          instruction[7];\n          var opacity =\n          /** @type {number} */\n          instruction[8];\n          var originX =\n          /** @type {number} */\n          instruction[9];\n          var originY =\n          /** @type {number} */\n          instruction[10];\n          var rotateWithView =\n          /** @type {boolean} */\n          instruction[11];\n          var rotation =\n          /** @type {number} */\n          instruction[12];\n          var scale =\n          /** @type {number} */\n          instruction[13];\n          var width =\n          /** @type {number} */\n          instruction[14];\n          var padding = void 0,\n              backgroundFill = void 0,\n              backgroundStroke = void 0;\n\n          if (instruction.length > 16) {\n            padding =\n            /** @type {Array<number>} */\n            instruction[15];\n            backgroundFill =\n            /** @type {boolean} */\n            instruction[16];\n            backgroundStroke =\n            /** @type {boolean} */\n            instruction[17];\n          } else {\n            padding = render_canvas["j" /* defaultPadding */];\n            backgroundFill = backgroundStroke = false;\n          }\n\n          if (rotateWithView) {\n            rotation += viewRotation;\n          }\n\n          for (; d < dd; d += 2) {\n            this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ?\n            /** @type {Array<*>} */\n            lastFillInstruction : null, backgroundStroke ?\n            /** @type {Array<*>} */\n            lastStrokeInstruction : null);\n          }\n\n          this.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n\n        case canvas_Instruction.DRAW_CHARS:\n          var begin =\n          /** @type {number} */\n          instruction[1];\n          var end =\n          /** @type {number} */\n          instruction[2];\n          var baseline =\n          /** @type {number} */\n          instruction[3];\n          declutterGroup = featureCallback ? null :\n          /** @type {import("../canvas.js").DeclutterGroup} */\n          instruction[4];\n          var overflow =\n          /** @type {number} */\n          instruction[5];\n          var fillKey =\n          /** @type {string} */\n          instruction[6];\n          var maxAngle =\n          /** @type {number} */\n          instruction[7];\n          var measure =\n          /** @type {function(string):number} */\n          instruction[8];\n          var offsetY =\n          /** @type {number} */\n          instruction[9];\n          var strokeKey =\n          /** @type {string} */\n          instruction[10];\n          var strokeWidth =\n          /** @type {number} */\n          instruction[11];\n          var text =\n          /** @type {string} */\n          instruction[12];\n          var textKey =\n          /** @type {string} */\n          instruction[13];\n          var textScale =\n          /** @type {number} */\n          instruction[14];\n          var pathLength = Object(flat_length["a" /* lineStringLength */])(pixelCoordinates, begin, end, 2);\n          var textLength = measure(text);\n\n          if (overflow || textLength <= pathLength) {\n            /** @type {import("./TextReplay.js").default} */\n            var textReplay =\n            /** @type {?} */\n            this;\n            var textAlign = textReplay.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * render_replay["b" /* TEXT_ALIGN */][textAlign];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n\n            if (parts) {\n              var c = void 0,\n                  cc = void 0,\n                  chars = void 0,\n                  label = void 0,\n                  part = void 0;\n\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label = textReplay.getImage(chars, textKey, \'\', strokeKey);\n                  anchorX =\n                  /** @type {number} */\n                  part[2] + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                  this.replayImage_(context,\n                  /** @type {number} */\n                  part[0],\n                  /** @type {number} */\n                  part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                  /** @type {number} */\n                  part[3], textScale, false, label.width, render_canvas["j" /* defaultPadding */], null, null);\n                }\n              }\n\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n\n                  chars =\n                  /** @type {string} */\n                  part[4];\n                  label = textReplay.getImage(chars, textKey, fillKey, \'\');\n                  anchorX =\n                  /** @type {number} */\n                  part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  this.replayImage_(context,\n                  /** @type {number} */\n                  part[0],\n                  /** @type {number} */\n                  part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                  /** @type {number} */\n                  part[3], textScale, false, label.width, render_canvas["j" /* defaultPadding */], null, null);\n                }\n              }\n            }\n          }\n\n          this.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n\n        case canvas_Instruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature =\n            /** @type {import("../../Feature.js").default|import("../Feature.js").default} */\n            instruction[1];\n            var result = featureCallback(feature);\n\n            if (result) {\n              return result;\n            }\n          }\n\n          ++i;\n          break;\n\n        case canvas_Instruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n\n          ++i;\n          break;\n\n        case canvas_Instruction.MOVE_TO_LINE_TO:\n          d =\n          /** @type {number} */\n          instruction[1];\n          dd =\n          /** @type {number} */\n          instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n\n          ++i;\n          break;\n\n        case canvas_Instruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle =\n          /** @type {import("../../colorlike.js").ColorLike} */\n          instruction[1];\n          ++i;\n          break;\n\n        case canvas_Instruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n\n          this.setStrokeStyle_(context,\n          /** @type {Array<*>} */\n          instruction);\n          ++i;\n          break;\n\n        case canvas_Instruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n\n          ++i;\n          break;\n\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n\n          break;\n      }\n    }\n\n    if (pendingFill) {\n      this.fill_(context);\n    }\n\n    if (pendingStroke) {\n      context.stroke();\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../transform.js").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   */\n\n\n  CanvasReplay.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel) {\n    this.viewRotation_ = viewRotation;\n    this.replay_(context, transform, skippedFeaturesHash, this.instructions, snapToPixel, undefined, undefined);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../transform.js").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  CanvasReplay.prototype.replayHitDetection = function replayHitDetection(context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n  /**\n   * Reverse the hit detection instructions.\n   */\n\n\n  CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions() {\n    var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array\n\n    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks\n\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type =\n      /** @type {CanvasInstruction} */\n      instruction[0];\n\n      if (type == canvas_Instruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == canvas_Instruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        Object(array["i" /* reverseSubArray */])(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n    var state = this.state;\n\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = Object(colorlike["a" /* asColorLike */])(fillStyleColor ? fillStyleColor : render_canvas["b" /* defaultFillStyle */]);\n    } else {\n      state.fillStyle = undefined;\n    }\n\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = Object(colorlike["a" /* asColorLike */])(strokeStyleColor ? strokeStyleColor : render_canvas["k" /* defaultStrokeStyle */]);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : render_canvas["d" /* defaultLineCap */];\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : render_canvas["e" /* defaultLineDash */];\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : render_canvas["f" /* defaultLineDashOffset */];\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : render_canvas["g" /* defaultLineJoin */];\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : render_canvas["h" /* defaultLineWidth */];\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : render_canvas["i" /* defaultMiterLimit */];\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache\n\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n  /**\n   * @param {import("../canvas.js").FillStrokeState} state State.\n   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.\n   * @return {Array<*>} Fill instruction.\n   */\n\n\n  CanvasReplay.prototype.createFill = function createFill(state, geometry) {\n    var fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n\n    var fillInstruction = [canvas_Instruction.SET_FILL_STYLE, fillStyle];\n\n    if (typeof fillStyle !== \'string\') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n\n    return fillInstruction;\n  };\n  /**\n   * @param {import("../canvas.js").FillStrokeState} state State.\n   */\n\n\n  CanvasReplay.prototype.applyStroke = function applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  };\n  /**\n   * @param {import("../canvas.js").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n\n\n  CanvasReplay.prototype.createStroke = function createStroke(state) {\n    return [canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  };\n  /**\n   * @param {import("../canvas.js").FillStrokeState} state State.\n   * @param {function(this:CanvasReplay, import("../canvas.js").FillStrokeState, (import("../../geom/Geometry.js").default|import("../Feature.js").default)):Array<*>} createFill Create fill.\n   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.\n   */\n\n\n  CanvasReplay.prototype.updateFillStyle = function updateFillStyle(state, createFill, geometry) {\n    var fillStyle = state.fillStyle;\n\n    if (typeof fillStyle !== \'string\' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state, geometry));\n      }\n\n      state.currentFillStyle = fillStyle;\n    }\n  };\n  /**\n   * @param {import("../canvas.js").FillStrokeState} state State.\n   * @param {function(this:CanvasReplay, import("../canvas.js").FillStrokeState)} applyStroke Apply stroke.\n   */\n\n\n  CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle(state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !Object(array["b" /* equals */])(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n  /**\n   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.\n   * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.\n   */\n\n\n  CanvasReplay.prototype.endGeometry = function endGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [canvas_Instruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import("../../extent.js").Extent} The buffered rendering extent.\n   * @protected\n   */\n\n\n  CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = Object(ol_extent["clone"])(this.maxExtent);\n\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        Object(ol_extent["buffer"])(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n\n    return this.bufferedMaxExtent_;\n  };\n\n  return CanvasReplay;\n}(render_VectorContext["a" /* default */]);\n\n/* harmony default export */ var Replay = (Replay_CanvasReplay);\n// CONCATENATED MODULE: ./node_modules/ol/render/canvas/ImageReplay.js\n/**\n * @module ol/render/canvas/ImageReplay\n */\n\n\n\nvar ImageReplay_CanvasImageReplay =\n/*@__PURE__*/\nfunction (CanvasReplay) {\n  function CanvasImageReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n    /**\n     * @private\n     * @type {import("../canvas.js").DeclutterGroup}\n     */\n\n    this.declutterGroup_ = null;\n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}\n     */\n\n    this.hitDetectionImage_ = null;\n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}\n     */\n\n    this.image_ = null;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.anchorX_ = undefined;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.anchorY_ = undefined;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.height_ = undefined;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.opacity_ = undefined;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.originX_ = undefined;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.originY_ = undefined;\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n\n    this.rotateWithView_ = undefined;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.rotation_ = undefined;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.scale_ = undefined;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.width_ = undefined;\n  }\n\n  if (CanvasReplay) CanvasImageReplay.__proto__ = CanvasReplay;\n  CanvasImageReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasImageReplay.prototype.constructor = CanvasImageReplay;\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} My end.\n   */\n\n  CanvasImageReplay.prototype.drawCoordinates_ = function drawCoordinates_(flatCoordinates, offset, end, stride) {\n    return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasImageReplay.prototype.drawPoint = function drawPoint(pointGeometry, feature) {\n    if (!this.image_) {\n      return;\n    }\n\n    this.beginGeometry(pointGeometry, feature);\n    var flatCoordinates = pointGeometry.getFlatCoordinates();\n    var stride = pointGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n    this.instructions.push([canvas_Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order\n    this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.width_]);\n    this.hitDetectionInstructions.push([canvas_Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order\n    this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]);\n    this.endGeometry(pointGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasImageReplay.prototype.drawMultiPoint = function drawMultiPoint(multiPointGeometry, feature) {\n    if (!this.image_) {\n      return;\n    }\n\n    this.beginGeometry(multiPointGeometry, feature);\n    var flatCoordinates = multiPointGeometry.getFlatCoordinates();\n    var stride = multiPointGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n    this.instructions.push([canvas_Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order\n    this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.width_]);\n    this.hitDetectionInstructions.push([canvas_Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order\n    this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_]);\n    this.endGeometry(multiPointGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasImageReplay.prototype.finish = function finish() {\n    this.reverseHitDetectionInstructions(); // FIXME this doesn\'t really protect us against further calls to draw*Geometry\n\n    this.anchorX_ = undefined;\n    this.anchorY_ = undefined;\n    this.hitDetectionImage_ = null;\n    this.image_ = null;\n    this.height_ = undefined;\n    this.scale_ = undefined;\n    this.opacity_ = undefined;\n    this.originX_ = undefined;\n    this.originY_ = undefined;\n    this.rotateWithView_ = undefined;\n    this.rotation_ = undefined;\n    this.width_ = undefined;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasImageReplay.prototype.setImageStyle = function setImageStyle(imageStyle, declutterGroup) {\n    var anchor = imageStyle.getAnchor();\n    var size = imageStyle.getSize();\n    var hitDetectionImage = imageStyle.getHitDetectionImage(1);\n    var image = imageStyle.getImage(1);\n    var origin = imageStyle.getOrigin();\n    this.anchorX_ = anchor[0];\n    this.anchorY_ = anchor[1];\n    this.declutterGroup_ =\n    /** @type {import("../canvas.js").DeclutterGroup} */\n    declutterGroup;\n    this.hitDetectionImage_ = hitDetectionImage;\n    this.image_ = image;\n    this.height_ = size[1];\n    this.opacity_ = imageStyle.getOpacity();\n    this.originX_ = origin[0];\n    this.originY_ = origin[1];\n    this.rotateWithView_ = imageStyle.getRotateWithView();\n    this.rotation_ = imageStyle.getRotation();\n    this.scale_ = imageStyle.getScale();\n    this.width_ = size[0];\n  };\n\n  return CanvasImageReplay;\n}(Replay);\n\n/* harmony default export */ var ImageReplay = (ImageReplay_CanvasImageReplay);\n// CONCATENATED MODULE: ./node_modules/ol/render/canvas/LineStringReplay.js\n/**\n * @module ol/render/canvas/LineStringReplay\n */\n\n\n\nvar LineStringReplay_CanvasLineStringReplay =\n/*@__PURE__*/\nfunction (CanvasReplay) {\n  function CanvasLineStringReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n\n  if (CanvasReplay) CanvasLineStringReplay.__proto__ = CanvasReplay;\n  CanvasLineStringReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasLineStringReplay.prototype.constructor = CanvasLineStringReplay;\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} end.\n   */\n\n  CanvasLineStringReplay.prototype.drawFlatCoordinates_ = function drawFlatCoordinates_(flatCoordinates, offset, end, stride) {\n    var myBegin = this.coordinates.length;\n    var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n    var moveToLineToInstruction = [canvas_Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n    this.instructions.push(moveToLineToInstruction);\n    this.hitDetectionInstructions.push(moveToLineToInstruction);\n    return end;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasLineStringReplay.prototype.drawLineString = function drawLineString(lineStringGeometry, feature) {\n    var state = this.state;\n    var strokeStyle = state.strokeStyle;\n    var lineWidth = state.lineWidth;\n\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(lineStringGeometry, feature);\n    this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);\n    var flatCoordinates = lineStringGeometry.getFlatCoordinates();\n    var stride = lineStringGeometry.getStride();\n    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);\n    this.hitDetectionInstructions.push(Instruction_strokeInstruction);\n    this.endGeometry(lineStringGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasLineStringReplay.prototype.drawMultiLineString = function drawMultiLineString(multiLineStringGeometry, feature) {\n    var state = this.state;\n    var strokeStyle = state.strokeStyle;\n    var lineWidth = state.lineWidth;\n\n    if (strokeStyle === undefined || lineWidth === undefined) {\n      return;\n    }\n\n    this.updateStrokeStyle(state, this.applyStroke);\n    this.beginGeometry(multiLineStringGeometry, feature);\n    this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], beginPathInstruction);\n    var ends = multiLineStringGeometry.getEnds();\n    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();\n    var stride = multiLineStringGeometry.getStride();\n    var offset = 0;\n\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);\n    }\n\n    this.hitDetectionInstructions.push(Instruction_strokeInstruction);\n    this.endGeometry(multiLineStringGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasLineStringReplay.prototype.finish = function finish() {\n    var state = this.state;\n\n    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n      this.instructions.push(Instruction_strokeInstruction);\n    }\n\n    this.reverseHitDetectionInstructions();\n    this.state = null;\n  };\n  /**\n   * @inheritDoc.\n   */\n\n\n  CanvasLineStringReplay.prototype.applyStroke = function applyStroke(state) {\n    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {\n      this.instructions.push(Instruction_strokeInstruction);\n      state.lastStroke = this.coordinates.length;\n    }\n\n    state.lastStroke = 0;\n    CanvasReplay.prototype.applyStroke.call(this, state);\n    this.instructions.push(beginPathInstruction);\n  };\n\n  return CanvasLineStringReplay;\n}(Replay);\n\n/* harmony default export */ var LineStringReplay = (LineStringReplay_CanvasLineStringReplay);\n// EXTERNAL MODULE: ./node_modules/ol/color.js\nvar color = __webpack_require__(37);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js\nvar simplify = __webpack_require__(46);\n\n// CONCATENATED MODULE: ./node_modules/ol/render/canvas/PolygonReplay.js\n/**\n * @module ol/render/canvas/PolygonReplay\n */\n\n\n\n\n\n\nvar PolygonReplay_CanvasPolygonReplay =\n/*@__PURE__*/\nfunction (CanvasReplay) {\n  function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n  }\n\n  if (CanvasReplay) CanvasPolygonReplay.__proto__ = CanvasReplay;\n  CanvasPolygonReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n\n  CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_(flatCoordinates, offset, ends, stride) {\n    var state = this.state;\n    var fill = state.fillStyle !== undefined;\n    var stroke = state.strokeStyle != undefined;\n    var numEnds = ends.length;\n    this.instructions.push(beginPathInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction);\n\n    for (var i = 0; i < numEnds; ++i) {\n      var end = ends[i];\n      var myBegin = this.coordinates.length;\n      var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);\n      var moveToLineToInstruction = [canvas_Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];\n      this.instructions.push(moveToLineToInstruction);\n      this.hitDetectionInstructions.push(moveToLineToInstruction);\n\n      if (stroke) {\n        // Performance optimization: only call closePath() when we have a stroke.\n        // Otherwise the ring is closed already (see appendFlatCoordinates above).\n        this.instructions.push(closePathInstruction);\n        this.hitDetectionInstructions.push(closePathInstruction);\n      }\n\n      offset = end;\n    }\n\n    if (fill) {\n      this.instructions.push(Instruction_fillInstruction);\n      this.hitDetectionInstructions.push(Instruction_fillInstruction);\n    }\n\n    if (stroke) {\n      this.instructions.push(Instruction_strokeInstruction);\n      this.hitDetectionInstructions.push(Instruction_strokeInstruction);\n    }\n\n    return offset;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawCircle = function drawCircle(circleGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(circleGeometry);\n    this.beginGeometry(circleGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([canvas_Instruction.SET_FILL_STYLE, Object(color["b" /* asString */])(render_canvas["b" /* defaultFillStyle */])]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var flatCoordinates = circleGeometry.getFlatCoordinates();\n    var stride = circleGeometry.getStride();\n    var myBegin = this.coordinates.length;\n    this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n    var circleInstruction = [canvas_Instruction.CIRCLE, myBegin];\n    this.instructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);\n    this.hitDetectionInstructions.push(Instruction_fillInstruction);\n\n    if (state.fillStyle !== undefined) {\n      this.instructions.push(Instruction_fillInstruction);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.instructions.push(Instruction_strokeInstruction);\n      this.hitDetectionInstructions.push(Instruction_strokeInstruction);\n    }\n\n    this.endGeometry(circleGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon(polygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(polygonGeometry);\n    this.beginGeometry(polygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([canvas_Instruction.SET_FILL_STYLE, Object(color["b" /* asString */])(render_canvas["b" /* defaultFillStyle */])]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var ends = polygonGeometry.getEnds();\n    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();\n    var stride = polygonGeometry.getStride();\n    this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);\n    this.endGeometry(polygonGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon(multiPolygonGeometry, feature) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n    var strokeStyle = state.strokeStyle;\n\n    if (fillStyle === undefined && strokeStyle === undefined) {\n      return;\n    }\n\n    this.setFillStrokeStyles_(multiPolygonGeometry);\n    this.beginGeometry(multiPolygonGeometry, feature);\n\n    if (state.fillStyle !== undefined) {\n      this.hitDetectionInstructions.push([canvas_Instruction.SET_FILL_STYLE, Object(color["b" /* asString */])(render_canvas["b" /* defaultFillStyle */])]);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.hitDetectionInstructions.push([canvas_Instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);\n    }\n\n    var endss = multiPolygonGeometry.getEndss();\n    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();\n    var stride = multiPolygonGeometry.getStride();\n    var offset = 0;\n\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);\n    }\n\n    this.endGeometry(multiPolygonGeometry, feature);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasPolygonReplay.prototype.finish = function finish() {\n    this.reverseHitDetectionInstructions();\n    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are\n    // simplified using quantization and point elimination. However, we might\n    // have received a mix of quantized and non-quantized geometries, so ensure\n    // that all are quantized by quantizing all coordinates in the batch.\n\n    var tolerance = this.tolerance;\n\n    if (tolerance !== 0) {\n      var coordinates = this.coordinates;\n\n      for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Object(simplify["e" /* snap */])(coordinates[i], tolerance);\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry Geometry.\n   */\n\n\n  CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_(geometry) {\n    var state = this.state;\n    var fillStyle = state.fillStyle;\n\n    if (fillStyle !== undefined) {\n      this.updateFillStyle(state, this.createFill, geometry);\n    }\n\n    if (state.strokeStyle !== undefined) {\n      this.updateStrokeStyle(state, this.applyStroke);\n    }\n  };\n\n  return CanvasPolygonReplay;\n}(Replay);\n\n/* harmony default export */ var PolygonReplay = (PolygonReplay_CanvasPolygonReplay);\n// CONCATENATED MODULE: ./node_modules/ol/geom/flat/straightchunk.js\n/**\n * @module ol/geom/flat/straightchunk\n */\n\n/**\n * @param {number} maxAngle Maximum acceptable angle delta between segments.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Array<number>} Start and end of the first suitable chunk of the\n * given `flatCoordinates`.\n */\nfunction matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {\n  var chunkStart = offset;\n  var chunkEnd = offset;\n  var chunkM = 0;\n  var m = 0;\n  var start = offset;\n  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\n\n  for (i = offset; i < end; i += stride) {\n    var x2 = flatCoordinates[i];\n    var y2 = flatCoordinates[i + 1];\n\n    if (x1 !== undefined) {\n      x23 = x2 - x1;\n      y23 = y2 - y1;\n      m23 = Math.sqrt(x23 * x23 + y23 * y23);\n\n      if (x12 !== undefined) {\n        m += m12;\n        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n\n        if (acos > maxAngle) {\n          if (m > chunkM) {\n            chunkM = m;\n            chunkStart = start;\n            chunkEnd = i;\n          }\n\n          m = 0;\n          start = i - stride;\n        }\n      }\n\n      m12 = m23;\n      x12 = x23;\n      y12 = y23;\n    }\n\n    x1 = x2;\n    y1 = y2;\n  }\n\n  m += m23;\n  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\n}\n// EXTERNAL MODULE: ./node_modules/ol/style/TextPlacement.js\nvar TextPlacement = __webpack_require__(92);\n\n// CONCATENATED MODULE: ./node_modules/ol/render/canvas/TextReplay.js\n/**\n * @module ol/render/canvas/TextReplay\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar TextReplay_CanvasTextReplay =\n/*@__PURE__*/\nfunction (CanvasReplay) {\n  function CanvasTextReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n    /**\n     * @private\n     * @type {import("../canvas.js").DeclutterGroup}\n     */\n\n    this.declutterGroup_;\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n\n    this.labels_ = null;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.text_ = \'\';\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textOffsetX_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textOffsetY_ = 0;\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n\n    this.textRotateWithView_ = undefined;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textRotation_ = 0;\n    /**\n     * @private\n     * @type {?import("../canvas.js").FillState}\n     */\n\n    this.textFillState_ = null;\n    /**\n     * @type {!Object<string, import("../canvas.js").FillState>}\n     */\n\n    this.fillStates = {};\n    /**\n     * @private\n     * @type {?import("../canvas.js").StrokeState}\n     */\n\n    this.textStrokeState_ = null;\n    /**\n     * @type {!Object<string, import("../canvas.js").StrokeState>}\n     */\n\n    this.strokeStates = {};\n    /**\n     * @private\n     * @type {import("../canvas.js").TextState}\n     */\n\n    this.textState_ =\n    /** @type {import("../canvas.js").TextState} */\n    {};\n    /**\n     * @type {!Object<string, import("../canvas.js").TextState>}\n     */\n\n    this.textStates = {};\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.textKey_ = \'\';\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.fillKey_ = \'\';\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.strokeKey_ = \'\';\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n\n    this.widths_ = {};\n    render_canvas["o" /* labelCache */].prune();\n  }\n\n  if (CanvasReplay) CanvasTextReplay.__proto__ = CanvasReplay;\n  CanvasTextReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasTextReplay.prototype.constructor = CanvasTextReplay;\n  /**\n   * @inheritDoc\n   */\n\n  CanvasTextReplay.prototype.drawText = function drawText(geometry, feature) {\n    var fillState = this.textFillState_;\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n\n    if (this.text_ === \'\' || !textState || !fillState && !strokeState) {\n      return;\n    }\n\n    var begin = this.coordinates.length;\n    var geometryType = geometry.getType();\n    var flatCoordinates = null;\n    var end = 2;\n    var stride = 2;\n    var i, ii;\n\n    if (textState.placement === TextPlacement["a" /* default */].LINE) {\n      if (!Object(ol_extent["intersects"])(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n\n      var ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n      stride = geometry.getStride();\n\n      if (geometryType == GeometryType["a" /* default */].LINE_STRING) {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == GeometryType["a" /* default */].MULTI_LINE_STRING) {\n        ends = geometry.getEnds();\n      } else if (geometryType == GeometryType["a" /* default */].POLYGON) {\n        ends = geometry.getEnds().slice(0, 1);\n      } else if (geometryType == GeometryType["a" /* default */].MULTI_POLYGON) {\n        var endss = geometry.getEndss();\n        ends = [];\n\n        for (i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n\n      this.beginGeometry(geometry, feature);\n      var textAlign = textState.textAlign;\n      var flatOffset = 0;\n      var flatEnd;\n\n      for (var o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n\n        for (i = flatOffset; i < flatEnd; i += stride) {\n          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n\n        end = this.coordinates.length;\n        flatOffset = ends[o];\n        this.drawChars_(begin, end, this.declutterGroup_);\n        begin = end;\n      }\n\n      this.endGeometry(geometry, feature);\n    } else {\n      var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\n      var width = label.width / this.pixelRatio;\n\n      switch (geometryType) {\n        case GeometryType["a" /* default */].POINT:\n        case GeometryType["a" /* default */].MULTI_POINT:\n          flatCoordinates = geometry.getFlatCoordinates();\n          end = flatCoordinates.length;\n          break;\n\n        case GeometryType["a" /* default */].LINE_STRING:\n          flatCoordinates =\n          /** @type {import("../../geom/LineString.js").default} */\n          geometry.getFlatMidpoint();\n          break;\n\n        case GeometryType["a" /* default */].CIRCLE:\n          flatCoordinates =\n          /** @type {import("../../geom/Circle.js").default} */\n          geometry.getCenter();\n          break;\n\n        case GeometryType["a" /* default */].MULTI_LINE_STRING:\n          flatCoordinates =\n          /** @type {import("../../geom/MultiLineString.js").default} */\n          geometry.getFlatMidpoints();\n          end = flatCoordinates.length;\n          break;\n\n        case GeometryType["a" /* default */].POLYGON:\n          flatCoordinates =\n          /** @type {import("../../geom/Polygon.js").default} */\n          geometry.getFlatInteriorPoint();\n\n          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\n            return;\n          }\n\n          stride = 3;\n          break;\n\n        case GeometryType["a" /* default */].MULTI_POLYGON:\n          var interiorPoints =\n          /** @type {import("../../geom/MultiPolygon.js").default} */\n          geometry.getFlatInteriorPoints();\n          flatCoordinates = [];\n\n          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\n              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n            }\n          }\n\n          end = flatCoordinates.length;\n\n          if (end == 0) {\n            return;\n          }\n\n          break;\n\n        default:\n      }\n\n      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\n\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill, geometry);\n          this.hitDetectionInstructions.push(this.createFill(this.state, geometry));\n        }\n\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n\n      this.beginGeometry(geometry, feature);\n      this.drawTextImage_(label, begin, end);\n      this.endGeometry(geometry, feature);\n    }\n  };\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {HTMLCanvasElement} Image.\n   */\n\n\n  CanvasTextReplay.prototype.getImage = function getImage(text, textKey, fillKey, strokeKey) {\n    var label;\n    var key = strokeKey + textKey + text + fillKey + this.pixelRatio;\n\n    if (!render_canvas["o" /* labelCache */].containsKey(key)) {\n      var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\n      var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\n      var textState = this.textStates[textKey] || this.textState_;\n      var pixelRatio = this.pixelRatio;\n      var scale = textState.scale * pixelRatio;\n      var align = render_replay["b" /* TEXT_ALIGN */][textState.textAlign || render_canvas["l" /* defaultTextAlign */]];\n      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n      var lines = text.split(\'\\n\');\n      var numLines = lines.length;\n      var widths = [];\n      var width = measureTextWidths(textState.font, lines, widths);\n      var lineHeight = Object(render_canvas["p" /* measureTextHeight */])(textState.font);\n      var height = lineHeight * numLines;\n      var renderWidth = width + strokeWidth;\n      var context = Object(dom["a" /* createCanvasContext2D */])(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));\n      label = context.canvas;\n      render_canvas["o" /* labelCache */].set(key, label);\n\n      if (scale != 1) {\n        context.scale(scale, scale);\n      }\n\n      context.font = textState.font;\n\n      if (strokeKey) {\n        context.strokeStyle = strokeState.strokeStyle;\n        context.lineWidth = strokeWidth;\n        context.lineCap =\n        /** @type {CanvasLineCap} */\n        strokeState.lineCap;\n        context.lineJoin =\n        /** @type {CanvasLineJoin} */\n        strokeState.lineJoin;\n        context.miterLimit = strokeState.miterLimit;\n\n        if (has["a" /* CANVAS_LINE_DASH */] && strokeState.lineDash.length) {\n          context.setLineDash(strokeState.lineDash);\n          context.lineDashOffset = strokeState.lineDashOffset;\n        }\n      }\n\n      if (fillKey) {\n        context.fillStyle = fillState.fillStyle;\n      }\n\n      context.textBaseline = \'middle\';\n      context.textAlign = \'center\';\n      var leftRight = 0.5 - align;\n      var x = align * label.width / scale + leftRight * strokeWidth;\n      var i;\n\n      if (strokeKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n\n      if (fillKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n    }\n\n    return render_canvas["o" /* labelCache */].get(key);\n  };\n  /**\n   * @private\n   * @param {HTMLCanvasElement} label Label.\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n\n\n  CanvasTextReplay.prototype.drawTextImage_ = function drawTextImage_(label, begin, end) {\n    var textState = this.textState_;\n    var strokeState = this.textStrokeState_;\n    var pixelRatio = this.pixelRatio;\n    var align = render_replay["b" /* TEXT_ALIGN */][textState.textAlign || render_canvas["l" /* defaultTextAlign */]];\n    var baseline = render_replay["b" /* TEXT_ALIGN */][textState.textBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    this.instructions.push([canvas_Instruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, label.width, textState.padding == render_canvas["j" /* defaultPadding */] ? render_canvas["j" /* defaultPadding */] : textState.padding.map(function (p) {\n      return p * pixelRatio;\n    }), !!textState.backgroundFill, !!textState.backgroundStroke]);\n    this.hitDetectionInstructions.push([canvas_Instruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / pixelRatio, label.width, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke]);\n  };\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.\n   */\n\n\n  CanvasTextReplay.prototype.drawChars_ = function drawChars_(begin, end, declutterGroup) {\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    var fillState = this.textFillState_;\n    var strokeKey = this.strokeKey_;\n\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] =\n        /** @type {import("../canvas.js").StrokeState} */\n        {\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        };\n      }\n    }\n\n    var textKey = this.textKey_;\n\n    if (!(this.textKey_ in this.textStates)) {\n      this.textStates[this.textKey_] =\n      /** @type {import("../canvas.js").TextState} */\n      {\n        font: textState.font,\n        textAlign: textState.textAlign || render_canvas["l" /* defaultTextAlign */],\n        scale: textState.scale\n      };\n    }\n\n    var fillKey = this.fillKey_;\n\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] =\n        /** @type {import("../canvas.js").FillState} */\n        {\n          fillStyle: fillState.fillStyle\n        };\n      }\n    }\n\n    var pixelRatio = this.pixelRatio;\n    var baseline = render_replay["b" /* TEXT_ALIGN */][textState.textBaseline];\n    var offsetY = this.textOffsetY_ * pixelRatio;\n    var text = this.text_;\n    var font = textState.font;\n    var textScale = textState.scale;\n    var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\n    var widths = this.widths_[font];\n\n    if (!widths) {\n      this.widths_[font] = widths = {};\n    }\n\n    this.instructions.push([canvas_Instruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {\n      var width = widths[text];\n\n      if (!width) {\n        width = widths[text] = Object(render_canvas["q" /* measureTextWidth */])(font, text);\n      }\n\n      return width * textScale * pixelRatio;\n    }, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);\n    this.hitDetectionInstructions.push([canvas_Instruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {\n      var width = widths[text];\n\n      if (!width) {\n        width = widths[text] = Object(render_canvas["q" /* measureTextWidth */])(font, text);\n      }\n\n      return width * textScale;\n    }, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTextReplay.prototype.setTextStyle = function setTextStyle(textStyle, declutterGroup) {\n    var textState, fillState, strokeState;\n\n    if (!textStyle) {\n      this.text_ = \'\';\n    } else {\n      this.declutterGroup_ =\n      /** @type {import("../canvas.js").DeclutterGroup} */\n      declutterGroup;\n      var textFillStyle = textStyle.getFill();\n\n      if (!textFillStyle) {\n        fillState = this.textFillState_ = null;\n      } else {\n        fillState = this.textFillState_;\n\n        if (!fillState) {\n          fillState = this.textFillState_ =\n          /** @type {import("../canvas.js").FillState} */\n          {};\n        }\n\n        fillState.fillStyle = Object(colorlike["a" /* asColorLike */])(textFillStyle.getColor() || render_canvas["b" /* defaultFillStyle */]);\n      }\n\n      var textStrokeStyle = textStyle.getStroke();\n\n      if (!textStrokeStyle) {\n        strokeState = this.textStrokeState_ = null;\n      } else {\n        strokeState = this.textStrokeState_;\n\n        if (!strokeState) {\n          strokeState = this.textStrokeState_ =\n          /** @type {import("../canvas.js").StrokeState} */\n          {};\n        }\n\n        var lineDash = textStrokeStyle.getLineDash();\n        var lineDashOffset = textStrokeStyle.getLineDashOffset();\n        var lineWidth = textStrokeStyle.getWidth();\n        var miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || render_canvas["d" /* defaultLineCap */];\n        strokeState.lineDash = lineDash ? lineDash.slice() : render_canvas["e" /* defaultLineDash */];\n        strokeState.lineDashOffset = lineDashOffset === undefined ? render_canvas["f" /* defaultLineDashOffset */] : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || render_canvas["g" /* defaultLineJoin */];\n        strokeState.lineWidth = lineWidth === undefined ? render_canvas["h" /* defaultLineWidth */] : lineWidth;\n        strokeState.miterLimit = miterLimit === undefined ? render_canvas["i" /* defaultMiterLimit */] : miterLimit;\n        strokeState.strokeStyle = Object(colorlike["a" /* asColorLike */])(textStrokeStyle.getColor() || render_canvas["k" /* defaultStrokeStyle */]);\n      }\n\n      textState = this.textState_;\n      var font = textStyle.getFont() || render_canvas["c" /* defaultFont */];\n      Object(render_canvas["a" /* checkFont */])(font);\n      var textScale = textStyle.getScale();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.textBaseline = textStyle.getTextBaseline() || render_canvas["m" /* defaultTextBaseline */];\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || render_canvas["j" /* defaultPadding */];\n      textState.scale = textScale === undefined ? 1 : textScale;\n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || \'\';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == \'string\' ? strokeState.strokeStyle : Object(util["c" /* getUid */])(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + \'|\' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + \'[\' + strokeState.lineDash.join() + \']\' : \'\';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || \'?\');\n      this.fillKey_ = fillState ? typeof fillState.fillStyle == \'string\' ? fillState.fillStyle : \'|\' + Object(util["c" /* getUid */])(fillState.fillStyle) : \'\';\n    }\n  };\n\n  return CanvasTextReplay;\n}(Replay);\n/**\n * @param {string} font Font to use for measuring.\n * @param {Array<string>} lines Lines to measure.\n * @param {Array<number>} widths Array will be populated with the widths of\n * each line.\n * @return {number} Width of the whole text.\n */\n\n\nfunction measureTextWidths(font, lines, widths) {\n  var numLines = lines.length;\n  var width = 0;\n\n  for (var i = 0; i < numLines; ++i) {\n    var currentWidth = Object(render_canvas["q" /* measureTextWidth */])(font, lines[i]);\n    width = Math.max(width, currentWidth);\n    widths.push(currentWidth);\n  }\n\n  return width;\n}\n/* harmony default export */ var TextReplay = (TextReplay_CanvasTextReplay);\n// CONCATENATED MODULE: ./node_modules/ol/render/canvas/ReplayGroup.js\n/* unused harmony export getCircleArray */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return replayDeclutter; });\n/**\n * @module ol/render/canvas/ReplayGroup\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @type {Object<ReplayType, typeof CanvasReplay>}\n */\n\nvar BATCH_CONSTRUCTORS = {\n  \'Circle\': PolygonReplay,\n  \'Default\': Replay,\n  \'Image\': ImageReplay,\n  \'LineString\': LineStringReplay,\n  \'Polygon\': PolygonReplay,\n  \'Text\': TextReplay\n};\n\nvar ReplayGroup_CanvasReplayGroup =\n/*@__PURE__*/\nfunction (ReplayGroup) {\n  function CanvasReplayGroup(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {\n    ReplayGroup.call(this);\n    /**\n     * Declutter tree.\n     * @private\n     */\n\n    this.declutterTree_ = declutterTree;\n    /**\n     * @type {import("../canvas.js").DeclutterGroup}\n     * @private\n     */\n\n    this.declutterGroup_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.tolerance_ = tolerance;\n    /**\n     * @private\n     * @type {import("../../extent.js").Extent}\n     */\n\n    this.maxExtent_ = maxExtent;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.overlaps_ = overlaps;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.resolution_ = resolution;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.renderBuffer_ = opt_renderBuffer;\n    /**\n     * @private\n     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}\n     */\n\n    this.replaysByZIndex_ = {};\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.hitDetectionContext_ = Object(dom["a" /* createCanvasContext2D */])(1, 1);\n    /**\n     * @private\n     * @type {import("../../transform.js").Transform}\n     */\n\n    this.hitDetectionTransform_ = Object(ol_transform["c" /* create */])();\n  }\n\n  if (ReplayGroup) CanvasReplayGroup.__proto__ = ReplayGroup;\n  CanvasReplayGroup.prototype = Object.create(ReplayGroup && ReplayGroup.prototype);\n  CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;\n  /**\n   * @inheritDoc\n   */\n\n  CanvasReplayGroup.prototype.addDeclutter = function addDeclutter(group) {\n    var declutter = null;\n\n    if (this.declutterTree_) {\n      if (group) {\n        declutter = this.declutterGroup_;\n        /** @type {number} */\n\n        declutter[4]++;\n      } else {\n        declutter = this.declutterGroup_ = Object(ol_extent["createEmpty"])();\n        declutter.push(1);\n      }\n    }\n\n    return declutter;\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../transform.js").Transform} transform Transform.\n   */\n\n\n  CanvasReplayGroup.prototype.clip = function clip(context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n  /**\n   * @param {Array<ReplayType>} replays Replays.\n   * @return {boolean} Has replays of the provided types.\n   */\n\n\n  CanvasReplayGroup.prototype.hasReplays = function hasReplays(replays) {\n    for (var zIndex in this.replaysByZIndex_) {\n      var candidates = this.replaysByZIndex_[zIndex];\n\n      for (var i = 0, ii = replays.length; i < ii; ++i) {\n        if (replays[i] in candidates) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * FIXME empty description for jsdoc\n   */\n\n\n  CanvasReplayGroup.prototype.finish = function finish() {\n    for (var zKey in this.replaysByZIndex_) {\n      var replays = this.replaysByZIndex_[zKey];\n\n      for (var replayKey in replays) {\n        replays[replayKey].finish();\n      }\n    }\n  };\n  /**\n   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {function((import("../../Feature.js").default|import("../Feature.js").default)): T} callback Feature callback.\n   * @param {Object<string, import("../canvas.js").DeclutterGroup>} declutterReplays Declutter replays.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n\n\n  CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = Object(ol_transform["b" /* compose */])(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    var context = this.hitDetectionContext_;\n\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n    /**\n     * @type {import("../../extent.js").Extent}\n     */\n\n\n    var hitExtent;\n\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = Object(ol_extent["createEmpty"])();\n      Object(ol_extent["extendCoordinate"])(hitExtent, coordinate);\n      Object(ol_extent["buffer"])(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n\n    var mask = getCircleArray(hitTolerance);\n    var declutteredFeatures;\n\n    if (this.declutterTree_) {\n      declutteredFeatures = this.declutterTree_.all().map(function (entry) {\n        return entry.value;\n      });\n    }\n\n    var replayType;\n    /**\n     * @param {import("../../Feature.js").default|import("../Feature.js").default} feature Feature.\n     * @return {?} Callback result.\n     */\n\n    function featureCallback(feature) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n\n      for (var i = 0; i < contextSize; i++) {\n        for (var j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              var result = void 0;\n\n              if (!(declutteredFeatures && (replayType == ReplayType["a" /* default */].IMAGE || replayType == ReplayType["a" /* default */].TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {\n                result = callback(feature);\n              }\n\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n    /** @type {Array<number>} */\n\n\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(array["g" /* numberSafeCompareFunction */]);\n    var i, j, replays, replay, result;\n\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n\n      for (j = render_replay["a" /* ORDER */].length - 1; j >= 0; --j) {\n        replayType = render_replay["a" /* ORDER */][j];\n        replay = replays[replayType];\n\n        if (replay !== undefined) {\n          if (declutterReplays && (replayType == ReplayType["a" /* default */].IMAGE || replayType == ReplayType["a" /* default */].TEXT)) {\n            var declutter = declutterReplays[zIndexKey];\n\n            if (!declutter) {\n              declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            result = replay.replayHitDetection(context, transform, rotation, skippedFeaturesHash, featureCallback, hitExtent);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {import("../../transform.js").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n\n\n  CanvasReplayGroup.prototype.getClipCoords = function getClipCoords(transform) {\n    var maxExtent = this.maxExtent_;\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    Object(flat_transform["c" /* transform2D */])(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasReplayGroup.prototype.getReplay = function getReplay(zIndex, replayType) {\n    var zIndexKey = zIndex !== undefined ? zIndex.toString() : \'0\';\n    var replays = this.replaysByZIndex_[zIndexKey];\n\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n\n    var replay = replays[replayType];\n\n    if (replay === undefined) {\n      var Constructor = BATCH_CONSTRUCTORS[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n      replays[replayType] = replay;\n    }\n\n    return replay;\n  };\n  /**\n   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.\n   */\n\n\n  CanvasReplayGroup.prototype.getReplays = function getReplays() {\n    return this.replaysByZIndex_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasReplayGroup.prototype.isEmpty = function isEmpty$1() {\n    return Object(obj["d" /* isEmpty */])(this.replaysByZIndex_);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../transform.js").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import("../canvas.js").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n\n\n  CanvasReplayGroup.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel, opt_replayTypes, opt_declutterReplays) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(array["g" /* numberSafeCompareFunction */]); // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n\n    context.save();\n    this.clip(context, transform);\n    var replayTypes = opt_replayTypes ? opt_replayTypes : render_replay["a" /* ORDER */];\n    var i, ii, j, jj, replays, replay;\n\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n\n      for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n        var replayType = replayTypes[j];\n        replay = replays[replayType];\n\n        if (replay !== undefined) {\n          if (opt_declutterReplays && (replayType == ReplayType["a" /* default */].IMAGE || replayType == ReplayType["a" /* default */].TEXT)) {\n            var declutter = opt_declutterReplays[zIndexKey];\n\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);\n          }\n        }\n      }\n    }\n\n    context.restore();\n  };\n\n  return CanvasReplayGroup;\n}(render_ReplayGroup);\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\n\n\nvar circleArrayCache = {\n  0: [[true]]\n};\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\n\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  var i;\n  var radius = Math.floor(array.length / 2);\n\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\n\n\nfunction getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n\n  var arraySize = radius * 2 + 1;\n  var arr = new Array(arraySize);\n\n  for (var i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n\n  var x = radius;\n  var y = 0;\n  var error = 0;\n\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n    y++;\n    error += 1 + 2 * y;\n\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n */\n\nfunction replayDeclutter(declutterReplays, context, rotation, snapToPixel) {\n  var zs = Object.keys(declutterReplays).map(Number).sort(array["g" /* numberSafeCompareFunction */]);\n  var skippedFeatureUids = {};\n\n  for (var z = 0, zz = zs.length; z < zz; ++z) {\n    var replayData = declutterReplays[zs[z].toString()];\n\n    for (var i = 0, ii = replayData.length; i < ii;) {\n      var replay = replayData[i++];\n      var transform = replayData[i++];\n      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);\n    }\n  }\n}\n/* harmony default export */ var canvas_ReplayGroup = __webpack_exports__["a"] = (ReplayGroup_CanvasReplayGroup);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3JlbmRlci9SZXBsYXlHcm91cC5qcz8yZjk3Iiwid2VicGFjazovLy8uLi8uLi8uLi8uLi9zcmMvb2wvZ2VvbS9mbGF0L3RleHRwYXRoLmpzPzAyZmYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXIvY2FudmFzL0luc3RydWN0aW9uLmpzP2NiM2QiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXIvY2FudmFzL1JlcGxheS5qcz9hZTg2Iiwid2VicGFjazovLy8uLi8uLi8uLi8uLi9zcmMvb2wvcmVuZGVyL2NhbnZhcy9JbWFnZVJlcGxheS5qcz84NjAwIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi9zcmMvb2wvcmVuZGVyL2NhbnZhcy9MaW5lU3RyaW5nUmVwbGF5LmpzP2VmMzgiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXIvY2FudmFzL1BvbHlnb25SZXBsYXkuanM/MzRjZSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9zdHJhaWdodGNodW5rLmpzPzM1YmQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXIvY2FudmFzL1RleHRSZXBsYXkuanM/ZTc5ZSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanM/ODJmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL1JlcGxheUdyb3VwXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHJlcGxheSBncm91cHMuXG4gKi9cbmNsYXNzIFJlcGxheUdyb3VwIHtcbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHpJbmRleCBaIGluZGV4LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vUmVwbGF5VHlwZS5qc1wiKS5kZWZhdWx0fSByZXBsYXlUeXBlIFJlcGxheSB0eXBlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1ZlY3RvckNvbnRleHQuanNcIikuZGVmYXVsdH0gUmVwbGF5LlxuICAgKi9cbiAgZ2V0UmVwbGF5KHpJbmRleCwgcmVwbGF5VHlwZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZ3JvdXAgR3JvdXAgd2l0aCBwcmV2aW91cyByZXBsYXlcbiAgICogQHJldHVybiB7QXJyYXk8Kj59IFRoZSByZXN1bHRpbmcgaW5zdHJ1Y3Rpb24gZ3JvdXBcbiAgICovXG4gIGFkZERlY2x1dHRlcihncm91cCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlcGxheUdyb3VwO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC90ZXh0cGF0aFxuICovXG5pbXBvcnQge2xlcnB9IGZyb20gJy4uLy4uL21hdGguanMnO1xuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgUGF0aCB0byBwdXQgdGV4dCBvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgU3RhcnQgb2Zmc2V0IG9mIHRoZSBgZmxhdENvb3JkaW5hdGVzYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldCBvZiB0aGUgYGZsYXRDb29yZGluYXRlc2AuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGxhY2Ugb24gdGhlIHBhdGguXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk6bnVtYmVyfSBtZWFzdXJlIE1lYXN1cmUgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZVxuICogd2lkdGggb2YgdGhlIGNoYXJhY3RlciBwYXNzZWQgYXMgMXN0IGFyZ3VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0TSBtIGFsb25nIHRoZSBwYXRoIHdoZXJlIHRoZSB0ZXh0IHN0YXJ0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBNYXggYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFycyBpbiByYWRpYW5zLlxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8Kj4+fSBUaGUgcmVzdWx0IGFycmF5IG9mIG51bGwgaWYgYG1heEFuZ2xlYCB3YXNcbiAqIGV4Y2VlZGVkLiBFbnRyaWVzIG9mIHRoZSBhcnJheSBhcmUgeCwgeSwgYW5jaG9yWCwgYW5nbGUsIGNodW5rLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhd1RleHRPblBhdGgoXG4gIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgdGV4dCwgbWVhc3VyZSwgc3RhcnRNLCBtYXhBbmdsZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAvLyBLZWVwIHRleHQgdXByaWdodFxuICBjb25zdCByZXZlcnNlID0gZmxhdENvb3JkaW5hdGVzW29mZnNldF0gPiBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcblxuICBjb25zdCBudW1DaGFycyA9IHRleHQubGVuZ3RoO1xuXG4gIGxldCB4MSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBsZXQgeTEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIG9mZnNldCArPSBzdHJpZGU7XG4gIGxldCB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBsZXQgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gIGxldCBzZWdtZW50TSA9IDA7XG4gIGxldCBzZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpO1xuXG4gIGxldCBjaHVuayA9ICcnO1xuICBsZXQgY2h1bmtMZW5ndGggPSAwO1xuICBsZXQgZGF0YSwgaW5kZXgsIHByZXZpb3VzQW5nbGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2hhcnM7ICsraSkge1xuICAgIGluZGV4ID0gcmV2ZXJzZSA/IG51bUNoYXJzIC0gaSAtIDEgOiBpO1xuICAgIGNvbnN0IGNoYXIgPSB0ZXh0LmNoYXJBdChpbmRleCk7XG4gICAgY2h1bmsgPSByZXZlcnNlID8gY2hhciArIGNodW5rIDogY2h1bmsgKyBjaGFyO1xuICAgIGNvbnN0IGNoYXJMZW5ndGggPSBtZWFzdXJlKGNodW5rKSAtIGNodW5rTGVuZ3RoO1xuICAgIGNodW5rTGVuZ3RoICs9IGNoYXJMZW5ndGg7XG4gICAgY29uc3QgY2hhck0gPSBzdGFydE0gKyBjaGFyTGVuZ3RoIC8gMjtcbiAgICB3aGlsZSAob2Zmc2V0IDwgZW5kIC0gc3RyaWRlICYmIHNlZ21lbnRNICsgc2VnbWVudExlbmd0aCA8IGNoYXJNKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICAgIG9mZnNldCArPSBzdHJpZGU7XG4gICAgICB4MiA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICAgICAgeTIgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV07XG4gICAgICBzZWdtZW50TSArPSBzZWdtZW50TGVuZ3RoO1xuICAgICAgc2VnbWVudExlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKTtcbiAgICB9XG4gICAgY29uc3Qgc2VnbWVudFBvcyA9IGNoYXJNIC0gc2VnbWVudE07XG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgYW5nbGUgKz0gYW5nbGUgPiAwID8gLU1hdGguUEkgOiBNYXRoLlBJO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNBbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgZGVsdGEgPSBhbmdsZSAtIHByZXZpb3VzQW5nbGU7XG4gICAgICBkZWx0YSArPSAoZGVsdGEgPiBNYXRoLlBJKSA/IC0yICogTWF0aC5QSSA6IChkZWx0YSA8IC1NYXRoLlBJKSA/IDIgKiBNYXRoLlBJIDogMDtcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPiBtYXhBbmdsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZXJwb2xhdGUgPSBzZWdtZW50UG9zIC8gc2VnbWVudExlbmd0aDtcbiAgICBjb25zdCB4ID0gbGVycCh4MSwgeDIsIGludGVycG9sYXRlKTtcbiAgICBjb25zdCB5ID0gbGVycCh5MSwgeTIsIGludGVycG9sYXRlKTtcbiAgICBpZiAocHJldmlvdXNBbmdsZSA9PSBhbmdsZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgZGF0YVswXSA9IHg7XG4gICAgICAgIGRhdGFbMV0gPSB5O1xuICAgICAgICBkYXRhWzJdID0gY2hhckxlbmd0aCAvIDI7XG4gICAgICB9XG4gICAgICBkYXRhWzRdID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNodW5rID0gY2hhcjtcbiAgICAgIGNodW5rTGVuZ3RoID0gY2hhckxlbmd0aDtcbiAgICAgIGRhdGEgPSBbeCwgeSwgY2hhckxlbmd0aCAvIDIsIGFuZ2xlLCBjaHVua107XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXN1bHQudW5zaGlmdChkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRhdGEpO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNBbmdsZSA9IGFuZ2xlO1xuICAgIH1cbiAgICBzdGFydE0gKz0gY2hhckxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvSW5zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IEluc3RydWN0aW9uID0ge1xuICBCRUdJTl9HRU9NRVRSWTogMCxcbiAgQkVHSU5fUEFUSDogMSxcbiAgQ0lSQ0xFOiAyLFxuICBDTE9TRV9QQVRIOiAzLFxuICBDVVNUT006IDQsXG4gIERSQVdfQ0hBUlM6IDUsXG4gIERSQVdfSU1BR0U6IDYsXG4gIEVORF9HRU9NRVRSWTogNyxcbiAgRklMTDogOCxcbiAgTU9WRV9UT19MSU5FX1RPOiA5LFxuICBTRVRfRklMTF9TVFlMRTogMTAsXG4gIFNFVF9TVFJPS0VfU1RZTEU6IDExLFxuICBTVFJPS0U6IDEyXG59O1xuXG5cbi8qKlxuICogQHR5cGUge0FycmF5PEluc3RydWN0aW9uPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbGxJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5GSUxMXTtcblxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxJbnN0cnVjdGlvbj59XG4gKi9cbmV4cG9ydCBjb25zdCBzdHJva2VJbnN0cnVjdGlvbiA9IFtJbnN0cnVjdGlvbi5TVFJPS0VdO1xuXG5cbi8qKlxuICogQHR5cGUge0FycmF5PEluc3RydWN0aW9uPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJlZ2luUGF0aEluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLkJFR0lOX1BBVEhdO1xuXG5cbi8qKlxuICogQHR5cGUge0FycmF5PEluc3RydWN0aW9uPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNsb3NlUGF0aEluc3RydWN0aW9uID0gW0luc3RydWN0aW9uLkNMT1NFX1BBVEhdO1xuXG5cbmV4cG9ydCBkZWZhdWx0IEluc3RydWN0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvUmVwbGF5XG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi8uLi91dGlsLmpzJztcbmltcG9ydCB7ZXF1YWxzLCByZXZlcnNlU3ViQXJyYXl9IGZyb20gJy4uLy4uL2FycmF5LmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uLy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2J1ZmZlciwgY2xvbmUsIGNvb3JkaW5hdGVSZWxhdGlvbnNoaXAsIGNyZWF0ZUVtcHR5LCBjcmVhdGVPclVwZGF0ZSxcbiAgY3JlYXRlT3JVcGRhdGVFbXB0eSwgZXh0ZW5kLCBleHRlbmRDb29yZGluYXRlLCBpbnRlcnNlY3RzfSBmcm9tICcuLi8uLi9leHRlbnQuanMnO1xuaW1wb3J0IFJlbGF0aW9uc2hpcCBmcm9tICcuLi8uLi9leHRlbnQvUmVsYXRpb25zaGlwLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHtpbmZsYXRlQ29vcmRpbmF0ZXMsIGluZmxhdGVDb29yZGluYXRlc0FycmF5LCBpbmZsYXRlTXVsdGlDb29yZGluYXRlc0FycmF5fSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyc7XG5pbXBvcnQge2xpbmVTdHJpbmdMZW5ndGh9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9sZW5ndGguanMnO1xuaW1wb3J0IHtkcmF3VGV4dE9uUGF0aH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RleHRwYXRoLmpzJztcbmltcG9ydCB7dHJhbnNmb3JtMkR9IGZyb20gJy4uLy4uL2dlb20vZmxhdC90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtDQU5WQVNfTElORV9EQVNIfSBmcm9tICcuLi8uLi9oYXMuanMnO1xuaW1wb3J0IHtpc0VtcHR5fSBmcm9tICcuLi8uLi9vYmouanMnO1xuaW1wb3J0IFZlY3RvckNvbnRleHQgZnJvbSAnLi4vVmVjdG9yQ29udGV4dC5qcyc7XG5pbXBvcnQge2RyYXdJbWFnZSwgcmVzZXRUcmFuc2Zvcm0sIGRlZmF1bHRQYWRkaW5nLCBkZWZhdWx0RmlsbFN0eWxlLCBkZWZhdWx0U3Ryb2tlU3R5bGUsXG4gIGRlZmF1bHRNaXRlckxpbWl0LCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRMaW5lRGFzaE9mZnNldCxcbiAgZGVmYXVsdExpbmVEYXNoLCBkZWZhdWx0TGluZUNhcH0gZnJvbSAnLi4vY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCB7VEVYVF9BTElHTn0gZnJvbSAnLi4vcmVwbGF5LmpzJztcbmltcG9ydCB7XG4gIGNyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sXG4gIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSxcbiAgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm0sXG4gIHNldEZyb21BcnJheSBhcyB0cmFuc2Zvcm1TZXRGcm9tQXJyYXlcbn0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICovXG5jb25zdCB0bXBFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuXG5cbi8qKlxuICogQHR5cGUgeyFpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICovXG5jb25zdCB0bXBUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuXG5jbGFzcyBDYW52YXNSZXBsYXkgZXh0ZW5kcyBWZWN0b3JDb250ZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IG1heEV4dGVudCBNYXhpbXVtIGV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcmxhcHMgVGhlIHJlcGxheSBjYW4gaGF2ZSBvdmVybGFwcGluZyBnZW9tZXRyaWVzLlxuICAgKiBAcGFyYW0gez99IGRlY2x1dHRlclRyZWUgRGVjbHV0dGVyIHRyZWUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJUcmVlID0gZGVjbHV0dGVyVHJlZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlID0gdG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMubWF4RXh0ZW50ID0gbWF4RXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxhcHMgPSBvdmVybGFwcztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm1heExpbmVXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsaWduRmlsbF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTwqPn1cbiAgICAgKi9cbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAqL1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxudW1iZXIsaW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfEFycmF5PGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT58QXJyYXk8QXJyYXk8aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPj4+fVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZUNhY2hlXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IWltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZX0gKi8gKHt9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSAwO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHAxIDFzdCBwb2ludCBvZiB0aGUgYmFja2dyb3VuZCBib3guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwMiAybmQgcG9pbnQgb2YgdGhlIGJhY2tncm91bmQgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gcDMgM3JkIHBvaW50IG9mIHRoZSBiYWNrZ3JvdW5kIGJveC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHA0IDR0aCBwb2ludCBvZiB0aGUgYmFja2dyb3VuZCBib3guXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGZpbGxJbnN0cnVjdGlvbiBGaWxsIGluc3RydWN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBzdHJva2VJbnN0cnVjdGlvbiBTdHJva2UgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICByZXBsYXlUZXh0QmFja2dyb3VuZF8oY29udGV4dCwgcDEsIHAyLCBwMywgcDQsIGZpbGxJbnN0cnVjdGlvbiwgc3Ryb2tlSW5zdHJ1Y3Rpb24pIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvLmFwcGx5KGNvbnRleHQsIHAxKTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwMik7XG4gICAgY29udGV4dC5saW5lVG8uYXBwbHkoY29udGV4dCwgcDMpO1xuICAgIGNvbnRleHQubGluZVRvLmFwcGx5KGNvbnRleHQsIHA0KTtcbiAgICBjb250ZXh0LmxpbmVUby5hcHBseShjb250ZXh0LCBwMSk7XG4gICAgaWYgKGZpbGxJbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5hbGlnbkZpbGxfID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoZmlsbEluc3RydWN0aW9uWzJdKTtcbiAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChzdHJva2VJbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5zZXRTdHJva2VTdHlsZV8oY29udGV4dCwgLyoqIEB0eXBlIHtBcnJheTwqPn0gKi8gKHN0cm9rZUluc3RydWN0aW9uKSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBZLlxuICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgSW1hZ2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmNob3JYIEFuY2hvciBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5jaG9yWSBBbmNob3IgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9IGRlY2x1dHRlckdyb3VwIERlY2x1dHRlciBncm91cC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5YIE9yaWdpbiBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luWSBPcmlnaW4gWS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgU2NhbGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCB0byBwaXhlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBhZGRpbmcgUGFkZGluZy5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gZmlsbEluc3RydWN0aW9uIEZpbGwgaW5zdHJ1Y3Rpb24uXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IHN0cm9rZUluc3RydWN0aW9uIFN0cm9rZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIHJlcGxheUltYWdlXyhcbiAgICBjb250ZXh0LFxuICAgIHgsXG4gICAgeSxcbiAgICBpbWFnZSxcbiAgICBhbmNob3JYLFxuICAgIGFuY2hvclksXG4gICAgZGVjbHV0dGVyR3JvdXAsXG4gICAgaGVpZ2h0LFxuICAgIG9wYWNpdHksXG4gICAgb3JpZ2luWCxcbiAgICBvcmlnaW5ZLFxuICAgIHJvdGF0aW9uLFxuICAgIHNjYWxlLFxuICAgIHNuYXBUb1BpeGVsLFxuICAgIHdpZHRoLFxuICAgIHBhZGRpbmcsXG4gICAgZmlsbEluc3RydWN0aW9uLFxuICAgIHN0cm9rZUluc3RydWN0aW9uXG4gICkge1xuICAgIGNvbnN0IGZpbGxTdHJva2UgPSBmaWxsSW5zdHJ1Y3Rpb24gfHwgc3Ryb2tlSW5zdHJ1Y3Rpb247XG4gICAgYW5jaG9yWCAqPSBzY2FsZTtcbiAgICBhbmNob3JZICo9IHNjYWxlO1xuICAgIHggLT0gYW5jaG9yWDtcbiAgICB5IC09IGFuY2hvclk7XG5cbiAgICBjb25zdCB3ID0gKHdpZHRoICsgb3JpZ2luWCA+IGltYWdlLndpZHRoKSA/IGltYWdlLndpZHRoIC0gb3JpZ2luWCA6IHdpZHRoO1xuICAgIGNvbnN0IGggPSAoaGVpZ2h0ICsgb3JpZ2luWSA+IGltYWdlLmhlaWdodCkgPyBpbWFnZS5oZWlnaHQgLSBvcmlnaW5ZIDogaGVpZ2h0O1xuICAgIGNvbnN0IGJveFcgPSBwYWRkaW5nWzNdICsgdyAqIHNjYWxlICsgcGFkZGluZ1sxXTtcbiAgICBjb25zdCBib3hIID0gcGFkZGluZ1swXSArIGggKiBzY2FsZSArIHBhZGRpbmdbMl07XG4gICAgY29uc3QgYm94WCA9IHggLSBwYWRkaW5nWzNdO1xuICAgIGNvbnN0IGJveFkgPSB5IC0gcGFkZGluZ1swXTtcblxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqL1xuICAgIGxldCBwMTtcbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi9cbiAgICBsZXQgcDI7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovXG4gICAgbGV0IHAzO1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqL1xuICAgIGxldCBwNDtcbiAgICBpZiAoZmlsbFN0cm9rZSB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgcDEgPSBbYm94WCwgYm94WV07XG4gICAgICBwMiA9IFtib3hYICsgYm94VywgYm94WV07XG4gICAgICBwMyA9IFtib3hYICsgYm94VywgYm94WSArIGJveEhdO1xuICAgICAgcDQgPSBbYm94WCwgYm94WSArIGJveEhdO1xuICAgIH1cblxuICAgIGxldCB0cmFuc2Zvcm0gPSBudWxsO1xuICAgIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgICAgY29uc3QgY2VudGVyWCA9IHggKyBhbmNob3JYO1xuICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBhbmNob3JZO1xuICAgICAgdHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sIGNlbnRlclgsIGNlbnRlclksIDEsIDEsIHJvdGF0aW9uLCAtY2VudGVyWCwgLWNlbnRlclkpO1xuXG4gICAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KHRtcEV4dGVudCk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKHRtcEV4dGVudCwgYXBwbHlUcmFuc2Zvcm0odG1wVHJhbnNmb3JtLCBwMSkpO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZSh0bXBFeHRlbnQsIGFwcGx5VHJhbnNmb3JtKHRtcFRyYW5zZm9ybSwgcDIpKTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUodG1wRXh0ZW50LCBhcHBseVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sIHAzKSk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKHRtcEV4dGVudCwgYXBwbHlUcmFuc2Zvcm0odG1wVHJhbnNmb3JtLCBwNCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVPclVwZGF0ZShib3hYLCBib3hZLCBib3hYICsgYm94VywgYm94WSArIGJveEgsIHRtcEV4dGVudCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGNvbnN0IHN0cm9rZVBhZGRpbmcgPSBzdHJva2VJbnN0cnVjdGlvbiA/IChzdHJva2VJbnN0cnVjdGlvblsyXSAqIHNjYWxlIC8gMikgOiAwO1xuICAgIGNvbnN0IGludGVyc2VjdHMgPVxuICAgICAgICB0bXBFeHRlbnRbMF0gLSBzdHJva2VQYWRkaW5nIDw9IGNhbnZhcy53aWR0aCAmJiB0bXBFeHRlbnRbMl0gKyBzdHJva2VQYWRkaW5nID49IDAgJiZcbiAgICAgICAgdG1wRXh0ZW50WzFdIC0gc3Ryb2tlUGFkZGluZyA8PSBjYW52YXMuaGVpZ2h0ICYmIHRtcEV4dGVudFszXSArIHN0cm9rZVBhZGRpbmcgPj0gMDtcblxuICAgIGlmIChzbmFwVG9QaXhlbCkge1xuICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICB9XG5cbiAgICBpZiAoZGVjbHV0dGVyR3JvdXApIHtcbiAgICAgIGlmICghaW50ZXJzZWN0cyAmJiBkZWNsdXR0ZXJHcm91cFs0XSA9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4dGVuZChkZWNsdXR0ZXJHcm91cCwgdG1wRXh0ZW50KTtcbiAgICAgIGNvbnN0IGRlY2x1dHRlckFyZ3MgPSBpbnRlcnNlY3RzID9cbiAgICAgICAgW2NvbnRleHQsIHRyYW5zZm9ybSA/IHRyYW5zZm9ybS5zbGljZSgwKSA6IG51bGwsIG9wYWNpdHksIGltYWdlLCBvcmlnaW5YLCBvcmlnaW5ZLCB3LCBoLCB4LCB5LCBzY2FsZV0gOlxuICAgICAgICBudWxsO1xuICAgICAgaWYgKGRlY2x1dHRlckFyZ3MgJiYgZmlsbFN0cm9rZSkge1xuICAgICAgICBkZWNsdXR0ZXJBcmdzLnB1c2goZmlsbEluc3RydWN0aW9uLCBzdHJva2VJbnN0cnVjdGlvbiwgcDEsIHAyLCBwMywgcDQpO1xuICAgICAgfVxuICAgICAgZGVjbHV0dGVyR3JvdXAucHVzaChkZWNsdXR0ZXJBcmdzKTtcbiAgICB9IGVsc2UgaWYgKGludGVyc2VjdHMpIHtcbiAgICAgIGlmIChmaWxsU3Ryb2tlKSB7XG4gICAgICAgIHRoaXMucmVwbGF5VGV4dEJhY2tncm91bmRfKGNvbnRleHQsIHAxLCBwMiwgcDMsIHA0LFxuICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChmaWxsSW5zdHJ1Y3Rpb24pLFxuICAgICAgICAgIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChzdHJva2VJbnN0cnVjdGlvbikpO1xuICAgICAgfVxuICAgICAgZHJhd0ltYWdlKGNvbnRleHQsIHRyYW5zZm9ybSwgb3BhY2l0eSwgaW1hZ2UsIG9yaWdpblgsIG9yaWdpblksIHcsIGgsIHgsIHksIHNjYWxlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGRhc2hBcnJheSBEYXNoIGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBEYXNoIGFycmF5IHdpdGggcGl4ZWwgcmF0aW8gYXBwbGllZFxuICAgKi9cbiAgYXBwbHlQaXhlbFJhdGlvKGRhc2hBcnJheSkge1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLnBpeGVsUmF0aW87XG4gICAgcmV0dXJuIHBpeGVsUmF0aW8gPT0gMSA/IGRhc2hBcnJheSA6IGRhc2hBcnJheS5tYXAoZnVuY3Rpb24oZGFzaCkge1xuICAgICAgcmV0dXJuIGRhc2ggKiBwaXhlbFJhdGlvO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VkIExhc3QgaW5wdXQgY29vcmRpbmF0ZSBlcXVhbHMgZmlyc3QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcEZpcnN0IFNraXAgZmlyc3QgY29vcmRpbmF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE15IGVuZC5cbiAgICovXG4gIGFwcGVuZEZsYXRDb29yZGluYXRlcyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGNsb3NlZCwgc2tpcEZpcnN0KSB7XG5cbiAgICBsZXQgbXlFbmQgPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICBjb25zdCBleHRlbnQgPSB0aGlzLmdldEJ1ZmZlcmVkTWF4RXh0ZW50KCk7XG4gICAgaWYgKHNraXBGaXJzdCkge1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZTtcbiAgICB9XG4gICAgY29uc3QgbGFzdENvb3JkID0gW2ZsYXRDb29yZGluYXRlc1tvZmZzZXRdLCBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV1dO1xuICAgIGNvbnN0IG5leHRDb29yZCA9IFtOYU4sIE5hTl07XG4gICAgbGV0IHNraXBwZWQgPSB0cnVlO1xuXG4gICAgbGV0IGksIGxhc3RSZWwsIG5leHRSZWw7XG4gICAgZm9yIChpID0gb2Zmc2V0ICsgc3RyaWRlOyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgbmV4dENvb3JkWzBdID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgICAgbmV4dENvb3JkWzFdID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIG5leHRSZWwgPSBjb29yZGluYXRlUmVsYXRpb25zaGlwKGV4dGVudCwgbmV4dENvb3JkKTtcbiAgICAgIGlmIChuZXh0UmVsICE9PSBsYXN0UmVsKSB7XG4gICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RDb29yZFswXTtcbiAgICAgICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbGFzdENvb3JkWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBuZXh0Q29vcmRbMF07XG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBuZXh0Q29vcmRbMV07XG4gICAgICAgIHNraXBwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dFJlbCA9PT0gUmVsYXRpb25zaGlwLklOVEVSU0VDVElORykge1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbmV4dENvb3JkWzBdO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzW215RW5kKytdID0gbmV4dENvb3JkWzFdO1xuICAgICAgICBza2lwcGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RDb29yZFswXSA9IG5leHRDb29yZFswXTtcbiAgICAgIGxhc3RDb29yZFsxXSA9IG5leHRDb29yZFsxXTtcbiAgICAgIGxhc3RSZWwgPSBuZXh0UmVsO1xuICAgIH1cblxuICAgIC8vIExhc3QgY29vcmRpbmF0ZSBlcXVhbHMgZmlyc3Qgb3Igb25seSBvbmUgcG9pbnQgdG8gYXBwZW5kOlxuICAgIGlmICgoY2xvc2VkICYmIHNraXBwZWQpIHx8IGkgPT09IG9mZnNldCArIHN0cmlkZSkge1xuICAgICAgdGhpcy5jb29yZGluYXRlc1tteUVuZCsrXSA9IGxhc3RDb29yZFswXTtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZXNbbXlFbmQrK10gPSBsYXN0Q29vcmRbMV07XG4gICAgfVxuICAgIHJldHVybiBteUVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHJlcGxheUVuZHMgUmVwbGF5IGVuZHMuXG4gICAqIEByZXR1cm4ge251bWJlcn0gT2Zmc2V0LlxuICAgKi9cbiAgZHJhd0N1c3RvbUNvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlLCByZXBsYXlFbmRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBlbmQgPSBlbmRzW2ldO1xuICAgICAgY29uc3QgcmVwbGF5RW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgcmVwbGF5RW5kcy5wdXNoKHJlcGxheUVuZCk7XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2MuXG4gICAqL1xuICBkcmF3Q3VzdG9tKGdlb21ldHJ5LCBmZWF0dXJlLCByZW5kZXJlcikge1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgY29uc3QgdHlwZSA9IGdlb21ldHJ5LmdldFR5cGUoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBjb25zdCByZXBsYXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGxldCBmbGF0Q29vcmRpbmF0ZXMsIHJlcGxheUVuZCwgcmVwbGF5RW5kcywgcmVwbGF5RW5kc3M7XG4gICAgbGV0IG9mZnNldDtcbiAgICBpZiAodHlwZSA9PSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTikge1xuICAgICAgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSk7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgcmVwbGF5RW5kc3MgPSBbXTtcbiAgICAgIGNvbnN0IGVuZHNzID0gZ2VvbWV0cnkuZ2V0RW5kc3MoKTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG15RW5kcyA9IFtdO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmRyYXdDdXN0b21Db29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNzW2ldLCBzdHJpZGUsIG15RW5kcyk7XG4gICAgICAgIHJlcGxheUVuZHNzLnB1c2gobXlFbmRzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgcmVwbGF5QmVnaW4sIHJlcGxheUVuZHNzLCBnZW9tZXRyeSwgcmVuZGVyZXIsIGluZmxhdGVNdWx0aUNvb3JkaW5hdGVzQXJyYXldKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gR2VvbWV0cnlUeXBlLlBPTFlHT04gfHwgdHlwZSA9PSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkcpIHtcbiAgICAgIHJlcGxheUVuZHMgPSBbXTtcbiAgICAgIGZsYXRDb29yZGluYXRlcyA9ICh0eXBlID09IEdlb21ldHJ5VHlwZS5QT0xZR09OKSA/XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKSA6XG4gICAgICAgIGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3Q3VzdG9tQ29vcmRpbmF0ZXNfKGZsYXRDb29yZGluYXRlcywgMCxcbiAgICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEVuZHMoKSxcbiAgICAgICAgc3RyaWRlLCByZXBsYXlFbmRzKTtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgcmVwbGF5QmVnaW4sIHJlcGxheUVuZHMsIGdlb21ldHJ5LCByZW5kZXJlciwgaW5mbGF0ZUNvb3JkaW5hdGVzQXJyYXldKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HIHx8IHR5cGUgPT0gR2VvbWV0cnlUeXBlLk1VTFRJX1BPSU5UKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHJlcGxheUVuZCA9IHRoaXMuYXBwZW5kRmxhdENvb3JkaW5hdGVzKFxuICAgICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgcmVwbGF5QmVnaW4sIHJlcGxheUVuZCwgZ2VvbWV0cnksIHJlbmRlcmVyLCBpbmZsYXRlQ29vcmRpbmF0ZXNdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gR2VvbWV0cnlUeXBlLlBPSU5UKSB7XG4gICAgICBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZXMucHVzaChmbGF0Q29vcmRpbmF0ZXNbMF0sIGZsYXRDb29yZGluYXRlc1sxXSk7XG4gICAgICByZXBsYXlFbmQgPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkNVU1RPTSxcbiAgICAgICAgcmVwbGF5QmVnaW4sIHJlcGxheUVuZCwgZ2VvbWV0cnksIHJlbmRlcmVyXSk7XG4gICAgfVxuICAgIHRoaXMuZW5kR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBiZWdpbkdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24xXyA9IFtDYW52YXNJbnN0cnVjdGlvbi5CRUdJTl9HRU9NRVRSWSwgZmVhdHVyZSwgMF07XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaCh0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjFfKTtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjJfID0gW0NhbnZhc0luc3RydWN0aW9uLkJFR0lOX0dFT01FVFJZLCBmZWF0dXJlLCAwXTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgZmluaXNoKCkge31cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICovXG4gIGZpbGxfKGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5hbGlnbkZpbGxfKSB7XG4gICAgICBjb25zdCBvcmlnaW4gPSBhcHBseVRyYW5zZm9ybSh0aGlzLnJlbmRlcmVkVHJhbnNmb3JtXywgWzAsIDBdKTtcbiAgICAgIGNvbnN0IHJlcGVhdFNpemUgPSA1MTIgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShvcmlnaW5bMF0gJSByZXBlYXRTaXplLCBvcmlnaW5bMV0gJSByZXBlYXRTaXplKTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoaXMudmlld1JvdGF0aW9uXyk7XG4gICAgfVxuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGlmICh0aGlzLmFsaWduRmlsbF8pIHtcbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtLmFwcGx5KGNvbnRleHQsIHJlc2V0VHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gaW5zdHJ1Y3Rpb24gSW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBzZXRTdHJva2VTdHlsZV8oY29udGV4dCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgY29udGV4dC5saW5lQ2FwID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfSAqLyAoaW5zdHJ1Y3Rpb25bM10pO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAvKiogQHR5cGUge0NhbnZhc0xpbmVKb2lufSAqLyAoaW5zdHJ1Y3Rpb25bNF0pO1xuICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNV0pO1xuICAgIGlmIChDQU5WQVNfTElORV9EQVNIKSB7XG4gICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls3XSk7XG4gICAgICBjb250ZXh0LnNldExpbmVEYXNoKC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGluc3RydWN0aW9uWzZdKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwfSBkZWNsdXR0ZXJHcm91cCBEZWNsdXR0ZXIgZ3JvdXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgcmVuZGVyRGVjbHV0dGVyXyhkZWNsdXR0ZXJHcm91cCwgZmVhdHVyZSkge1xuICAgIGlmIChkZWNsdXR0ZXJHcm91cCAmJiBkZWNsdXR0ZXJHcm91cC5sZW5ndGggPiA1KSB7XG4gICAgICBjb25zdCBncm91cENvdW50ID0gZGVjbHV0dGVyR3JvdXBbNF07XG4gICAgICBpZiAoZ3JvdXBDb3VudCA9PSAxIHx8IGdyb3VwQ291bnQgPT0gZGVjbHV0dGVyR3JvdXAubGVuZ3RoIC0gNSkge1xuICAgICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3N0cnVjdHMvUkJ1c2guanNcIikuRW50cnl9ICovXG4gICAgICAgIGNvbnN0IGJveCA9IHtcbiAgICAgICAgICBtaW5YOiAvKiogQHR5cGUge251bWJlcn0gKi8gKGRlY2x1dHRlckdyb3VwWzBdKSxcbiAgICAgICAgICBtaW5ZOiAvKiogQHR5cGUge251bWJlcn0gKi8gKGRlY2x1dHRlckdyb3VwWzFdKSxcbiAgICAgICAgICBtYXhYOiAvKiogQHR5cGUge251bWJlcn0gKi8gKGRlY2x1dHRlckdyb3VwWzJdKSxcbiAgICAgICAgICBtYXhZOiAvKiogQHR5cGUge251bWJlcn0gKi8gKGRlY2x1dHRlckdyb3VwWzNdKSxcbiAgICAgICAgICB2YWx1ZTogZmVhdHVyZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuZGVjbHV0dGVyVHJlZS5jb2xsaWRlcyhib3gpKSB7XG4gICAgICAgICAgdGhpcy5kZWNsdXR0ZXJUcmVlLmluc2VydChib3gpO1xuICAgICAgICAgIGZvciAobGV0IGogPSA1LCBqaiA9IGRlY2x1dHRlckdyb3VwLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY2x1dHRlckRhdGEgPSAvKiogQHR5cGUge0FycmF5fSAqLyAoZGVjbHV0dGVyR3JvdXBbal0pO1xuICAgICAgICAgICAgaWYgKGRlY2x1dHRlckRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGRlY2x1dHRlckRhdGEubGVuZ3RoID4gMTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxheVRleHRCYWNrZ3JvdW5kXyhkZWNsdXR0ZXJEYXRhWzBdLFxuICAgICAgICAgICAgICAgICAgZGVjbHV0dGVyRGF0YVsxM10sIGRlY2x1dHRlckRhdGFbMTRdLCBkZWNsdXR0ZXJEYXRhWzE1XSwgZGVjbHV0dGVyRGF0YVsxNl0sXG4gICAgICAgICAgICAgICAgICBkZWNsdXR0ZXJEYXRhWzExXSwgZGVjbHV0dGVyRGF0YVsxMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRyYXdJbWFnZS5hcHBseSh1bmRlZmluZWQsIGRlY2x1dHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNsdXR0ZXJHcm91cC5sZW5ndGggPSA1O1xuICAgICAgICBjcmVhdGVPclVwZGF0ZUVtcHR5KGRlY2x1dHRlckdyb3VwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlc1xuICAgKiAgICAgdG8gc2tpcC5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gaW5zdHJ1Y3Rpb25zIEluc3RydWN0aW9ucyBhcnJheS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzbmFwVG9QaXhlbCBTbmFwIHBvaW50IHN5bWJvbHMgYW5kIHRleHQgdG8gaW50ZWdlciBwaXhlbHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpKTogVHx1bmRlZmluZWR9IGZlYXR1cmVDYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfaGl0RXh0ZW50IE9ubHkgY2hlY2sgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgdGhpc1xuICAgKiAgICAgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgcmVwbGF5XyhcbiAgICBjb250ZXh0LFxuICAgIHRyYW5zZm9ybSxcbiAgICBza2lwcGVkRmVhdHVyZXNIYXNoLFxuICAgIGluc3RydWN0aW9ucyxcbiAgICBzbmFwVG9QaXhlbCxcbiAgICBmZWF0dXJlQ2FsbGJhY2ssXG4gICAgb3B0X2hpdEV4dGVudFxuICApIHtcbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgbGV0IHBpeGVsQ29vcmRpbmF0ZXM7XG4gICAgaWYgKHRoaXMucGl4ZWxDb29yZGluYXRlc18gJiYgZXF1YWxzKHRyYW5zZm9ybSwgdGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8pKSB7XG4gICAgICBwaXhlbENvb3JkaW5hdGVzID0gdGhpcy5waXhlbENvb3JkaW5hdGVzXztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfKSB7XG4gICAgICAgIHRoaXMucGl4ZWxDb29yZGluYXRlc18gPSBbXTtcbiAgICAgIH1cbiAgICAgIHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm0yRChcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcywgMCwgdGhpcy5jb29yZGluYXRlcy5sZW5ndGgsIDIsXG4gICAgICAgIHRyYW5zZm9ybSwgdGhpcy5waXhlbENvb3JkaW5hdGVzXyk7XG4gICAgICB0cmFuc2Zvcm1TZXRGcm9tQXJyYXkodGhpcy5yZW5kZXJlZFRyYW5zZm9ybV8sIHRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGNvbnN0IHNraXBGZWF0dXJlcyA9ICFpc0VtcHR5KHNraXBwZWRGZWF0dXJlc0hhc2gpO1xuICAgIGxldCBpID0gMDsgLy8gaW5zdHJ1Y3Rpb24gaW5kZXhcbiAgICBjb25zdCBpaSA9IGluc3RydWN0aW9ucy5sZW5ndGg7IC8vIGVuZCBvZiBpbnN0cnVjdGlvbnNcbiAgICBsZXQgZCA9IDA7IC8vIGRhdGEgaW5kZXhcbiAgICBsZXQgZGQ7IC8vIGVuZCBvZiBwZXItaW5zdHJ1Y3Rpb24gZGF0YVxuICAgIGxldCBhbmNob3JYLCBhbmNob3JZLCBwcmV2WCwgcHJldlksIHJvdW5kWCwgcm91bmRZLCBkZWNsdXR0ZXJHcm91cCwgaW1hZ2U7XG4gICAgbGV0IHBlbmRpbmdGaWxsID0gMDtcbiAgICBsZXQgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgbGV0IGxhc3RGaWxsSW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgIGxldCBsYXN0U3Ryb2tlSW5zdHJ1Y3Rpb24gPSBudWxsO1xuICAgIGNvbnN0IGNvb3JkaW5hdGVDYWNoZSA9IHRoaXMuY29vcmRpbmF0ZUNhY2hlXztcbiAgICBjb25zdCB2aWV3Um90YXRpb24gPSB0aGlzLnZpZXdSb3RhdGlvbl87XG5cbiAgICBjb25zdCBzdGF0ZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyLmpzXCIpLlN0YXRlfSAqLyAoe1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIHBpeGVsUmF0aW86IHRoaXMucGl4ZWxSYXRpbyxcbiAgICAgIHJlc29sdXRpb246IHRoaXMucmVzb2x1dGlvbixcbiAgICAgIHJvdGF0aW9uOiB2aWV3Um90YXRpb25cbiAgICB9KTtcblxuICAgIC8vIFdoZW4gdGhlIGJhdGNoIHNpemUgZ2V0cyB0b28gYmlnLCBwZXJmb3JtYW5jZSBkZWNyZWFzZXMuIDIwMCBpcyBhIGdvb2RcbiAgICAvLyBiYWxhbmNlIGJldHdlZW4gYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGZpbGwvc3Ryb2tlIGluc3RydWN0aW9ucy5cbiAgICBjb25zdCBiYXRjaFNpemUgPSB0aGlzLmluc3RydWN0aW9ucyAhPSBpbnN0cnVjdGlvbnMgfHwgdGhpcy5vdmVybGFwcyA/IDAgOiAyMDA7XG4gICAgbGV0IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gZmVhdHVyZTtcbiAgICBsZXQgeCwgeTtcbiAgICB3aGlsZSAoaSA8IGlpKSB7XG4gICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcbiAgICAgIGNvbnN0IHR5cGUgPSAvKiogQHR5cGUge0NhbnZhc0luc3RydWN0aW9ufSAqLyAoaW5zdHJ1Y3Rpb25bMF0pO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlk6XG4gICAgICAgICAgZmVhdHVyZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBpZiAoKHNraXBGZWF0dXJlcyAmJiBza2lwcGVkRmVhdHVyZXNIYXNoW2dldFVpZChmZWF0dXJlKV0pIHx8ICFmZWF0dXJlLmdldEdlb21ldHJ5KCkpIHtcbiAgICAgICAgICAgIGkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdF9oaXRFeHRlbnQgIT09IHVuZGVmaW5lZCAmJiAhaW50ZXJzZWN0cyhcbiAgICAgICAgICAgIG9wdF9oaXRFeHRlbnQsIGZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgICAgICAgIGkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzJdKSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fUEFUSDpcbiAgICAgICAgICBpZiAocGVuZGluZ0ZpbGwgPiBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgICAgICAgICBwZW5kaW5nRmlsbCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcGVuZGluZ0ZpbGwgJiYgIXBlbmRpbmdTdHJva2UpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBwcmV2WCA9IHByZXZZID0gTmFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQ0lSQ0xFOlxuICAgICAgICAgIGQgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBjb25zdCB4MSA9IHBpeGVsQ29vcmRpbmF0ZXNbZF07XG4gICAgICAgICAgY29uc3QgeTEgPSBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXTtcbiAgICAgICAgICBjb25zdCB4MiA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDJdO1xuICAgICAgICAgIGNvbnN0IHkyID0gcGl4ZWxDb29yZGluYXRlc1tkICsgM107XG4gICAgICAgICAgY29uc3QgZHggPSB4MiAtIHgxO1xuICAgICAgICAgIGNvbnN0IGR5ID0geTIgLSB5MTtcbiAgICAgICAgICBjb25zdCByID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MSArIHIsIHkxKTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh4MSwgeTEsIHIsIDAsIDIgKiBNYXRoLlBJLCB0cnVlKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2FudmFzSW5zdHJ1Y3Rpb24uQ0xPU0VfUEFUSDpcbiAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5DVVNUT006XG4gICAgICAgICAgZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGRkID0gaW5zdHJ1Y3Rpb25bMl07XG4gICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gKi8gKGluc3RydWN0aW9uWzNdKTtcbiAgICAgICAgICBjb25zdCByZW5kZXJlciA9IGluc3RydWN0aW9uWzRdO1xuICAgICAgICAgIGNvbnN0IGZuID0gaW5zdHJ1Y3Rpb24ubGVuZ3RoID09IDYgPyBpbnN0cnVjdGlvbls1XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBzdGF0ZS5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICAgIHN0YXRlLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgIGlmICghKGkgaW4gY29vcmRpbmF0ZUNhY2hlKSkge1xuICAgICAgICAgICAgY29vcmRpbmF0ZUNhY2hlW2ldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvb3JkcyA9IGNvb3JkaW5hdGVDYWNoZVtpXTtcbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIGZuKHBpeGVsQ29vcmRpbmF0ZXMsIGQsIGRkLCAyLCBjb29yZHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb29yZHNbMF0gPSBwaXhlbENvb3JkaW5hdGVzW2RdO1xuICAgICAgICAgICAgY29vcmRzWzFdID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMV07XG4gICAgICAgICAgICBjb29yZHMubGVuZ3RoID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVuZGVyZXIoY29vcmRzLCBzdGF0ZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0U6XG4gICAgICAgICAgZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGRkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgaW1hZ2UgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gKi9cbiAgICAgICAgICAgICAgKGluc3RydWN0aW9uWzNdKTtcbiAgICAgICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIGluIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgICAgIGFuY2hvclggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICAgICAgICBhbmNob3JZID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls1XSk7XG4gICAgICAgICAgZGVjbHV0dGVyR3JvdXAgPSBmZWF0dXJlQ2FsbGJhY2sgPyBudWxsIDogLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9ICovIChpbnN0cnVjdGlvbls2XSk7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvbls3XSk7XG4gICAgICAgICAgY29uc3Qgb3BhY2l0eSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bOF0pO1xuICAgICAgICAgIGNvbnN0IG9yaWdpblggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzldKTtcbiAgICAgICAgICBjb25zdCBvcmlnaW5ZID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxMF0pO1xuICAgICAgICAgIGNvbnN0IHJvdGF0ZVdpdGhWaWV3ID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaW5zdHJ1Y3Rpb25bMTFdKTtcbiAgICAgICAgICBsZXQgcm90YXRpb24gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzEyXSk7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzEzXSk7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzE0XSk7XG5cbiAgICAgICAgICBsZXQgcGFkZGluZywgYmFja2dyb3VuZEZpbGwsIGJhY2tncm91bmRTdHJva2U7XG4gICAgICAgICAgaWYgKGluc3RydWN0aW9uLmxlbmd0aCA+IDE2KSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAoaW5zdHJ1Y3Rpb25bMTVdKTtcbiAgICAgICAgICAgIGJhY2tncm91bmRGaWxsID0gLyoqIEB0eXBlIHtib29sZWFufSAqLyAoaW5zdHJ1Y3Rpb25bMTZdKTtcbiAgICAgICAgICAgIGJhY2tncm91bmRTdHJva2UgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpbnN0cnVjdGlvblsxN10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gZGVmYXVsdFBhZGRpbmc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbCA9IGJhY2tncm91bmRTdHJva2UgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocm90YXRlV2l0aFZpZXcpIHtcbiAgICAgICAgICAgIHJvdGF0aW9uICs9IHZpZXdSb3RhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICg7IGQgPCBkZDsgZCArPSAyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxheUltYWdlXyhjb250ZXh0LFxuICAgICAgICAgICAgICBwaXhlbENvb3JkaW5hdGVzW2RdLCBwaXhlbENvb3JkaW5hdGVzW2QgKyAxXSwgaW1hZ2UsIGFuY2hvclgsIGFuY2hvclksXG4gICAgICAgICAgICAgIGRlY2x1dHRlckdyb3VwLCBoZWlnaHQsIG9wYWNpdHksIG9yaWdpblgsIG9yaWdpblksIHJvdGF0aW9uLCBzY2FsZSxcbiAgICAgICAgICAgICAgc25hcFRvUGl4ZWwsIHdpZHRoLCBwYWRkaW5nLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kRmlsbCA/IC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChsYXN0RmlsbEluc3RydWN0aW9uKSA6IG51bGwsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRTdHJva2UgPyAvKiogQHR5cGUge0FycmF5PCo+fSAqLyAobGFzdFN0cm9rZUluc3RydWN0aW9uKSA6IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnJlbmRlckRlY2x1dHRlcl8oZGVjbHV0dGVyR3JvdXAsIGZlYXR1cmUpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0NIQVJTOlxuICAgICAgICAgIGNvbnN0IGJlZ2luID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgY29uc3QgZW5kID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgY29uc3QgYmFzZWxpbmUgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzNdKTtcbiAgICAgICAgICBkZWNsdXR0ZXJHcm91cCA9IGZlYXR1cmVDYWxsYmFjayA/IG51bGwgOiAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH0gKi8gKGluc3RydWN0aW9uWzRdKTtcbiAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bNV0pO1xuICAgICAgICAgIGNvbnN0IGZpbGxLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzZdKTtcbiAgICAgICAgICBjb25zdCBtYXhBbmdsZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bN10pO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmUgPSAvKiogQHR5cGUge2Z1bmN0aW9uKHN0cmluZyk6bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bOF0pO1xuICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzldKTtcbiAgICAgICAgICBjb25zdCBzdHJva2VLZXkgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKGluc3RydWN0aW9uWzEwXSk7XG4gICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGluc3RydWN0aW9uWzExXSk7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoaW5zdHJ1Y3Rpb25bMTJdKTtcbiAgICAgICAgICBjb25zdCB0ZXh0S2V5ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChpbnN0cnVjdGlvblsxM10pO1xuICAgICAgICAgIGNvbnN0IHRleHRTY2FsZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMTRdKTtcblxuICAgICAgICAgIGNvbnN0IHBhdGhMZW5ndGggPSBsaW5lU3RyaW5nTGVuZ3RoKHBpeGVsQ29vcmRpbmF0ZXMsIGJlZ2luLCBlbmQsIDIpO1xuICAgICAgICAgIGNvbnN0IHRleHRMZW5ndGggPSBtZWFzdXJlKHRleHQpO1xuICAgICAgICAgIGlmIChvdmVyZmxvdyB8fCB0ZXh0TGVuZ3RoIDw9IHBhdGhMZW5ndGgpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9UZXh0UmVwbGF5LmpzXCIpLmRlZmF1bHR9ICovXG4gICAgICAgICAgICBjb25zdCB0ZXh0UmVwbGF5ID0gLyoqIEB0eXBlIHs/fSAqLyAodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QWxpZ24gPSB0ZXh0UmVwbGF5LnRleHRTdGF0ZXNbdGV4dEtleV0udGV4dEFsaWduO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRNID0gKHBhdGhMZW5ndGggLSB0ZXh0TGVuZ3RoKSAqIFRFWFRfQUxJR05bdGV4dEFsaWduXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gZHJhd1RleHRPblBhdGgoXG4gICAgICAgICAgICAgIHBpeGVsQ29vcmRpbmF0ZXMsIGJlZ2luLCBlbmQsIDIsIHRleHQsIG1lYXN1cmUsIHN0YXJ0TSwgbWF4QW5nbGUpO1xuICAgICAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgICAgIGxldCBjLCBjYywgY2hhcnMsIGxhYmVsLCBwYXJ0O1xuICAgICAgICAgICAgICBpZiAoc3Ryb2tlS2V5KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjID0gMCwgY2MgPSBwYXJ0cy5sZW5ndGg7IGMgPCBjYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydHNbY107IC8vIHgsIHksIGFuY2hvclgsIHJvdGF0aW9uLCBjaHVua1xuICAgICAgICAgICAgICAgICAgY2hhcnMgPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhcnRbNF0pO1xuICAgICAgICAgICAgICAgICAgbGFiZWwgPSB0ZXh0UmVwbGF5LmdldEltYWdlKGNoYXJzLCB0ZXh0S2V5LCAnJywgc3Ryb2tlS2V5KTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvclggPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbMl0pICsgc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgICBhbmNob3JZID0gYmFzZWxpbmUgKiBsYWJlbC5oZWlnaHQgKyAoMC41IC0gYmFzZWxpbmUpICogMiAqIHN0cm9rZVdpZHRoIC0gb2Zmc2V0WTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGF5SW1hZ2VfKGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFswXSksIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFsxXSksIGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JYLCBhbmNob3JZLCBkZWNsdXR0ZXJHcm91cCwgbGFiZWwuaGVpZ2h0LCAxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKHBhcnRbM10pLCB0ZXh0U2NhbGUsIGZhbHNlLCBsYWJlbC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFBhZGRpbmcsIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmlsbEtleSkge1xuICAgICAgICAgICAgICAgIGZvciAoYyA9IDAsIGNjID0gcGFydHMubGVuZ3RoOyBjIDwgY2M7ICsrYykge1xuICAgICAgICAgICAgICAgICAgcGFydCA9IHBhcnRzW2NdOyAvLyB4LCB5LCBhbmNob3JYLCByb3RhdGlvbiwgY2h1bmtcbiAgICAgICAgICAgICAgICAgIGNoYXJzID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXJ0WzRdKTtcbiAgICAgICAgICAgICAgICAgIGxhYmVsID0gdGV4dFJlcGxheS5nZXRJbWFnZShjaGFycywgdGV4dEtleSwgZmlsbEtleSwgJycpO1xuICAgICAgICAgICAgICAgICAgYW5jaG9yWCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFsyXSk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JZID0gYmFzZWxpbmUgKiBsYWJlbC5oZWlnaHQgLSBvZmZzZXRZO1xuICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYXlJbWFnZV8oY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzBdKSwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChwYXJ0WzFdKSwgbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvclgsIGFuY2hvclksIGRlY2x1dHRlckdyb3VwLCBsYWJlbC5oZWlnaHQsIDEsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAocGFydFszXSksIHRleHRTY2FsZSwgZmFsc2UsIGxhYmVsLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UGFkZGluZywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVuZGVyRGVjbHV0dGVyXyhkZWNsdXR0ZXJHcm91cCwgZmVhdHVyZSk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLkVORF9HRU9NRVRSWTpcbiAgICAgICAgICBpZiAoZmVhdHVyZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIChpbnN0cnVjdGlvblsxXSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBmZWF0dXJlQ2FsbGJhY2soZmVhdHVyZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5GSUxMOlxuICAgICAgICAgIGlmIChiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIHBlbmRpbmdGaWxsKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbF8oY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5NT1ZFX1RPX0xJTkVfVE86XG4gICAgICAgICAgZCA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgIGRkID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgICAgeCA9IHBpeGVsQ29vcmRpbmF0ZXNbZF07XG4gICAgICAgICAgeSA9IHBpeGVsQ29vcmRpbmF0ZXNbZCArIDFdO1xuICAgICAgICAgIHJvdW5kWCA9ICh4ICsgMC41KSB8IDA7XG4gICAgICAgICAgcm91bmRZID0gKHkgKyAwLjUpIHwgMDtcbiAgICAgICAgICBpZiAocm91bmRYICE9PSBwcmV2WCB8fCByb3VuZFkgIT09IHByZXZZKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgIHByZXZYID0gcm91bmRYO1xuICAgICAgICAgICAgcHJldlkgPSByb3VuZFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoZCArPSAyOyBkIDwgZGQ7IGQgKz0gMikge1xuICAgICAgICAgICAgeCA9IHBpeGVsQ29vcmRpbmF0ZXNbZF07XG4gICAgICAgICAgICB5ID0gcGl4ZWxDb29yZGluYXRlc1tkICsgMV07XG4gICAgICAgICAgICByb3VuZFggPSAoeCArIDAuNSkgfCAwO1xuICAgICAgICAgICAgcm91bmRZID0gKHkgKyAwLjUpIHwgMDtcbiAgICAgICAgICAgIGlmIChkID09IGRkIC0gMiB8fCByb3VuZFggIT09IHByZXZYIHx8IHJvdW5kWSAhPT0gcHJldlkpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgIHByZXZYID0gcm91bmRYO1xuICAgICAgICAgICAgICBwcmV2WSA9IHJvdW5kWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENhbnZhc0luc3RydWN0aW9uLlNFVF9GSUxMX1NUWUxFOlxuICAgICAgICAgIGxhc3RGaWxsSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgICB0aGlzLmFsaWduRmlsbF8gPSBpbnN0cnVjdGlvblsyXTtcblxuICAgICAgICAgIGlmIChwZW5kaW5nRmlsbCkge1xuICAgICAgICAgICAgdGhpcy5maWxsXyhjb250ZXh0KTtcbiAgICAgICAgICAgIHBlbmRpbmdGaWxsID0gMDtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgIHBlbmRpbmdTdHJva2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9jb2xvcmxpa2UuanNcIikuQ29sb3JMaWtlfSAqLyAoaW5zdHJ1Y3Rpb25bMV0pO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFOlxuICAgICAgICAgIGxhc3RTdHJva2VJbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uO1xuICAgICAgICAgIGlmIChwZW5kaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlU3R5bGVfKGNvbnRleHQsIC8qKiBAdHlwZSB7QXJyYXk8Kj59ICovIChpbnN0cnVjdGlvbikpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDYW52YXNJbnN0cnVjdGlvbi5TVFJPS0U6XG4gICAgICAgICAgaWYgKGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgcGVuZGluZ1N0cm9rZSsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgKytpOyAvLyBjb25zdW1lIHRoZSBpbnN0cnVjdGlvbiBhbnl3YXksIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBlbmRpbmdGaWxsKSB7XG4gICAgICB0aGlzLmZpbGxfKGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAocGVuZGluZ1N0cm9rZSkge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2aWV3Um90YXRpb24gVmlldyByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gc2tpcHBlZEZlYXR1cmVzSGFzaCBJZHMgb2YgZmVhdHVyZXNcbiAgICogICAgIHRvIHNraXAuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCBwb2ludCBzeW1ib2xzIGFuZCB0ZXh0IHRvIGludGVnZXIgcGl4ZWxzLlxuICAgKi9cbiAgcmVwbGF5KGNvbnRleHQsIHRyYW5zZm9ybSwgdmlld1JvdGF0aW9uLCBza2lwcGVkRmVhdHVyZXNIYXNoLCBzbmFwVG9QaXhlbCkge1xuICAgIHRoaXMudmlld1JvdGF0aW9uXyA9IHZpZXdSb3RhdGlvbjtcbiAgICB0aGlzLnJlcGxheV8oY29udGV4dCwgdHJhbnNmb3JtLFxuICAgICAgc2tpcHBlZEZlYXR1cmVzSGFzaCwgdGhpcy5pbnN0cnVjdGlvbnMsIHNuYXBUb1BpeGVsLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlld1JvdGF0aW9uIFZpZXcgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHNraXBwZWRGZWF0dXJlc0hhc2ggSWRzIG9mIGZlYXR1cmVzXG4gICAqICAgICB0byBza2lwLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KSk6IFQ9fSBvcHRfZmVhdHVyZUNhbGxiYWNrXG4gICAqICAgICBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfaGl0RXh0ZW50IE9ubHkgY2hlY2sgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgdGhpc1xuICAgKiAgICAgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgcmVwbGF5SGl0RGV0ZWN0aW9uKFxuICAgIGNvbnRleHQsXG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdSb3RhdGlvbixcbiAgICBza2lwcGVkRmVhdHVyZXNIYXNoLFxuICAgIG9wdF9mZWF0dXJlQ2FsbGJhY2ssXG4gICAgb3B0X2hpdEV4dGVudFxuICApIHtcbiAgICB0aGlzLnZpZXdSb3RhdGlvbl8gPSB2aWV3Um90YXRpb247XG4gICAgcmV0dXJuIHRoaXMucmVwbGF5Xyhjb250ZXh0LCB0cmFuc2Zvcm0sIHNraXBwZWRGZWF0dXJlc0hhc2gsXG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucywgdHJ1ZSwgb3B0X2ZlYXR1cmVDYWxsYmFjaywgb3B0X2hpdEV4dGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmV2ZXJzZSB0aGUgaGl0IGRldGVjdGlvbiBpbnN0cnVjdGlvbnMuXG4gICAqL1xuICByZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCkge1xuICAgIGNvbnN0IGhpdERldGVjdGlvbkluc3RydWN0aW9ucyA9IHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zO1xuICAgIC8vIHN0ZXAgMSAtIHJldmVyc2UgYXJyYXlcbiAgICBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucmV2ZXJzZSgpO1xuICAgIC8vIHN0ZXAgMiAtIHJldmVyc2UgaW5zdHJ1Y3Rpb25zIHdpdGhpbiBnZW9tZXRyeSBibG9ja3NcbiAgICBsZXQgaTtcbiAgICBjb25zdCBuID0gaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLmxlbmd0aDtcbiAgICBsZXQgaW5zdHJ1Y3Rpb247XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IGJlZ2luID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaW5zdHJ1Y3Rpb24gPSBoaXREZXRlY3Rpb25JbnN0cnVjdGlvbnNbaV07XG4gICAgICB0eXBlID0gLyoqIEB0eXBlIHtDYW52YXNJbnN0cnVjdGlvbn0gKi8gKGluc3RydWN0aW9uWzBdKTtcbiAgICAgIGlmICh0eXBlID09IENhbnZhc0luc3RydWN0aW9uLkVORF9HRU9NRVRSWSkge1xuICAgICAgICBiZWdpbiA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gQ2FudmFzSW5zdHJ1Y3Rpb24uQkVHSU5fR0VPTUVUUlkpIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25bMl0gPSBpO1xuICAgICAgICByZXZlcnNlU3ViQXJyYXkodGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMsIGJlZ2luLCBpKTtcbiAgICAgICAgYmVnaW4gPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHNldEZpbGxTdHJva2VTdHlsZShmaWxsU3R5bGUsIHN0cm9rZVN0eWxlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChmaWxsU3R5bGUpIHtcbiAgICAgIGNvbnN0IGZpbGxTdHlsZUNvbG9yID0gZmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICBzdGF0ZS5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShmaWxsU3R5bGVDb2xvciA/XG4gICAgICAgIGZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmZpbGxTdHlsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUNvbG9yID0gc3Ryb2tlU3R5bGUuZ2V0Q29sb3IoKTtcbiAgICAgIHN0YXRlLnN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2Uoc3Ryb2tlU3R5bGVDb2xvciA/XG4gICAgICAgIHN0cm9rZVN0eWxlQ29sb3IgOiBkZWZhdWx0U3Ryb2tlU3R5bGUpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lQ2FwID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpO1xuICAgICAgc3RhdGUubGluZUNhcCA9IHN0cm9rZVN0eWxlTGluZUNhcCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgc3Ryb2tlU3R5bGVMaW5lQ2FwIDogZGVmYXVsdExpbmVDYXA7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUxpbmVEYXNoID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgIHN0YXRlLmxpbmVEYXNoID0gc3Ryb2tlU3R5bGVMaW5lRGFzaCA/XG4gICAgICAgIHN0cm9rZVN0eWxlTGluZURhc2guc2xpY2UoKSA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgPSBzdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgc3RhdGUubGluZURhc2hPZmZzZXQgPSBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0ID9cbiAgICAgICAgc3Ryb2tlU3R5bGVMaW5lRGFzaE9mZnNldCA6IGRlZmF1bHRMaW5lRGFzaE9mZnNldDtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZUpvaW4gPSBzdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpO1xuICAgICAgc3RhdGUubGluZUpvaW4gPSBzdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZUxpbmVKb2luIDogZGVmYXVsdExpbmVKb2luO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVXaWR0aCA9IHN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICBzdGF0ZS5saW5lV2lkdGggPSBzdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICBzdHJva2VTdHlsZVdpZHRoIDogZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA9IHN0cm9rZVN0eWxlLmdldE1pdGVyTGltaXQoKTtcbiAgICAgIHN0YXRlLm1pdGVyTGltaXQgPSBzdHJva2VTdHlsZU1pdGVyTGltaXQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA6IGRlZmF1bHRNaXRlckxpbWl0O1xuXG4gICAgICBpZiAoc3RhdGUubGluZVdpZHRoID4gdGhpcy5tYXhMaW5lV2lkdGgpIHtcbiAgICAgICAgdGhpcy5tYXhMaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGg7XG4gICAgICAgIC8vIGludmFsaWRhdGUgdGhlIGJ1ZmZlcmVkIG1heCBleHRlbnQgY2FjaGVcbiAgICAgICAgdGhpcy5idWZmZXJlZE1heEV4dGVudF8gPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5zdHJva2VTdHlsZSA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLmxpbmVDYXAgPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5saW5lRGFzaCA9IG51bGw7XG4gICAgICBzdGF0ZS5saW5lRGFzaE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIHN0YXRlLmxpbmVKb2luID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubGluZVdpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgc3RhdGUubWl0ZXJMaW1pdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHJldHVybiB7QXJyYXk8Kj59IEZpbGwgaW5zdHJ1Y3Rpb24uXG4gICAqL1xuICBjcmVhdGVGaWxsKHN0YXRlLCBnZW9tZXRyeSkge1xuICAgIGNvbnN0IGZpbGxTdHlsZSA9IHN0YXRlLmZpbGxTdHlsZTtcbiAgICAvKiogQHR5cGUge0FycmF5PCo+fSAqL1xuICAgIGNvbnN0IGZpbGxJbnN0cnVjdGlvbiA9IFtDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSwgZmlsbFN0eWxlXTtcbiAgICBpZiAodHlwZW9mIGZpbGxTdHlsZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEZpbGwgaXMgYSBwYXR0ZXJuIG9yIGdyYWRpZW50IC0gYWxpZ24gaXQhXG4gICAgICBmaWxsSW5zdHJ1Y3Rpb24ucHVzaCh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxJbnN0cnVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKi9cbiAgYXBwbHlTdHJva2Uoc3RhdGUpIHtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHRoaXMuY3JlYXRlU3Ryb2tlKHN0YXRlKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8Kj59IFN0cm9rZSBpbnN0cnVjdGlvbi5cbiAgICovXG4gIGNyZWF0ZVN0cm9rZShzdGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsIHN0YXRlLmxpbmVXaWR0aCAqIHRoaXMucGl4ZWxSYXRpbywgc3RhdGUubGluZUNhcCxcbiAgICAgIHN0YXRlLmxpbmVKb2luLCBzdGF0ZS5taXRlckxpbWl0LFxuICAgICAgdGhpcy5hcHBseVBpeGVsUmF0aW8oc3RhdGUubGluZURhc2gpLCBzdGF0ZS5saW5lRGFzaE9mZnNldCAqIHRoaXMucGl4ZWxSYXRpb1xuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlfSBzdGF0ZSBTdGF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOkNhbnZhc1JlcGxheSwgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdHJva2VTdGF0ZSwgKGltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpKTpBcnJheTwqPn0gY3JlYXRlRmlsbCBDcmVhdGUgZmlsbC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICovXG4gIHVwZGF0ZUZpbGxTdHlsZShzdGF0ZSwgY3JlYXRlRmlsbCwgZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgaWYgKHR5cGVvZiBmaWxsU3R5bGUgIT09ICdzdHJpbmcnIHx8IHN0YXRlLmN1cnJlbnRGaWxsU3R5bGUgIT0gZmlsbFN0eWxlKSB7XG4gICAgICBpZiAoZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChjcmVhdGVGaWxsLmNhbGwodGhpcywgc3RhdGUsIGdlb21ldHJ5KSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5jdXJyZW50RmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3Ryb2tlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6Q2FudmFzUmVwbGF5LCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0cm9rZVN0YXRlKX0gYXBwbHlTdHJva2UgQXBwbHkgc3Ryb2tlLlxuICAgKi9cbiAgdXBkYXRlU3Ryb2tlU3R5bGUoc3RhdGUsIGFwcGx5U3Ryb2tlKSB7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBjb25zdCBsaW5lQ2FwID0gc3RhdGUubGluZUNhcDtcbiAgICBjb25zdCBsaW5lRGFzaCA9IHN0YXRlLmxpbmVEYXNoO1xuICAgIGNvbnN0IGxpbmVEYXNoT2Zmc2V0ID0gc3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgY29uc3QgbGluZUpvaW4gPSBzdGF0ZS5saW5lSm9pbjtcbiAgICBjb25zdCBsaW5lV2lkdGggPSBzdGF0ZS5saW5lV2lkdGg7XG4gICAgY29uc3QgbWl0ZXJMaW1pdCA9IHN0YXRlLm1pdGVyTGltaXQ7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnRTdHJva2VTdHlsZSAhPSBzdHJva2VTdHlsZSB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TGluZUNhcCAhPSBsaW5lQ2FwIHx8XG4gICAgICAgIChsaW5lRGFzaCAhPSBzdGF0ZS5jdXJyZW50TGluZURhc2ggJiYgIWVxdWFscyhzdGF0ZS5jdXJyZW50TGluZURhc2gsIGxpbmVEYXNoKSkgfHxcbiAgICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoT2Zmc2V0ICE9IGxpbmVEYXNoT2Zmc2V0IHx8XG4gICAgICAgIHN0YXRlLmN1cnJlbnRMaW5lSm9pbiAhPSBsaW5lSm9pbiB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TGluZVdpZHRoICE9IGxpbmVXaWR0aCB8fFxuICAgICAgICBzdGF0ZS5jdXJyZW50TWl0ZXJMaW1pdCAhPSBtaXRlckxpbWl0KSB7XG4gICAgICBpZiAoc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcHBseVN0cm9rZS5jYWxsKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmN1cnJlbnRTdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICBzdGF0ZS5jdXJyZW50TGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIHN0YXRlLmN1cnJlbnRMaW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgc3RhdGUuY3VycmVudExpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIHN0YXRlLmN1cnJlbnRNaXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBlbmRHZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeUluc3RydWN0aW9uMV9bMl0gPSB0aGlzLmluc3RydWN0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24xXyA9IG51bGw7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5SW5zdHJ1Y3Rpb24yX1syXSA9IHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLmxlbmd0aDtcbiAgICB0aGlzLmJlZ2luR2VvbWV0cnlJbnN0cnVjdGlvbjJfID0gbnVsbDtcbiAgICBjb25zdCBlbmRHZW9tZXRyeUluc3RydWN0aW9uID0gW0NhbnZhc0luc3RydWN0aW9uLkVORF9HRU9NRVRSWSwgZmVhdHVyZV07XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChlbmRHZW9tZXRyeUluc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGVuZEdlb21ldHJ5SW5zdHJ1Y3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyZWQgcmVuZGVyaW5nIGV4dGVudC4gIFJlbmRlcmluZyB3aWxsIGJlIGNsaXBwZWQgdG8gdGhlIGV4dGVudFxuICAgKiBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuICBUbyBhY2NvdW50IGZvciBzeW1ib2xpemVycyB0aGF0IG1heSBpbnRlcnNlY3RcbiAgICogdGhpcyBleHRlbnQsIHdlIGNhbGN1bGF0ZSBhIGJ1ZmZlcmVkIGV4dGVudCAoZS5nLiBiYXNlZCBvbiBzdHJva2Ugd2lkdGgpLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBUaGUgYnVmZmVyZWQgcmVuZGVyaW5nIGV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0QnVmZmVyZWRNYXhFeHRlbnQoKSB7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50Xykge1xuICAgICAgdGhpcy5idWZmZXJlZE1heEV4dGVudF8gPSBjbG9uZSh0aGlzLm1heEV4dGVudCk7XG4gICAgICBpZiAodGhpcy5tYXhMaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5yZXNvbHV0aW9uICogKHRoaXMubWF4TGluZVdpZHRoICsgMSkgLyAyO1xuICAgICAgICBidWZmZXIodGhpcy5idWZmZXJlZE1heEV4dGVudF8sIHdpZHRoLCB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50Xyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkTWF4RXh0ZW50XztcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1JlcGxheTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0ltYWdlUmVwbGF5XG4gKi9cbmltcG9ydCBDYW52YXNJbnN0cnVjdGlvbiBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi9SZXBsYXkuanMnO1xuXG5jbGFzcyBDYW52YXNJbWFnZVJlcGxheSBleHRlbmRzIENhbnZhc1JlcGxheSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4aW11bSBleHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXBzIFRoZSByZXBsYXkgY2FuIGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHs/fSBkZWNsdXR0ZXJUcmVlIERlY2x1dHRlciB0cmVlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKSB7XG4gICAgc3VwZXIodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlckdyb3VwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JYXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmNob3JZXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5oZWlnaHRfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9wYWNpdHlfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpblhfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbllfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25fID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy53aWR0aF8gPSB1bmRlZmluZWQ7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE15IGVuZC5cbiAgICovXG4gIGRyYXdDb29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kRmxhdENvb3JkaW5hdGVzKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZHJhd1BvaW50KHBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBpZiAoIXRoaXMuaW1hZ2VfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShwb2ludEdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBwb2ludEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHN0cmlkZSA9IHBvaW50R2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IG15RW5kID0gdGhpcy5kcmF3Q29vcmRpbmF0ZXNfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgIENhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIG15QmVnaW4sIG15RW5kLCB0aGlzLmltYWdlXyxcbiAgICAgIC8vIFJlbWFpbmluZyBhcmd1bWVudHMgdG8gRFJBV19JTUFHRSBhcmUgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG4gICAgICB0aGlzLmFuY2hvclhfLCB0aGlzLmFuY2hvcllfLCB0aGlzLmRlY2x1dHRlckdyb3VwXywgdGhpcy5oZWlnaHRfLCB0aGlzLm9wYWNpdHlfLFxuICAgICAgdGhpcy5vcmlnaW5YXywgdGhpcy5vcmlnaW5ZXywgdGhpcy5yb3RhdGVXaXRoVmlld18sIHRoaXMucm90YXRpb25fLFxuICAgICAgdGhpcy5zY2FsZV8gKiB0aGlzLnBpeGVsUmF0aW8sIHRoaXMud2lkdGhfXG4gICAgXSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBteUJlZ2luLCBteUVuZCwgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXywgdGhpcy5hbmNob3JZXywgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIHRoaXMuaGVpZ2h0XywgdGhpcy5vcGFjaXR5XyxcbiAgICAgIHRoaXMub3JpZ2luWF8sIHRoaXMub3JpZ2luWV8sIHRoaXMucm90YXRlV2l0aFZpZXdfLCB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfLCB0aGlzLndpZHRoX1xuICAgIF0pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkocG9pbnRHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGRyYXdNdWx0aVBvaW50KG11bHRpUG9pbnRHZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIGlmICghdGhpcy5pbWFnZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KG11bHRpUG9pbnRHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gbXVsdGlQb2ludEdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgIGNvbnN0IHN0cmlkZSA9IG11bHRpUG9pbnRHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBjb25zdCBteUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgY29uc3QgbXlFbmQgPSB0aGlzLmRyYXdDb29yZGluYXRlc18oXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0lNQUdFLCBteUJlZ2luLCBteUVuZCwgdGhpcy5pbWFnZV8sXG4gICAgICAvLyBSZW1haW5pbmcgYXJndW1lbnRzIHRvIERSQVdfSU1BR0UgYXJlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuICAgICAgdGhpcy5hbmNob3JYXywgdGhpcy5hbmNob3JZXywgdGhpcy5kZWNsdXR0ZXJHcm91cF8sIHRoaXMuaGVpZ2h0XywgdGhpcy5vcGFjaXR5XyxcbiAgICAgIHRoaXMub3JpZ2luWF8sIHRoaXMub3JpZ2luWV8sIHRoaXMucm90YXRlV2l0aFZpZXdfLCB0aGlzLnJvdGF0aW9uXyxcbiAgICAgIHRoaXMuc2NhbGVfICogdGhpcy5waXhlbFJhdGlvLCB0aGlzLndpZHRoX1xuICAgIF0pO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSwgbXlCZWdpbiwgbXlFbmQsIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfLFxuICAgICAgLy8gUmVtYWluaW5nIGFyZ3VtZW50cyB0byBEUkFXX0lNQUdFIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgICAgIHRoaXMuYW5jaG9yWF8sIHRoaXMuYW5jaG9yWV8sIHRoaXMuZGVjbHV0dGVyR3JvdXBfLCB0aGlzLmhlaWdodF8sIHRoaXMub3BhY2l0eV8sXG4gICAgICB0aGlzLm9yaWdpblhfLCB0aGlzLm9yaWdpbllfLCB0aGlzLnJvdGF0ZVdpdGhWaWV3XywgdGhpcy5yb3RhdGlvbl8sXG4gICAgICB0aGlzLnNjYWxlXywgdGhpcy53aWR0aF9cbiAgICBdKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KG11bHRpUG9pbnRHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGZpbmlzaCgpIHtcbiAgICB0aGlzLnJldmVyc2VIaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMoKTtcbiAgICAvLyBGSVhNRSB0aGlzIGRvZXNuJ3QgcmVhbGx5IHByb3RlY3QgdXMgYWdhaW5zdCBmdXJ0aGVyIGNhbGxzIHRvIGRyYXcqR2VvbWV0cnlcbiAgICB0aGlzLmFuY2hvclhfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYW5jaG9yWV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSBudWxsO1xuICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcbiAgICB0aGlzLmhlaWdodF8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vcGFjaXR5XyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9yaWdpblhfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3JpZ2luWV8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yb3RhdGlvbl8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aF8gPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgZGVjbHV0dGVyR3JvdXApIHtcbiAgICBjb25zdCBhbmNob3IgPSBpbWFnZVN0eWxlLmdldEFuY2hvcigpO1xuICAgIGNvbnN0IHNpemUgPSBpbWFnZVN0eWxlLmdldFNpemUoKTtcbiAgICBjb25zdCBoaXREZXRlY3Rpb25JbWFnZSA9IGltYWdlU3R5bGUuZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UoMSk7XG4gICAgY29uc3QgaW1hZ2UgPSBpbWFnZVN0eWxlLmdldEltYWdlKDEpO1xuICAgIGNvbnN0IG9yaWdpbiA9IGltYWdlU3R5bGUuZ2V0T3JpZ2luKCk7XG4gICAgdGhpcy5hbmNob3JYXyA9IGFuY2hvclswXTtcbiAgICB0aGlzLmFuY2hvcllfID0gYW5jaG9yWzFdO1xuICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9ICovIChkZWNsdXR0ZXJHcm91cCk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSBoaXREZXRlY3Rpb25JbWFnZTtcbiAgICB0aGlzLmltYWdlXyA9IGltYWdlO1xuICAgIHRoaXMuaGVpZ2h0XyA9IHNpemVbMV07XG4gICAgdGhpcy5vcGFjaXR5XyA9IGltYWdlU3R5bGUuZ2V0T3BhY2l0eSgpO1xuICAgIHRoaXMub3JpZ2luWF8gPSBvcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZXyA9IG9yaWdpblsxXTtcbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IGltYWdlU3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICB0aGlzLnJvdGF0aW9uXyA9IGltYWdlU3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICB0aGlzLnNjYWxlXyA9IGltYWdlU3R5bGUuZ2V0U2NhbGUoKTtcbiAgICB0aGlzLndpZHRoXyA9IHNpemVbMF07XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNJbWFnZVJlcGxheTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL0xpbmVTdHJpbmdSZXBsYXlcbiAqL1xuaW1wb3J0IENhbnZhc0luc3RydWN0aW9uLCB7c3Ryb2tlSW5zdHJ1Y3Rpb24sIGJlZ2luUGF0aEluc3RydWN0aW9ufSBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi9SZXBsYXkuanMnO1xuXG5jbGFzcyBDYW52YXNMaW5lU3RyaW5nUmVwbGF5IGV4dGVuZHMgQ2FudmFzUmVwbGF5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2UgVG9sZXJhbmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IG1heEV4dGVudCBNYXhpbXVtIGV4dGVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcmxhcHMgVGhlIHJlcGxheSBjYW4gaGF2ZSBvdmVybGFwcGluZyBnZW9tZXRyaWVzLlxuICAgKiBAcGFyYW0gez99IGRlY2x1dHRlclRyZWUgRGVjbHV0dGVyIHRyZWUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpIHtcbiAgICBzdXBlcih0b2xlcmFuY2UsIG1heEV4dGVudCwgcmVzb2x1dGlvbiwgcGl4ZWxSYXRpbywgb3ZlcmxhcHMsIGRlY2x1dHRlclRyZWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gZW5kLlxuICAgKi9cbiAgZHJhd0ZsYXRDb29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgY29uc3QgbXlCZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGNvbnN0IG15RW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgY29uc3QgbW92ZVRvTGluZVRvSW5zdHJ1Y3Rpb24gPSBbQ2FudmFzSW5zdHJ1Y3Rpb24uTU9WRV9UT19MSU5FX1RPLCBteUJlZ2luLCBteUVuZF07XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgcmV0dXJuIGVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZHJhd0xpbmVTdHJpbmcobGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgY29uc3QgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgIGlmIChzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3Ryb2tlU3R5bGUoc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX1NUUk9LRV9TVFlMRSxcbiAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLCBzdGF0ZS5saW5lV2lkdGgsIHN0YXRlLmxpbmVDYXAsIHN0YXRlLmxpbmVKb2luLFxuICAgICAgc3RhdGUubWl0ZXJMaW1pdCwgc3RhdGUubGluZURhc2gsIHN0YXRlLmxpbmVEYXNoT2Zmc2V0XG4gICAgXSwgYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGxpbmVTdHJpbmdHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBsaW5lU3RyaW5nR2VvbWV0cnkuZ2V0U3RyaWRlKCk7XG4gICAgdGhpcy5kcmF3RmxhdENvb3JkaW5hdGVzXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5lbmRHZW9tZXRyeShsaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBkcmF3TXVsdGlMaW5lU3RyaW5nKG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgY29uc3QgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoO1xuICAgIGlmIChzdHJva2VTdHlsZSA9PT0gdW5kZWZpbmVkIHx8IGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU3Ryb2tlU3R5bGUoc3RhdGUsIHRoaXMuYXBwbHlTdHJva2UpO1xuICAgIHRoaXMuYmVnaW5HZW9tZXRyeShtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgc3RhdGUuc3Ryb2tlU3R5bGUsIHN0YXRlLmxpbmVXaWR0aCwgc3RhdGUubGluZUNhcCwgc3RhdGUubGluZUpvaW4sXG4gICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICBdLCBiZWdpblBhdGhJbnN0cnVjdGlvbik7XG4gICAgY29uc3QgZW5kcyA9IG11bHRpTGluZVN0cmluZ0dlb21ldHJ5LmdldEVuZHMoKTtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBtdWx0aUxpbmVTdHJpbmdHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbaV0sIHN0cmlkZSk7XG4gICAgfVxuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgIHRoaXMuZW5kR2VvbWV0cnkobXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5sYXN0U3Ryb2tlICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5sYXN0U3Ryb2tlICE9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5yZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2MuXG4gICAqL1xuICBhcHBseVN0cm9rZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5sYXN0U3Ryb2tlICE9IHVuZGVmaW5lZCAmJiBzdGF0ZS5sYXN0U3Ryb2tlICE9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICAgIHN0YXRlLmxhc3RTdHJva2UgPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGUubGFzdFN0cm9rZSA9IDA7XG4gICAgc3VwZXIuYXBwbHlTdHJva2Uoc3RhdGUpO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24pO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzTGluZVN0cmluZ1JlcGxheTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvY2FudmFzL1BvbHlnb25SZXBsYXlcbiAqL1xuaW1wb3J0IHthc1N0cmluZ30gZnJvbSAnLi4vLi4vY29sb3IuanMnO1xuaW1wb3J0IHtzbmFwfSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvc2ltcGxpZnkuanMnO1xuaW1wb3J0IHtkZWZhdWx0RmlsbFN0eWxlfSBmcm9tICcuLi9jYW52YXMuanMnO1xuaW1wb3J0IENhbnZhc0luc3RydWN0aW9uLCB7XG4gIGZpbGxJbnN0cnVjdGlvbiwgc3Ryb2tlSW5zdHJ1Y3Rpb24sIGJlZ2luUGF0aEluc3RydWN0aW9uLCBjbG9zZVBhdGhJbnN0cnVjdGlvblxufSBmcm9tICcuL0luc3RydWN0aW9uLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi9SZXBsYXkuanMnO1xuXG5cbmNsYXNzIENhbnZhc1BvbHlnb25SZXBsYXkgZXh0ZW5kcyBDYW52YXNSZXBsYXkge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heGltdW0gZXh0ZW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGFwcyBUaGUgcmVwbGF5IGNhbiBoYXZlIG92ZXJsYXBwaW5nIGdlb21ldHJpZXMuXG4gICAqIEBwYXJhbSB7P30gZGVjbHV0dGVyVHJlZSBEZWNsdXR0ZXIgdHJlZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSkge1xuICAgIHN1cGVyKHRvbGVyYW5jZSwgbWF4RXh0ZW50LCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBvdmVybGFwcywgZGVjbHV0dGVyVHJlZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZW5kcyBFbmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bnVtYmVyfSBFbmQuXG4gICAqL1xuICBkcmF3RmxhdENvb3JkaW5hdGVzc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBmaWxsID0gc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3Ryb2tlID0gc3RhdGUuc3Ryb2tlU3R5bGUgIT0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG51bUVuZHMgPSBlbmRzLmxlbmd0aDtcbiAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVuZHM7ICsraSkge1xuICAgICAgY29uc3QgZW5kID0gZW5kc1tpXTtcbiAgICAgIGNvbnN0IG15QmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG15RW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCB0cnVlLCAhc3Ryb2tlKTtcbiAgICAgIGNvbnN0IG1vdmVUb0xpbmVUb0luc3RydWN0aW9uID0gW0NhbnZhc0luc3RydWN0aW9uLk1PVkVfVE9fTElORV9UTywgbXlCZWdpbiwgbXlFbmRdO1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChtb3ZlVG9MaW5lVG9JbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKG1vdmVUb0xpbmVUb0luc3RydWN0aW9uKTtcbiAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBvbmx5IGNhbGwgY2xvc2VQYXRoKCkgd2hlbiB3ZSBoYXZlIGEgc3Ryb2tlLlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIHJpbmcgaXMgY2xvc2VkIGFscmVhZHkgKHNlZSBhcHBlbmRGbGF0Q29vcmRpbmF0ZXMgYWJvdmUpLlxuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGNsb3NlUGF0aEluc3RydWN0aW9uKTtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChjbG9zZVBhdGhJbnN0cnVjdGlvbik7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSBlbmQ7XG4gICAgfVxuICAgIGlmIChmaWxsKSB7XG4gICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGZpbGxJbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGZpbGxJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goc3Ryb2tlSW5zdHJ1Y3Rpb24pO1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGRyYXdDaXJjbGUoY2lyY2xlR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKGZpbGxTdHlsZSA9PT0gdW5kZWZpbmVkICYmIHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGVzXyhjaXJjbGVHZW9tZXRyeSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KGNpcmNsZUdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgYXNTdHJpbmcoZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLCBzdGF0ZS5saW5lV2lkdGgsIHN0YXRlLmxpbmVDYXAsIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBjaXJjbGVHZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBjaXJjbGVHZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBjb25zdCBteUJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgICBjb25zdCBjaXJjbGVJbnN0cnVjdGlvbiA9IFtDYW52YXNJbnN0cnVjdGlvbi5DSVJDTEUsIG15QmVnaW5dO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goYmVnaW5QYXRoSW5zdHJ1Y3Rpb24sIGNpcmNsZUluc3RydWN0aW9uKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKGJlZ2luUGF0aEluc3RydWN0aW9uLCBjaXJjbGVJbnN0cnVjdGlvbik7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgIGlmIChzdGF0ZS5maWxsU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChmaWxsSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChzdHJva2VJbnN0cnVjdGlvbik7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHN0cm9rZUluc3RydWN0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5lbmRHZW9tZXRyeShjaXJjbGVHZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGRyYXdQb2x5Z29uKHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgY29uc3Qgc3Ryb2tlU3R5bGUgPSBzdGF0ZS5zdHJva2VTdHlsZTtcbiAgICBpZiAoZmlsbFN0eWxlID09PSB1bmRlZmluZWQgJiYgc3Ryb2tlU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldEZpbGxTdHJva2VTdHlsZXNfKHBvbHlnb25HZW9tZXRyeSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgaWYgKHN0YXRlLmZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtcbiAgICAgICAgQ2FudmFzSW5zdHJ1Y3Rpb24uU0VUX0ZJTExfU1RZTEUsXG4gICAgICAgIGFzU3RyaW5nKGRlZmF1bHRGaWxsU3R5bGUpXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnN0cm9rZVN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfU1RST0tFX1NUWUxFLFxuICAgICAgICBzdGF0ZS5zdHJva2VTdHlsZSwgc3RhdGUubGluZVdpZHRoLCBzdGF0ZS5saW5lQ2FwLCBzdGF0ZS5saW5lSm9pbixcbiAgICAgICAgc3RhdGUubWl0ZXJMaW1pdCwgc3RhdGUubGluZURhc2gsIHN0YXRlLmxpbmVEYXNoT2Zmc2V0XG4gICAgICBdKTtcbiAgICB9XG4gICAgY29uc3QgZW5kcyA9IHBvbHlnb25HZW9tZXRyeS5nZXRFbmRzKCk7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gcG9seWdvbkdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCk7XG4gICAgY29uc3Qgc3RyaWRlID0gcG9seWdvbkdlb21ldHJ5LmdldFN0cmlkZSgpO1xuICAgIHRoaXMuZHJhd0ZsYXRDb29yZGluYXRlc3NfKGZsYXRDb29yZGluYXRlcywgMCwgZW5kcywgc3RyaWRlKTtcbiAgICB0aGlzLmVuZEdlb21ldHJ5KHBvbHlnb25HZW9tZXRyeSwgZmVhdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGRyYXdNdWx0aVBvbHlnb24obXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgZmlsbFN0eWxlID0gc3RhdGUuZmlsbFN0eWxlO1xuICAgIGNvbnN0IHN0cm9rZVN0eWxlID0gc3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgaWYgKGZpbGxTdHlsZSA9PT0gdW5kZWZpbmVkICYmIHN0cm9rZVN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGVzXyhtdWx0aVBvbHlnb25HZW9tZXRyeSk7XG4gICAgdGhpcy5iZWdpbkdlb21ldHJ5KG11bHRpUG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICBpZiAoc3RhdGUuZmlsbFN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zLnB1c2goW1xuICAgICAgICBDYW52YXNJbnN0cnVjdGlvbi5TRVRfRklMTF9TVFlMRSxcbiAgICAgICAgYXNTdHJpbmcoZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgIF0pO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuc3Ryb2tlU3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbXG4gICAgICAgIENhbnZhc0luc3RydWN0aW9uLlNFVF9TVFJPS0VfU1RZTEUsXG4gICAgICAgIHN0YXRlLnN0cm9rZVN0eWxlLCBzdGF0ZS5saW5lV2lkdGgsIHN0YXRlLmxpbmVDYXAsIHN0YXRlLmxpbmVKb2luLFxuICAgICAgICBzdGF0ZS5taXRlckxpbWl0LCBzdGF0ZS5saW5lRGFzaCwgc3RhdGUubGluZURhc2hPZmZzZXRcbiAgICAgIF0pO1xuICAgIH1cbiAgICBjb25zdCBlbmRzcyA9IG11bHRpUG9seWdvbkdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgY29uc3QgZmxhdENvb3JkaW5hdGVzID0gbXVsdGlQb2x5Z29uR2VvbWV0cnkuZ2V0T3JpZW50ZWRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBtdWx0aVBvbHlnb25HZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmRyYXdGbGF0Q29vcmRpbmF0ZXNzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kc3NbaV0sIHN0cmlkZSk7XG4gICAgfVxuICAgIHRoaXMuZW5kR2VvbWV0cnkobXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgdGhpcy5yZXZlcnNlSGl0RGV0ZWN0aW9uSW5zdHJ1Y3Rpb25zKCk7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgLy8gV2Ugd2FudCB0byBwcmVzZXJ2ZSB0b3BvbG9neSB3aGVuIGRyYXdpbmcgcG9seWdvbnMuICBQb2x5Z29ucyBhcmVcbiAgICAvLyBzaW1wbGlmaWVkIHVzaW5nIHF1YW50aXphdGlvbiBhbmQgcG9pbnQgZWxpbWluYXRpb24uIEhvd2V2ZXIsIHdlIG1pZ2h0XG4gICAgLy8gaGF2ZSByZWNlaXZlZCBhIG1peCBvZiBxdWFudGl6ZWQgYW5kIG5vbi1xdWFudGl6ZWQgZ2VvbWV0cmllcywgc28gZW5zdXJlXG4gICAgLy8gdGhhdCBhbGwgYXJlIHF1YW50aXplZCBieSBxdWFudGl6aW5nIGFsbCBjb29yZGluYXRlcyBpbiB0aGUgYmF0Y2guXG4gICAgY29uc3QgdG9sZXJhbmNlID0gdGhpcy50b2xlcmFuY2U7XG4gICAgaWYgKHRvbGVyYW5jZSAhPT0gMCkge1xuICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb29yZGluYXRlc1tpXSA9IHNuYXAoY29vcmRpbmF0ZXNbaV0sIHRvbGVyYW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqL1xuICBzZXRGaWxsU3Ryb2tlU3R5bGVzXyhnZW9tZXRyeSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSBzdGF0ZS5maWxsU3R5bGU7XG4gICAgaWYgKGZpbGxTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGxTdHlsZShzdGF0ZSwgdGhpcy5jcmVhdGVGaWxsLCBnZW9tZXRyeSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5zdHJva2VTdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVN0cm9rZVN0eWxlKHN0YXRlLCB0aGlzLmFwcGx5U3Ryb2tlKTtcbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNQb2x5Z29uUmVwbGF5O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9zdHJhaWdodGNodW5rXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBbmdsZSBNYXhpbXVtIGFjY2VwdGFibGUgYW5nbGUgZGVsdGEgYmV0d2VlbiBzZWdtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBTdGFydCBhbmQgZW5kIG9mIHRoZSBmaXJzdCBzdWl0YWJsZSBjaHVuayBvZiB0aGVcbiAqIGdpdmVuIGBmbGF0Q29vcmRpbmF0ZXNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hpbmdDaHVuayhtYXhBbmdsZSwgZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gIGxldCBjaHVua1N0YXJ0ID0gb2Zmc2V0O1xuICBsZXQgY2h1bmtFbmQgPSBvZmZzZXQ7XG4gIGxldCBjaHVua00gPSAwO1xuICBsZXQgbSA9IDA7XG4gIGxldCBzdGFydCA9IG9mZnNldDtcbiAgbGV0IGFjb3MsIGksIG0xMiwgbTIzLCB4MSwgeTEsIHgxMiwgeTEyLCB4MjMsIHkyMztcbiAgZm9yIChpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IHN0cmlkZSkge1xuICAgIGNvbnN0IHgyID0gZmxhdENvb3JkaW5hdGVzW2ldO1xuICAgIGNvbnN0IHkyID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICBpZiAoeDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeDIzID0geDIgLSB4MTtcbiAgICAgIHkyMyA9IHkyIC0geTE7XG4gICAgICBtMjMgPSBNYXRoLnNxcnQoeDIzICogeDIzICsgeTIzICogeTIzKTtcbiAgICAgIGlmICh4MTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtICs9IG0xMjtcbiAgICAgICAgYWNvcyA9IE1hdGguYWNvcygoeDEyICogeDIzICsgeTEyICogeTIzKSAvIChtMTIgKiBtMjMpKTtcbiAgICAgICAgaWYgKGFjb3MgPiBtYXhBbmdsZSkge1xuICAgICAgICAgIGlmIChtID4gY2h1bmtNKSB7XG4gICAgICAgICAgICBjaHVua00gPSBtO1xuICAgICAgICAgICAgY2h1bmtTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2h1bmtFbmQgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gMDtcbiAgICAgICAgICBzdGFydCA9IGkgLSBzdHJpZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG0xMiA9IG0yMztcbiAgICAgIHgxMiA9IHgyMztcbiAgICAgIHkxMiA9IHkyMztcbiAgICB9XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICB9XG4gIG0gKz0gbTIzO1xuICByZXR1cm4gbSA+IGNodW5rTSA/IFtzdGFydCwgaV0gOiBbY2h1bmtTdGFydCwgY2h1bmtFbmRdO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvVGV4dFJlcGxheVxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQge2FzQ29sb3JMaWtlfSBmcm9tICcuLi8uLi9jb2xvcmxpa2UuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2ludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge21hdGNoaW5nQ2h1bmt9IGZyb20gJy4uLy4uL2dlb20vZmxhdC9zdHJhaWdodGNodW5rLmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHtDQU5WQVNfTElORV9EQVNIfSBmcm9tICcuLi8uLi9oYXMuanMnO1xuaW1wb3J0IHtsYWJlbENhY2hlLCBtZWFzdXJlVGV4dFdpZHRoLCBkZWZhdWx0VGV4dEFsaWduLCBtZWFzdXJlVGV4dEhlaWdodCwgZGVmYXVsdFBhZGRpbmcsIGRlZmF1bHRMaW5lQ2FwLCBkZWZhdWx0TGluZURhc2hPZmZzZXQsIGRlZmF1bHRMaW5lRGFzaCwgZGVmYXVsdExpbmVKb2luLCBkZWZhdWx0RmlsbFN0eWxlLCBjaGVja0ZvbnQsIGRlZmF1bHRGb250LCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TWl0ZXJMaW1pdCwgZGVmYXVsdFN0cm9rZVN0eWxlLCBkZWZhdWx0VGV4dEJhc2VsaW5lfSBmcm9tICcuLi9jYW52YXMuanMnO1xuaW1wb3J0IENhbnZhc0luc3RydWN0aW9uIGZyb20gJy4vSW5zdHJ1Y3Rpb24uanMnO1xuaW1wb3J0IENhbnZhc1JlcGxheSBmcm9tICcuL1JlcGxheS5qcyc7XG5pbXBvcnQge1RFWFRfQUxJR059IGZyb20gJy4uL3JlcGxheS5qcyc7XG5pbXBvcnQgVGV4dFBsYWNlbWVudCBmcm9tICcuLi8uLi9zdHlsZS9UZXh0UGxhY2VtZW50LmpzJztcblxuY2xhc3MgQ2FudmFzVGV4dFJlcGxheSBleHRlbmRzIENhbnZhc1JlcGxheSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIFRvbGVyYW5jZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSBtYXhFeHRlbnQgTWF4aW11bSBleHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXBzIFRoZSByZXBsYXkgY2FuIGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHs/fSBkZWNsdXR0ZXJUcmVlIERlY2x1dHRlciB0cmVlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKSB7XG4gICAgc3VwZXIodG9sZXJhbmNlLCBtYXhFeHRlbnQsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIG92ZXJsYXBzLCBkZWNsdXR0ZXJUcmVlKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5EZWNsdXR0ZXJHcm91cH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlckdyb3VwXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PEhUTUxDYW52YXNFbGVtZW50Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxhYmVsc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudGV4dF8gPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRPZmZzZXRYXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFJvdGF0aW9uXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRGaWxsU3RhdGVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5maWxsU3RhdGVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZT59XG4gICAgICovXG4gICAgdGhpcy5zdHJva2VTdGF0ZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0U3RhdGVfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfSAqLyAoe30pO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdGF0ZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHRLZXlfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5maWxsS2V5XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlS2V5XyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgT2JqZWN0PHN0cmluZywgbnVtYmVyPj59XG4gICAgICovXG4gICAgdGhpcy53aWR0aHNfID0ge307XG5cbiAgICBsYWJlbENhY2hlLnBydW5lKCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZHJhd1RleHQoZ2VvbWV0cnksIGZlYXR1cmUpIHtcbiAgICBjb25zdCBmaWxsU3RhdGUgPSB0aGlzLnRleHRGaWxsU3RhdGVfO1xuICAgIGNvbnN0IHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgIGNvbnN0IHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlXztcbiAgICBpZiAodGhpcy50ZXh0XyA9PT0gJycgfHwgIXRleHRTdGF0ZSB8fCAoIWZpbGxTdGF0ZSAmJiAhc3Ryb2tlU3RhdGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGJlZ2luID0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7XG5cbiAgICBjb25zdCBnZW9tZXRyeVR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgbGV0IGZsYXRDb29yZGluYXRlcyA9IG51bGw7XG4gICAgbGV0IGVuZCA9IDI7XG4gICAgbGV0IHN0cmlkZSA9IDI7XG4gICAgbGV0IGksIGlpO1xuXG4gICAgaWYgKHRleHRTdGF0ZS5wbGFjZW1lbnQgPT09IFRleHRQbGFjZW1lbnQuTElORSkge1xuICAgICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZ2V0QnVmZmVyZWRNYXhFeHRlbnQoKSwgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBlbmRzO1xuICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICAgIGlmIChnZW9tZXRyeVR5cGUgPT0gR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HKSB7XG4gICAgICAgIGVuZHMgPSBbZmxhdENvb3JkaW5hdGVzLmxlbmd0aF07XG4gICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5VHlwZSA9PSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkcpIHtcbiAgICAgICAgZW5kcyA9IGdlb21ldHJ5LmdldEVuZHMoKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlUeXBlID09IEdlb21ldHJ5VHlwZS5QT0xZR09OKSB7XG4gICAgICAgIGVuZHMgPSBnZW9tZXRyeS5nZXRFbmRzKCkuc2xpY2UoMCwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5VHlwZSA9PSBHZW9tZXRyeVR5cGUuTVVMVElfUE9MWUdPTikge1xuICAgICAgICBjb25zdCBlbmRzcyA9IGdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgICAgIGVuZHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgZW5kcy5wdXNoKGVuZHNzW2ldWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5iZWdpbkdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHRleHRTdGF0ZS50ZXh0QWxpZ247XG4gICAgICBsZXQgZmxhdE9mZnNldCA9IDA7XG4gICAgICBsZXQgZmxhdEVuZDtcbiAgICAgIGZvciAobGV0IG8gPSAwLCBvbyA9IGVuZHMubGVuZ3RoOyBvIDwgb287ICsrbykge1xuICAgICAgICBpZiAodGV4dEFsaWduID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IHJhbmdlID0gbWF0Y2hpbmdDaHVuayh0ZXh0U3RhdGUubWF4QW5nbGUsIGZsYXRDb29yZGluYXRlcywgZmxhdE9mZnNldCwgZW5kc1tvXSwgc3RyaWRlKTtcbiAgICAgICAgICBmbGF0T2Zmc2V0ID0gcmFuZ2VbMF07XG4gICAgICAgICAgZmxhdEVuZCA9IHJhbmdlWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXRFbmQgPSBlbmRzW29dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGZsYXRPZmZzZXQ7IGkgPCBmbGF0RW5kOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgIHRoaXMuY29vcmRpbmF0ZXMucHVzaChmbGF0Q29vcmRpbmF0ZXNbaV0sIGZsYXRDb29yZGluYXRlc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVuZCA9IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICBmbGF0T2Zmc2V0ID0gZW5kc1tvXTtcbiAgICAgICAgdGhpcy5kcmF3Q2hhcnNfKGJlZ2luLCBlbmQsIHRoaXMuZGVjbHV0dGVyR3JvdXBfKTtcbiAgICAgICAgYmVnaW4gPSBlbmQ7XG4gICAgICB9XG4gICAgICB0aGlzLmVuZEdlb21ldHJ5KGdlb21ldHJ5LCBmZWF0dXJlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0SW1hZ2UodGhpcy50ZXh0XywgdGhpcy50ZXh0S2V5XywgdGhpcy5maWxsS2V5XywgdGhpcy5zdHJva2VLZXlfKTtcbiAgICAgIGNvbnN0IHdpZHRoID0gbGFiZWwud2lkdGggLyB0aGlzLnBpeGVsUmF0aW87XG4gICAgICBzd2l0Y2ggKGdlb21ldHJ5VHlwZSkge1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0lOVDpcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG4gICAgICAgICAgZW5kID0gZmxhdENvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTElORV9TVFJJTkc6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRGbGF0TWlkcG9pbnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuQ0lSQ0xFOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KS5nZXRDZW50ZXIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgICAgZmxhdENvb3JkaW5hdGVzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEZsYXRNaWRwb2ludHMoKTtcbiAgICAgICAgICBlbmQgPSBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0xZR09OOlxuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkuZ2V0RmxhdEludGVyaW9yUG9pbnQoKTtcbiAgICAgICAgICBpZiAoIXRleHRTdGF0ZS5vdmVyZmxvdyAmJiBmbGF0Q29vcmRpbmF0ZXNbMl0gLyB0aGlzLnJlc29sdXRpb24gPCB3aWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdlb21ldHJ5VHlwZS5NVUxUSV9QT0xZR09OOlxuICAgICAgICAgIGNvbnN0IGludGVyaW9yUG9pbnRzID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAoZ2VvbWV0cnkpLmdldEZsYXRJbnRlcmlvclBvaW50cygpO1xuICAgICAgICAgIGZsYXRDb29yZGluYXRlcyA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IDAsIGlpID0gaW50ZXJpb3JQb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRleHRTdGF0ZS5vdmVyZmxvdyB8fCBpbnRlcmlvclBvaW50c1tpICsgMl0gLyB0aGlzLnJlc29sdXRpb24gPj0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgZmxhdENvb3JkaW5hdGVzLnB1c2goaW50ZXJpb3JQb2ludHNbaV0sIGludGVyaW9yUG9pbnRzW2kgKyAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZCA9IGZsYXRDb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGVuZCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgICAgZW5kID0gdGhpcy5hcHBlbmRGbGF0Q29vcmRpbmF0ZXMoZmxhdENvb3JkaW5hdGVzLCAwLCBlbmQsIHN0cmlkZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGlmICh0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwgfHwgdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UpIHtcbiAgICAgICAgdGhpcy5zZXRGaWxsU3Ryb2tlU3R5bGUodGV4dFN0YXRlLmJhY2tncm91bmRGaWxsLCB0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZSk7XG4gICAgICAgIGlmICh0ZXh0U3RhdGUuYmFja2dyb3VuZEZpbGwpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUZpbGxTdHlsZSh0aGlzLnN0YXRlLCB0aGlzLmNyZWF0ZUZpbGwsIGdlb21ldHJ5KTtcbiAgICAgICAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKHRoaXMuY3JlYXRlRmlsbCh0aGlzLnN0YXRlLCBnZW9tZXRyeSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0U3RhdGUuYmFja2dyb3VuZFN0cm9rZSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlU3Ryb2tlU3R5bGUodGhpcy5zdGF0ZSwgdGhpcy5hcHBseVN0cm9rZSk7XG4gICAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaCh0aGlzLmNyZWF0ZVN0cm9rZSh0aGlzLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYmVnaW5HZW9tZXRyeShnZW9tZXRyeSwgZmVhdHVyZSk7XG4gICAgICB0aGlzLmRyYXdUZXh0SW1hZ2VfKGxhYmVsLCBiZWdpbiwgZW5kKTtcbiAgICAgIHRoaXMuZW5kR2VvbWV0cnkoZ2VvbWV0cnksIGZlYXR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dEtleSBUZXh0IHN0eWxlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGxLZXkgRmlsbCBzdHlsZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VLZXkgU3Ryb2tlIHN0eWxlIGtleS5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9IEltYWdlLlxuICAgKi9cbiAgZ2V0SW1hZ2UodGV4dCwgdGV4dEtleSwgZmlsbEtleSwgc3Ryb2tlS2V5KSB7XG4gICAgbGV0IGxhYmVsO1xuICAgIGNvbnN0IGtleSA9IHN0cm9rZUtleSArIHRleHRLZXkgKyB0ZXh0ICsgZmlsbEtleSArIHRoaXMucGl4ZWxSYXRpbztcblxuICAgIGlmICghbGFiZWxDYWNoZS5jb250YWluc0tleShrZXkpKSB7XG4gICAgICBjb25zdCBzdHJva2VTdGF0ZSA9IHN0cm9rZUtleSA/IHRoaXMuc3Ryb2tlU3RhdGVzW3N0cm9rZUtleV0gfHwgdGhpcy50ZXh0U3Ryb2tlU3RhdGVfIDogbnVsbDtcbiAgICAgIGNvbnN0IGZpbGxTdGF0ZSA9IGZpbGxLZXkgPyB0aGlzLmZpbGxTdGF0ZXNbZmlsbEtleV0gfHwgdGhpcy50ZXh0RmlsbFN0YXRlXyA6IG51bGw7XG4gICAgICBjb25zdCB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZXNbdGV4dEtleV0gfHwgdGhpcy50ZXh0U3RhdGVfO1xuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIGNvbnN0IHNjYWxlID0gdGV4dFN0YXRlLnNjYWxlICogcGl4ZWxSYXRpbztcbiAgICAgIGNvbnN0IGFsaWduID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEFsaWduIHx8IGRlZmF1bHRUZXh0QWxpZ25dO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBzdHJva2VLZXkgJiYgc3Ryb2tlU3RhdGUubGluZVdpZHRoID8gc3Ryb2tlU3RhdGUubGluZVdpZHRoIDogMDtcblxuICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgIGNvbnN0IG51bUxpbmVzID0gbGluZXMubGVuZ3RoO1xuICAgICAgY29uc3Qgd2lkdGhzID0gW107XG4gICAgICBjb25zdCB3aWR0aCA9IG1lYXN1cmVUZXh0V2lkdGhzKHRleHRTdGF0ZS5mb250LCBsaW5lcywgd2lkdGhzKTtcbiAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBtZWFzdXJlVGV4dEhlaWdodCh0ZXh0U3RhdGUuZm9udCk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBsaW5lSGVpZ2h0ICogbnVtTGluZXM7XG4gICAgICBjb25zdCByZW5kZXJXaWR0aCA9ICh3aWR0aCArIHN0cm9rZVdpZHRoKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgICAgIE1hdGguY2VpbChyZW5kZXJXaWR0aCAqIHNjYWxlKSxcbiAgICAgICAgTWF0aC5jZWlsKChoZWlnaHQgKyBzdHJva2VXaWR0aCkgKiBzY2FsZSkpO1xuICAgICAgbGFiZWwgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIGxhYmVsQ2FjaGUuc2V0KGtleSwgbGFiZWwpO1xuICAgICAgaWYgKHNjYWxlICE9IDEpIHtcbiAgICAgICAgY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgICAgY29udGV4dC5mb250ID0gdGV4dFN0YXRlLmZvbnQ7XG4gICAgICBpZiAoc3Ryb2tlS2V5KSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gLyoqIEB0eXBlIHtDYW52YXNMaW5lQ2FwfSAqLyAoc3Ryb2tlU3RhdGUubGluZUNhcCk7XG4gICAgICAgIGNvbnRleHQubGluZUpvaW4gPSAvKiogQHR5cGUge0NhbnZhc0xpbmVKb2lufSAqLyAoc3Ryb2tlU3RhdGUubGluZUpvaW4pO1xuICAgICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0O1xuICAgICAgICBpZiAoQ0FOVkFTX0xJTkVfREFTSCAmJiBzdHJva2VTdGF0ZS5saW5lRGFzaC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHN0cm9rZVN0YXRlLmxpbmVEYXNoKTtcbiAgICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWxsS2V5KSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbFN0YXRlLmZpbGxTdHlsZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgY29uc3QgbGVmdFJpZ2h0ID0gKDAuNSAtIGFsaWduKTtcbiAgICAgIGNvbnN0IHggPSBhbGlnbiAqIGxhYmVsLndpZHRoIC8gc2NhbGUgKyBsZWZ0UmlnaHQgKiBzdHJva2VXaWR0aDtcbiAgICAgIGxldCBpO1xuICAgICAgaWYgKHN0cm9rZUtleSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtTGluZXM7ICsraSkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChsaW5lc1tpXSwgeCArIGxlZnRSaWdodCAqIHdpZHRoc1tpXSwgMC41ICogKHN0cm9rZVdpZHRoICsgbGluZUhlaWdodCkgKyBpICogbGluZUhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWxsS2V5KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1MaW5lczsgKytpKSB7XG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dChsaW5lc1tpXSwgeCArIGxlZnRSaWdodCAqIHdpZHRoc1tpXSwgMC41ICogKHN0cm9rZVdpZHRoICsgbGluZUhlaWdodCkgKyBpICogbGluZUhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsQ2FjaGUuZ2V0KGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gbGFiZWwgTGFiZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbiBCZWdpbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqL1xuICBkcmF3VGV4dEltYWdlXyhsYWJlbCwgYmVnaW4sIGVuZCkge1xuICAgIGNvbnN0IHRleHRTdGF0ZSA9IHRoaXMudGV4dFN0YXRlXztcbiAgICBjb25zdCBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXztcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIGNvbnN0IGFsaWduID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEFsaWduIHx8IGRlZmF1bHRUZXh0QWxpZ25dO1xuICAgIGNvbnN0IGJhc2VsaW5lID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEJhc2VsaW5lXTtcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IHN0cm9rZVN0YXRlICYmIHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA/IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCA6IDA7XG5cbiAgICBjb25zdCBhbmNob3JYID0gYWxpZ24gKiBsYWJlbC53aWR0aCAvIHBpeGVsUmF0aW8gKyAyICogKDAuNSAtIGFsaWduKSAqIHN0cm9rZVdpZHRoO1xuICAgIGNvbnN0IGFuY2hvclkgPSBiYXNlbGluZSAqIGxhYmVsLmhlaWdodCAvIHBpeGVsUmF0aW8gKyAyICogKDAuNSAtIGJhc2VsaW5lKSAqIHN0cm9rZVdpZHRoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkRSQVdfSU1BR0UsIGJlZ2luLCBlbmQsXG4gICAgICBsYWJlbCwgKGFuY2hvclggLSB0aGlzLnRleHRPZmZzZXRYXykgKiBwaXhlbFJhdGlvLCAoYW5jaG9yWSAtIHRoaXMudGV4dE9mZnNldFlfKSAqIHBpeGVsUmF0aW8sXG4gICAgICB0aGlzLmRlY2x1dHRlckdyb3VwXywgbGFiZWwuaGVpZ2h0LCAxLCAwLCAwLCB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18sIHRoaXMudGV4dFJvdGF0aW9uXyxcbiAgICAgIDEsIGxhYmVsLndpZHRoLFxuICAgICAgdGV4dFN0YXRlLnBhZGRpbmcgPT0gZGVmYXVsdFBhZGRpbmcgP1xuICAgICAgICBkZWZhdWx0UGFkZGluZyA6IHRleHRTdGF0ZS5wYWRkaW5nLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIHAgKiBwaXhlbFJhdGlvO1xuICAgICAgICB9KSxcbiAgICAgICEhdGV4dFN0YXRlLmJhY2tncm91bmRGaWxsLCAhIXRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlXG4gICAgXSk7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbnN0cnVjdGlvbnMucHVzaChbQ2FudmFzSW5zdHJ1Y3Rpb24uRFJBV19JTUFHRSwgYmVnaW4sIGVuZCxcbiAgICAgIGxhYmVsLCAoYW5jaG9yWCAtIHRoaXMudGV4dE9mZnNldFhfKSAqIHBpeGVsUmF0aW8sIChhbmNob3JZIC0gdGhpcy50ZXh0T2Zmc2V0WV8pICogcGl4ZWxSYXRpbyxcbiAgICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfLCBsYWJlbC5oZWlnaHQsIDEsIDAsIDAsIHRoaXMudGV4dFJvdGF0ZVdpdGhWaWV3XywgdGhpcy50ZXh0Um90YXRpb25fLFxuICAgICAgMSAvIHBpeGVsUmF0aW8sIGxhYmVsLndpZHRoLCB0ZXh0U3RhdGUucGFkZGluZyxcbiAgICAgICEhdGV4dFN0YXRlLmJhY2tncm91bmRGaWxsLCAhIXRleHRTdGF0ZS5iYWNrZ3JvdW5kU3Ryb2tlXG4gICAgXSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luIEJlZ2luLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9IGRlY2x1dHRlckdyb3VwIERlY2x1dHRlciBncm91cC5cbiAgICovXG4gIGRyYXdDaGFyc18oYmVnaW4sIGVuZCwgZGVjbHV0dGVyR3JvdXApIHtcbiAgICBjb25zdCBzdHJva2VTdGF0ZSA9IHRoaXMudGV4dFN0cm9rZVN0YXRlXztcbiAgICBjb25zdCB0ZXh0U3RhdGUgPSB0aGlzLnRleHRTdGF0ZV87XG4gICAgY29uc3QgZmlsbFN0YXRlID0gdGhpcy50ZXh0RmlsbFN0YXRlXztcblxuICAgIGNvbnN0IHN0cm9rZUtleSA9IHRoaXMuc3Ryb2tlS2V5XztcbiAgICBpZiAoc3Ryb2tlU3RhdGUpIHtcbiAgICAgIGlmICghKHN0cm9rZUtleSBpbiB0aGlzLnN0cm9rZVN0YXRlcykpIHtcbiAgICAgICAgdGhpcy5zdHJva2VTdGF0ZXNbc3Ryb2tlS2V5XSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlfSAqLyAoe1xuICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSxcbiAgICAgICAgICBsaW5lQ2FwOiBzdHJva2VTdGF0ZS5saW5lQ2FwLFxuICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCxcbiAgICAgICAgICBsaW5lV2lkdGg6IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCxcbiAgICAgICAgICBsaW5lSm9pbjogc3Ryb2tlU3RhdGUubGluZUpvaW4sXG4gICAgICAgICAgbWl0ZXJMaW1pdDogc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCxcbiAgICAgICAgICBsaW5lRGFzaDogc3Ryb2tlU3RhdGUubGluZURhc2hcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHRLZXkgPSB0aGlzLnRleHRLZXlfO1xuICAgIGlmICghKHRoaXMudGV4dEtleV8gaW4gdGhpcy50ZXh0U3RhdGVzKSkge1xuICAgICAgdGhpcy50ZXh0U3RhdGVzW3RoaXMudGV4dEtleV9dID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuVGV4dFN0YXRlfSAqLyAoe1xuICAgICAgICBmb250OiB0ZXh0U3RhdGUuZm9udCxcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0U3RhdGUudGV4dEFsaWduIHx8IGRlZmF1bHRUZXh0QWxpZ24sXG4gICAgICAgIHNjYWxlOiB0ZXh0U3RhdGUuc2NhbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBmaWxsS2V5ID0gdGhpcy5maWxsS2V5XztcbiAgICBpZiAoZmlsbFN0YXRlKSB7XG4gICAgICBpZiAoIShmaWxsS2V5IGluIHRoaXMuZmlsbFN0YXRlcykpIHtcbiAgICAgICAgdGhpcy5maWxsU3RhdGVzW2ZpbGxLZXldID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfSAqLyAoe1xuICAgICAgICAgIGZpbGxTdHlsZTogZmlsbFN0YXRlLmZpbGxTdHlsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvO1xuICAgIGNvbnN0IGJhc2VsaW5lID0gVEVYVF9BTElHTlt0ZXh0U3RhdGUudGV4dEJhc2VsaW5lXTtcblxuICAgIGNvbnN0IG9mZnNldFkgPSB0aGlzLnRleHRPZmZzZXRZXyAqIHBpeGVsUmF0aW87XG4gICAgY29uc3QgdGV4dCA9IHRoaXMudGV4dF87XG4gICAgY29uc3QgZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgIGNvbnN0IHRleHRTY2FsZSA9IHRleHRTdGF0ZS5zY2FsZTtcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IHN0cm9rZVN0YXRlID8gc3Ryb2tlU3RhdGUubGluZVdpZHRoICogdGV4dFNjYWxlIC8gMiA6IDA7XG4gICAgbGV0IHdpZHRocyA9IHRoaXMud2lkdGhzX1tmb250XTtcbiAgICBpZiAoIXdpZHRocykge1xuICAgICAgdGhpcy53aWR0aHNfW2ZvbnRdID0gd2lkdGhzID0ge307XG4gICAgfVxuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2goW0NhbnZhc0luc3RydWN0aW9uLkRSQVdfQ0hBUlMsXG4gICAgICBiZWdpbiwgZW5kLCBiYXNlbGluZSwgZGVjbHV0dGVyR3JvdXAsXG4gICAgICB0ZXh0U3RhdGUub3ZlcmZsb3csIGZpbGxLZXksIHRleHRTdGF0ZS5tYXhBbmdsZSxcbiAgICAgIGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gd2lkdGhzW3RleHRdO1xuICAgICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSB3aWR0aHNbdGV4dF0gPSBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aWR0aCAqIHRleHRTY2FsZSAqIHBpeGVsUmF0aW87XG4gICAgICB9LFxuICAgICAgb2Zmc2V0WSwgc3Ryb2tlS2V5LCBzdHJva2VXaWR0aCAqIHBpeGVsUmF0aW8sIHRleHQsIHRleHRLZXksIDFcbiAgICBdKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkluc3RydWN0aW9ucy5wdXNoKFtDYW52YXNJbnN0cnVjdGlvbi5EUkFXX0NIQVJTLFxuICAgICAgYmVnaW4sIGVuZCwgYmFzZWxpbmUsIGRlY2x1dHRlckdyb3VwLFxuICAgICAgdGV4dFN0YXRlLm92ZXJmbG93LCBmaWxsS2V5LCB0ZXh0U3RhdGUubWF4QW5nbGUsXG4gICAgICBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIGxldCB3aWR0aCA9IHdpZHRoc1t0ZXh0XTtcbiAgICAgICAgaWYgKCF3aWR0aCkge1xuICAgICAgICAgIHdpZHRoID0gd2lkdGhzW3RleHRdID0gbWVhc3VyZVRleHRXaWR0aChmb250LCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGggKiB0ZXh0U2NhbGU7XG4gICAgICB9LFxuICAgICAgb2Zmc2V0WSwgc3Ryb2tlS2V5LCBzdHJva2VXaWR0aCwgdGV4dCwgdGV4dEtleSwgMSAvIHBpeGVsUmF0aW9cbiAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgZGVjbHV0dGVyR3JvdXApIHtcbiAgICBsZXQgdGV4dFN0YXRlLCBmaWxsU3RhdGUsIHN0cm9rZVN0YXRlO1xuICAgIGlmICghdGV4dFN0eWxlKSB7XG4gICAgICB0aGlzLnRleHRfID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjbHV0dGVyR3JvdXBfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9ICovIChkZWNsdXR0ZXJHcm91cCk7XG5cbiAgICAgIGNvbnN0IHRleHRGaWxsU3R5bGUgPSB0ZXh0U3R5bGUuZ2V0RmlsbCgpO1xuICAgICAgaWYgKCF0ZXh0RmlsbFN0eWxlKSB7XG4gICAgICAgIGZpbGxTdGF0ZSA9IHRoaXMudGV4dEZpbGxTdGF0ZV8gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsbFN0YXRlID0gdGhpcy50ZXh0RmlsbFN0YXRlXztcbiAgICAgICAgaWYgKCFmaWxsU3RhdGUpIHtcbiAgICAgICAgICBmaWxsU3RhdGUgPSB0aGlzLnRleHRGaWxsU3RhdGVfID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfSAqLyAoe30pO1xuICAgICAgICB9XG4gICAgICAgIGZpbGxTdGF0ZS5maWxsU3R5bGUgPSBhc0NvbG9yTGlrZShcbiAgICAgICAgICB0ZXh0RmlsbFN0eWxlLmdldENvbG9yKCkgfHwgZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZSA9IHRleHRTdHlsZS5nZXRTdHJva2UoKTtcbiAgICAgIGlmICghdGV4dFN0cm9rZVN0eWxlKSB7XG4gICAgICAgIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZVN0YXRlID0gdGhpcy50ZXh0U3Ryb2tlU3RhdGVfO1xuICAgICAgICBpZiAoIXN0cm9rZVN0YXRlKSB7XG4gICAgICAgICAgc3Ryb2tlU3RhdGUgPSB0aGlzLnRleHRTdHJva2VTdGF0ZV8gPSAvKiogQHR5cGUge2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX0gKi8gKHt9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lRGFzaCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaCgpO1xuICAgICAgICBjb25zdCBsaW5lRGFzaE9mZnNldCA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgICBjb25zdCBsaW5lV2lkdGggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0V2lkdGgoKTtcbiAgICAgICAgY29uc3QgbWl0ZXJMaW1pdCA9IHRleHRTdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgIHN0cm9rZVN0YXRlLmxpbmVDYXAgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpIHx8IGRlZmF1bHRMaW5lQ2FwO1xuICAgICAgICBzdHJva2VTdGF0ZS5saW5lRGFzaCA9IGxpbmVEYXNoID8gbGluZURhc2guc2xpY2UoKSA6IGRlZmF1bHRMaW5lRGFzaDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZURhc2hPZmZzZXQgPVxuICAgICAgICAgICAgbGluZURhc2hPZmZzZXQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRMaW5lRGFzaE9mZnNldCA6IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICBzdHJva2VTdGF0ZS5saW5lSm9pbiA9IHRleHRTdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpIHx8IGRlZmF1bHRMaW5lSm9pbjtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZVdpZHRoID1cbiAgICAgICAgICAgIGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdExpbmVXaWR0aCA6IGxpbmVXaWR0aDtcbiAgICAgICAgc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCA9XG4gICAgICAgICAgICBtaXRlckxpbWl0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0TWl0ZXJMaW1pdCA6IG1pdGVyTGltaXQ7XG4gICAgICAgIHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2UoXG4gICAgICAgICAgdGV4dFN0cm9rZVN0eWxlLmdldENvbG9yKCkgfHwgZGVmYXVsdFN0cm9rZVN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgdGV4dFN0YXRlID0gdGhpcy50ZXh0U3RhdGVfO1xuICAgICAgY29uc3QgZm9udCA9IHRleHRTdHlsZS5nZXRGb250KCkgfHwgZGVmYXVsdEZvbnQ7XG4gICAgICBjaGVja0ZvbnQoZm9udCk7XG4gICAgICBjb25zdCB0ZXh0U2NhbGUgPSB0ZXh0U3R5bGUuZ2V0U2NhbGUoKTtcbiAgICAgIHRleHRTdGF0ZS5vdmVyZmxvdyA9IHRleHRTdHlsZS5nZXRPdmVyZmxvdygpO1xuICAgICAgdGV4dFN0YXRlLmZvbnQgPSBmb250O1xuICAgICAgdGV4dFN0YXRlLm1heEFuZ2xlID0gdGV4dFN0eWxlLmdldE1heEFuZ2xlKCk7XG4gICAgICB0ZXh0U3RhdGUucGxhY2VtZW50ID0gdGV4dFN0eWxlLmdldFBsYWNlbWVudCgpO1xuICAgICAgdGV4dFN0YXRlLnRleHRBbGlnbiA9IHRleHRTdHlsZS5nZXRUZXh0QWxpZ24oKTtcbiAgICAgIHRleHRTdGF0ZS50ZXh0QmFzZWxpbmUgPSB0ZXh0U3R5bGUuZ2V0VGV4dEJhc2VsaW5lKCkgfHwgZGVmYXVsdFRleHRCYXNlbGluZTtcbiAgICAgIHRleHRTdGF0ZS5iYWNrZ3JvdW5kRmlsbCA9IHRleHRTdHlsZS5nZXRCYWNrZ3JvdW5kRmlsbCgpO1xuICAgICAgdGV4dFN0YXRlLmJhY2tncm91bmRTdHJva2UgPSB0ZXh0U3R5bGUuZ2V0QmFja2dyb3VuZFN0cm9rZSgpO1xuICAgICAgdGV4dFN0YXRlLnBhZGRpbmcgPSB0ZXh0U3R5bGUuZ2V0UGFkZGluZygpIHx8IGRlZmF1bHRQYWRkaW5nO1xuICAgICAgdGV4dFN0YXRlLnNjYWxlID0gdGV4dFNjYWxlID09PSB1bmRlZmluZWQgPyAxIDogdGV4dFNjYWxlO1xuXG4gICAgICBjb25zdCB0ZXh0T2Zmc2V0WCA9IHRleHRTdHlsZS5nZXRPZmZzZXRYKCk7XG4gICAgICBjb25zdCB0ZXh0T2Zmc2V0WSA9IHRleHRTdHlsZS5nZXRPZmZzZXRZKCk7XG4gICAgICBjb25zdCB0ZXh0Um90YXRlV2l0aFZpZXcgPSB0ZXh0U3R5bGUuZ2V0Um90YXRlV2l0aFZpZXcoKTtcbiAgICAgIGNvbnN0IHRleHRSb3RhdGlvbiA9IHRleHRTdHlsZS5nZXRSb3RhdGlvbigpO1xuICAgICAgdGhpcy50ZXh0XyA9IHRleHRTdHlsZS5nZXRUZXh0KCkgfHwgJyc7XG4gICAgICB0aGlzLnRleHRPZmZzZXRYXyA9IHRleHRPZmZzZXRYID09PSB1bmRlZmluZWQgPyAwIDogdGV4dE9mZnNldFg7XG4gICAgICB0aGlzLnRleHRPZmZzZXRZXyA9IHRleHRPZmZzZXRZID09PSB1bmRlZmluZWQgPyAwIDogdGV4dE9mZnNldFk7XG4gICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18gPSB0ZXh0Um90YXRlV2l0aFZpZXcgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdGV4dFJvdGF0ZVdpdGhWaWV3O1xuICAgICAgdGhpcy50ZXh0Um90YXRpb25fID0gdGV4dFJvdGF0aW9uID09PSB1bmRlZmluZWQgPyAwIDogdGV4dFJvdGF0aW9uO1xuXG4gICAgICB0aGlzLnN0cm9rZUtleV8gPSBzdHJva2VTdGF0ZSA/XG4gICAgICAgICh0eXBlb2Ygc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGUgPT0gJ3N0cmluZycgPyBzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSA6IGdldFVpZChzdHJva2VTdGF0ZS5zdHJva2VTdHlsZSkpICtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZUNhcCArIHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ICsgJ3wnICsgc3Ryb2tlU3RhdGUubGluZVdpZHRoICtcbiAgICAgICAgc3Ryb2tlU3RhdGUubGluZUpvaW4gKyBzdHJva2VTdGF0ZS5taXRlckxpbWl0ICsgJ1snICsgc3Ryb2tlU3RhdGUubGluZURhc2guam9pbigpICsgJ10nIDpcbiAgICAgICAgJyc7XG4gICAgICB0aGlzLnRleHRLZXlfID0gdGV4dFN0YXRlLmZvbnQgKyB0ZXh0U3RhdGUuc2NhbGUgKyAodGV4dFN0YXRlLnRleHRBbGlnbiB8fCAnPycpO1xuICAgICAgdGhpcy5maWxsS2V5XyA9IGZpbGxTdGF0ZSA/XG4gICAgICAgICh0eXBlb2YgZmlsbFN0YXRlLmZpbGxTdHlsZSA9PSAnc3RyaW5nJyA/IGZpbGxTdGF0ZS5maWxsU3R5bGUgOiAoJ3wnICsgZ2V0VWlkKGZpbGxTdGF0ZS5maWxsU3R5bGUpKSkgOlxuICAgICAgICAnJztcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250IEZvbnQgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGxpbmVzIExpbmVzIHRvIG1lYXN1cmUuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHdpZHRocyBBcnJheSB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIHRoZSB3aWR0aHMgb2ZcbiAqIGVhY2ggbGluZS5cbiAqIEByZXR1cm4ge251bWJlcn0gV2lkdGggb2YgdGhlIHdob2xlIHRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWFzdXJlVGV4dFdpZHRocyhmb250LCBsaW5lcywgd2lkdGhzKSB7XG4gIGNvbnN0IG51bUxpbmVzID0gbGluZXMubGVuZ3RoO1xuICBsZXQgd2lkdGggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUxpbmVzOyArK2kpIHtcbiAgICBjb25zdCBjdXJyZW50V2lkdGggPSBtZWFzdXJlVGV4dFdpZHRoKGZvbnQsIGxpbmVzW2ldKTtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdXJyZW50V2lkdGgpO1xuICAgIHdpZHRocy5wdXNoKGN1cnJlbnRXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIHdpZHRoO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1RleHRSZXBsYXk7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cFxuICovXG5cbmltcG9ydCB7bnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbn0gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4uLy4uL2RvbS5qcyc7XG5pbXBvcnQge2J1ZmZlciwgY3JlYXRlRW1wdHksIGV4dGVuZENvb3JkaW5hdGV9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge3RyYW5zZm9ybTJEfSBmcm9tICcuLi8uLi9nZW9tL2ZsYXQvdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vLi4vb2JqLmpzJztcbmltcG9ydCBSZXBsYXlHcm91cCBmcm9tICcuLi9SZXBsYXlHcm91cC5qcyc7XG5pbXBvcnQgUmVwbGF5VHlwZSBmcm9tICcuLi9SZXBsYXlUeXBlLmpzJztcbmltcG9ydCBDYW52YXNSZXBsYXkgZnJvbSAnLi9SZXBsYXkuanMnO1xuaW1wb3J0IENhbnZhc0ltYWdlUmVwbGF5IGZyb20gJy4vSW1hZ2VSZXBsYXkuanMnO1xuaW1wb3J0IENhbnZhc0xpbmVTdHJpbmdSZXBsYXkgZnJvbSAnLi9MaW5lU3RyaW5nUmVwbGF5LmpzJztcbmltcG9ydCBDYW52YXNQb2x5Z29uUmVwbGF5IGZyb20gJy4vUG9seWdvblJlcGxheS5qcyc7XG5pbXBvcnQgQ2FudmFzVGV4dFJlcGxheSBmcm9tICcuL1RleHRSZXBsYXkuanMnO1xuaW1wb3J0IHtPUkRFUn0gZnJvbSAnLi4vcmVwbGF5LmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxSZXBsYXlUeXBlLCB0eXBlb2YgQ2FudmFzUmVwbGF5Pn1cbiAqL1xuY29uc3QgQkFUQ0hfQ09OU1RSVUNUT1JTID0ge1xuICAnQ2lyY2xlJzogQ2FudmFzUG9seWdvblJlcGxheSxcbiAgJ0RlZmF1bHQnOiBDYW52YXNSZXBsYXksXG4gICdJbWFnZSc6IENhbnZhc0ltYWdlUmVwbGF5LFxuICAnTGluZVN0cmluZyc6IENhbnZhc0xpbmVTdHJpbmdSZXBsYXksXG4gICdQb2x5Z29uJzogQ2FudmFzUG9seWdvblJlcGxheSxcbiAgJ1RleHQnOiBDYW52YXNUZXh0UmVwbGF5XG59O1xuXG5cbmNsYXNzIENhbnZhc1JlcGxheUdyb3VwIGV4dGVuZHMgUmVwbGF5R3JvdXAge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUb2xlcmFuY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gbWF4RXh0ZW50IE1heCBleHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJsYXBzIFRoZSByZXBsYXkgZ3JvdXAgY2FuIGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAgICogQHBhcmFtIHs/fSBkZWNsdXR0ZXJUcmVlIERlY2x1dHRlciB0cmVlIGZvciBkZWNsdXR0ZXIgcHJvY2Vzc2luZyBpbiBwb3N0cmVuZGVyLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9yZW5kZXJCdWZmZXIgT3B0aW9uYWwgcmVuZGVyaW5nIGJ1ZmZlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHRvbGVyYW5jZSxcbiAgICBtYXhFeHRlbnQsXG4gICAgcmVzb2x1dGlvbixcbiAgICBwaXhlbFJhdGlvLFxuICAgIG92ZXJsYXBzLFxuICAgIGRlY2x1dHRlclRyZWUsXG4gICAgb3B0X3JlbmRlckJ1ZmZlclxuICApIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogRGVjbHV0dGVyIHRyZWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlclRyZWVfID0gZGVjbHV0dGVyVHJlZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXB9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlckdyb3VwXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50b2xlcmFuY2VfID0gdG9sZXJhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLm1heEV4dGVudF8gPSBtYXhFeHRlbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxhcHNfID0gb3ZlcmxhcHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHV0aW9uXyA9IHJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyQnVmZmVyXyA9IG9wdF9yZW5kZXJCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU9iamVjdDxSZXBsYXlUeXBlLCBDYW52YXNSZXBsYXk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGxheXNCeVpJbmRleF8gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkNvbnRleHRfID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvblRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgYWRkRGVjbHV0dGVyKGdyb3VwKSB7XG4gICAgbGV0IGRlY2x1dHRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuZGVjbHV0dGVyVHJlZV8pIHtcbiAgICAgIGlmIChncm91cCkge1xuICAgICAgICBkZWNsdXR0ZXIgPSB0aGlzLmRlY2x1dHRlckdyb3VwXztcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChkZWNsdXR0ZXJbNF0pKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWNsdXR0ZXIgPSB0aGlzLmRlY2x1dHRlckdyb3VwXyA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgICAgIGRlY2x1dHRlci5wdXNoKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjbHV0dGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICovXG4gIGNsaXAoY29udGV4dCwgdHJhbnNmb3JtKSB7XG4gICAgY29uc3QgZmxhdENsaXBDb29yZHMgPSB0aGlzLmdldENsaXBDb29yZHModHJhbnNmb3JtKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGZsYXRDbGlwQ29vcmRzWzBdLCBmbGF0Q2xpcENvb3Jkc1sxXSk7XG4gICAgY29udGV4dC5saW5lVG8oZmxhdENsaXBDb29yZHNbMl0sIGZsYXRDbGlwQ29vcmRzWzNdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhmbGF0Q2xpcENvb3Jkc1s0XSwgZmxhdENsaXBDb29yZHNbNV0pO1xuICAgIGNvbnRleHQubGluZVRvKGZsYXRDbGlwQ29vcmRzWzZdLCBmbGF0Q2xpcENvb3Jkc1s3XSk7XG4gICAgY29udGV4dC5jbGlwKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxSZXBsYXlUeXBlPn0gcmVwbGF5cyBSZXBsYXlzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBIYXMgcmVwbGF5cyBvZiB0aGUgcHJvdmlkZWQgdHlwZXMuXG4gICAqL1xuICBoYXNSZXBsYXlzKHJlcGxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHpJbmRleCBpbiB0aGlzLnJlcGxheXNCeVpJbmRleF8pIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnJlcGxheXNCeVpJbmRleF9bekluZGV4XTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHJlcGxheXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBpZiAocmVwbGF5c1tpXSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgZmluaXNoKCkge1xuICAgIGZvciAoY29uc3QgektleSBpbiB0aGlzLnJlcGxheXNCeVpJbmRleF8pIHtcbiAgICAgIGNvbnN0IHJlcGxheXMgPSB0aGlzLnJlcGxheXNCeVpJbmRleF9bektleV07XG4gICAgICBmb3IgKGNvbnN0IHJlcGxheUtleSBpbiByZXBsYXlzKSB7XG4gICAgICAgIHJlcGxheXNbcmVwbGF5S2V5XS5maW5pc2goKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSBza2lwcGVkRmVhdHVyZXNIYXNoIElkcyBvZiBmZWF0dXJlcyB0byBza2lwLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKChpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KSk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwPn0gZGVjbHV0dGVyUmVwbGF5cyBEZWNsdXR0ZXIgcmVwbGF5cy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgcmVzb2x1dGlvbixcbiAgICByb3RhdGlvbixcbiAgICBoaXRUb2xlcmFuY2UsXG4gICAgc2tpcHBlZEZlYXR1cmVzSGFzaCxcbiAgICBjYWxsYmFjayxcbiAgICBkZWNsdXR0ZXJSZXBsYXlzXG4gICkge1xuXG4gICAgaGl0VG9sZXJhbmNlID0gTWF0aC5yb3VuZChoaXRUb2xlcmFuY2UpO1xuICAgIGNvbnN0IGNvbnRleHRTaXplID0gaGl0VG9sZXJhbmNlICogMiArIDE7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gY29tcG9zZVRyYW5zZm9ybSh0aGlzLmhpdERldGVjdGlvblRyYW5zZm9ybV8sXG4gICAgICBoaXRUb2xlcmFuY2UgKyAwLjUsIGhpdFRvbGVyYW5jZSArIDAuNSxcbiAgICAgIDEgLyByZXNvbHV0aW9uLCAtMSAvIHJlc29sdXRpb24sXG4gICAgICAtcm90YXRpb24sXG4gICAgICAtY29vcmRpbmF0ZVswXSwgLWNvb3JkaW5hdGVbMV0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmhpdERldGVjdGlvbkNvbnRleHRfO1xuXG4gICAgaWYgKGNvbnRleHQuY2FudmFzLndpZHRoICE9PSBjb250ZXh0U2l6ZSB8fCBjb250ZXh0LmNhbnZhcy5oZWlnaHQgIT09IGNvbnRleHRTaXplKSB7XG4gICAgICBjb250ZXh0LmNhbnZhcy53aWR0aCA9IGNvbnRleHRTaXplO1xuICAgICAgY29udGV4dC5jYW52YXMuaGVpZ2h0ID0gY29udGV4dFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNvbnRleHRTaXplLCBjb250ZXh0U2l6ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgbGV0IGhpdEV4dGVudDtcbiAgICBpZiAodGhpcy5yZW5kZXJCdWZmZXJfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhpdEV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGhpdEV4dGVudCwgY29vcmRpbmF0ZSk7XG4gICAgICBidWZmZXIoaGl0RXh0ZW50LCByZXNvbHV0aW9uICogKHRoaXMucmVuZGVyQnVmZmVyXyArIGhpdFRvbGVyYW5jZSksIGhpdEV4dGVudCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFzayA9IGdldENpcmNsZUFycmF5KGhpdFRvbGVyYW5jZSk7XG4gICAgbGV0IGRlY2x1dHRlcmVkRmVhdHVyZXM7XG4gICAgaWYgKHRoaXMuZGVjbHV0dGVyVHJlZV8pIHtcbiAgICAgIGRlY2x1dHRlcmVkRmVhdHVyZXMgPSB0aGlzLmRlY2x1dHRlclRyZWVfLmFsbCgpLm1hcChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgcmVwbGF5VHlwZTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAqIEByZXR1cm4gez99IENhbGxiYWNrIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmZWF0dXJlQ2FsbGJhY2soZmVhdHVyZSkge1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY29udGV4dFNpemUsIGNvbnRleHRTaXplKS5kYXRhO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0U2l6ZTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29udGV4dFNpemU7IGorKykge1xuICAgICAgICAgIGlmIChtYXNrW2ldW2pdKSB7XG4gICAgICAgICAgICBpZiAoaW1hZ2VEYXRhWyhqICogY29udGV4dFNpemUgKyBpKSAqIDQgKyAzXSA+IDApIHtcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgaWYgKCEoZGVjbHV0dGVyZWRGZWF0dXJlcyAmJiAocmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLklNQUdFIHx8IHJlcGxheVR5cGUgPT0gUmVwbGF5VHlwZS5URVhUKSkgfHxcbiAgICAgICAgICAgICAgICAgIGRlY2x1dHRlcmVkRmVhdHVyZXMuaW5kZXhPZihmZWF0dXJlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhmZWF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjb250ZXh0U2l6ZSwgY29udGV4dFNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gICAgY29uc3QgenMgPSBPYmplY3Qua2V5cyh0aGlzLnJlcGxheXNCeVpJbmRleF8pLm1hcChOdW1iZXIpO1xuICAgIHpzLnNvcnQobnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbik7XG5cbiAgICBsZXQgaSwgaiwgcmVwbGF5cywgcmVwbGF5LCByZXN1bHQ7XG4gICAgZm9yIChpID0genMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHpJbmRleEtleSA9IHpzW2ldLnRvU3RyaW5nKCk7XG4gICAgICByZXBsYXlzID0gdGhpcy5yZXBsYXlzQnlaSW5kZXhfW3pJbmRleEtleV07XG4gICAgICBmb3IgKGogPSBPUkRFUi5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICByZXBsYXlUeXBlID0gT1JERVJbal07XG4gICAgICAgIHJlcGxheSA9IHJlcGxheXNbcmVwbGF5VHlwZV07XG4gICAgICAgIGlmIChyZXBsYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChkZWNsdXR0ZXJSZXBsYXlzICYmXG4gICAgICAgICAgICAgIChyZXBsYXlUeXBlID09IFJlcGxheVR5cGUuSU1BR0UgfHwgcmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLlRFWFQpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNsdXR0ZXIgPSBkZWNsdXR0ZXJSZXBsYXlzW3pJbmRleEtleV07XG4gICAgICAgICAgICBpZiAoIWRlY2x1dHRlcikge1xuICAgICAgICAgICAgICBkZWNsdXR0ZXJSZXBsYXlzW3pJbmRleEtleV0gPSBbcmVwbGF5LCB0cmFuc2Zvcm0uc2xpY2UoMCldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVjbHV0dGVyLnB1c2gocmVwbGF5LCB0cmFuc2Zvcm0uc2xpY2UoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXBsYXkucmVwbGF5SGl0RGV0ZWN0aW9uKGNvbnRleHQsIHRyYW5zZm9ybSwgcm90YXRpb24sXG4gICAgICAgICAgICAgIHNraXBwZWRGZWF0dXJlc0hhc2gsIGZlYXR1cmVDYWxsYmFjaywgaGl0RXh0ZW50KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IHRyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IENsaXAgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBnZXRDbGlwQ29vcmRzKHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IG1heEV4dGVudCA9IHRoaXMubWF4RXh0ZW50XztcbiAgICBjb25zdCBtaW5YID0gbWF4RXh0ZW50WzBdO1xuICAgIGNvbnN0IG1pblkgPSBtYXhFeHRlbnRbMV07XG4gICAgY29uc3QgbWF4WCA9IG1heEV4dGVudFsyXTtcbiAgICBjb25zdCBtYXhZID0gbWF4RXh0ZW50WzNdO1xuICAgIGNvbnN0IGZsYXRDbGlwQ29vcmRzID0gW21pblgsIG1pblksIG1pblgsIG1heFksIG1heFgsIG1heFksIG1heFgsIG1pblldO1xuICAgIHRyYW5zZm9ybTJEKFxuICAgICAgZmxhdENsaXBDb29yZHMsIDAsIDgsIDIsIHRyYW5zZm9ybSwgZmxhdENsaXBDb29yZHMpO1xuICAgIHJldHVybiBmbGF0Q2xpcENvb3JkcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0UmVwbGF5KHpJbmRleCwgcmVwbGF5VHlwZSkge1xuICAgIGNvbnN0IHpJbmRleEtleSA9IHpJbmRleCAhPT0gdW5kZWZpbmVkID8gekluZGV4LnRvU3RyaW5nKCkgOiAnMCc7XG4gICAgbGV0IHJlcGxheXMgPSB0aGlzLnJlcGxheXNCeVpJbmRleF9bekluZGV4S2V5XTtcbiAgICBpZiAocmVwbGF5cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXBsYXlzID0ge307XG4gICAgICB0aGlzLnJlcGxheXNCeVpJbmRleF9bekluZGV4S2V5XSA9IHJlcGxheXM7XG4gICAgfVxuICAgIGxldCByZXBsYXkgPSByZXBsYXlzW3JlcGxheVR5cGVdO1xuICAgIGlmIChyZXBsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgQ29uc3RydWN0b3IgPSBCQVRDSF9DT05TVFJVQ1RPUlNbcmVwbGF5VHlwZV07XG4gICAgICByZXBsYXkgPSBuZXcgQ29uc3RydWN0b3IodGhpcy50b2xlcmFuY2VfLCB0aGlzLm1heEV4dGVudF8sXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbl8sIHRoaXMucGl4ZWxSYXRpb18sIHRoaXMub3ZlcmxhcHNfLCB0aGlzLmRlY2x1dHRlclRyZWVfKTtcbiAgICAgIHJlcGxheXNbcmVwbGF5VHlwZV0gPSByZXBsYXk7XG4gICAgfVxuICAgIHJldHVybiByZXBsYXk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgT2JqZWN0PFJlcGxheVR5cGUsIENhbnZhc1JlcGxheT4+fSBSZXBsYXlzLlxuICAgKi9cbiAgZ2V0UmVwbGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYXlzQnlaSW5kZXhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBpc0VtcHR5KHRoaXMucmVwbGF5c0J5WkluZGV4Xyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmlld1JvdGF0aW9uIFZpZXcgcm90YXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHNraXBwZWRGZWF0dXJlc0hhc2ggSWRzIG9mIGZlYXR1cmVzIHRvIHNraXAuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCBwb2ludCBzeW1ib2xzIGFuZCB0ZXN0IHRvIGludGVnZXIgcGl4ZWwuXG4gICAqIEBwYXJhbSB7QXJyYXk8UmVwbGF5VHlwZT49fSBvcHRfcmVwbGF5VHlwZXMgT3JkZXJlZCByZXBsYXkgdHlwZXMgdG8gcmVwbGF5LlxuICAgKiAgICAgRGVmYXVsdCBpcyB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9yZXBsYXl+T1JERVJ9XG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwPj19IG9wdF9kZWNsdXR0ZXJSZXBsYXlzIERlY2x1dHRlciByZXBsYXlzLlxuICAgKi9cbiAgcmVwbGF5KFxuICAgIGNvbnRleHQsXG4gICAgdHJhbnNmb3JtLFxuICAgIHZpZXdSb3RhdGlvbixcbiAgICBza2lwcGVkRmVhdHVyZXNIYXNoLFxuICAgIHNuYXBUb1BpeGVsLFxuICAgIG9wdF9yZXBsYXlUeXBlcyxcbiAgICBvcHRfZGVjbHV0dGVyUmVwbGF5c1xuICApIHtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICBjb25zdCB6cyA9IE9iamVjdC5rZXlzKHRoaXMucmVwbGF5c0J5WkluZGV4XykubWFwKE51bWJlcik7XG4gICAgenMuc29ydChudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9uKTtcblxuICAgIC8vIHNldHVwIGNsaXBwaW5nIHNvIHRoYXQgdGhlIHBhcnRzIG9mIG92ZXItc2ltcGxpZmllZCBnZW9tZXRyaWVzIGFyZSBub3RcbiAgICAvLyB2aXNpYmxlIG91dHNpZGUgdGhlIGN1cnJlbnQgZXh0ZW50IHdoZW4gcGFubmluZ1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIHRoaXMuY2xpcChjb250ZXh0LCB0cmFuc2Zvcm0pO1xuXG4gICAgY29uc3QgcmVwbGF5VHlwZXMgPSBvcHRfcmVwbGF5VHlwZXMgPyBvcHRfcmVwbGF5VHlwZXMgOiBPUkRFUjtcbiAgICBsZXQgaSwgaWksIGosIGpqLCByZXBsYXlzLCByZXBsYXk7XG4gICAgZm9yIChpID0gMCwgaWkgPSB6cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCB6SW5kZXhLZXkgPSB6c1tpXS50b1N0cmluZygpO1xuICAgICAgcmVwbGF5cyA9IHRoaXMucmVwbGF5c0J5WkluZGV4X1t6SW5kZXhLZXldO1xuICAgICAgZm9yIChqID0gMCwgamogPSByZXBsYXlUeXBlcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgIGNvbnN0IHJlcGxheVR5cGUgPSByZXBsYXlUeXBlc1tqXTtcbiAgICAgICAgcmVwbGF5ID0gcmVwbGF5c1tyZXBsYXlUeXBlXTtcbiAgICAgICAgaWYgKHJlcGxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG9wdF9kZWNsdXR0ZXJSZXBsYXlzICYmXG4gICAgICAgICAgICAgIChyZXBsYXlUeXBlID09IFJlcGxheVR5cGUuSU1BR0UgfHwgcmVwbGF5VHlwZSA9PSBSZXBsYXlUeXBlLlRFWFQpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNsdXR0ZXIgPSBvcHRfZGVjbHV0dGVyUmVwbGF5c1t6SW5kZXhLZXldO1xuICAgICAgICAgICAgaWYgKCFkZWNsdXR0ZXIpIHtcbiAgICAgICAgICAgICAgb3B0X2RlY2x1dHRlclJlcGxheXNbekluZGV4S2V5XSA9IFtyZXBsYXksIHRyYW5zZm9ybS5zbGljZSgwKV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWNsdXR0ZXIucHVzaChyZXBsYXksIHRyYW5zZm9ybS5zbGljZSgwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxheS5yZXBsYXkoY29udGV4dCwgdHJhbnNmb3JtLCB2aWV3Um90YXRpb24sIHNraXBwZWRGZWF0dXJlc0hhc2gsIHNuYXBUb1BpeGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogVGhpcyBjYWNoZSBpcyB1c2VkIGZvciBzdG9yaW5nIGNhbGN1bGF0ZWQgcGl4ZWwgY2lyY2xlcyBmb3IgaW5jcmVhc2luZyBwZXJmb3JtYW5jZS5cbiAqIEl0IGlzIGEgc3RhdGljIHByb3BlcnR5IHRvIGFsbG93IGVhY2ggUmVwbGF5Z3JvdXAgdG8gYWNjZXNzIGl0LlxuICogQHR5cGUge09iamVjdDxudW1iZXIsIEFycmF5PEFycmF5PChib29sZWFufHVuZGVmaW5lZCk+Pj59XG4gKi9cbmNvbnN0IGNpcmNsZUFycmF5Q2FjaGUgPSB7XG4gIDA6IFtbdHJ1ZV1dXG59O1xuXG5cbi8qKlxuICogVGhpcyBtZXRob2QgZmlsbHMgYSByb3cgaW4gdGhlIGFycmF5IGZyb20gdGhlIGdpdmVuIGNvb3JkaW5hdGUgdG8gdGhlXG4gKiBtaWRkbGUgd2l0aCBgdHJ1ZWAuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PChib29sZWFufHVuZGVmaW5lZCk+Pn0gYXJyYXkgVGhlIGFycmF5IHRoYXQgd2lsbCBiZSBhbHRlcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgWSBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnJheSwgeCwgeSkge1xuICBsZXQgaTtcbiAgY29uc3QgcmFkaXVzID0gTWF0aC5mbG9vcihhcnJheS5sZW5ndGggLyAyKTtcbiAgaWYgKHggPj0gcmFkaXVzKSB7XG4gICAgZm9yIChpID0gcmFkaXVzOyBpIDwgeDsgaSsrKSB7XG4gICAgICBhcnJheVtpXVt5XSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHggPCByYWRpdXMpIHtcbiAgICBmb3IgKGkgPSB4ICsgMTsgaSA8IHJhZGl1czsgaSsrKSB7XG4gICAgICBhcnJheVtpXVt5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBUaGlzIG1ldGhvZHMgY3JlYXRlcyBhIGNpcmNsZSBpbnNpZGUgYSBmaXR0aW5nIGFycmF5LiBQb2ludHMgaW5zaWRlIHRoZVxuICogY2lyY2xlIGFyZSBtYXJrZWQgYnkgdHJ1ZSwgcG9pbnRzIG9uIHRoZSBvdXRzaWRlIGFyZSB1bmRlZmluZWQuXG4gKiBJdCB1c2VzIHRoZSBtaWRwb2ludCBjaXJjbGUgYWxnb3JpdGhtLlxuICogQSBjYWNoZSBpcyB1c2VkIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMuXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8KGJvb2xlYW58dW5kZWZpbmVkKT4+fSBBbiBhcnJheSB3aXRoIG1hcmtlZCBjaXJjbGUgcG9pbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2lyY2xlQXJyYXkocmFkaXVzKSB7XG4gIGlmIChjaXJjbGVBcnJheUNhY2hlW3JhZGl1c10gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjaXJjbGVBcnJheUNhY2hlW3JhZGl1c107XG4gIH1cblxuICBjb25zdCBhcnJheVNpemUgPSByYWRpdXMgKiAyICsgMTtcbiAgY29uc3QgYXJyID0gbmV3IEFycmF5KGFycmF5U2l6ZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlTaXplOyBpKyspIHtcbiAgICBhcnJbaV0gPSBuZXcgQXJyYXkoYXJyYXlTaXplKTtcbiAgfVxuXG4gIGxldCB4ID0gcmFkaXVzO1xuICBsZXQgeSA9IDA7XG4gIGxldCBlcnJvciA9IDA7XG5cbiAgd2hpbGUgKHggPj0geSkge1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzICsgeCwgcmFkaXVzICsgeSk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgKyB5LCByYWRpdXMgKyB4KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyAtIHksIHJhZGl1cyArIHgpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzIC0geCwgcmFkaXVzICsgeSk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgLSB4LCByYWRpdXMgLSB5KTtcbiAgICBmaWxsQ2lyY2xlQXJyYXlSb3dUb01pZGRsZShhcnIsIHJhZGl1cyAtIHksIHJhZGl1cyAtIHgpO1xuICAgIGZpbGxDaXJjbGVBcnJheVJvd1RvTWlkZGxlKGFyciwgcmFkaXVzICsgeSwgcmFkaXVzIC0geCk7XG4gICAgZmlsbENpcmNsZUFycmF5Um93VG9NaWRkbGUoYXJyLCByYWRpdXMgKyB4LCByYWRpdXMgLSB5KTtcblxuICAgIHkrKztcbiAgICBlcnJvciArPSAxICsgMiAqIHk7XG4gICAgaWYgKDIgKiAoZXJyb3IgLSB4KSArIDEgPiAwKSB7XG4gICAgICB4IC09IDE7XG4gICAgICBlcnJvciArPSAxIC0gMiAqIHg7XG4gICAgfVxuICB9XG5cbiAgY2lyY2xlQXJyYXlDYWNoZVtyYWRpdXNdID0gYXJyO1xuICByZXR1cm4gYXJyO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgQXJyYXk8Kj4+fSBkZWNsdXR0ZXJSZXBsYXlzIERlY2x1dHRlciByZXBsYXlzLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc25hcFRvUGl4ZWwgU25hcCBwb2ludCBzeW1ib2xzIGFuZCB0ZXh0IHRvIGludGVnZXIgcGl4ZWxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGF5RGVjbHV0dGVyKGRlY2x1dHRlclJlcGxheXMsIGNvbnRleHQsIHJvdGF0aW9uLCBzbmFwVG9QaXhlbCkge1xuICBjb25zdCB6cyA9IE9iamVjdC5rZXlzKGRlY2x1dHRlclJlcGxheXMpLm1hcChOdW1iZXIpLnNvcnQobnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbik7XG4gIGNvbnN0IHNraXBwZWRGZWF0dXJlVWlkcyA9IHt9O1xuICBmb3IgKGxldCB6ID0gMCwgenogPSB6cy5sZW5ndGg7IHogPCB6ejsgKyt6KSB7XG4gICAgY29uc3QgcmVwbGF5RGF0YSA9IGRlY2x1dHRlclJlcGxheXNbenNbel0udG9TdHJpbmcoKV07XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcmVwbGF5RGF0YS5sZW5ndGg7IGkgPCBpaTspIHtcbiAgICAgIGNvbnN0IHJlcGxheSA9IHJlcGxheURhdGFbaSsrXTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHJlcGxheURhdGFbaSsrXTtcbiAgICAgIHJlcGxheS5yZXBsYXkoY29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVVaWRzLCBzbmFwVG9QaXhlbCk7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzUmVwbGF5R3JvdXA7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUdBOzs7OztBQUtBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7Ozs7OztBQzNGQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTs7Ozs7QUFvQkE7Ozs7O0FBTUE7Ozs7O0FBTUE7Ozs7O0FBTUE7QUFHQTs7Ozs7Ozs7QUNoREE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBV0E7Ozs7O0FBTUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQVNBO0FBQ0E7Ozs7O0FBS0E7Ozs7OztBQU1BOzs7Ozs7O0FBT0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBQUE7QUFBQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFFQTs7O0FBRUE7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBRUE7O0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFMQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7O0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7OztBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQXRQQTtBQXdQQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQVFBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQU1BOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBbmhDQTtBQUNBO0FBcWhDQTs7QUNoa0NBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFTQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFHQTtBQUlBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUlBO0FBR0E7QUFJQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE5TUE7QUFDQTtBQWdOQTs7QUN2TkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQVNBO0FBQ0E7Ozs7O0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0dBO0FBQ0E7QUE2R0E7Ozs7Ozs7O0FDcEhBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFTQTtBQUNBOzs7OztBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBdE1BO0FBQ0E7QUF3TUE7O0FDck5BOzs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7OztBQ2xEQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFTQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBS0E7Ozs7OztBQU1BOzs7OztBQUtBOzs7Ozs7QUFNQTtBQUFBO0FBQUE7Ozs7O0FBS0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBRUE7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQXBDQTtBQUNBO0FBcUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUdBO0FBTUE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFyZkE7Ozs7Ozs7Ozs7QUErZkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7O0FDM2hCQTtBQUFBO0FBQUE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBU0E7QUFBQTtBQUFBO0FBVUE7QUFTQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7OztBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQVVBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBWUE7O0FBV0E7QUFDQTs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqWEE7Ozs7Ozs7O0FBeVhBO0FBQ0E7QUFEQTs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/ol/color.js\nvar ol_color = __webpack_require__(37);\n\n// EXTERNAL MODULE: ./node_modules/ol/colorlike.js\nvar colorlike = __webpack_require__(39);\n\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/has.js\nvar has = __webpack_require__(19);\n\n// EXTERNAL MODULE: ./node_modules/ol/ImageState.js\nvar ImageState = __webpack_require__(22);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js\nvar canvas = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/Image.js\nvar Image = __webpack_require__(91);\n\n// CONCATENATED MODULE: ./node_modules/ol/style/RegularShape.js\n/**\n * @module ol/style/RegularShape\n */\n\n\n\n\n\n\n\n/**\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\n * @typedef {Object} Options\n * @property {import("./Fill.js").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} [radius] Radius of a regular polygon.\n * @property {number} [radius1] Outer radius of a star.\n * @property {number} [radius2] Inner radius of a star.\n * @property {number} [angle=0] Shape\'s angle in radians. A value of 0 will have one of the shape\'s point facing up.\n * @property {import("./Stroke.js").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {import("./AtlasManager.js").default} [atlasManager] The atlas manager to use for this symbol. When\n * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the\n * symbol is added to an atlas. By default no atlas manager is used.\n */\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import("../colorlike.js").ColorLike} [strokeStyle]\n * @property {number} strokeWidth\n * @property {number} size\n * @property {string} lineCap\n * @property {Array<number>} lineDash\n * @property {number} lineDashOffset\n * @property {string} lineJoin\n * @property {number} miterLimit\n */\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n * @api\n */\n\nvar RegularShape_RegularShape =\n/*@__PURE__*/\nfunction (ImageStyle) {\n  function RegularShape(options) {\n    /**\n     * @type {boolean}\n     */\n    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;\n    ImageStyle.call(this, {\n      opacity: 1,\n      rotateWithView: rotateWithView,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: 1\n    });\n    /**\n     * @private\n     * @type {Array<string|number>}\n     */\n\n    this.checksums_ = null;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.canvas_ = null;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.hitDetectionCanvas_ = null;\n    /**\n     * @private\n     * @type {import("./Fill.js").default}\n     */\n\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.origin_ = [0, 0];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.points_ = options.points;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.radius_ =\n    /** @type {number} */\n    options.radius !== undefined ? options.radius : options.radius1;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.radius2_ = options.radius2;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n    /**\n     * @private\n     * @type {import("./Stroke.js").default}\n     */\n\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.anchor_ = null;\n    /**\n     * @private\n     * @type {import("../size.js").Size}\n     */\n\n    this.size_ = null;\n    /**\n     * @private\n     * @type {import("../size.js").Size}\n     */\n\n    this.imageSize_ = null;\n    /**\n     * @private\n     * @type {import("../size.js").Size}\n     */\n\n    this.hitDetectionImageSize_ = null;\n    /**\n     * @protected\n     * @type {import("./AtlasManager.js").default|undefined}\n     */\n\n    this.atlasManager_ = options.atlasManager;\n    this.render_(this.atlasManager_);\n  }\n\n  if (ImageStyle) RegularShape.__proto__ = ImageStyle;\n  RegularShape.prototype = Object.create(ImageStyle && ImageStyle.prototype);\n  RegularShape.prototype.constructor = RegularShape;\n  /**\n   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n   * @return {RegularShape} The cloned style.\n   * @api\n   */\n\n  RegularShape.prototype.clone = function clone() {\n    var style = new RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      atlasManager: this.atlasManager_\n    });\n    style.setOpacity(this.getOpacity());\n    style.setScale(this.getScale());\n    return style;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  RegularShape.prototype.getAnchor = function getAnchor() {\n    return this.anchor_;\n  };\n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape\'s rotation in radians.\n   * @api\n   */\n\n\n  RegularShape.prototype.getAngle = function getAngle() {\n    return this.angle_;\n  };\n  /**\n   * Get the fill style for the shape.\n   * @return {import("./Fill.js").default} Fill style.\n   * @api\n   */\n\n\n  RegularShape.prototype.getFill = function getFill() {\n    return this.fill_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage(pixelRatio) {\n    return this.hitDetectionCanvas_;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  RegularShape.prototype.getImage = function getImage(pixelRatio) {\n    return this.canvas_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RegularShape.prototype.getImageSize = function getImageSize() {\n    return this.imageSize_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize() {\n    return this.hitDetectionImageSize_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RegularShape.prototype.getImageState = function getImageState() {\n    return ImageState["a" /* default */].LOADED;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  RegularShape.prototype.getOrigin = function getOrigin() {\n    return this.origin_;\n  };\n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n\n\n  RegularShape.prototype.getPoints = function getPoints() {\n    return this.points_;\n  };\n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n\n\n  RegularShape.prototype.getRadius = function getRadius() {\n    return this.radius_;\n  };\n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n\n\n  RegularShape.prototype.getRadius2 = function getRadius2() {\n    return this.radius2_;\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  RegularShape.prototype.getSize = function getSize() {\n    return this.size_;\n  };\n  /**\n   * Get the stroke style for the shape.\n   * @return {import("./Stroke.js").default} Stroke style.\n   * @api\n   */\n\n\n  RegularShape.prototype.getStroke = function getStroke() {\n    return this.stroke_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RegularShape.prototype.listenImageChange = function listenImageChange(listener, thisArg) {\n    return undefined;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  RegularShape.prototype.load = function load() {};\n  /**\n   * @inheritDoc\n   */\n\n\n  RegularShape.prototype.unlistenImageChange = function unlistenImageChange(listener, thisArg) {};\n  /**\n   * @protected\n   * @param {import("./AtlasManager.js").default|undefined} atlasManager An atlas manager.\n   */\n\n\n  RegularShape.prototype.render_ = function render_(atlasManager) {\n    var imageSize;\n    var lineCap = \'\';\n    var lineJoin = \'\';\n    var miterLimit = 0;\n    var lineDash = null;\n    var lineDashOffset = 0;\n    var strokeStyle;\n    var strokeWidth = 0;\n\n    if (this.stroke_) {\n      strokeStyle = this.stroke_.getColor();\n\n      if (strokeStyle === null) {\n        strokeStyle = canvas["k" /* defaultStrokeStyle */];\n      }\n\n      strokeStyle = Object(colorlike["a" /* asColorLike */])(strokeStyle);\n      strokeWidth = this.stroke_.getWidth();\n\n      if (strokeWidth === undefined) {\n        strokeWidth = canvas["h" /* defaultLineWidth */];\n      }\n\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset();\n\n      if (!has["a" /* CANVAS_LINE_DASH */]) {\n        lineDash = null;\n        lineDashOffset = 0;\n      }\n\n      lineJoin = this.stroke_.getLineJoin();\n\n      if (lineJoin === undefined) {\n        lineJoin = canvas["g" /* defaultLineJoin */];\n      }\n\n      lineCap = this.stroke_.getLineCap();\n\n      if (lineCap === undefined) {\n        lineCap = canvas["d" /* defaultLineCap */];\n      }\n\n      miterLimit = this.stroke_.getMiterLimit();\n\n      if (miterLimit === undefined) {\n        miterLimit = canvas["i" /* defaultMiterLimit */];\n      }\n    }\n\n    var size = 2 * (this.radius_ + strokeWidth) + 1;\n    /** @type {RenderOptions} */\n\n    var renderOptions = {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineCap: lineCap,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit\n    };\n\n    if (atlasManager === undefined) {\n      // no atlas manager is used, create a new canvas\n      var context = Object(dom["a" /* createCanvasContext2D */])(size, size);\n      this.canvas_ = context.canvas; // canvas.width and height are rounded to the closest integer\n\n      size = this.canvas_.width;\n      imageSize = size;\n      this.draw_(renderOptions, context, 0, 0);\n      this.createHitDetectionCanvas_(renderOptions);\n    } else {\n      // an atlas manager is used, add the symbol to an atlas\n      size = Math.round(size);\n      var hasCustomHitDetectionImage = !this.fill_;\n      var renderHitDetectionCallback;\n\n      if (hasCustomHitDetectionImage) {\n        // render the hit-detection image into a separate atlas image\n        renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);\n      }\n\n      var id = this.getChecksum();\n      var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);\n      this.canvas_ = info.image;\n      this.origin_ = [info.offsetX, info.offsetY];\n      imageSize = info.image.width;\n\n      if (hasCustomHitDetectionImage) {\n        this.hitDetectionCanvas_ = info.hitImage;\n        this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];\n      } else {\n        this.hitDetectionCanvas_ = this.canvas_;\n        this.hitDetectionImageSize_ = [imageSize, imageSize];\n      }\n    }\n\n    this.anchor_ = [size / 2, size / 2];\n    this.size_ = [size, size];\n    this.imageSize_ = [imageSize, imageSize];\n  };\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n\n\n  RegularShape.prototype.draw_ = function draw_(renderOptions, context, x, y) {\n    var i, angle0, radiusC; // reset transform\n\n    context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)\n\n    context.translate(x, y);\n    context.beginPath();\n    var points = this.points_;\n\n    if (points === Infinity) {\n      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n\n    if (this.fill_) {\n      var color = this.fill_.getColor();\n\n      if (color === null) {\n        color = canvas["b" /* defaultFillStyle */];\n      }\n\n      context.fillStyle = Object(colorlike["a" /* asColorLike */])(color);\n      context.fill();\n    }\n\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n\n      context.lineCap =\n      /** @type {CanvasLineCap} */\n      renderOptions.lineCap;\n      context.lineJoin =\n      /** @type {CanvasLineJoin} */\n      renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n\n    context.closePath();\n  };\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   */\n\n\n  RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_(renderOptions) {\n    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n\n    if (this.fill_) {\n      this.hitDetectionCanvas_ = this.canvas_;\n      return;\n    } // if no fill style is set, create an extra hit-detection image with a\n    // default fill style\n\n\n    var context = Object(dom["a" /* createCanvasContext2D */])(renderOptions.size, renderOptions.size);\n    this.hitDetectionCanvas_ = context.canvas;\n    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n  };\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n\n\n  RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_(renderOptions, context, x, y) {\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0); // then move to (x, y)\n\n    context.translate(x, y);\n    context.beginPath();\n    var points = this.points_;\n\n    if (points === Infinity) {\n      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n\n      var i, radiusC, angle0;\n\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n\n    context.fillStyle = Object(ol_color["b" /* asString */])(canvas["b" /* defaultFillStyle */]);\n    context.fill();\n\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n\n      context.stroke();\n    }\n\n    context.closePath();\n  };\n  /**\n   * @return {string} The checksum.\n   */\n\n\n  RegularShape.prototype.getChecksum = function getChecksum() {\n    var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : \'-\';\n    var fillChecksum = this.fill_ ? this.fill_.getChecksum() : \'-\';\n    var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];\n\n    if (recalculate) {\n      var checksum = \'r\' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : \'-\') + (this.radius2_ !== undefined ? this.radius2_.toString() : \'-\') + (this.angle_ !== undefined ? this.angle_.toString() : \'-\') + (this.points_ !== undefined ? this.points_.toString() : \'-\');\n      this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];\n    }\n\n    return (\n      /** @type {string} */\n      this.checksums_[0]\n    );\n  };\n\n  return RegularShape;\n}(Image["a" /* default */]);\n\n/* harmony default export */ var style_RegularShape = (RegularShape_RegularShape);\n// CONCATENATED MODULE: ./node_modules/ol/style/Circle.js\n/**\n * @module ol/style/Circle\n */\n\n/**\n * @typedef {Object} Options\n * @property {import("./Fill.js").default} [fill] Fill style.\n * @property {number} radius Circle radius.\n * @property {import("./Stroke.js").default} [stroke] Stroke style.\n * @property {import("./AtlasManager.js").default} [atlasManager] The atlas manager to use for this circle.\n * When using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given,\n * the circle is added to an atlas. By default no atlas manager is used.\n */\n\n/**\n * @classdesc\n * Set circle style for vector features.\n * @api\n */\n\nvar CircleStyle =\n/*@__PURE__*/\nfunction (RegularShape) {\n  function CircleStyle(opt_options) {\n    var options = opt_options ||\n    /** @type {Options} */\n    {};\n    RegularShape.call(this, {\n      points: Infinity,\n      fill: options.fill,\n      radius: options.radius,\n      stroke: options.stroke,\n      atlasManager: options.atlasManager\n    });\n  }\n\n  if (RegularShape) CircleStyle.__proto__ = RegularShape;\n  CircleStyle.prototype = Object.create(RegularShape && RegularShape.prototype);\n  CircleStyle.prototype.constructor = CircleStyle;\n  /**\n  * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n  * @return {CircleStyle} The cloned style.\n  * @override\n  * @api\n  */\n\n  CircleStyle.prototype.clone = function clone() {\n    var style = new CircleStyle({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      radius: this.getRadius(),\n      atlasManager: this.atlasManager_\n    });\n    style.setOpacity(this.getOpacity());\n    style.setScale(this.getScale());\n    return style;\n  };\n  /**\n  * Set the circle radius.\n  *\n  * @param {number} radius Circle radius.\n  * @api\n  */\n\n\n  CircleStyle.prototype.setRadius = function setRadius(radius) {\n    this.radius_ = radius;\n    this.render_(this.atlasManager_);\n  };\n\n  return CircleStyle;\n}(style_RegularShape);\n\n/* harmony default export */ var Circle = __webpack_exports__["a"] = (CircleStyle);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL1JlZ3VsYXJTaGFwZS5qcz83ZTc2Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc3R5bGUvQ2lyY2xlLmpzP2NmZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL1JlZ3VsYXJTaGFwZVxuICovXG5cbmltcG9ydCB7YXNTdHJpbmd9IGZyb20gJy4uL2NvbG9yLmpzJztcbmltcG9ydCB7YXNDb2xvckxpa2V9IGZyb20gJy4uL2NvbG9ybGlrZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vZG9tLmpzJztcbmltcG9ydCB7Q0FOVkFTX0xJTkVfREFTSH0gZnJvbSAnLi4vaGFzLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtkZWZhdWx0U3Ryb2tlU3R5bGUsIGRlZmF1bHRGaWxsU3R5bGUsIGRlZmF1bHRMaW5lQ2FwLCBkZWZhdWx0TGluZVdpZHRoLCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRNaXRlckxpbWl0fSBmcm9tICcuLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuXG5cbi8qKlxuICogU3BlY2lmeSByYWRpdXMgZm9yIHJlZ3VsYXIgcG9seWdvbnMsIG9yIHJhZGl1czEgYW5kIHJhZGl1czIgZm9yIHN0YXJzLlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9pbnRzIE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLiBJbiBjYXNlIG9mIGEgcG9seWdvbiwgdGhlIG51bWJlciBvZiBwb2ludHNcbiAqIGlzIHRoZSBudW1iZXIgb2Ygc2lkZXMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1c10gUmFkaXVzIG9mIGEgcmVndWxhciBwb2x5Z29uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXMxXSBPdXRlciByYWRpdXMgb2YgYSBzdGFyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRpdXMyXSBJbm5lciByYWRpdXMgb2YgYSBzdGFyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthbmdsZT0wXSBTaGFwZSdzIGFuZ2xlIGluIHJhZGlhbnMuIEEgdmFsdWUgb2YgMCB3aWxsIGhhdmUgb25lIG9mIHRoZSBzaGFwZSdzIHBvaW50IGZhY2luZyB1cC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gW3N0cm9rZV0gU3Ryb2tlIHN0eWxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcm90YXRlV2l0aFZpZXc9ZmFsc2VdIFdoZXRoZXIgdG8gcm90YXRlIHRoZSBzaGFwZSB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0F0bGFzTWFuYWdlci5qc1wiKS5kZWZhdWx0fSBbYXRsYXNNYW5hZ2VyXSBUaGUgYXRsYXMgbWFuYWdlciB0byB1c2UgZm9yIHRoaXMgc3ltYm9sLiBXaGVuXG4gKiB1c2luZyBXZWJHTCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYW4gYXRsYXMgbWFuYWdlciB0byBhdm9pZCB0ZXh0dXJlIHN3aXRjaGluZy4gSWYgYW4gYXRsYXMgbWFuYWdlciBpcyBnaXZlbiwgdGhlXG4gKiBzeW1ib2wgaXMgYWRkZWQgdG8gYW4gYXRsYXMuIEJ5IGRlZmF1bHQgbm8gYXRsYXMgbWFuYWdlciBpcyB1c2VkLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZW5kZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2NvbG9ybGlrZS5qc1wiKS5Db2xvckxpa2V9IFtzdHJva2VTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdHJva2VXaWR0aFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5lQ2FwXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGxpbmVEYXNoXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZURhc2hPZmZzZXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaW5lSm9pblxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pdGVyTGltaXRcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IHJlZ3VsYXIgc2hhcGUgc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy4gVGhlIHJlc3VsdGluZyBzaGFwZSB3aWxsIGJlXG4gKiBhIHJlZ3VsYXIgcG9seWdvbiB3aGVuIGByYWRpdXNgIGlzIHByb3ZpZGVkLCBvciBhIHN0YXIgd2hlbiBgcmFkaXVzMWAgYW5kXG4gKiBgcmFkaXVzMmAgYXJlIHByb3ZpZGVkLlxuICogQGFwaVxuICovXG5jbGFzcyBSZWd1bGFyU2hhcGUgZXh0ZW5kcyBJbWFnZVN0eWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0ZVdpdGhWaWV3ID0gb3B0aW9ucy5yb3RhdGVXaXRoVmlldyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucm90YXRlV2l0aFZpZXcgOiBmYWxzZTtcblxuICAgIHN1cGVyKHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICByb3RhdGVXaXRoVmlldzogcm90YXRlV2l0aFZpZXcsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yb3RhdGlvbiA6IDAsXG4gICAgICBzY2FsZTogMVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nfG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5jaGVja3N1bXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5fID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRzXyA9IG9wdGlvbnMucG9pbnRzO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXNfID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovIChvcHRpb25zLnJhZGl1cyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucmFkaXVzIDogb3B0aW9ucy5yYWRpdXMxKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yYWRpdXMyXyA9IG9wdGlvbnMucmFkaXVzMjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlXyA9IG9wdGlvbnMuYW5nbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZV8gPSBvcHRpb25zLnN0cm9rZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTaXplXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZVNpemVfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9BdGxhc01hbmFnZXIuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hdGxhc01hbmFnZXJfID0gb3B0aW9ucy5hdGxhc01hbmFnZXI7XG5cbiAgICB0aGlzLnJlbmRlcl8odGhpcy5hdGxhc01hbmFnZXJfKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuIElmIGFuIGF0bGFzbWFuYWdlciB3YXMgcHJvdmlkZWQgdG8gdGhlIG9yaWdpbmFsIHN0eWxlIGl0IHdpbGwgYmUgdXNlZCBpbiB0aGUgY2xvbmVkIHN0eWxlLCB0b28uXG4gICAqIEByZXR1cm4ge1JlZ3VsYXJTaGFwZX0gVGhlIGNsb25lZCBzdHlsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBuZXcgUmVndWxhclNoYXBlKHtcbiAgICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHBvaW50czogdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgIHJhZGl1czogdGhpcy5nZXRSYWRpdXMoKSxcbiAgICAgIHJhZGl1czI6IHRoaXMuZ2V0UmFkaXVzMigpLFxuICAgICAgYW5nbGU6IHRoaXMuZ2V0QW5nbGUoKSxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpLFxuICAgICAgYXRsYXNNYW5hZ2VyOiB0aGlzLmF0bGFzTWFuYWdlcl9cbiAgICB9KTtcbiAgICBzdHlsZS5zZXRPcGFjaXR5KHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICBzdHlsZS5zZXRTY2FsZSh0aGlzLmdldFNjYWxlKCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBbmNob3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFuZ2xlIHVzZWQgaW4gZ2VuZXJhdGluZyB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gU2hhcGUncyByb3RhdGlvbiBpbiByYWRpYW5zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmdsZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWxsIHN0eWxlIGZvciB0aGUgc2hhcGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBGaWxsIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGaWxsKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRIaXREZXRlY3Rpb25JbWFnZShwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJbWFnZShwaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0SW1hZ2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlU2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaXREZXRlY3Rpb25JbWFnZVNpemVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRJbWFnZVN0YXRlKCkge1xuICAgIHJldHVybiBJbWFnZVN0YXRlLkxPQURFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiBwb2ludHMgZm9yIGdlbmVyYXRpbmcgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBwb2ludHMgZm9yIHN0YXJzIGFuZCByZWd1bGFyIHBvbHlnb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRQb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIChwcmltYXJ5KSByYWRpdXMgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSYWRpdXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kYXJ5IHJhZGl1cyBmb3IgdGhlIHNoYXBlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSYWRpdXMyLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRSYWRpdXMyKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1czJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSBzaGFwZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gU3Ryb2tlIHN0eWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRTdHJva2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Ryb2tlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgbGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBsb2FkKCkge31cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHVubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIsIHRoaXNBcmcpIHt9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0F0bGFzTWFuYWdlci5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gYXRsYXNNYW5hZ2VyIEFuIGF0bGFzIG1hbmFnZXIuXG4gICAqL1xuICByZW5kZXJfKGF0bGFzTWFuYWdlcikge1xuICAgIGxldCBpbWFnZVNpemU7XG4gICAgbGV0IGxpbmVDYXAgPSAnJztcbiAgICBsZXQgbGluZUpvaW4gPSAnJztcbiAgICBsZXQgbWl0ZXJMaW1pdCA9IDA7XG4gICAgbGV0IGxpbmVEYXNoID0gbnVsbDtcbiAgICBsZXQgbGluZURhc2hPZmZzZXQgPSAwO1xuICAgIGxldCBzdHJva2VTdHlsZTtcbiAgICBsZXQgc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZV8uZ2V0Q29sb3IoKTtcbiAgICAgIGlmIChzdHJva2VTdHlsZSA9PT0gbnVsbCkge1xuICAgICAgICBzdHJva2VTdHlsZSA9IGRlZmF1bHRTdHJva2VTdHlsZTtcbiAgICAgIH1cbiAgICAgIHN0cm9rZVN0eWxlID0gYXNDb2xvckxpa2Uoc3Ryb2tlU3R5bGUpO1xuICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLnN0cm9rZV8uZ2V0V2lkdGgoKTtcbiAgICAgIGlmIChzdHJva2VXaWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gZGVmYXVsdExpbmVXaWR0aDtcbiAgICAgIH1cbiAgICAgIGxpbmVEYXNoID0gdGhpcy5zdHJva2VfLmdldExpbmVEYXNoKCk7XG4gICAgICBsaW5lRGFzaE9mZnNldCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lRGFzaE9mZnNldCgpO1xuICAgICAgaWYgKCFDQU5WQVNfTElORV9EQVNIKSB7XG4gICAgICAgIGxpbmVEYXNoID0gbnVsbDtcbiAgICAgICAgbGluZURhc2hPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgbGluZUpvaW4gPSB0aGlzLnN0cm9rZV8uZ2V0TGluZUpvaW4oKTtcbiAgICAgIGlmIChsaW5lSm9pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmVKb2luID0gZGVmYXVsdExpbmVKb2luO1xuICAgICAgfVxuICAgICAgbGluZUNhcCA9IHRoaXMuc3Ryb2tlXy5nZXRMaW5lQ2FwKCk7XG4gICAgICBpZiAobGluZUNhcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbmVDYXAgPSBkZWZhdWx0TGluZUNhcDtcbiAgICAgIH1cbiAgICAgIG1pdGVyTGltaXQgPSB0aGlzLnN0cm9rZV8uZ2V0TWl0ZXJMaW1pdCgpO1xuICAgICAgaWYgKG1pdGVyTGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtaXRlckxpbWl0ID0gZGVmYXVsdE1pdGVyTGltaXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNpemUgPSAyICogKHRoaXMucmFkaXVzXyArIHN0cm9rZVdpZHRoKSArIDE7XG5cbiAgICAvKiogQHR5cGUge1JlbmRlck9wdGlvbnN9ICovXG4gICAgY29uc3QgcmVuZGVyT3B0aW9ucyA9IHtcbiAgICAgIHN0cm9rZVN0eWxlOiBzdHJva2VTdHlsZSxcbiAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCxcbiAgICAgIHNpemU6IHNpemUsXG4gICAgICBsaW5lQ2FwOiBsaW5lQ2FwLFxuICAgICAgbGluZURhc2g6IGxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgbGluZUpvaW46IGxpbmVKb2luLFxuICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdFxuICAgIH07XG5cbiAgICBpZiAoYXRsYXNNYW5hZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG5vIGF0bGFzIG1hbmFnZXIgaXMgdXNlZCwgY3JlYXRlIGEgbmV3IGNhbnZhc1xuICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQyRChzaXplLCBzaXplKTtcbiAgICAgIHRoaXMuY2FudmFzXyA9IGNvbnRleHQuY2FudmFzO1xuXG4gICAgICAvLyBjYW52YXMud2lkdGggYW5kIGhlaWdodCBhcmUgcm91bmRlZCB0byB0aGUgY2xvc2VzdCBpbnRlZ2VyXG4gICAgICBzaXplID0gdGhpcy5jYW52YXNfLndpZHRoO1xuICAgICAgaW1hZ2VTaXplID0gc2l6ZTtcblxuICAgICAgdGhpcy5kcmF3XyhyZW5kZXJPcHRpb25zLCBjb250ZXh0LCAwLCAwKTtcblxuICAgICAgdGhpcy5jcmVhdGVIaXREZXRlY3Rpb25DYW52YXNfKHJlbmRlck9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbiBhdGxhcyBtYW5hZ2VyIGlzIHVzZWQsIGFkZCB0aGUgc3ltYm9sIHRvIGFuIGF0bGFzXG4gICAgICBzaXplID0gTWF0aC5yb3VuZChzaXplKTtcblxuICAgICAgY29uc3QgaGFzQ3VzdG9tSGl0RGV0ZWN0aW9uSW1hZ2UgPSAhdGhpcy5maWxsXztcbiAgICAgIGxldCByZW5kZXJIaXREZXRlY3Rpb25DYWxsYmFjaztcbiAgICAgIGlmIChoYXNDdXN0b21IaXREZXRlY3Rpb25JbWFnZSkge1xuICAgICAgICAvLyByZW5kZXIgdGhlIGhpdC1kZXRlY3Rpb24gaW1hZ2UgaW50byBhIHNlcGFyYXRlIGF0bGFzIGltYWdlXG4gICAgICAgIHJlbmRlckhpdERldGVjdGlvbkNhbGxiYWNrID1cbiAgICAgICAgICAgIHRoaXMuZHJhd0hpdERldGVjdGlvbkNhbnZhc18uYmluZCh0aGlzLCByZW5kZXJPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaWQgPSB0aGlzLmdldENoZWNrc3VtKCk7XG4gICAgICBjb25zdCBpbmZvID0gYXRsYXNNYW5hZ2VyLmFkZChcbiAgICAgICAgaWQsIHNpemUsIHNpemUsIHRoaXMuZHJhd18uYmluZCh0aGlzLCByZW5kZXJPcHRpb25zKSxcbiAgICAgICAgcmVuZGVySGl0RGV0ZWN0aW9uQ2FsbGJhY2spO1xuXG4gICAgICB0aGlzLmNhbnZhc18gPSBpbmZvLmltYWdlO1xuICAgICAgdGhpcy5vcmlnaW5fID0gW2luZm8ub2Zmc2V0WCwgaW5mby5vZmZzZXRZXTtcbiAgICAgIGltYWdlU2l6ZSA9IGluZm8uaW1hZ2Uud2lkdGg7XG5cbiAgICAgIGlmIChoYXNDdXN0b21IaXREZXRlY3Rpb25JbWFnZSkge1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBpbmZvLmhpdEltYWdlO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlU2l6ZV8gPVxuICAgICAgICAgICAgW2luZm8uaGl0SW1hZ2Uud2lkdGgsIGluZm8uaGl0SW1hZ2UuaGVpZ2h0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGl0RGV0ZWN0aW9uQ2FudmFzXyA9IHRoaXMuY2FudmFzXztcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZVNpemVfID0gW2ltYWdlU2l6ZSwgaW1hZ2VTaXplXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFuY2hvcl8gPSBbc2l6ZSAvIDIsIHNpemUgLyAyXTtcbiAgICB0aGlzLnNpemVfID0gW3NpemUsIHNpemVdO1xuICAgIHRoaXMuaW1hZ2VTaXplXyA9IFtpbWFnZVNpemUsIGltYWdlU2l6ZV07XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRoZSBvcmlnaW4gZm9yIHRoZSBzeW1ib2wgKHgpLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgb3JpZ2luIGZvciB0aGUgc3ltYm9sICh5KS5cbiAgICovXG4gIGRyYXdfKHJlbmRlck9wdGlvbnMsIGNvbnRleHQsIHgsIHkpIHtcbiAgICBsZXQgaSwgYW5nbGUwLCByYWRpdXNDO1xuICAgIC8vIHJlc2V0IHRyYW5zZm9ybVxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgLy8gdGhlbiBtb3ZlIHRvICh4LCB5KVxuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGxldCBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgaWYgKHBvaW50cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgLyAyLCByZW5kZXJPcHRpb25zLnNpemUgLyAyLFxuICAgICAgICB0aGlzLnJhZGl1c18sIDAsIDIgKiBNYXRoLlBJLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmFkaXVzMiA9ICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQpID8gdGhpcy5yYWRpdXMyX1xuICAgICAgICA6IHRoaXMucmFkaXVzXztcbiAgICAgIGlmIChyYWRpdXMyICE9PSB0aGlzLnJhZGl1c18pIHtcbiAgICAgICAgcG9pbnRzID0gMiAqIHBvaW50cztcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gcG9pbnRzOyBpKyspIHtcbiAgICAgICAgYW5nbGUwID0gaSAqIDIgKiBNYXRoLlBJIC8gcG9pbnRzIC0gTWF0aC5QSSAvIDIgKyB0aGlzLmFuZ2xlXztcbiAgICAgICAgcmFkaXVzQyA9IGkgJSAyID09PSAwID8gdGhpcy5yYWRpdXNfIDogcmFkaXVzMjtcbiAgICAgICAgY29udGV4dC5saW5lVG8ocmVuZGVyT3B0aW9ucy5zaXplIC8gMiArIHJhZGl1c0MgKiBNYXRoLmNvcyhhbmdsZTApLFxuICAgICAgICAgIHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIgKyByYWRpdXNDICogTWF0aC5zaW4oYW5nbGUwKSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBpZiAodGhpcy5maWxsXykge1xuICAgICAgbGV0IGNvbG9yID0gdGhpcy5maWxsXy5nZXRDb2xvcigpO1xuICAgICAgaWYgKGNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIGNvbG9yID0gZGVmYXVsdEZpbGxTdHlsZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYXNDb2xvckxpa2UoY29sb3IpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZV8pIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSByZW5kZXJPcHRpb25zLnN0cm9rZVN0eWxlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSByZW5kZXJPcHRpb25zLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHJlbmRlck9wdGlvbnMubGluZURhc2gpIHtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChyZW5kZXJPcHRpb25zLmxpbmVEYXNoKTtcbiAgICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IHJlbmRlck9wdGlvbnMubGluZURhc2hPZmZzZXQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAvKiogQHR5cGUge0NhbnZhc0xpbmVDYXB9ICovIChyZW5kZXJPcHRpb25zLmxpbmVDYXApO1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUpvaW59ICovIChyZW5kZXJPcHRpb25zLmxpbmVKb2luKTtcbiAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHJlbmRlck9wdGlvbnMubWl0ZXJMaW1pdDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKi9cbiAgY3JlYXRlSGl0RGV0ZWN0aW9uQ2FudmFzXyhyZW5kZXJPcHRpb25zKSB7XG4gICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZVNpemVfID0gW3JlbmRlck9wdGlvbnMuc2l6ZSwgcmVuZGVyT3B0aW9ucy5zaXplXTtcbiAgICBpZiAodGhpcy5maWxsXykge1xuICAgICAgdGhpcy5oaXREZXRlY3Rpb25DYW52YXNfID0gdGhpcy5jYW52YXNfO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGlmIG5vIGZpbGwgc3R5bGUgaXMgc2V0LCBjcmVhdGUgYW4gZXh0cmEgaGl0LWRldGVjdGlvbiBpbWFnZSB3aXRoIGFcbiAgICAvLyBkZWZhdWx0IGZpbGwgc3R5bGVcbiAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHJlbmRlck9wdGlvbnMuc2l6ZSwgcmVuZGVyT3B0aW9ucy5zaXplKTtcbiAgICB0aGlzLmhpdERldGVjdGlvbkNhbnZhc18gPSBjb250ZXh0LmNhbnZhcztcblxuICAgIHRoaXMuZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCwgMCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZW5kZXJPcHRpb25zfSByZW5kZXJPcHRpb25zIFJlbmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBUaGUgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIG9yaWdpbiBmb3IgdGhlIHN5bWJvbCAoeCkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBvcmlnaW4gZm9yIHRoZSBzeW1ib2wgKHkpLlxuICAgKi9cbiAgZHJhd0hpdERldGVjdGlvbkNhbnZhc18ocmVuZGVyT3B0aW9ucywgY29udGV4dCwgeCwgeSkge1xuICAgIC8vIHJlc2V0IHRyYW5zZm9ybVxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgLy8gdGhlbiBtb3ZlIHRvICh4LCB5KVxuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGxldCBwb2ludHMgPSB0aGlzLnBvaW50c187XG4gICAgaWYgKHBvaW50cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgLyAyLCByZW5kZXJPcHRpb25zLnNpemUgLyAyLFxuICAgICAgICB0aGlzLnJhZGl1c18sIDAsIDIgKiBNYXRoLlBJLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmFkaXVzMiA9ICh0aGlzLnJhZGl1czJfICE9PSB1bmRlZmluZWQpID8gdGhpcy5yYWRpdXMyX1xuICAgICAgICA6IHRoaXMucmFkaXVzXztcbiAgICAgIGlmIChyYWRpdXMyICE9PSB0aGlzLnJhZGl1c18pIHtcbiAgICAgICAgcG9pbnRzID0gMiAqIHBvaW50cztcbiAgICAgIH1cbiAgICAgIGxldCBpLCByYWRpdXNDLCBhbmdsZTA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDw9IHBvaW50czsgaSsrKSB7XG4gICAgICAgIGFuZ2xlMCA9IGkgKiAyICogTWF0aC5QSSAvIHBvaW50cyAtIE1hdGguUEkgLyAyICsgdGhpcy5hbmdsZV87XG4gICAgICAgIHJhZGl1c0MgPSBpICUgMiA9PT0gMCA/IHRoaXMucmFkaXVzXyA6IHJhZGl1czI7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHJlbmRlck9wdGlvbnMuc2l6ZSAvIDIgKyByYWRpdXNDICogTWF0aC5jb3MoYW5nbGUwKSxcbiAgICAgICAgICByZW5kZXJPcHRpb25zLnNpemUgLyAyICsgcmFkaXVzQyAqIE1hdGguc2luKGFuZ2xlMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYXNTdHJpbmcoZGVmYXVsdEZpbGxTdHlsZSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgaWYgKHRoaXMuc3Ryb2tlXykge1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlU3R5bGU7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHJlbmRlck9wdGlvbnMuc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAocmVuZGVyT3B0aW9ucy5saW5lRGFzaCkge1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKHJlbmRlck9wdGlvbnMubGluZURhc2gpO1xuICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gcmVuZGVyT3B0aW9ucy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2hlY2tzdW0uXG4gICAqL1xuICBnZXRDaGVja3N1bSgpIHtcbiAgICBjb25zdCBzdHJva2VDaGVja3N1bSA9IHRoaXMuc3Ryb2tlXyA/XG4gICAgICB0aGlzLnN0cm9rZV8uZ2V0Q2hlY2tzdW0oKSA6ICctJztcbiAgICBjb25zdCBmaWxsQ2hlY2tzdW0gPSB0aGlzLmZpbGxfID9cbiAgICAgIHRoaXMuZmlsbF8uZ2V0Q2hlY2tzdW0oKSA6ICctJztcblxuICAgIGNvbnN0IHJlY2FsY3VsYXRlID0gIXRoaXMuY2hlY2tzdW1zXyB8fFxuICAgICAgICAoc3Ryb2tlQ2hlY2tzdW0gIT0gdGhpcy5jaGVja3N1bXNfWzFdIHx8XG4gICAgICAgIGZpbGxDaGVja3N1bSAhPSB0aGlzLmNoZWNrc3Vtc19bMl0gfHxcbiAgICAgICAgdGhpcy5yYWRpdXNfICE9IHRoaXMuY2hlY2tzdW1zX1szXSB8fFxuICAgICAgICB0aGlzLnJhZGl1czJfICE9IHRoaXMuY2hlY2tzdW1zX1s0XSB8fFxuICAgICAgICB0aGlzLmFuZ2xlXyAhPSB0aGlzLmNoZWNrc3Vtc19bNV0gfHxcbiAgICAgICAgdGhpcy5wb2ludHNfICE9IHRoaXMuY2hlY2tzdW1zX1s2XSk7XG5cbiAgICBpZiAocmVjYWxjdWxhdGUpIHtcbiAgICAgIGNvbnN0IGNoZWNrc3VtID0gJ3InICsgc3Ryb2tlQ2hlY2tzdW0gKyBmaWxsQ2hlY2tzdW0gK1xuICAgICAgICAgICh0aGlzLnJhZGl1c18gIT09IHVuZGVmaW5lZCA/IHRoaXMucmFkaXVzXy50b1N0cmluZygpIDogJy0nKSArXG4gICAgICAgICAgKHRoaXMucmFkaXVzMl8gIT09IHVuZGVmaW5lZCA/IHRoaXMucmFkaXVzMl8udG9TdHJpbmcoKSA6ICctJykgK1xuICAgICAgICAgICh0aGlzLmFuZ2xlXyAhPT0gdW5kZWZpbmVkID8gdGhpcy5hbmdsZV8udG9TdHJpbmcoKSA6ICctJykgK1xuICAgICAgICAgICh0aGlzLnBvaW50c18gIT09IHVuZGVmaW5lZCA/IHRoaXMucG9pbnRzXy50b1N0cmluZygpIDogJy0nKTtcbiAgICAgIHRoaXMuY2hlY2tzdW1zXyA9IFtjaGVja3N1bSwgc3Ryb2tlQ2hlY2tzdW0sIGZpbGxDaGVja3N1bSxcbiAgICAgICAgdGhpcy5yYWRpdXNfLCB0aGlzLnJhZGl1czJfLCB0aGlzLmFuZ2xlXywgdGhpcy5wb2ludHNfXTtcbiAgICB9XG5cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0aGlzLmNoZWNrc3Vtc19bMF0pO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVndWxhclNoYXBlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0NpcmNsZVxuICovXG5cbmltcG9ydCBSZWd1bGFyU2hhcGUgZnJvbSAnLi9SZWd1bGFyU2hhcGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gW2ZpbGxdIEZpbGwgc3R5bGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmFkaXVzIENpcmNsZSByYWRpdXMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtzdHJva2VdIFN0cm9rZSBzdHlsZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9BdGxhc01hbmFnZXIuanNcIikuZGVmYXVsdH0gW2F0bGFzTWFuYWdlcl0gVGhlIGF0bGFzIG1hbmFnZXIgdG8gdXNlIGZvciB0aGlzIGNpcmNsZS5cbiAqIFdoZW4gdXNpbmcgV2ViR0wgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGFuIGF0bGFzIG1hbmFnZXIgdG8gYXZvaWQgdGV4dHVyZSBzd2l0Y2hpbmcuIElmIGFuIGF0bGFzIG1hbmFnZXIgaXMgZ2l2ZW4sXG4gKiB0aGUgY2lyY2xlIGlzIGFkZGVkIHRvIGFuIGF0bGFzLiBCeSBkZWZhdWx0IG5vIGF0bGFzIG1hbmFnZXIgaXMgdXNlZC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IGNpcmNsZSBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG5jbGFzcyBDaXJjbGVTdHlsZSBleHRlbmRzIFJlZ3VsYXJTaGFwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X29wdGlvbnMpIHtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCAvKiogQHR5cGUge09wdGlvbnN9ICovICh7fSk7XG5cbiAgICBzdXBlcih7XG4gICAgICBwb2ludHM6IEluZmluaXR5LFxuICAgICAgZmlsbDogb3B0aW9ucy5maWxsLFxuICAgICAgcmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcbiAgICAgIHN0cm9rZTogb3B0aW9ucy5zdHJva2UsXG4gICAgICBhdGxhc01hbmFnZXI6IG9wdGlvbnMuYXRsYXNNYW5hZ2VyXG4gICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAqIENsb25lcyB0aGUgc3R5bGUuICBJZiBhbiBhdGxhc21hbmFnZXIgd2FzIHByb3ZpZGVkIHRvIHRoZSBvcmlnaW5hbCBzdHlsZSBpdCB3aWxsIGJlIHVzZWQgaW4gdGhlIGNsb25lZCBzdHlsZSwgdG9vLlxuICAqIEByZXR1cm4ge0NpcmNsZVN0eWxlfSBUaGUgY2xvbmVkIHN0eWxlLlxuICAqIEBvdmVycmlkZVxuICAqIEBhcGlcbiAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBuZXcgQ2lyY2xlU3R5bGUoe1xuICAgICAgZmlsbDogdGhpcy5nZXRGaWxsKCkgPyB0aGlzLmdldEZpbGwoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgc3Ryb2tlOiB0aGlzLmdldFN0cm9rZSgpID8gdGhpcy5nZXRTdHJva2UoKS5jbG9uZSgpIDogdW5kZWZpbmVkLFxuICAgICAgcmFkaXVzOiB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgYXRsYXNNYW5hZ2VyOiB0aGlzLmF0bGFzTWFuYWdlcl9cbiAgICB9KTtcbiAgICBzdHlsZS5zZXRPcGFjaXR5KHRoaXMuZ2V0T3BhY2l0eSgpKTtcbiAgICBzdHlsZS5zZXRTY2FsZSh0aGlzLmdldFNjYWxlKCkpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgY2lyY2xlIHJhZGl1cy5cbiAgKlxuICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgQ2lyY2xlIHJhZGl1cy5cbiAgKiBAYXBpXG4gICovXG4gIHNldFJhZGl1cyhyYWRpdXMpIHtcbiAgICB0aGlzLnJhZGl1c18gPSByYWRpdXM7XG4gICAgdGhpcy5yZW5kZXJfKHRoaXMuYXRsYXNNYW5hZ2VyXyk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDaXJjbGVTdHlsZTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBDQTtBQUFBO0FBQUE7QUFJQTs7OztBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOzs7Ozs7QUFXQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUFBO0FBQUE7Ozs7OztBQU9BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUVBOzs7OztBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTs7Ozs7O0FBS0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBT0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFsaEJBO0FBQ0E7QUFvaEJBOztBQ3prQkE7OztBQUlBOzs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOzs7OztBQVFBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUNBO0FBQ0E7QUFnREEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///82\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/Collection.js\nvar Collection = __webpack_require__(49);\n\n// EXTERNAL MODULE: ./node_modules/ol/CollectionEventType.js\nvar CollectionEventType = __webpack_require__(27);\n\n// EXTERNAL MODULE: ./node_modules/ol/ObjectEventType.js\nvar ObjectEventType = __webpack_require__(54);\n\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(13);\n\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(11);\n\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/Event.js\nvar Event = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar EventType = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/functions.js\nvar functions = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/ol/format/FormatType.js\nvar FormatType = __webpack_require__(57);\n\n// CONCATENATED MODULE: ./node_modules/ol/featureloader.js\n/**\n * @module ol/featureloader\n */\n\n\n/**\n * {@link module:ol/source/Vector} sources use a function of this type to\n * load features.\n *\n * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,\n * a `{number}` representing the resolution (map units per pixel) and an\n * {@link module:ol/proj/Projection} for the projection  as\n * arguments. `this` within the function is bound to the\n * {@link module:ol/source/Vector} it\'s called from.\n *\n * The function is responsible for loading the features and adding them to the\n * source.\n * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default), import("./extent.js").Extent, number,\n *                    import("./proj/Projection.js").default)} FeatureLoader\n * @api\n */\n\n/**\n * {@link module:ol/source/Vector} sources use a function of this type to\n * get the url to load features from.\n *\n * This function takes an {@link module:ol/extent~Extent} representing the area\n * to be loaded, a `{number}` representing the resolution (map units per pixel)\n * and an {@link module:ol/proj/Projection} for the projection  as\n * arguments and returns a `{string}` representing the URL.\n * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction\n * @api\n */\n\n/**\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import("./format/Feature.js").default} format Feature format.\n * @param {function(this:import("./VectorTile.js").default, Array<import("./Feature.js").default>, import("./proj/Projection.js").default, import("./extent.js").Extent)|function(this:import("./source/Vector").default, Array<import("./Feature.js").default>)} success\n *     Function called with the loaded features and optionally with the data\n *     projection. Called with the vector tile or source as `this`.\n * @param {function(this:import("./VectorTile.js").default)|function(this:import("./source/Vector").default)} failure\n *     Function called when loading failed. Called with the vector tile or\n *     source as `this`.\n * @return {FeatureLoader} The feature loader.\n */\n\nfunction loadFeaturesXhr(url, format, success, failure) {\n  return (\n    /**\n     * @param {import("./extent.js").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @param {import("./proj/Projection.js").default} projection Projection.\n     * @this {import("./source/Vector").default|import("./VectorTile.js").default}\n     */\n    function (extent, resolution, projection) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\'GET\', typeof url === \'function\' ? url(extent, resolution, projection) : url, true);\n\n      if (format.getType() == FormatType["default"].ARRAY_BUFFER) {\n        xhr.responseType = \'arraybuffer\';\n      }\n      /**\n       * @param {Event} event Event.\n       * @private\n       */\n\n\n      xhr.onload = function (event) {\n        // status will be 0 for file:// urls\n        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {\n          var type = format.getType();\n          /** @type {Document|Node|Object|string|undefined} */\n\n          var source;\n\n          if (type == FormatType["default"].JSON || type == FormatType["default"].TEXT) {\n            source = xhr.responseText;\n          } else if (type == FormatType["default"].XML) {\n            source = xhr.responseXML;\n\n            if (!source) {\n              source = new DOMParser().parseFromString(xhr.responseText, \'application/xml\');\n            }\n          } else if (type == FormatType["default"].ARRAY_BUFFER) {\n            source =\n            /** @type {ArrayBuffer} */\n            xhr.response;\n          }\n\n          if (source) {\n            success.call(this, format.readFeatures(source, {\n              featureProjection: projection\n            }), format.readProjection(source), format.getLastExtent());\n          } else {\n            failure.call(this);\n          }\n        } else {\n          failure.call(this);\n        }\n      }.bind(this);\n      /**\n       * @private\n       */\n\n\n      xhr.onerror = function () {\n        failure.call(this);\n      }.bind(this);\n\n      xhr.send();\n    }\n  );\n}\n/**\n * Create an XHR feature loader for a `url` and `format`. The feature loader\n * loads features (with XHR), parses the features, and adds them to the\n * vector source.\n * @param {string|FeatureUrlFunction} url Feature URL service.\n * @param {import("./format/Feature.js").default} format Feature format.\n * @return {FeatureLoader} The feature loader.\n * @api\n */\n\nfunction featureloader_xhr(url, format) {\n  return loadFeaturesXhr(url, format,\n  /**\n   * @param {Array<import("./Feature.js").default>} features The loaded features.\n   * @param {import("./proj/Projection.js").default} dataProjection Data\n   * projection.\n   * @this {import("./source/Vector").default|import("./VectorTile.js").default}\n   */\n  function (features, dataProjection) {\n    var sourceOrTile =\n    /** @type {?} */\n    this;\n\n    if (typeof sourceOrTile.addFeatures === \'function\') {\n      /** @type {import("./source/Vector").default} */\n      sourceOrTile.addFeatures(features);\n    }\n  },\n  /* FIXME handle error */\n  functions["c" /* VOID */]);\n}\n// CONCATENATED MODULE: ./node_modules/ol/loadingstrategy.js\n/**\n * @module ol/loadingstrategy\n */\n\n/**\n * Strategy function for loading all features with a single request.\n * @param {import("./extent.js").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import("./extent.js").Extent>} Extents.\n * @api\n */\nfunction loadingstrategy_all(extent, resolution) {\n  return [[-Infinity, -Infinity, Infinity, Infinity]];\n}\n/**\n * Strategy function for loading features based on the view\'s extent and\n * resolution.\n * @param {import("./extent.js").Extent} extent Extent.\n * @param {number} resolution Resolution.\n * @return {Array<import("./extent.js").Extent>} Extents.\n * @api\n */\n\nfunction loadingstrategy_bbox(extent, resolution) {\n  return [extent];\n}\n/**\n * Creates a strategy function for loading features based on a tile grid.\n * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.\n * @return {function(import("./extent.js").Extent, number): Array<import("./extent.js").Extent>} Loading strategy.\n * @api\n */\n\nfunction tile(tileGrid) {\n  return (\n    /**\n     * @param {import("./extent.js").Extent} extent Extent.\n     * @param {number} resolution Resolution.\n     * @return {Array<import("./extent.js").Extent>} Extents.\n     */\n    function (extent, resolution) {\n      var z = tileGrid.getZForResolution(resolution);\n      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n      /** @type {Array<import("./extent.js").Extent>} */\n\n      var extents = [];\n      /** @type {import("./tilecoord.js").TileCoord} */\n\n      var tileCoord = [z, 0, 0];\n\n      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {\n        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {\n          extents.push(tileGrid.getTileCoordExtent(tileCoord));\n        }\n      }\n\n      return extents;\n    }\n  );\n}\n// EXTERNAL MODULE: ./node_modules/ol/obj.js\nvar ol_obj = __webpack_require__(12);\n\n// EXTERNAL MODULE: ./node_modules/ol/source/Source.js\nvar source_Source = __webpack_require__(94);\n\n// EXTERNAL MODULE: ./node_modules/ol/source/State.js\nvar State = __webpack_require__(45);\n\n// CONCATENATED MODULE: ./node_modules/ol/source/VectorEventType.js\n/**\n * @module ol/source/VectorEventType\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ var VectorEventType = ({\n  /**\n   * Triggered when a feature is added to the source.\n   * @event ol/source/Vector.VectorSourceEvent#addfeature\n   * @api\n   */\n  ADDFEATURE: \'addfeature\',\n\n  /**\n   * Triggered when a feature is updated.\n   * @event ol/source/Vector.VectorSourceEvent#changefeature\n   * @api\n   */\n  CHANGEFEATURE: \'changefeature\',\n\n  /**\n   * Triggered when the clear method is called on the source.\n   * @event ol/source/Vector.VectorSourceEvent#clear\n   * @api\n   */\n  CLEAR: \'clear\',\n\n  /**\n   * Triggered when a feature is removed from the source.\n   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.\n   * @event ol/source/Vector.VectorSourceEvent#removefeature\n   * @api\n   */\n  REMOVEFEATURE: \'removefeature\'\n});\n// EXTERNAL MODULE: ./node_modules/rbush/index.js\nvar rbush = __webpack_require__(74);\nvar rbush_default = /*#__PURE__*/__webpack_require__.n(rbush);\n\n// CONCATENATED MODULE: ./node_modules/ol/structs/RBush.js\n/**\n * @module ol/structs/RBush\n */\n\n\n\n\n/**\n * @typedef {Object} Entry\n * @property {number} minX\n * @property {number} minY\n * @property {number} maxX\n * @property {number} maxY\n * @property {Object} [value]\n */\n\n/**\n * @classdesc\n * Wrapper around the RBush by Vladimir Agafonkin.\n * See https://github.com/mourner/rbush.\n *\n * @template T\n */\n\nvar RBush_RBush = function RBush(opt_maxEntries) {\n  /**\n   * @private\n   */\n  this.rbush_ = rbush_default()(opt_maxEntries, undefined);\n  /**\n   * A mapping between the objects added to this rbush wrapper\n   * and the objects that are actually added to the internal rbush.\n   * @private\n   * @type {Object<string, Entry>}\n   */\n\n  this.items_ = {};\n};\n/**\n * Insert a value into the RBush.\n * @param {import("../extent.js").Extent} extent Extent.\n * @param {T} value Value.\n */\n\n\nRBush_RBush.prototype.insert = function insert(extent, value) {\n  /** @type {Entry} */\n  var item = {\n    minX: extent[0],\n    minY: extent[1],\n    maxX: extent[2],\n    maxY: extent[3],\n    value: value\n  };\n  this.rbush_.insert(item);\n  this.items_[Object(util["c" /* getUid */])(value)] = item;\n};\n/**\n * Bulk-insert values into the RBush.\n * @param {Array<import("../extent.js").Extent>} extents Extents.\n * @param {Array<T>} values Values.\n */\n\n\nRBush_RBush.prototype.load = function load(extents, values) {\n  var items = new Array(values.length);\n\n  for (var i = 0, l = values.length; i < l; i++) {\n    var extent = extents[i];\n    var value = values[i];\n    /** @type {Entry} */\n\n    var item = {\n      minX: extent[0],\n      minY: extent[1],\n      maxX: extent[2],\n      maxY: extent[3],\n      value: value\n    };\n    items[i] = item;\n    this.items_[Object(util["c" /* getUid */])(value)] = item;\n  }\n\n  this.rbush_.load(items);\n};\n/**\n * Remove a value from the RBush.\n * @param {T} value Value.\n * @return {boolean} Removed.\n */\n\n\nRBush_RBush.prototype.remove = function remove(value) {\n  var uid = Object(util["c" /* getUid */])(value); // get the object in which the value was wrapped when adding to the\n  // internal rbush. then use that object to do the removal.\n\n  var item = this.items_[uid];\n  delete this.items_[uid];\n  return this.rbush_.remove(item) !== null;\n};\n/**\n * Update the extent of a value in the RBush.\n * @param {import("../extent.js").Extent} extent Extent.\n * @param {T} value Value.\n */\n\n\nRBush_RBush.prototype.update = function update(extent, value) {\n  var item = this.items_[Object(util["c" /* getUid */])(value)];\n  var bbox = [item.minX, item.minY, item.maxX, item.maxY];\n\n  if (!Object(ol_extent["equals"])(bbox, extent)) {\n    this.remove(value);\n    this.insert(extent, value);\n  }\n};\n/**\n * Return all values in the RBush.\n * @return {Array<T>} All.\n */\n\n\nRBush_RBush.prototype.getAll = function getAll() {\n  var items = this.rbush_.all();\n  return items.map(function (item) {\n    return item.value;\n  });\n};\n/**\n * Return all values in the given extent.\n * @param {import("../extent.js").Extent} extent Extent.\n * @return {Array<T>} All in extent.\n */\n\n\nRBush_RBush.prototype.getInExtent = function getInExtent(extent) {\n  /** @type {Entry} */\n  var bbox = {\n    minX: extent[0],\n    minY: extent[1],\n    maxX: extent[2],\n    maxY: extent[3]\n  };\n  var items = this.rbush_.search(bbox);\n  return items.map(function (item) {\n    return item.value;\n  });\n};\n/**\n * Calls a callback function with each value in the tree.\n * If the callback returns a truthy value, this value is returned without\n * checking the rest of the tree.\n * @param {function(this: S, T): *} callback Callback.\n * @param {S=} opt_this The object to use as `this` in `callback`.\n * @return {*} Callback return value.\n * @template S\n */\n\n\nRBush_RBush.prototype.forEach = function forEach(callback, opt_this) {\n  return this.forEach_(this.getAll(), callback, opt_this);\n};\n/**\n * Calls a callback function with each value in the provided extent.\n * @param {import("../extent.js").Extent} extent Extent.\n * @param {function(this: S, T): *} callback Callback.\n * @param {S=} opt_this The object to use as `this` in `callback`.\n * @return {*} Callback return value.\n * @template S\n */\n\n\nRBush_RBush.prototype.forEachInExtent = function forEachInExtent(extent, callback, opt_this) {\n  return this.forEach_(this.getInExtent(extent), callback, opt_this);\n};\n/**\n * @param {Array<T>} values Values.\n * @param {function(this: S, T): *} callback Callback.\n * @param {S=} opt_this The object to use as `this` in `callback`.\n * @private\n * @return {*} Callback return value.\n * @template S\n */\n\n\nRBush_RBush.prototype.forEach_ = function forEach_(values, callback, opt_this) {\n  var result;\n\n  for (var i = 0, l = values.length; i < l; i++) {\n    result = callback.call(opt_this, values[i]);\n\n    if (result) {\n      return result;\n    }\n  }\n\n  return result;\n};\n/**\n * @return {boolean} Is empty.\n */\n\n\nRBush_RBush.prototype.isEmpty = function isEmpty$1() {\n  return Object(ol_obj["d" /* isEmpty */])(this.items_);\n};\n/**\n * Remove all values from the RBush.\n */\n\n\nRBush_RBush.prototype.clear = function clear() {\n  this.rbush_.clear();\n  this.items_ = {};\n};\n/**\n * @param {import("../extent.js").Extent=} opt_extent Extent.\n * @return {import("../extent.js").Extent} Extent.\n */\n\n\nRBush_RBush.prototype.getExtent = function getExtent(opt_extent) {\n  var data = this.rbush_.toJSON();\n  return Object(ol_extent["createOrUpdate"])(data.minX, data.minY, data.maxX, data.maxY, opt_extent);\n};\n/**\n * @param {RBush} rbush R-Tree.\n */\n\n\nRBush_RBush.prototype.concat = function concat(rbush) {\n  this.rbush_.load(rbush.rbush_.all());\n\n  for (var i in rbush.items_) {\n    this.items_[i] = rbush.items_[i];\n  }\n};\n\n/* harmony default export */ var structs_RBush = (RBush_RBush);\n// CONCATENATED MODULE: ./node_modules/ol/source/Vector.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorSourceEvent", function() { return VectorSourceEvent; });\n/**\n * @module ol/source/Vector\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and\n * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this\n * is one of the standard {@link module:ol/loadingstrategy} strategies.\n *\n * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy\n * @api\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Vector} instances are instances of this\n * type.\n */\n\nvar VectorSourceEvent =\n/*@__PURE__*/\nfunction (Event) {\n  function VectorSourceEvent(type, opt_feature) {\n    Event.call(this, type);\n    /**\n     * The feature being added or removed.\n     * @type {import("../Feature.js").default|undefined}\n     * @api\n     */\n\n    this.feature = opt_feature;\n  }\n\n  if (Event) VectorSourceEvent.__proto__ = Event;\n  VectorSourceEvent.prototype = Object.create(Event && Event.prototype);\n  VectorSourceEvent.prototype.constructor = VectorSourceEvent;\n  return VectorSourceEvent;\n}(Event["a" /* default */]);\n/**\n * @typedef {Object} Options\n * @property {import("./Source.js").AttributionLike} [attributions] Attributions.\n * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]\n * Features. If provided as {@link module:ol/Collection}, the features in the source\n * and the collection will stay in sync.\n * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR\n * feature loader when `url` is set. Required if `url` is set, otherwise ignored.\n * @property {import("../featureloader.js").FeatureLoader} [loader]\n * The loader function used to load features, from a remote source for example.\n * If this is not set and `url` is set, the source will create and use an XHR\n * feature loader.\n *\n * Example:\n *\n * ```js\n * import {Vector} from \'ol/source\';\n * import {GeoJSON} from \'ol/format\';\n * import {bbox} from \'ol/loadingstrategy\';\n *\n * var vectorSource = new Vector({\n *   format: new GeoJSON(),\n *   loader: function(extent, resolution, projection) {\n *      var proj = projection.getCode();\n *      var url = \'https://ahocevar.com/geoserver/wfs?service=WFS&\' +\n *          \'version=1.1.0&request=GetFeature&typename=osm:water_areas&\' +\n *          \'outputFormat=application/json&srsname=\' + proj + \'&\' +\n *          \'bbox=\' + extent.join(\',\') + \',\' + proj;\n *      var xhr = new XMLHttpRequest();\n *      xhr.open(\'GET\', url);\n *      var onError = function() {\n *        vectorSource.removeLoadedExtent(extent);\n *      }\n *      xhr.onerror = onError;\n *      xhr.onload = function() {\n *        if (xhr.status == 200) {\n *          vectorSource.addFeatures(\n *              vectorSource.getFormat().readFeatures(xhr.responseText));\n *        } else {\n *          onError();\n *        }\n *      }\n *      xhr.send();\n *    },\n *    strategy: bbox\n *  });\n * ```\n * @property {boolean} [overlaps=true] This source may have overlapping geometries.\n * Setting this to `false` (e.g. for sources with polygons that represent administrative\n * boundaries or TopoJSON sources) allows the renderer to optimise fill and\n * stroke operations.\n * @property {LoadingStrategy} [strategy] The loading strategy to use.\n * By default an {@link module:ol/loadingstrategy~all}\n * strategy is used, a one-off strategy which loads all features at once.\n * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]\n * Setting this option instructs the source to load features using an XHR loader\n * (see {@link module:ol/featureloader~xhr}). Use a `string` and an\n * {@link module:ol/loadingstrategy~all} for a one-off download of all features from\n * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with\n * other loading strategies.\n * Requires `format` to be set as well.\n * When default XHR feature loader is provided, the features will\n * be transformed from the data projection to the view projection\n * during parsing. If your remote data source does not advertise its projection\n * properly, this transformation will be incorrect. For some formats, the\n * default projection (usually EPSG:4326) can be overridden by setting the\n * dataProjection constructor option on the format.\n * Note that if a source contains non-feature data, such as a GeoJSON geometry\n * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.\n * @property {boolean} [useSpatialIndex=true]\n * By default, an RTree is used as spatial index. When features are removed and\n * added frequently, and the total number of features is low, setting this to\n * `false` may improve performance.\n *\n * Note that\n * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},\n * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and\n * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is\n * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop\n * through all features.\n *\n * When set to `false`, the features will be maintained in an\n * {@link module:ol/Collection}, which can be retrieved through\n * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.\n * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the\n * -180 and 180 meridians to work properly, this should be set to `false`. The\n * resulting geometry coordinates will then exceed the world bounds.\n */\n\n/**\n * @classdesc\n * Provides a source of features for vector layers. Vector features provided\n * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for\n * vector data that is optimized for rendering.\n *\n * @fires ol/source/Vector.VectorSourceEvent\n * @api\n */\n\nvar Vector_VectorSource =\n/*@__PURE__*/\nfunction (Source) {\n  function VectorSource(opt_options) {\n    var options = opt_options || {};\n    Source.call(this, {\n      attributions: options.attributions,\n      projection: undefined,\n      state: State["a" /* default */].READY,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true\n    });\n    /**\n     * @private\n     * @type {import("../featureloader.js").FeatureLoader}\n     */\n\n    this.loader_ = functions["c" /* VOID */];\n    /**\n     * @private\n     * @type {import("../format/Feature.js").default|undefined}\n     */\n\n    this.format_ = options.format;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;\n    /**\n     * @private\n     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}\n     */\n\n    this.url_ = options.url;\n\n    if (options.loader !== undefined) {\n      this.loader_ = options.loader;\n    } else if (this.url_ !== undefined) {\n      Object(asserts["a" /* assert */])(this.format_, 7); // `format` must be set when `url` is set\n      // create a XHR feature loader for "url" and "format"\n\n      this.loader_ = featureloader_xhr(this.url_,\n      /** @type {import("../format/Feature.js").default} */\n      this.format_);\n    }\n    /**\n     * @private\n     * @type {LoadingStrategy}\n     */\n\n\n    this.strategy_ = options.strategy !== undefined ? options.strategy : loadingstrategy_all;\n    var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;\n    /**\n     * @private\n     * @type {RBush<import("../Feature.js").default>}\n     */\n\n    this.featuresRtree_ = useSpatialIndex ? new structs_RBush() : null;\n    /**\n     * @private\n     * @type {RBush<{extent: import("../extent.js").Extent}>}\n     */\n\n    this.loadedExtentsRtree_ = new structs_RBush();\n    /**\n     * @private\n     * @type {!Object<string, import("../Feature.js").default>}\n     */\n\n    this.nullGeometryFeatures_ = {};\n    /**\n     * A lookup of features by id (the return from feature.getId()).\n     * @private\n     * @type {!Object<string, import("../Feature.js").default>}\n     */\n\n    this.idIndex_ = {};\n    /**\n     * A lookup of features without id (keyed by getUid(feature)).\n     * @private\n     * @type {!Object<string, import("../Feature.js").default>}\n     */\n\n    this.undefIdIndex_ = {};\n    /**\n     * @private\n     * @type {Object<string, Array<import("../events.js").EventsKey>>}\n     */\n\n    this.featureChangeKeys_ = {};\n    /**\n     * @private\n     * @type {Collection<import("../Feature.js").default>}\n     */\n\n    this.featuresCollection_ = null;\n    var collection, features;\n\n    if (Array.isArray(options.features)) {\n      features = options.features;\n    } else if (options.features) {\n      collection = options.features;\n      features = collection.getArray();\n    }\n\n    if (!useSpatialIndex && collection === undefined) {\n      collection = new Collection["a" /* default */](features);\n    }\n\n    if (features !== undefined) {\n      this.addFeaturesInternal(features);\n    }\n\n    if (collection !== undefined) {\n      this.bindFeaturesCollection_(collection);\n    }\n  }\n\n  if (Source) VectorSource.__proto__ = Source;\n  VectorSource.prototype = Object.create(Source && Source.prototype);\n  VectorSource.prototype.constructor = VectorSource;\n  /**\n   * Add a single feature to the source.  If you want to add a batch of features\n   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}\n   * instead. A feature will not be added to the source if feature with\n   * the same id is already there. The reason for this behavior is to avoid\n   * feature duplication when using bbox or tile loading strategies.\n   * @param {import("../Feature.js").default} feature Feature to add.\n   * @api\n   */\n\n  VectorSource.prototype.addFeature = function addFeature(feature) {\n    this.addFeatureInternal(feature);\n    this.changed();\n  };\n  /**\n   * Add a feature without firing a `change` event.\n   * @param {import("../Feature.js").default} feature Feature.\n   * @protected\n   */\n\n\n  VectorSource.prototype.addFeatureInternal = function addFeatureInternal(feature) {\n    var featureKey = Object(util["c" /* getUid */])(feature);\n\n    if (!this.addToIndex_(featureKey, feature)) {\n      return;\n    }\n\n    this.setupChangeEvents_(featureKey, feature);\n    var geometry = feature.getGeometry();\n\n    if (geometry) {\n      var extent = geometry.getExtent();\n\n      if (this.featuresRtree_) {\n        this.featuresRtree_.insert(extent, feature);\n      }\n    } else {\n      this.nullGeometryFeatures_[featureKey] = feature;\n    }\n\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));\n  };\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {import("../Feature.js").default} feature The feature.\n   * @private\n   */\n\n\n  VectorSource.prototype.setupChangeEvents_ = function setupChangeEvents_(featureKey, feature) {\n    this.featureChangeKeys_[featureKey] = [Object(events["a" /* listen */])(feature, EventType["a" /* default */].CHANGE, this.handleFeatureChange_, this), Object(events["a" /* listen */])(feature, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.handleFeatureChange_, this)];\n  };\n  /**\n   * @param {string} featureKey Unique identifier for the feature.\n   * @param {import("../Feature.js").default} feature The feature.\n   * @return {boolean} The feature is "valid", in the sense that it is also a\n   *     candidate for insertion into the Rtree.\n   * @private\n   */\n\n\n  VectorSource.prototype.addToIndex_ = function addToIndex_(featureKey, feature) {\n    var valid = true;\n    var id = feature.getId();\n\n    if (id !== undefined) {\n      if (!(id.toString() in this.idIndex_)) {\n        this.idIndex_[id.toString()] = feature;\n      } else {\n        valid = false;\n      }\n    } else {\n      Object(asserts["a" /* assert */])(!(featureKey in this.undefIdIndex_), 30); // The passed `feature` was already added to the source\n\n      this.undefIdIndex_[featureKey] = feature;\n    }\n\n    return valid;\n  };\n  /**\n   * Add a batch of features to the source.\n   * @param {Array<import("../Feature.js").default>} features Features to add.\n   * @api\n   */\n\n\n  VectorSource.prototype.addFeatures = function addFeatures(features) {\n    this.addFeaturesInternal(features);\n    this.changed();\n  };\n  /**\n   * Add features without firing a `change` event.\n   * @param {Array<import("../Feature.js").default>} features Features.\n   * @protected\n   */\n\n\n  VectorSource.prototype.addFeaturesInternal = function addFeaturesInternal(features) {\n    var extents = [];\n    var newFeatures = [];\n    var geometryFeatures = [];\n\n    for (var i = 0, length = features.length; i < length; i++) {\n      var feature = features[i];\n      var featureKey = Object(util["c" /* getUid */])(feature);\n\n      if (this.addToIndex_(featureKey, feature)) {\n        newFeatures.push(feature);\n      }\n    }\n\n    for (var i$1 = 0, length$1 = newFeatures.length; i$1 < length$1; i$1++) {\n      var feature$1 = newFeatures[i$1];\n      var featureKey$1 = Object(util["c" /* getUid */])(feature$1);\n      this.setupChangeEvents_(featureKey$1, feature$1);\n      var geometry = feature$1.getGeometry();\n\n      if (geometry) {\n        var extent = geometry.getExtent();\n        extents.push(extent);\n        geometryFeatures.push(feature$1);\n      } else {\n        this.nullGeometryFeatures_[featureKey$1] = feature$1;\n      }\n    }\n\n    if (this.featuresRtree_) {\n      this.featuresRtree_.load(extents, geometryFeatures);\n    }\n\n    for (var i$2 = 0, length$2 = newFeatures.length; i$2 < length$2; i$2++) {\n      this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i$2]));\n    }\n  };\n  /**\n   * @param {!Collection<import("../Feature.js").default>} collection Collection.\n   * @private\n   */\n\n\n  VectorSource.prototype.bindFeaturesCollection_ = function bindFeaturesCollection_(collection) {\n    var modifyingCollection = false;\n    Object(events["a" /* listen */])(this, VectorEventType.ADDFEATURE,\n    /**\n     * @param {VectorSourceEvent} evt The vector source event\n     */\n    function (evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        collection.push(evt.feature);\n        modifyingCollection = false;\n      }\n    });\n    Object(events["a" /* listen */])(this, VectorEventType.REMOVEFEATURE,\n    /**\n     * @param {VectorSourceEvent} evt The vector source event\n     */\n    function (evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        collection.remove(evt.feature);\n        modifyingCollection = false;\n      }\n    });\n    Object(events["a" /* listen */])(collection, CollectionEventType["a" /* default */].ADD,\n    /**\n     * @param {import("../Collection.js").CollectionEvent} evt The collection event\n     */\n    function (evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        this.addFeature(\n        /** @type {import("../Feature.js").default} */\n        evt.element);\n        modifyingCollection = false;\n      }\n    }, this);\n    Object(events["a" /* listen */])(collection, CollectionEventType["a" /* default */].REMOVE,\n    /**\n     * @param {import("../Collection.js").CollectionEvent} evt The collection event\n     */\n    function (evt) {\n      if (!modifyingCollection) {\n        modifyingCollection = true;\n        this.removeFeature(\n        /** @type {import("../Feature.js").default} */\n        evt.element);\n        modifyingCollection = false;\n      }\n    }, this);\n    this.featuresCollection_ = collection;\n  };\n  /**\n   * Remove all features from the source.\n   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.\n   * @api\n   */\n\n\n  VectorSource.prototype.clear = function clear(opt_fast) {\n    if (opt_fast) {\n      for (var featureId in this.featureChangeKeys_) {\n        var keys = this.featureChangeKeys_[featureId];\n        keys.forEach(events["e" /* unlistenByKey */]);\n      }\n\n      if (!this.featuresCollection_) {\n        this.featureChangeKeys_ = {};\n        this.idIndex_ = {};\n        this.undefIdIndex_ = {};\n      }\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.forEach(this.removeFeatureInternal, this);\n\n        for (var id in this.nullGeometryFeatures_) {\n          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);\n        }\n      }\n    }\n\n    if (this.featuresCollection_) {\n      this.featuresCollection_.clear();\n    }\n\n    if (this.featuresRtree_) {\n      this.featuresRtree_.clear();\n    }\n\n    this.loadedExtentsRtree_.clear();\n    this.nullGeometryFeatures_ = {};\n    var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);\n    this.dispatchEvent(clearEvent);\n    this.changed();\n  };\n  /**\n   * Iterate through all features on the source, calling the provided callback\n   * with each one.  If the callback returns any "truthy" value, iteration will\n   * stop and the function will return the same value.\n   * Note: this function only iterate through the feature that have a defined geometry.\n   *\n   * @param {function(import("../Feature.js").default): T} callback Called with each feature\n   *     on the source.  Return a truthy value to stop iteration.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n\n\n  VectorSource.prototype.forEachFeature = function forEachFeature(callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEach(callback);\n    } else if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  };\n  /**\n   * Iterate through all features whose geometries contain the provided\n   * coordinate, calling the callback with each feature.  If the callback returns\n   * a "truthy" value, iteration will stop and the function will return the same\n   * value.\n   *\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {function(import("../Feature.js").default): T} callback Called with each feature\n   *     whose goemetry contains the provided coordinate.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   */\n\n\n  VectorSource.prototype.forEachFeatureAtCoordinateDirect = function forEachFeatureAtCoordinateDirect(coordinate, callback) {\n    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];\n    return this.forEachFeatureInExtent(extent, function (feature) {\n      var geometry = feature.getGeometry();\n\n      if (geometry.intersectsCoordinate(coordinate)) {\n        return callback(feature);\n      } else {\n        return undefined;\n      }\n    });\n  };\n  /**\n   * Iterate through all features whose bounding box intersects the provided\n   * extent (note that the feature\'s geometry may not intersect the extent),\n   * calling the callback with each feature.  If the callback returns a "truthy"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you are interested in features whose geometry intersects an extent, call\n   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.\n   *\n   * When `useSpatialIndex` is set to false, this method will loop through all\n   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.\n   *\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {function(import("../Feature.js").default): T} callback Called with each feature\n   *     whose bounding box intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n\n\n  VectorSource.prototype.forEachFeatureInExtent = function forEachFeatureInExtent(extent, callback) {\n    if (this.featuresRtree_) {\n      return this.featuresRtree_.forEachInExtent(extent, callback);\n    } else if (this.featuresCollection_) {\n      this.featuresCollection_.forEach(callback);\n    }\n  };\n  /**\n   * Iterate through all features whose geometry intersects the provided extent,\n   * calling the callback with each feature.  If the callback returns a "truthy"\n   * value, iteration will stop and the function will return the same value.\n   *\n   * If you only want to test for bounding box intersection, call the\n   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.\n   *\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {function(import("../Feature.js").default): T} callback Called with each feature\n   *     whose geometry intersects the provided extent.\n   * @return {T|undefined} The return value from the last call to the callback.\n   * @template T\n   * @api\n   */\n\n\n  VectorSource.prototype.forEachFeatureIntersectingExtent = function forEachFeatureIntersectingExtent(extent, callback) {\n    return this.forEachFeatureInExtent(extent,\n    /**\n     * @param {import("../Feature.js").default} feature Feature.\n     * @return {T|undefined} The return value from the last call to the callback.\n     */\n    function (feature) {\n      var geometry = feature.getGeometry();\n\n      if (geometry.intersectsExtent(extent)) {\n        var result = callback(feature);\n\n        if (result) {\n          return result;\n        }\n      }\n    });\n  };\n  /**\n   * Get the features collection associated with this source. Will be `null`\n   * unless the source was configured with `useSpatialIndex` set to `false`, or\n   * with an {@link module:ol/Collection} as `features`.\n   * @return {Collection<import("../Feature.js").default>} The collection of features.\n   * @api\n   */\n\n\n  VectorSource.prototype.getFeaturesCollection = function getFeaturesCollection() {\n    return this.featuresCollection_;\n  };\n  /**\n   * Get all features on the source in random order.\n   * @return {Array<import("../Feature.js").default>} Features.\n   * @api\n   */\n\n\n  VectorSource.prototype.getFeatures = function getFeatures() {\n    var features;\n\n    if (this.featuresCollection_) {\n      features = this.featuresCollection_.getArray();\n    } else if (this.featuresRtree_) {\n      features = this.featuresRtree_.getAll();\n\n      if (!Object(ol_obj["d" /* isEmpty */])(this.nullGeometryFeatures_)) {\n        Object(array["c" /* extend */])(features, Object(ol_obj["c" /* getValues */])(this.nullGeometryFeatures_));\n      }\n    }\n\n    return (\n      /** @type {Array<import("../Feature.js").default>} */\n      features\n    );\n  };\n  /**\n   * Get all features whose geometry intersects the provided coordinate.\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @return {Array<import("../Feature.js").default>} Features.\n   * @api\n   */\n\n\n  VectorSource.prototype.getFeaturesAtCoordinate = function getFeaturesAtCoordinate(coordinate) {\n    var features = [];\n    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {\n      features.push(feature);\n    });\n    return features;\n  };\n  /**\n   * Get all features in the provided extent.  Note that this returns an array of\n   * all features intersecting the given extent in random order (so it may include\n   * features whose geometries do not intersect the extent).\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @return {Array<import("../Feature.js").default>} Features.\n   * @api\n   */\n\n\n  VectorSource.prototype.getFeaturesInExtent = function getFeaturesInExtent(extent) {\n    return this.featuresRtree_.getInExtent(extent);\n  };\n  /**\n   * Get the closest feature to the provided coordinate.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {function(import("../Feature.js").default):boolean=} opt_filter Feature filter function.\n   *     The filter function will receive one argument, the {@link module:ol/Feature feature}\n   *     and it should return a boolean value. By default, no filtering is made.\n   * @return {import("../Feature.js").default} Closest feature.\n   * @api\n   */\n\n\n  VectorSource.prototype.getClosestFeatureToCoordinate = function getClosestFeatureToCoordinate(coordinate, opt_filter) {\n    // Find the closest feature using branch and bound.  We start searching an\n    // infinite extent, and find the distance from the first feature found.  This\n    // becomes the closest feature.  We then compute a smaller extent which any\n    // closer feature must intersect.  We continue searching with this smaller\n    // extent, trying to find a closer feature.  Every time we find a closer\n    // feature, we update the extent being searched so that any even closer\n    // feature must intersect it.  We continue until we run out of features.\n    var x = coordinate[0];\n    var y = coordinate[1];\n    var closestFeature = null;\n    var closestPoint = [NaN, NaN];\n    var minSquaredDistance = Infinity;\n    var extent = [-Infinity, -Infinity, Infinity, Infinity];\n    var filter = opt_filter ? opt_filter : functions["b" /* TRUE */];\n    this.featuresRtree_.forEachInExtent(extent,\n    /**\n     * @param {import("../Feature.js").default} feature Feature.\n     */\n    function (feature) {\n      if (filter(feature)) {\n        var geometry = feature.getGeometry();\n        var previousMinSquaredDistance = minSquaredDistance;\n        minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);\n\n        if (minSquaredDistance < previousMinSquaredDistance) {\n          closestFeature = feature; // This is sneaky.  Reduce the extent that it is currently being\n          // searched while the R-Tree traversal using this same extent object\n          // is still in progress.  This is safe because the new extent is\n          // strictly contained by the old extent.\n\n          var minDistance = Math.sqrt(minSquaredDistance);\n          extent[0] = x - minDistance;\n          extent[1] = y - minDistance;\n          extent[2] = x + minDistance;\n          extent[3] = y + minDistance;\n        }\n      }\n    });\n    return closestFeature;\n  };\n  /**\n   * Get the extent of the features currently in the source.\n   *\n   * This method is not available when the source is configured with\n   * `useSpatialIndex` set to `false`.\n   * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent\n   *     will be created. Instead, that extent\'s coordinates will be overwritten.\n   * @return {import("../extent.js").Extent} Extent.\n   * @api\n   */\n\n\n  VectorSource.prototype.getExtent = function getExtent(opt_extent) {\n    return this.featuresRtree_.getExtent(opt_extent);\n  };\n  /**\n   * Get a feature by its identifier (the value returned by feature.getId()).\n   * Note that the index treats string and numeric identifiers as the same.  So\n   * `source.getFeatureById(2)` will return a feature with id `\'2\'` or `2`.\n   *\n   * @param {string|number} id Feature identifier.\n   * @return {import("../Feature.js").default} The feature (or `null` if not found).\n   * @api\n   */\n\n\n  VectorSource.prototype.getFeatureById = function getFeatureById(id) {\n    var feature = this.idIndex_[id.toString()];\n    return feature !== undefined ? feature : null;\n  };\n  /**\n   * Get the format associated with this source.\n   *\n   * @return {import("../format/Feature.js").default|undefined} The feature format.\n   * @api\n   */\n\n\n  VectorSource.prototype.getFormat = function getFormat() {\n    return this.format_;\n  };\n  /**\n   * @return {boolean} The source can have overlapping geometries.\n   */\n\n\n  VectorSource.prototype.getOverlaps = function getOverlaps() {\n    return this.overlaps_;\n  };\n  /**\n   * Get the url associated with this source.\n   *\n   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.\n   * @api\n   */\n\n\n  VectorSource.prototype.getUrl = function getUrl() {\n    return this.url_;\n  };\n  /**\n   * @param {Event} event Event.\n   * @private\n   */\n\n\n  VectorSource.prototype.handleFeatureChange_ = function handleFeatureChange_(event) {\n    var feature =\n    /** @type {import("../Feature.js").default} */\n    event.target;\n    var featureKey = Object(util["c" /* getUid */])(feature);\n    var geometry = feature.getGeometry();\n\n    if (!geometry) {\n      if (!(featureKey in this.nullGeometryFeatures_)) {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.remove(feature);\n        }\n\n        this.nullGeometryFeatures_[featureKey] = feature;\n      }\n    } else {\n      var extent = geometry.getExtent();\n\n      if (featureKey in this.nullGeometryFeatures_) {\n        delete this.nullGeometryFeatures_[featureKey];\n\n        if (this.featuresRtree_) {\n          this.featuresRtree_.insert(extent, feature);\n        }\n      } else {\n        if (this.featuresRtree_) {\n          this.featuresRtree_.update(extent, feature);\n        }\n      }\n    }\n\n    var id = feature.getId();\n\n    if (id !== undefined) {\n      var sid = id.toString();\n\n      if (featureKey in this.undefIdIndex_) {\n        delete this.undefIdIndex_[featureKey];\n        this.idIndex_[sid] = feature;\n      } else {\n        if (this.idIndex_[sid] !== feature) {\n          this.removeFromIdIndex_(feature);\n          this.idIndex_[sid] = feature;\n        }\n      }\n    } else {\n      if (!(featureKey in this.undefIdIndex_)) {\n        this.removeFromIdIndex_(feature);\n        this.undefIdIndex_[featureKey] = feature;\n      }\n    }\n\n    this.changed();\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));\n  };\n  /**\n   * Returns true if the feature is contained within the source.\n   * @param {import("../Feature.js").default} feature Feature.\n   * @return {boolean} Has feature.\n   * @api\n   */\n\n\n  VectorSource.prototype.hasFeature = function hasFeature(feature) {\n    var id = feature.getId();\n\n    if (id !== undefined) {\n      return id in this.idIndex_;\n    } else {\n      return Object(util["c" /* getUid */])(feature) in this.undefIdIndex_;\n    }\n  };\n  /**\n   * @return {boolean} Is empty.\n   */\n\n\n  VectorSource.prototype.isEmpty = function isEmpty$1() {\n    return this.featuresRtree_.isEmpty() && Object(ol_obj["d" /* isEmpty */])(this.nullGeometryFeatures_);\n  };\n  /**\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   */\n\n\n  VectorSource.prototype.loadFeatures = function loadFeatures(extent, resolution, projection) {\n    var this$1 = this;\n    var loadedExtentsRtree = this.loadedExtentsRtree_;\n    var extentsToLoad = this.strategy_(extent, resolution);\n    this.loading = false;\n\n    var loop = function loop(i, ii) {\n      var extentToLoad = extentsToLoad[i];\n      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,\n      /**\n       * @param {{extent: import("../extent.js").Extent}} object Object.\n       * @return {boolean} Contains.\n       */\n      function (object) {\n        return Object(ol_extent["containsExtent"])(object.extent, extentToLoad);\n      });\n\n      if (!alreadyLoaded) {\n        this$1.loader_.call(this$1, extentToLoad, resolution, projection);\n        loadedExtentsRtree.insert(extentToLoad, {\n          extent: extentToLoad.slice()\n        });\n        this$1.loading = this$1.loader_ !== functions["c" /* VOID */];\n      }\n    };\n\n    for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {\n      loop(i, ii);\n    }\n  };\n  /**\n   * Remove an extent from the list of loaded extents.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @api\n   */\n\n\n  VectorSource.prototype.removeLoadedExtent = function removeLoadedExtent(extent) {\n    var loadedExtentsRtree = this.loadedExtentsRtree_;\n    var obj;\n    loadedExtentsRtree.forEachInExtent(extent, function (object) {\n      if (Object(ol_extent["equals"])(object.extent, extent)) {\n        obj = object;\n        return true;\n      }\n    });\n\n    if (obj) {\n      loadedExtentsRtree.remove(obj);\n    }\n  };\n  /**\n   * Remove a single feature from the source.  If you want to remove all features\n   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method\n   * instead.\n   * @param {import("../Feature.js").default} feature Feature to remove.\n   * @api\n   */\n\n\n  VectorSource.prototype.removeFeature = function removeFeature(feature) {\n    var featureKey = Object(util["c" /* getUid */])(feature);\n\n    if (featureKey in this.nullGeometryFeatures_) {\n      delete this.nullGeometryFeatures_[featureKey];\n    } else {\n      if (this.featuresRtree_) {\n        this.featuresRtree_.remove(feature);\n      }\n    }\n\n    this.removeFeatureInternal(feature);\n    this.changed();\n  };\n  /**\n   * Remove feature without firing a `change` event.\n   * @param {import("../Feature.js").default} feature Feature.\n   * @protected\n   */\n\n\n  VectorSource.prototype.removeFeatureInternal = function removeFeatureInternal(feature) {\n    var featureKey = Object(util["c" /* getUid */])(feature);\n    this.featureChangeKeys_[featureKey].forEach(events["e" /* unlistenByKey */]);\n    delete this.featureChangeKeys_[featureKey];\n    var id = feature.getId();\n\n    if (id !== undefined) {\n      delete this.idIndex_[id.toString()];\n    } else {\n      delete this.undefIdIndex_[featureKey];\n    }\n\n    this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));\n  };\n  /**\n   * Remove a feature from the id index.  Called internally when the feature id\n   * may have changed.\n   * @param {import("../Feature.js").default} feature The feature.\n   * @return {boolean} Removed the feature from the index.\n   * @private\n   */\n\n\n  VectorSource.prototype.removeFromIdIndex_ = function removeFromIdIndex_(feature) {\n    var removed = false;\n\n    for (var id in this.idIndex_) {\n      if (this.idIndex_[id] === feature) {\n        delete this.idIndex_[id];\n        removed = true;\n        break;\n      }\n    }\n\n    return removed;\n  };\n  /**\n   * Set the new loader of the source. The next loadFeatures call will use the\n   * new loader.\n   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.\n   * @api\n   */\n\n\n  VectorSource.prototype.setLoader = function setLoader(loader) {\n    this.loader_ = loader;\n  };\n\n  return VectorSource;\n}(source_Source["a" /* default */]);\n\n/* harmony default export */ var Vector = __webpack_exports__["default"] = (Vector_VectorSource);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2ZlYXR1cmVsb2FkZXIuanM/M2U3MiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL2xvYWRpbmdzdHJhdGVneS5qcz8xMmRmIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc291cmNlL1ZlY3RvckV2ZW50VHlwZS5qcz8wZGIzIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc3RydWN0cy9SQnVzaC5qcz8wMzU1Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc291cmNlL1ZlY3Rvci5qcz9iYmViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9mZWF0dXJlbG9hZGVyXG4gKi9cbmltcG9ydCB7Vk9JRH0gZnJvbSAnLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IEZvcm1hdFR5cGUgZnJvbSAnLi9mb3JtYXQvRm9ybWF0VHlwZS5qcyc7XG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0b1xuICogbG9hZCBmZWF0dXJlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudH0gcmVwcmVzZW50aW5nIHRoZSBhcmVhIHRvIGJlIGxvYWRlZCxcbiAqIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHJlc29sdXRpb24gKG1hcCB1bml0cyBwZXIgcGl4ZWwpIGFuZCBhblxuICoge0BsaW5rIG1vZHVsZTpvbC9wcm9qL1Byb2plY3Rpb259IGZvciB0aGUgcHJvamVjdGlvbiAgYXNcbiAqIGFyZ3VtZW50cy4gYHRoaXNgIHdpdGhpbiB0aGUgZnVuY3Rpb24gaXMgYm91bmQgdG8gdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IGl0J3MgY2FsbGVkIGZyb20uXG4gKlxuICogVGhlIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nIHRoZSBmZWF0dXJlcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlXG4gKiBzb3VyY2UuXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24odGhpczooaW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHQpLCBpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQsIG51bWJlcixcbiAqICAgICAgICAgICAgICAgICAgICBpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0KX0gRmVhdHVyZUxvYWRlclxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IHNvdXJjZXMgdXNlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIHRvXG4gKiBnZXQgdGhlIHVybCB0byBsb2FkIGZlYXR1cmVzIGZyb20uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IHJlcHJlc2VudGluZyB0aGUgYXJlYVxuICogdG8gYmUgbG9hZGVkLCBhIGB7bnVtYmVyfWAgcmVwcmVzZW50aW5nIHRoZSByZXNvbHV0aW9uIChtYXAgdW5pdHMgcGVyIHBpeGVsKVxuICogYW5kIGFuIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9ufSBmb3IgdGhlIHByb2plY3Rpb24gIGFzXG4gKiBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBge3N0cmluZ31gIHJlcHJlc2VudGluZyB0aGUgVVJMLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyLCBpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0KTogc3RyaW5nfSBGZWF0dXJlVXJsRnVuY3Rpb25cbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8RmVhdHVyZVVybEZ1bmN0aW9ufSB1cmwgRmVhdHVyZSBVUkwgc2VydmljZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmb3JtYXQgRmVhdHVyZSBmb3JtYXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHQsIEFycmF5PGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0PiwgaW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdCwgaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50KXxmdW5jdGlvbih0aGlzOmltcG9ydChcIi4vc291cmNlL1ZlY3RvclwiKS5kZWZhdWx0LCBBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD4pfSBzdWNjZXNzXG4gKiAgICAgRnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIGxvYWRlZCBmZWF0dXJlcyBhbmQgb3B0aW9uYWxseSB3aXRoIHRoZSBkYXRhXG4gKiAgICAgcHJvamVjdGlvbi4gQ2FsbGVkIHdpdGggdGhlIHZlY3RvciB0aWxlIG9yIHNvdXJjZSBhcyBgdGhpc2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHQpfGZ1bmN0aW9uKHRoaXM6aW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHQpfSBmYWlsdXJlXG4gKiAgICAgRnVuY3Rpb24gY2FsbGVkIHdoZW4gbG9hZGluZyBmYWlsZWQuIENhbGxlZCB3aXRoIHRoZSB2ZWN0b3IgdGlsZSBvclxuICogICAgIHNvdXJjZSBhcyBgdGhpc2AuXG4gKiBAcmV0dXJuIHtGZWF0dXJlTG9hZGVyfSBUaGUgZmVhdHVyZSBsb2FkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRmVhdHVyZXNYaHIodXJsLCBmb3JtYXQsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgICAqIEB0aGlzIHtpbXBvcnQoXCIuL3NvdXJjZS9WZWN0b3JcIikuZGVmYXVsdHxpbXBvcnQoXCIuL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pIHtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsXG4gICAgICAgIHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicgPyB1cmwoZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSA6IHVybCxcbiAgICAgICAgdHJ1ZSk7XG4gICAgICBpZiAoZm9ybWF0LmdldFR5cGUoKSA9PSBGb3JtYXRUeXBlLkFSUkFZX0JVRkZFUikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgLy8gc3RhdHVzIHdpbGwgYmUgMCBmb3IgZmlsZTovLyB1cmxzXG4gICAgICAgIGlmICgheGhyLnN0YXR1cyB8fCB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGZvcm1hdC5nZXRUeXBlKCk7XG4gICAgICAgICAgLyoqIEB0eXBlIHtEb2N1bWVudHxOb2RlfE9iamVjdHxzdHJpbmd8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gRm9ybWF0VHlwZS5KU09OIHx8IHR5cGUgPT0gRm9ybWF0VHlwZS5URVhUKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSBGb3JtYXRUeXBlLlhNTCkge1xuICAgICAgICAgICAgc291cmNlID0geGhyLnJlc3BvbnNlWE1MO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgc291cmNlID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0LCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IEZvcm1hdFR5cGUuQVJSQVlfQlVGRkVSKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSAvKiogQHR5cGUge0FycmF5QnVmZmVyfSAqLyAoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMsIGZvcm1hdC5yZWFkRmVhdHVyZXMoc291cmNlLFxuICAgICAgICAgICAgICB7ZmVhdHVyZVByb2plY3Rpb246IHByb2plY3Rpb259KSxcbiAgICAgICAgICAgIGZvcm1hdC5yZWFkUHJvamVjdGlvbihzb3VyY2UpLCBmb3JtYXQuZ2V0TGFzdEV4dGVudCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFpbHVyZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWlsdXJlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZmFpbHVyZS5jYWxsKHRoaXMpO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgYW4gWEhSIGZlYXR1cmUgbG9hZGVyIGZvciBhIGB1cmxgIGFuZCBgZm9ybWF0YC4gVGhlIGZlYXR1cmUgbG9hZGVyXG4gKiBsb2FkcyBmZWF0dXJlcyAod2l0aCBYSFIpLCBwYXJzZXMgdGhlIGZlYXR1cmVzLCBhbmQgYWRkcyB0aGVtIHRvIHRoZVxuICogdmVjdG9yIHNvdXJjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfEZlYXR1cmVVcmxGdW5jdGlvbn0gdXJsIEZlYXR1cmUgVVJMIHNlcnZpY2UuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZm9ybWF0L0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZm9ybWF0IEZlYXR1cmUgZm9ybWF0LlxuICogQHJldHVybiB7RmVhdHVyZUxvYWRlcn0gVGhlIGZlYXR1cmUgbG9hZGVyLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24geGhyKHVybCwgZm9ybWF0KSB7XG4gIHJldHVybiBsb2FkRmVhdHVyZXNYaHIodXJsLCBmb3JtYXQsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGZlYXR1cmVzIFRoZSBsb2FkZWQgZmVhdHVyZXMuXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBkYXRhUHJvamVjdGlvbiBEYXRhXG4gICAgICogcHJvamVjdGlvbi5cbiAgICAgKiBAdGhpcyB7aW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgZnVuY3Rpb24oZmVhdHVyZXMsIGRhdGFQcm9qZWN0aW9uKSB7XG4gICAgICBjb25zdCBzb3VyY2VPclRpbGUgPSAvKiogQHR5cGUgez99ICovICh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlT3JUaWxlLmFkZEZlYXR1cmVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9zb3VyY2UvVmVjdG9yXCIpLmRlZmF1bHR9ICovIChzb3VyY2VPclRpbGUpLmFkZEZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICAgIH1cbiAgICB9LCAvKiBGSVhNRSBoYW5kbGUgZXJyb3IgKi8gVk9JRCk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbG9hZGluZ3N0cmF0ZWd5XG4gKi9cblxuXG4vKipcbiAqIFN0cmF0ZWd5IGZ1bmN0aW9uIGZvciBsb2FkaW5nIGFsbCBmZWF0dXJlcyB3aXRoIGEgc2luZ2xlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBFeHRlbnRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWxsKGV4dGVudCwgcmVzb2x1dGlvbikge1xuICByZXR1cm4gW1stSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XV07XG59XG5cblxuLyoqXG4gKiBTdHJhdGVneSBmdW5jdGlvbiBmb3IgbG9hZGluZyBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgdmlldydzIGV4dGVudCBhbmRcbiAqIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBFeHRlbnRzLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmJveChleHRlbnQsIHJlc29sdXRpb24pIHtcbiAgcmV0dXJuIFtleHRlbnRdO1xufVxuXG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmF0ZWd5IGZ1bmN0aW9uIGZvciBsb2FkaW5nIGZlYXR1cmVzIGJhc2VkIG9uIGEgdGlsZSBncmlkLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVHcmlkIFRpbGUgZ3JpZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyKTogQXJyYXk8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50Pn0gTG9hZGluZyBzdHJhdGVneS5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbGUodGlsZUdyaWQpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IEV4dGVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uKSB7XG4gICAgICBjb25zdCB6ID0gdGlsZUdyaWQuZ2V0WkZvclJlc29sdXRpb24ocmVzb2x1dGlvbik7XG4gICAgICBjb25zdCB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudD59ICovXG4gICAgICBjb25zdCBleHRlbnRzID0gW107XG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gKi9cbiAgICAgIGNvbnN0IHRpbGVDb29yZCA9IFt6LCAwLCAwXTtcbiAgICAgIGZvciAodGlsZUNvb3JkWzFdID0gdGlsZVJhbmdlLm1pblg7IHRpbGVDb29yZFsxXSA8PSB0aWxlUmFuZ2UubWF4WDsgKyt0aWxlQ29vcmRbMV0pIHtcbiAgICAgICAgZm9yICh0aWxlQ29vcmRbMl0gPSB0aWxlUmFuZ2UubWluWTsgdGlsZUNvb3JkWzJdIDw9IHRpbGVSYW5nZS5tYXhZOyArK3RpbGVDb29yZFsyXSkge1xuICAgICAgICAgIGV4dGVudHMucHVzaCh0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZUNvb3JkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRlbnRzO1xuICAgIH1cbiAgKTtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVmVjdG9yRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGZlYXR1cmUgaXMgYWRkZWQgdG8gdGhlIHNvdXJjZS5cbiAgICogQGV2ZW50IG9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjYWRkZmVhdHVyZVxuICAgKiBAYXBpXG4gICAqL1xuICBBRERGRUFUVVJFOiAnYWRkZmVhdHVyZScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgZmVhdHVyZSBpcyB1cGRhdGVkLlxuICAgKiBAZXZlbnQgb2wvc291cmNlL1ZlY3Rvci5WZWN0b3JTb3VyY2VFdmVudCNjaGFuZ2VmZWF0dXJlXG4gICAqIEBhcGlcbiAgICovXG4gIENIQU5HRUZFQVRVUkU6ICdjaGFuZ2VmZWF0dXJlJyxcblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIGNsZWFyIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIHNvdXJjZS5cbiAgICogQGV2ZW50IG9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnQjY2xlYXJcbiAgICogQGFwaVxuICAgKi9cbiAgQ0xFQVI6ICdjbGVhcicsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgZmVhdHVyZSBpcyByZW1vdmVkIGZyb20gdGhlIHNvdXJjZS5cbiAgICogU2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3RvciNjbGVhciBzb3VyY2UuY2xlYXIoKX0gZm9yIGV4Y2VwdGlvbnMuXG4gICAqIEBldmVudCBvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I3JlbW92ZWZlYXR1cmVcbiAgICogQGFwaVxuICAgKi9cbiAgUkVNT1ZFRkVBVFVSRTogJ3JlbW92ZWZlYXR1cmUnXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0cnVjdHMvUkJ1c2hcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHJidXNoIGZyb20gJ3JidXNoJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGUsIGVxdWFsc30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7aXNFbXB0eX0gZnJvbSAnLi4vb2JqLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFbnRyeVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1pblhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5ZXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4WFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFlcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbdmFsdWVdXG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBXcmFwcGVyIGFyb3VuZCB0aGUgUkJ1c2ggYnkgVmxhZGltaXIgQWdhZm9ua2luLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNsYXNzIFJCdXNoIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X21heEVudHJpZXMgTWF4IGVudHJpZXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfbWF4RW50cmllcykge1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJidXNoXyA9IHJidXNoKG9wdF9tYXhFbnRyaWVzLCB1bmRlZmluZWQpO1xuXG4gICAgLyoqXG4gICAgICogQSBtYXBwaW5nIGJldHdlZW4gdGhlIG9iamVjdHMgYWRkZWQgdG8gdGhpcyByYnVzaCB3cmFwcGVyXG4gICAgICogYW5kIHRoZSBvYmplY3RzIHRoYXQgYXJlIGFjdHVhbGx5IGFkZGVkIHRvIHRoZSBpbnRlcm5hbCByYnVzaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBFbnRyeT59XG4gICAgICovXG4gICAgdGhpcy5pdGVtc18gPSB7fTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhIHZhbHVlIGludG8gdGhlIFJCdXNoLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqL1xuICBpbnNlcnQoZXh0ZW50LCB2YWx1ZSkge1xuICAgIC8qKiBAdHlwZSB7RW50cnl9ICovXG4gICAgY29uc3QgaXRlbSA9IHtcbiAgICAgIG1pblg6IGV4dGVudFswXSxcbiAgICAgIG1pblk6IGV4dGVudFsxXSxcbiAgICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICAgIG1heFk6IGV4dGVudFszXSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH07XG5cbiAgICB0aGlzLnJidXNoXy5pbnNlcnQoaXRlbSk7XG4gICAgdGhpcy5pdGVtc19bZ2V0VWlkKHZhbHVlKV0gPSBpdGVtO1xuICB9XG5cblxuICAvKipcbiAgICogQnVsay1pbnNlcnQgdmFsdWVzIGludG8gdGhlIFJCdXNoLlxuICAgKiBAcGFyYW0ge0FycmF5PGltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ+fSBleHRlbnRzIEV4dGVudHMuXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IHZhbHVlcyBWYWx1ZXMuXG4gICAqL1xuICBsb2FkKGV4dGVudHMsIHZhbHVlcykge1xuICAgIGNvbnN0IGl0ZW1zID0gbmV3IEFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgZXh0ZW50ID0gZXh0ZW50c1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAvKiogQHR5cGUge0VudHJ5fSAqL1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgbWluWDogZXh0ZW50WzBdLFxuICAgICAgICBtaW5ZOiBleHRlbnRbMV0sXG4gICAgICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICAgICAgbWF4WTogZXh0ZW50WzNdLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgICBpdGVtc1tpXSA9IGl0ZW07XG4gICAgICB0aGlzLml0ZW1zX1tnZXRVaWQodmFsdWUpXSA9IGl0ZW07XG4gICAgfVxuICAgIHRoaXMucmJ1c2hfLmxvYWQoaXRlbXMpO1xuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGEgdmFsdWUgZnJvbSB0aGUgUkJ1c2guXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVmFsdWUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUodmFsdWUpIHtcbiAgICBjb25zdCB1aWQgPSBnZXRVaWQodmFsdWUpO1xuXG4gICAgLy8gZ2V0IHRoZSBvYmplY3QgaW4gd2hpY2ggdGhlIHZhbHVlIHdhcyB3cmFwcGVkIHdoZW4gYWRkaW5nIHRvIHRoZVxuICAgIC8vIGludGVybmFsIHJidXNoLiB0aGVuIHVzZSB0aGF0IG9iamVjdCB0byBkbyB0aGUgcmVtb3ZhbC5cbiAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc19bdWlkXTtcbiAgICBkZWxldGUgdGhpcy5pdGVtc19bdWlkXTtcbiAgICByZXR1cm4gdGhpcy5yYnVzaF8ucmVtb3ZlKGl0ZW0pICE9PSBudWxsO1xuICB9XG5cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBleHRlbnQgb2YgYSB2YWx1ZSBpbiB0aGUgUkJ1c2guXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHVwZGF0ZShleHRlbnQsIHZhbHVlKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNfW2dldFVpZCh2YWx1ZSldO1xuICAgIGNvbnN0IGJib3ggPSBbaXRlbS5taW5YLCBpdGVtLm1pblksIGl0ZW0ubWF4WCwgaXRlbS5tYXhZXTtcbiAgICBpZiAoIWVxdWFscyhiYm94LCBleHRlbnQpKSB7XG4gICAgICB0aGlzLnJlbW92ZSh2YWx1ZSk7XG4gICAgICB0aGlzLmluc2VydChleHRlbnQsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYWxsIHZhbHVlcyBpbiB0aGUgUkJ1c2guXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fSBBbGwuXG4gICAqL1xuICBnZXRBbGwoKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLnJidXNoXy5hbGwoKTtcbiAgICByZXR1cm4gaXRlbXMubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCB2YWx1ZXMgaW4gdGhlIGdpdmVuIGV4dGVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn0gQWxsIGluIGV4dGVudC5cbiAgICovXG4gIGdldEluRXh0ZW50KGV4dGVudCkge1xuICAgIC8qKiBAdHlwZSB7RW50cnl9ICovXG4gICAgY29uc3QgYmJveCA9IHtcbiAgICAgIG1pblg6IGV4dGVudFswXSxcbiAgICAgIG1pblk6IGV4dGVudFsxXSxcbiAgICAgIG1heFg6IGV4dGVudFsyXSxcbiAgICAgIG1heFk6IGV4dGVudFszXVxuICAgIH07XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLnJidXNoXy5zZWFyY2goYmJveCk7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENhbGxzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBlYWNoIHZhbHVlIGluIHRoZSB0cmVlLlxuICAgKiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhpcyB2YWx1ZSBpcyByZXR1cm5lZCB3aXRob3V0XG4gICAqIGNoZWNraW5nIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHBhcmFtIHtTPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm4geyp9IENhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFNcbiAgICovXG4gIGZvckVhY2goY2FsbGJhY2ssIG9wdF90aGlzKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaF8odGhpcy5nZXRBbGwoKSwgY2FsbGJhY2ssIG9wdF90aGlzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENhbGxzIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBlYWNoIHZhbHVlIGluIHRoZSBwcm92aWRlZCBleHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBUKTogKn0gY2FsbGJhY2sgQ2FsbGJhY2suXG4gICAqIEBwYXJhbSB7Uz19IG9wdF90aGlzIFRoZSBvYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJuIHsqfSBDYWxsYmFjayByZXR1cm4gdmFsdWUuXG4gICAqIEB0ZW1wbGF0ZSBTXG4gICAqL1xuICBmb3JFYWNoSW5FeHRlbnQoZXh0ZW50LCBjYWxsYmFjaywgb3B0X3RoaXMpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JFYWNoXyh0aGlzLmdldEluRXh0ZW50KGV4dGVudCksIGNhbGxiYWNrLCBvcHRfdGhpcyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSB2YWx1ZXMgVmFsdWVzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIFQpOiAqfSBjYWxsYmFjayBDYWxsYmFjay5cbiAgICogQHBhcmFtIHtTPX0gb3B0X3RoaXMgVGhlIG9iamVjdCB0byB1c2UgYXMgYHRoaXNgIGluIGBjYWxsYmFja2AuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4geyp9IENhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFNcbiAgICovXG4gIGZvckVhY2hfKHZhbHVlcywgY2FsbGJhY2ssIG9wdF90aGlzKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIHZhbHVlc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGlzRW1wdHkodGhpcy5pdGVtc18pO1xuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB2YWx1ZXMgZnJvbSB0aGUgUkJ1c2guXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnJidXNoXy5jbGVhcigpO1xuICAgIHRoaXMuaXRlbXNfID0ge307XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnQ9fSBvcHRfZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gRXh0ZW50LlxuICAgKi9cbiAgZ2V0RXh0ZW50KG9wdF9leHRlbnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yYnVzaF8udG9KU09OKCk7XG4gICAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlKGRhdGEubWluWCwgZGF0YS5taW5ZLCBkYXRhLm1heFgsIGRhdGEubWF4WSwgb3B0X2V4dGVudCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JCdXNofSByYnVzaCBSLVRyZWUuXG4gICAqL1xuICBjb25jYXQocmJ1c2gpIHtcbiAgICB0aGlzLnJidXNoXy5sb2FkKHJidXNoLnJidXNoXy5hbGwoKSk7XG4gICAgZm9yIChjb25zdCBpIGluIHJidXNoLml0ZW1zXykge1xuICAgICAgdGhpcy5pdGVtc19baV0gPSByYnVzaC5pdGVtc19baV07XG4gICAgfVxuICB9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBSQnVzaDtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zb3VyY2UvVmVjdG9yXG4gKi9cblxuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IENvbGxlY3Rpb24gZnJvbSAnLi4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuLi9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLi9hcnJheS5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuLi9ldmVudHMvRXZlbnQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Y29udGFpbnNFeHRlbnQsIGVxdWFsc30gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7eGhyfSBmcm9tICcuLi9mZWF0dXJlbG9hZGVyLmpzJztcbmltcG9ydCB7VFJVRSwgVk9JRH0gZnJvbSAnLi4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7YWxsIGFzIGFsbFN0cmF0ZWd5fSBmcm9tICcuLi9sb2FkaW5nc3RyYXRlZ3kuanMnO1xuaW1wb3J0IHtpc0VtcHR5LCBnZXRWYWx1ZXN9IGZyb20gJy4uL29iai5qcyc7XG5pbXBvcnQgU291cmNlIGZyb20gJy4vU291cmNlLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuL1N0YXRlLmpzJztcbmltcG9ydCBWZWN0b3JFdmVudFR5cGUgZnJvbSAnLi9WZWN0b3JFdmVudFR5cGUuanMnO1xuaW1wb3J0IFJCdXNoIGZyb20gJy4uL3N0cnVjdHMvUkJ1c2guanMnO1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL2V4dGVudH5FeHRlbnR9IGFuZCBhIHJlc29sdXRpb24gYXMgYXJndW1lbnRzLCBhbmRcbiAqIHJldHVybnMgYW4gYXJyYXkgb2Yge0BsaW5rIG1vZHVsZTpvbC9leHRlbnR+RXh0ZW50fSB3aXRoIHRoZSBleHRlbnRzIHRvIGxvYWQuIFVzdWFsbHkgdGhpc1xuICogaXMgb25lIG9mIHRoZSBzdGFuZGFyZCB7QGxpbmsgbW9kdWxlOm9sL2xvYWRpbmdzdHJhdGVneX0gc3RyYXRlZ2llcy5cbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudCwgbnVtYmVyKTogQXJyYXk8aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD59IExvYWRpbmdTdHJhdGVneVxuICogQGFwaVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBFdmVudHMgZW1pdHRlZCBieSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J9IGluc3RhbmNlcyBhcmUgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWN0b3JTb3VyY2VFdmVudCBleHRlbmRzIEV2ZW50IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ9fSBvcHRfZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0X2ZlYXR1cmUpIHtcblxuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZlYXR1cmUgYmVpbmcgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlID0gb3B0X2ZlYXR1cmU7XG5cbiAgfVxuXG59XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fENvbGxlY3Rpb248aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gW2ZlYXR1cmVzXVxuICogRmVhdHVyZXMuIElmIHByb3ZpZGVkIGFzIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn0sIHRoZSBmZWF0dXJlcyBpbiB0aGUgc291cmNlXG4gKiBhbmQgdGhlIGNvbGxlY3Rpb24gd2lsbCBzdGF5IGluIHN5bmMuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IFtmb3JtYXRdIFRoZSBmZWF0dXJlIGZvcm1hdCB1c2VkIGJ5IHRoZSBYSFJcbiAqIGZlYXR1cmUgbG9hZGVyIHdoZW4gYHVybGAgaXMgc2V0LiBSZXF1aXJlZCBpZiBgdXJsYCBpcyBzZXQsIG90aGVyd2lzZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVMb2FkZXJ9IFtsb2FkZXJdXG4gKiBUaGUgbG9hZGVyIGZ1bmN0aW9uIHVzZWQgdG8gbG9hZCBmZWF0dXJlcywgZnJvbSBhIHJlbW90ZSBzb3VyY2UgZm9yIGV4YW1wbGUuXG4gKiBJZiB0aGlzIGlzIG5vdCBzZXQgYW5kIGB1cmxgIGlzIHNldCwgdGhlIHNvdXJjZSB3aWxsIGNyZWF0ZSBhbmQgdXNlIGFuIFhIUlxuICogZmVhdHVyZSBsb2FkZXIuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHtWZWN0b3J9IGZyb20gJ29sL3NvdXJjZSc7XG4gKiBpbXBvcnQge0dlb0pTT059IGZyb20gJ29sL2Zvcm1hdCc7XG4gKiBpbXBvcnQge2Jib3h9IGZyb20gJ29sL2xvYWRpbmdzdHJhdGVneSc7XG4gKlxuICogdmFyIHZlY3RvclNvdXJjZSA9IG5ldyBWZWN0b3Ioe1xuICogICBmb3JtYXQ6IG5ldyBHZW9KU09OKCksXG4gKiAgIGxvYWRlcjogZnVuY3Rpb24oZXh0ZW50LCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKSB7XG4gKiAgICAgIHZhciBwcm9qID0gcHJvamVjdGlvbi5nZXRDb2RlKCk7XG4gKiAgICAgIHZhciB1cmwgPSAnaHR0cHM6Ly9haG9jZXZhci5jb20vZ2Vvc2VydmVyL3dmcz9zZXJ2aWNlPVdGUyYnICtcbiAqICAgICAgICAgICd2ZXJzaW9uPTEuMS4wJnJlcXVlc3Q9R2V0RmVhdHVyZSZ0eXBlbmFtZT1vc206d2F0ZXJfYXJlYXMmJyArXG4gKiAgICAgICAgICAnb3V0cHV0Rm9ybWF0PWFwcGxpY2F0aW9uL2pzb24mc3JzbmFtZT0nICsgcHJvaiArICcmJyArXG4gKiAgICAgICAgICAnYmJveD0nICsgZXh0ZW50LmpvaW4oJywnKSArICcsJyArIHByb2o7XG4gKiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAqICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XG4gKiAgICAgIHZhciBvbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgdmVjdG9yU291cmNlLnJlbW92ZUxvYWRlZEV4dGVudChleHRlbnQpO1xuICogICAgICB9XG4gKiAgICAgIHhoci5vbmVycm9yID0gb25FcnJvcjtcbiAqICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCkge1xuICogICAgICAgICAgdmVjdG9yU291cmNlLmFkZEZlYXR1cmVzKFxuICogICAgICAgICAgICAgIHZlY3RvclNvdXJjZS5nZXRGb3JtYXQoKS5yZWFkRmVhdHVyZXMoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICogICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICBvbkVycm9yKCk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICAgIHhoci5zZW5kKCk7XG4gKiAgICB9LFxuICogICAgc3RyYXRlZ3k6IGJib3hcbiAqICB9KTtcbiAqIGBgYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmxhcHM9dHJ1ZV0gVGhpcyBzb3VyY2UgbWF5IGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAqIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIChlLmcuIGZvciBzb3VyY2VzIHdpdGggcG9seWdvbnMgdGhhdCByZXByZXNlbnQgYWRtaW5pc3RyYXRpdmVcbiAqIGJvdW5kYXJpZXMgb3IgVG9wb0pTT04gc291cmNlcykgYWxsb3dzIHRoZSByZW5kZXJlciB0byBvcHRpbWlzZSBmaWxsIGFuZFxuICogc3Ryb2tlIG9wZXJhdGlvbnMuXG4gKiBAcHJvcGVydHkge0xvYWRpbmdTdHJhdGVneX0gW3N0cmF0ZWd5XSBUaGUgbG9hZGluZyBzdHJhdGVneSB0byB1c2UuXG4gKiBCeSBkZWZhdWx0IGFuIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5fmFsbH1cbiAqIHN0cmF0ZWd5IGlzIHVzZWQsIGEgb25lLW9mZiBzdHJhdGVneSB3aGljaCBsb2FkcyBhbGwgZmVhdHVyZXMgYXQgb25jZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfGltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZVVybEZ1bmN0aW9ufSBbdXJsXVxuICogU2V0dGluZyB0aGlzIG9wdGlvbiBpbnN0cnVjdHMgdGhlIHNvdXJjZSB0byBsb2FkIGZlYXR1cmVzIHVzaW5nIGFuIFhIUiBsb2FkZXJcbiAqIChzZWUge0BsaW5rIG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfnhocn0pLiBVc2UgYSBgc3RyaW5nYCBhbmQgYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvbG9hZGluZ3N0cmF0ZWd5fmFsbH0gZm9yIGEgb25lLW9mZiBkb3dubG9hZCBvZiBhbGwgZmVhdHVyZXMgZnJvbVxuICogdGhlIGdpdmVuIFVSTC4gVXNlIGEge0BsaW5rIG1vZHVsZTpvbC9mZWF0dXJlbG9hZGVyfkZlYXR1cmVVcmxGdW5jdGlvbn0gdG8gZ2VuZXJhdGUgdGhlIHVybCB3aXRoXG4gKiBvdGhlciBsb2FkaW5nIHN0cmF0ZWdpZXMuXG4gKiBSZXF1aXJlcyBgZm9ybWF0YCB0byBiZSBzZXQgYXMgd2VsbC5cbiAqIFdoZW4gZGVmYXVsdCBYSFIgZmVhdHVyZSBsb2FkZXIgaXMgcHJvdmlkZWQsIHRoZSBmZWF0dXJlcyB3aWxsXG4gKiBiZSB0cmFuc2Zvcm1lZCBmcm9tIHRoZSBkYXRhIHByb2plY3Rpb24gdG8gdGhlIHZpZXcgcHJvamVjdGlvblxuICogZHVyaW5nIHBhcnNpbmcuIElmIHlvdXIgcmVtb3RlIGRhdGEgc291cmNlIGRvZXMgbm90IGFkdmVydGlzZSBpdHMgcHJvamVjdGlvblxuICogcHJvcGVybHksIHRoaXMgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBpbmNvcnJlY3QuIEZvciBzb21lIGZvcm1hdHMsIHRoZVxuICogZGVmYXVsdCBwcm9qZWN0aW9uICh1c3VhbGx5IEVQU0c6NDMyNikgY2FuIGJlIG92ZXJyaWRkZW4gYnkgc2V0dGluZyB0aGVcbiAqIGRhdGFQcm9qZWN0aW9uIGNvbnN0cnVjdG9yIG9wdGlvbiBvbiB0aGUgZm9ybWF0LlxuICogTm90ZSB0aGF0IGlmIGEgc291cmNlIGNvbnRhaW5zIG5vbi1mZWF0dXJlIGRhdGEsIHN1Y2ggYXMgYSBHZW9KU09OIGdlb21ldHJ5XG4gKiBvciBhIEtNTCBOZXR3b3JrTGluaywgdGhlc2Ugd2lsbCBiZSBpZ25vcmVkLiBVc2UgYSBjdXN0b20gbG9hZGVyIHRvIGxvYWQgdGhlc2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VTcGF0aWFsSW5kZXg9dHJ1ZV1cbiAqIEJ5IGRlZmF1bHQsIGFuIFJUcmVlIGlzIHVzZWQgYXMgc3BhdGlhbCBpbmRleC4gV2hlbiBmZWF0dXJlcyBhcmUgcmVtb3ZlZCBhbmRcbiAqIGFkZGVkIGZyZXF1ZW50bHksIGFuZCB0aGUgdG90YWwgbnVtYmVyIG9mIGZlYXR1cmVzIGlzIGxvdywgc2V0dGluZyB0aGlzIHRvXG4gKiBgZmFsc2VgIG1heSBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICpcbiAqIE5vdGUgdGhhdFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRGZWF0dXJlc0luRXh0ZW50fSxcbiAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZ2V0Q2xvc2VzdEZlYXR1cmVUb0Nvb3JkaW5hdGV9IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRFeHRlbnR9IGNhbm5vdCBiZSB1c2VkIHdoZW4gYHVzZVNwYXRpYWxJbmRleGAgaXNcbiAqIHNldCB0byBgZmFsc2VgLCBhbmQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNmb3JFYWNoRmVhdHVyZUluRXh0ZW50fSB3aWxsIGxvb3BcbiAqIHRocm91Z2ggYWxsIGZlYXR1cmVzLlxuICpcbiAqIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHRoZSBmZWF0dXJlcyB3aWxsIGJlIG1haW50YWluZWQgaW4gYW5cbiAqIHtAbGluayBtb2R1bGU6b2wvQ29sbGVjdGlvbn0sIHdoaWNoIGNhbiBiZSByZXRyaWV2ZWQgdGhyb3VnaFxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNnZXRGZWF0dXJlc0NvbGxlY3Rpb259LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV0gV3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LiBGb3IgdmVjdG9yIGVkaXRpbmcgYWNyb3NzIHRoZVxuICogLTE4MMKwIGFuZCAxODDCsCBtZXJpZGlhbnMgdG8gd29yayBwcm9wZXJseSwgdGhpcyBzaG91bGQgYmUgc2V0IHRvIGBmYWxzZWAuIFRoZVxuICogcmVzdWx0aW5nIGdlb21ldHJ5IGNvb3JkaW5hdGVzIHdpbGwgdGhlbiBleGNlZWQgdGhlIHdvcmxkIGJvdW5kcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogUHJvdmlkZXMgYSBzb3VyY2Ugb2YgZmVhdHVyZXMgZm9yIHZlY3RvciBsYXllcnMuIFZlY3RvciBmZWF0dXJlcyBwcm92aWRlZFxuICogYnkgdGhpcyBzb3VyY2UgYXJlIHN1aXRhYmxlIGZvciBlZGl0aW5nLiBTZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yVGlsZX5WZWN0b3JUaWxlfSBmb3JcbiAqIHZlY3RvciBkYXRhIHRoYXQgaXMgb3B0aW1pemVkIGZvciByZW5kZXJpbmcuXG4gKlxuICogQGZpcmVzIG9sL3NvdXJjZS9WZWN0b3IuVmVjdG9yU291cmNlRXZlbnRcbiAqIEBhcGlcbiAqL1xuY2xhc3MgVmVjdG9yU291cmNlIGV4dGVuZHMgU291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIFZlY3RvciBzb3VyY2Ugb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9vcHRpb25zKSB7XG5cbiAgICBjb25zdCBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG5cbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgcHJvamVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgc3RhdGU6IFNvdXJjZVN0YXRlLlJFQURZLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9mZWF0dXJlbG9hZGVyLmpzXCIpLkZlYXR1cmVMb2FkZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb2FkZXJfID0gVk9JRDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZm9ybWF0XyA9IG9wdGlvbnMuZm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXBzXyA9IG9wdGlvbnMub3ZlcmxhcHMgPT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMub3ZlcmxhcHM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd8aW1wb3J0KFwiLi4vZmVhdHVyZWxvYWRlci5qc1wiKS5GZWF0dXJlVXJsRnVuY3Rpb258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMudXJsXyA9IG9wdGlvbnMudXJsO1xuXG4gICAgaWYgKG9wdGlvbnMubG9hZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9hZGVyXyA9IG9wdGlvbnMubG9hZGVyO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cmxfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2VydCh0aGlzLmZvcm1hdF8sIDcpOyAvLyBgZm9ybWF0YCBtdXN0IGJlIHNldCB3aGVuIGB1cmxgIGlzIHNldFxuICAgICAgLy8gY3JlYXRlIGEgWEhSIGZlYXR1cmUgbG9hZGVyIGZvciBcInVybFwiIGFuZCBcImZvcm1hdFwiXG4gICAgICB0aGlzLmxvYWRlcl8gPSB4aHIodGhpcy51cmxfLCAvKiogQHR5cGUge2ltcG9ydChcIi4uL2Zvcm1hdC9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmZvcm1hdF8pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtMb2FkaW5nU3RyYXRlZ3l9XG4gICAgICovXG4gICAgdGhpcy5zdHJhdGVneV8gPSBvcHRpb25zLnN0cmF0ZWd5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cmF0ZWd5IDogYWxsU3RyYXRlZ3k7XG5cbiAgICBjb25zdCB1c2VTcGF0aWFsSW5kZXggPVxuICAgICAgICBvcHRpb25zLnVzZVNwYXRpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy51c2VTcGF0aWFsSW5kZXggOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UkJ1c2g8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmZlYXR1cmVzUnRyZWVfID0gdXNlU3BhdGlhbEluZGV4ID8gbmV3IFJCdXNoKCkgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UkJ1c2g8e2V4dGVudDogaW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0+fVxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkRXh0ZW50c1J0cmVlXyA9IG5ldyBSQnVzaCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgbG9va3VwIG9mIGZlYXR1cmVzIGJ5IGlkICh0aGUgcmV0dXJuIGZyb20gZmVhdHVyZS5nZXRJZCgpKS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmlkSW5kZXhfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBIGxvb2t1cCBvZiBmZWF0dXJlcyB3aXRob3V0IGlkIChrZXllZCBieSBnZXRVaWQoZmVhdHVyZSkpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMudW5kZWZJZEluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT4+fVxuICAgICAqL1xuICAgIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fID0gbnVsbDtcblxuICAgIGxldCBjb2xsZWN0aW9uLCBmZWF0dXJlcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmZlYXR1cmVzKSkge1xuICAgICAgZmVhdHVyZXMgPSBvcHRpb25zLmZlYXR1cmVzO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5mZWF0dXJlcykge1xuICAgICAgY29sbGVjdGlvbiA9IG9wdGlvbnMuZmVhdHVyZXM7XG4gICAgICBmZWF0dXJlcyA9IGNvbGxlY3Rpb24uZ2V0QXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKCF1c2VTcGF0aWFsSW5kZXggJiYgY29sbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oZmVhdHVyZXMpO1xuICAgIH1cbiAgICBpZiAoZmVhdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hZGRGZWF0dXJlc0ludGVybmFsKGZlYXR1cmVzKTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5iaW5kRmVhdHVyZXNDb2xsZWN0aW9uXyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzaW5nbGUgZmVhdHVyZSB0byB0aGUgc291cmNlLiAgSWYgeW91IHdhbnQgdG8gYWRkIGEgYmF0Y2ggb2YgZmVhdHVyZXNcbiAgICogYXQgb25jZSwgY2FsbCB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2FkZEZlYXR1cmVzICNhZGRGZWF0dXJlcygpfVxuICAgKiBpbnN0ZWFkLiBBIGZlYXR1cmUgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHNvdXJjZSBpZiBmZWF0dXJlIHdpdGhcbiAgICogdGhlIHNhbWUgaWQgaXMgYWxyZWFkeSB0aGVyZS4gVGhlIHJlYXNvbiBmb3IgdGhpcyBiZWhhdmlvciBpcyB0byBhdm9pZFxuICAgKiBmZWF0dXJlIGR1cGxpY2F0aW9uIHdoZW4gdXNpbmcgYmJveCBvciB0aWxlIGxvYWRpbmcgc3RyYXRlZ2llcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZSB0byBhZGQuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZEZlYXR1cmUoZmVhdHVyZSkge1xuICAgIHRoaXMuYWRkRmVhdHVyZUludGVybmFsKGZlYXR1cmUpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cblxuICAvKipcbiAgICogQWRkIGEgZmVhdHVyZSB3aXRob3V0IGZpcmluZyBhIGBjaGFuZ2VgIGV2ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhZGRGZWF0dXJlSW50ZXJuYWwoZmVhdHVyZSkge1xuICAgIGNvbnN0IGZlYXR1cmVLZXkgPSBnZXRVaWQoZmVhdHVyZSk7XG5cbiAgICBpZiAoIXRoaXMuYWRkVG9JbmRleF8oZmVhdHVyZUtleSwgZmVhdHVyZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwQ2hhbmdlRXZlbnRzXyhmZWF0dXJlS2V5LCBmZWF0dXJlKTtcblxuICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeSkge1xuICAgICAgY29uc3QgZXh0ZW50ID0gZ2VvbWV0cnkuZ2V0RXh0ZW50KCk7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmluc2VydChleHRlbnQsIGZlYXR1cmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5XSA9IGZlYXR1cmU7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgbmV3IFZlY3RvclNvdXJjZUV2ZW50KFZlY3RvckV2ZW50VHlwZS5BRERGRUFUVVJFLCBmZWF0dXJlKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZUtleSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIFRoZSBmZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0dXBDaGFuZ2VFdmVudHNfKGZlYXR1cmVLZXksIGZlYXR1cmUpIHtcbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XSA9IFtcbiAgICAgIGxpc3RlbihmZWF0dXJlLCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZUZlYXR1cmVDaGFuZ2VfLCB0aGlzKSxcbiAgICAgIGxpc3RlbihmZWF0dXJlLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsXG4gICAgICAgIHRoaXMuaGFuZGxlRmVhdHVyZUNoYW5nZV8sIHRoaXMpXG4gICAgXTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlS2V5IFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgVGhlIGZlYXR1cmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBmZWF0dXJlIGlzIFwidmFsaWRcIiwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgaXMgYWxzbyBhXG4gICAqICAgICBjYW5kaWRhdGUgZm9yIGluc2VydGlvbiBpbnRvIHRoZSBSdHJlZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFkZFRvSW5kZXhfKGZlYXR1cmVLZXksIGZlYXR1cmUpIHtcbiAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIShpZC50b1N0cmluZygpIGluIHRoaXMuaWRJbmRleF8pKSB7XG4gICAgICAgIHRoaXMuaWRJbmRleF9baWQudG9TdHJpbmcoKV0gPSBmZWF0dXJlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCEoZmVhdHVyZUtleSBpbiB0aGlzLnVuZGVmSWRJbmRleF8pLFxuICAgICAgICAzMCk7IC8vIFRoZSBwYXNzZWQgYGZlYXR1cmVgIHdhcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBzb3VyY2VcbiAgICAgIHRoaXMudW5kZWZJZEluZGV4X1tmZWF0dXJlS2V5XSA9IGZlYXR1cmU7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBhIGJhdGNoIG9mIGZlYXR1cmVzIHRvIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gZmVhdHVyZXMgRmVhdHVyZXMgdG8gYWRkLlxuICAgKiBAYXBpXG4gICAqL1xuICBhZGRGZWF0dXJlcyhmZWF0dXJlcykge1xuICAgIHRoaXMuYWRkRmVhdHVyZXNJbnRlcm5hbChmZWF0dXJlcyk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBZGQgZmVhdHVyZXMgd2l0aG91dCBmaXJpbmcgYSBgY2hhbmdlYCBldmVudC5cbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSBmZWF0dXJlcyBGZWF0dXJlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgYWRkRmVhdHVyZXNJbnRlcm5hbChmZWF0dXJlcykge1xuICAgIGNvbnN0IGV4dGVudHMgPSBbXTtcbiAgICBjb25zdCBuZXdGZWF0dXJlcyA9IFtdO1xuICAgIGNvbnN0IGdlb21ldHJ5RmVhdHVyZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgY29uc3QgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICAgIGlmICh0aGlzLmFkZFRvSW5kZXhfKGZlYXR1cmVLZXksIGZlYXR1cmUpKSB7XG4gICAgICAgIG5ld0ZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IG5ld0ZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmZWF0dXJlID0gbmV3RmVhdHVyZXNbaV07XG4gICAgICBjb25zdCBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgICAgdGhpcy5zZXR1cENoYW5nZUV2ZW50c18oZmVhdHVyZUtleSwgZmVhdHVyZSk7XG5cbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgaWYgKGdlb21ldHJ5KSB7XG4gICAgICAgIGNvbnN0IGV4dGVudCA9IGdlb21ldHJ5LmdldEV4dGVudCgpO1xuICAgICAgICBleHRlbnRzLnB1c2goZXh0ZW50KTtcbiAgICAgICAgZ2VvbWV0cnlGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5sb2FkKGV4dGVudHMsIGdlb21ldHJ5RmVhdHVyZXMpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBuZXdGZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSwgbmV3RmVhdHVyZXNbaV0pKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDb2xsZWN0aW9uPGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IGNvbGxlY3Rpb24gQ29sbGVjdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJpbmRGZWF0dXJlc0NvbGxlY3Rpb25fKGNvbGxlY3Rpb24pIHtcbiAgICBsZXQgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgIGxpc3Rlbih0aGlzLCBWZWN0b3JFdmVudFR5cGUuQURERkVBVFVSRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtWZWN0b3JTb3VyY2VFdmVudH0gZXZ0IFRoZSB2ZWN0b3Igc291cmNlIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBjb2xsZWN0aW9uLnB1c2goZXZ0LmZlYXR1cmUpO1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgbGlzdGVuKHRoaXMsIFZlY3RvckV2ZW50VHlwZS5SRU1PVkVGRUFUVVJFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1ZlY3RvclNvdXJjZUV2ZW50fSBldnQgVGhlIHZlY3RvciBzb3VyY2UgZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghbW9kaWZ5aW5nQ29sbGVjdGlvbikge1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIGNvbGxlY3Rpb24ucmVtb3ZlKGV2dC5mZWF0dXJlKTtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGxpc3Rlbihjb2xsZWN0aW9uLCBDb2xsZWN0aW9uRXZlbnRUeXBlLkFERCxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZ0IFRoZSBjb2xsZWN0aW9uIGV2ZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoIW1vZGlmeWluZ0NvbGxlY3Rpb24pIHtcbiAgICAgICAgICBtb2RpZnlpbmdDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmFkZEZlYXR1cmUoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9ICovIChldnQuZWxlbWVudCkpO1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgbGlzdGVuKGNvbGxlY3Rpb24sIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldnQgVGhlIGNvbGxlY3Rpb24gZXZlbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghbW9kaWZ5aW5nQ29sbGVjdGlvbikge1xuICAgICAgICAgIG1vZGlmeWluZ0NvbGxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlRmVhdHVyZSgvKiogQHR5cGUge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gKi8gKGV2dC5lbGVtZW50KSk7XG4gICAgICAgICAgbW9kaWZ5aW5nQ29sbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8gPSBjb2xsZWN0aW9uO1xuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBmZWF0dXJlcyBmcm9tIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9mYXN0IFNraXAgZGlzcGF0Y2hpbmcgb2Yge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yLlZlY3RvclNvdXJjZUV2ZW50I3JlbW92ZWZlYXR1cmV9IGV2ZW50cy5cbiAgICogQGFwaVxuICAgKi9cbiAgY2xlYXIob3B0X2Zhc3QpIHtcbiAgICBpZiAob3B0X2Zhc3QpIHtcbiAgICAgIGZvciAoY29uc3QgZmVhdHVyZUlkIGluIHRoaXMuZmVhdHVyZUNoYW5nZUtleXNfKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlSWRdO1xuICAgICAgICBrZXlzLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXykge1xuICAgICAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzXyA9IHt9O1xuICAgICAgICB0aGlzLmlkSW5kZXhfID0ge307XG4gICAgICAgIHRoaXMudW5kZWZJZEluZGV4XyA9IHt9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmZvckVhY2godGhpcy5yZW1vdmVGZWF0dXJlSW50ZXJuYWwsIHRoaXMpO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGZWF0dXJlSW50ZXJuYWwodGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19baWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV8uY2xlYXIoKTtcbiAgICB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXyA9IHt9O1xuXG4gICAgY29uc3QgY2xlYXJFdmVudCA9IG5ldyBWZWN0b3JTb3VyY2VFdmVudChWZWN0b3JFdmVudFR5cGUuQ0xFQVIpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChjbGVhckV2ZW50KTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZmVhdHVyZXMgb24gdGhlIHNvdXJjZSwgY2FsbGluZyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcbiAgICogd2l0aCBlYWNoIG9uZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGFueSBcInRydXRoeVwiIHZhbHVlLCBpdGVyYXRpb24gd2lsbFxuICAgKiBzdG9wIGFuZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gb25seSBpdGVyYXRlIHRocm91Z2ggdGhlIGZlYXR1cmUgdGhhdCBoYXZlIGEgZGVmaW5lZCBnZW9tZXRyeS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBDYWxsZWQgd2l0aCBlYWNoIGZlYXR1cmVcbiAgICogICAgIG9uIHRoZSBzb3VyY2UuICBSZXR1cm4gYSB0cnV0aHkgdmFsdWUgdG8gc3RvcCBpdGVyYXRpb24uXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byB0aGUgY2FsbGJhY2suXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBhcGlcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICB0aGlzLmZlYXR1cmVzQ29sbGVjdGlvbl8uZm9yRWFjaChjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBnZW9tZXRyaWVzIGNvbnRhaW4gdGhlIHByb3ZpZGVkXG4gICAqIGNvb3JkaW5hdGUsIGNhbGxpbmcgdGhlIGNhbGxiYWNrIHdpdGggZWFjaCBmZWF0dXJlLiAgSWYgdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICogYSBcInRydXRoeVwiIHZhbHVlLCBpdGVyYXRpb24gd2lsbCBzdG9wIGFuZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0KTogVH0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggZWFjaCBmZWF0dXJlXG4gICAqICAgICB3aG9zZSBnb2VtZXRyeSBjb250YWlucyB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBjYWxsYmFjay5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlRGlyZWN0KGNvb3JkaW5hdGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gW2Nvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV1dO1xuICAgIHJldHVybiB0aGlzLmZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LCBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgIGlmIChnZW9tZXRyeS5pbnRlcnNlY3RzQ29vcmRpbmF0ZShjb29yZGluYXRlKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZmVhdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBmZWF0dXJlcyB3aG9zZSBib3VuZGluZyBib3ggaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWRcbiAgICogZXh0ZW50IChub3RlIHRoYXQgdGhlIGZlYXR1cmUncyBnZW9tZXRyeSBtYXkgbm90IGludGVyc2VjdCB0aGUgZXh0ZW50KSxcbiAgICogY2FsbGluZyB0aGUgY2FsbGJhY2sgd2l0aCBlYWNoIGZlYXR1cmUuICBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIFwidHJ1dGh5XCJcbiAgICogdmFsdWUsIGl0ZXJhdGlvbiB3aWxsIHN0b3AgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAgICpcbiAgICogSWYgeW91IGFyZSBpbnRlcmVzdGVkIGluIGZlYXR1cmVzIHdob3NlIGdlb21ldHJ5IGludGVyc2VjdHMgYW4gZXh0ZW50LCBjYWxsXG4gICAqIHRoZSB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlSW50ZXJzZWN0aW5nRXh0ZW50ICNmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudCgpfSBtZXRob2QgaW5zdGVhZC5cbiAgICpcbiAgICogV2hlbiBgdXNlU3BhdGlhbEluZGV4YCBpcyBzZXQgdG8gZmFsc2UsIHRoaXMgbWV0aG9kIHdpbGwgbG9vcCB0aHJvdWdoIGFsbFxuICAgKiBmZWF0dXJlcywgZXF1aXZhbGVudCB0byB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9WZWN0b3J+VmVjdG9yU291cmNlI2ZvckVhY2hGZWF0dXJlICNmb3JFYWNoRmVhdHVyZSgpfS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgd2hvc2UgYm91bmRpbmcgYm94IGludGVyc2VjdHMgdGhlIHByb3ZpZGVkIGV4dGVudC5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBjYWxsYmFjay5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQGFwaVxuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmVJbkV4dGVudChleHRlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmZvckVhY2hJbkV4dGVudChleHRlbnQsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXykge1xuICAgICAgdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZXh0ZW50LFxuICAgKiBjYWxsaW5nIHRoZSBjYWxsYmFjayB3aXRoIGVhY2ggZmVhdHVyZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGEgXCJ0cnV0aHlcIlxuICAgKiB2YWx1ZSwgaXRlcmF0aW9uIHdpbGwgc3RvcCBhbmQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICAgKlxuICAgKiBJZiB5b3Ugb25seSB3YW50IHRvIHRlc3QgZm9yIGJvdW5kaW5nIGJveCBpbnRlcnNlY3Rpb24sIGNhbGwgdGhlXG4gICAqIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1ZlY3Rvcn5WZWN0b3JTb3VyY2UjZm9yRWFjaEZlYXR1cmVJbkV4dGVudCAjZm9yRWFjaEZlYXR1cmVJbkV4dGVudCgpfSBtZXRob2QgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIENhbGxlZCB3aXRoIGVhY2ggZmVhdHVyZVxuICAgKiAgICAgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgZXh0ZW50LlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUludGVyc2VjdGluZ0V4dGVudChleHRlbnQsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaEZlYXR1cmVJbkV4dGVudChleHRlbnQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBsYXN0IGNhbGwgdG8gdGhlIGNhbGxiYWNrLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgICAgICBpZiAoZ2VvbWV0cnkuaW50ZXJzZWN0c0V4dGVudChleHRlbnQpKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2soZmVhdHVyZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBmZWF0dXJlcyBjb2xsZWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNvdXJjZS4gV2lsbCBiZSBgbnVsbGBcbiAgICogdW5sZXNzIHRoZSBzb3VyY2Ugd2FzIGNvbmZpZ3VyZWQgd2l0aCBgdXNlU3BhdGlhbEluZGV4YCBzZXQgdG8gYGZhbHNlYCwgb3JcbiAgICogd2l0aCBhbiB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb259IGFzIGBmZWF0dXJlc2AuXG4gICAqIEByZXR1cm4ge0NvbGxlY3Rpb248aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gVGhlIGNvbGxlY3Rpb24gb2YgZmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzQ29sbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IGFsbCBmZWF0dXJlcyBvbiB0aGUgc291cmNlIGluIHJhbmRvbSBvcmRlci5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzKCkge1xuICAgIGxldCBmZWF0dXJlcztcbiAgICBpZiAodGhpcy5mZWF0dXJlc0NvbGxlY3Rpb25fKSB7XG4gICAgICBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXNDb2xsZWN0aW9uXy5nZXRBcnJheSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzUnRyZWVfLmdldEFsbCgpO1xuICAgICAgaWYgKCFpc0VtcHR5KHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSkge1xuICAgICAgICBleHRlbmQoZmVhdHVyZXMsIGdldFZhbHVlcyh0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQ+fSAqLyAoZmVhdHVyZXMpXG4gICAgKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmVhdHVyZXMgd2hvc2UgZ2VvbWV0cnkgaW50ZXJzZWN0cyB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gRmVhdHVyZXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVzQXRDb29yZGluYXRlKGNvb3JkaW5hdGUpIHtcbiAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGVEaXJlY3QoY29vcmRpbmF0ZSwgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgZmVhdHVyZXMucHVzaChmZWF0dXJlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmVhdHVyZXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGZlYXR1cmVzIGluIHRoZSBwcm92aWRlZCBleHRlbnQuICBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIGFuIGFycmF5IG9mXG4gICAqIGFsbCBmZWF0dXJlcyBpbnRlcnNlY3RpbmcgdGhlIGdpdmVuIGV4dGVudCBpbiByYW5kb20gb3JkZXIgKHNvIGl0IG1heSBpbmNsdWRlXG4gICAqIGZlYXR1cmVzIHdob3NlIGdlb21ldHJpZXMgZG8gbm90IGludGVyc2VjdCB0aGUgZXh0ZW50KS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gICAqIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEByZXR1cm4ge0FycmF5PGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdD59IEZlYXR1cmVzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGZWF0dXJlc0luRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzUnRyZWVfLmdldEluRXh0ZW50KGV4dGVudCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsb3Nlc3QgZmVhdHVyZSB0byB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGF2YWlsYWJsZSB3aGVuIHRoZSBzb3VyY2UgaXMgY29uZmlndXJlZCB3aXRoXG4gICAqIGB1c2VTcGF0aWFsSW5kZXhgIHNldCB0byBgZmFsc2VgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6Ym9vbGVhbj19IG9wdF9maWx0ZXIgRmVhdHVyZSBmaWx0ZXIgZnVuY3Rpb24uXG4gICAqICAgICBUaGUgZmlsdGVyIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSBvbmUgYXJndW1lbnQsIHRoZSB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmUgZmVhdHVyZX1cbiAgICogICAgIGFuZCBpdCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbiB2YWx1ZS4gQnkgZGVmYXVsdCwgbm8gZmlsdGVyaW5nIGlzIG1hZGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gQ2xvc2VzdCBmZWF0dXJlLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDbG9zZXN0RmVhdHVyZVRvQ29vcmRpbmF0ZShjb29yZGluYXRlLCBvcHRfZmlsdGVyKSB7XG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBmZWF0dXJlIHVzaW5nIGJyYW5jaCBhbmQgYm91bmQuICBXZSBzdGFydCBzZWFyY2hpbmcgYW5cbiAgICAvLyBpbmZpbml0ZSBleHRlbnQsIGFuZCBmaW5kIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBmaXJzdCBmZWF0dXJlIGZvdW5kLiAgVGhpc1xuICAgIC8vIGJlY29tZXMgdGhlIGNsb3Nlc3QgZmVhdHVyZS4gIFdlIHRoZW4gY29tcHV0ZSBhIHNtYWxsZXIgZXh0ZW50IHdoaWNoIGFueVxuICAgIC8vIGNsb3NlciBmZWF0dXJlIG11c3QgaW50ZXJzZWN0LiAgV2UgY29udGludWUgc2VhcmNoaW5nIHdpdGggdGhpcyBzbWFsbGVyXG4gICAgLy8gZXh0ZW50LCB0cnlpbmcgdG8gZmluZCBhIGNsb3NlciBmZWF0dXJlLiAgRXZlcnkgdGltZSB3ZSBmaW5kIGEgY2xvc2VyXG4gICAgLy8gZmVhdHVyZSwgd2UgdXBkYXRlIHRoZSBleHRlbnQgYmVpbmcgc2VhcmNoZWQgc28gdGhhdCBhbnkgZXZlbiBjbG9zZXJcbiAgICAvLyBmZWF0dXJlIG11c3QgaW50ZXJzZWN0IGl0LiAgV2UgY29udGludWUgdW50aWwgd2UgcnVuIG91dCBvZiBmZWF0dXJlcy5cbiAgICBjb25zdCB4ID0gY29vcmRpbmF0ZVswXTtcbiAgICBjb25zdCB5ID0gY29vcmRpbmF0ZVsxXTtcbiAgICBsZXQgY2xvc2VzdEZlYXR1cmUgPSBudWxsO1xuICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IFtOYU4sIE5hTl07XG4gICAgbGV0IG1pblNxdWFyZWREaXN0YW5jZSA9IEluZmluaXR5O1xuICAgIGNvbnN0IGV4dGVudCA9IFstSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XTtcbiAgICBjb25zdCBmaWx0ZXIgPSBvcHRfZmlsdGVyID8gb3B0X2ZpbHRlciA6IFRSVUU7XG4gICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmaWx0ZXIoZmVhdHVyZSkpIHtcbiAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c01pblNxdWFyZWREaXN0YW5jZSA9IG1pblNxdWFyZWREaXN0YW5jZTtcbiAgICAgICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBnZW9tZXRyeS5jbG9zZXN0UG9pbnRYWShcbiAgICAgICAgICAgIHgsIHksIGNsb3Nlc3RQb2ludCwgbWluU3F1YXJlZERpc3RhbmNlKTtcbiAgICAgICAgICBpZiAobWluU3F1YXJlZERpc3RhbmNlIDwgcHJldmlvdXNNaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RGZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgc25lYWt5LiAgUmVkdWNlIHRoZSBleHRlbnQgdGhhdCBpdCBpcyBjdXJyZW50bHkgYmVpbmdcbiAgICAgICAgICAgIC8vIHNlYXJjaGVkIHdoaWxlIHRoZSBSLVRyZWUgdHJhdmVyc2FsIHVzaW5nIHRoaXMgc2FtZSBleHRlbnQgb2JqZWN0XG4gICAgICAgICAgICAvLyBpcyBzdGlsbCBpbiBwcm9ncmVzcy4gIFRoaXMgaXMgc2FmZSBiZWNhdXNlIHRoZSBuZXcgZXh0ZW50IGlzXG4gICAgICAgICAgICAvLyBzdHJpY3RseSBjb250YWluZWQgYnkgdGhlIG9sZCBleHRlbnQuXG4gICAgICAgICAgICBjb25zdCBtaW5EaXN0YW5jZSA9IE1hdGguc3FydChtaW5TcXVhcmVkRGlzdGFuY2UpO1xuICAgICAgICAgICAgZXh0ZW50WzBdID0geCAtIG1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgZXh0ZW50WzFdID0geSAtIG1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgZXh0ZW50WzJdID0geCArIG1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgZXh0ZW50WzNdID0geSArIG1pbkRpc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RGZWF0dXJlO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBleHRlbnQgb2YgdGhlIGZlYXR1cmVzIGN1cnJlbnRseSBpbiB0aGUgc291cmNlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIHdoZW4gdGhlIHNvdXJjZSBpcyBjb25maWd1cmVkIHdpdGhcbiAgICogYHVzZVNwYXRpYWxJbmRleGAgc2V0IHRvIGBmYWxzZWAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD19IG9wdF9leHRlbnQgRGVzdGluYXRpb24gZXh0ZW50LiBJZiBwcm92aWRlZCwgbm8gbmV3IGV4dGVudFxuICAgKiAgICAgd2lsbCBiZSBjcmVhdGVkLiBJbnN0ZWFkLCB0aGF0IGV4dGVudCdzIGNvb3JkaW5hdGVzIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXh0ZW50KG9wdF9leHRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5nZXRFeHRlbnQob3B0X2V4dGVudCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXQgYSBmZWF0dXJlIGJ5IGl0cyBpZGVudGlmaWVyICh0aGUgdmFsdWUgcmV0dXJuZWQgYnkgZmVhdHVyZS5nZXRJZCgpKS5cbiAgICogTm90ZSB0aGF0IHRoZSBpbmRleCB0cmVhdHMgc3RyaW5nIGFuZCBudW1lcmljIGlkZW50aWZpZXJzIGFzIHRoZSBzYW1lLiAgU29cbiAgICogYHNvdXJjZS5nZXRGZWF0dXJlQnlJZCgyKWAgd2lsbCByZXR1cm4gYSBmZWF0dXJlIHdpdGggaWQgYCcyJ2Agb3IgYDJgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIEZlYXR1cmUgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBUaGUgZmVhdHVyZSAob3IgYG51bGxgIGlmIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEZlYXR1cmVCeUlkKGlkKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuaWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgcmV0dXJuIGZlYXR1cmUgIT09IHVuZGVmaW5lZCA/IGZlYXR1cmUgOiBudWxsO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0IHRoZSBmb3JtYXQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc291cmNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9mb3JtYXQvRmVhdHVyZS5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIGZlYXR1cmUgZm9ybWF0LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0XztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzb3VyY2UgY2FuIGhhdmUgb3ZlcmxhcHBpbmcgZ2VvbWV0cmllcy5cbiAgICovXG4gIGdldE92ZXJsYXBzKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXBzXztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXJsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNvdXJjZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfGltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZVVybEZ1bmN0aW9ufHVuZGVmaW5lZH0gVGhlIHVybC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VXJsKCkge1xuICAgIHJldHVybiB0aGlzLnVybF87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUZlYXR1cmVDaGFuZ2VfKGV2ZW50KSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQudGFyZ2V0KTtcbiAgICBjb25zdCBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGlmICghZ2VvbWV0cnkpIHtcbiAgICAgIGlmICghKGZlYXR1cmVLZXkgaW4gdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc18pKSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgICAgdGhpcy5mZWF0dXJlc1J0cmVlXy5yZW1vdmUoZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV0gPSBmZWF0dXJlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBleHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICAgIGlmIChmZWF0dXJlS2V5IGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzX1tmZWF0dXJlS2V5XTtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXNSdHJlZV8pIHtcbiAgICAgICAgICB0aGlzLmZlYXR1cmVzUnRyZWVfLmluc2VydChleHRlbnQsIGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlc1J0cmVlXykge1xuICAgICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8udXBkYXRlKGV4dGVudCwgZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWQgPSBmZWF0dXJlLmdldElkKCk7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHNpZCA9IGlkLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoZmVhdHVyZUtleSBpbiB0aGlzLnVuZGVmSWRJbmRleF8pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudW5kZWZJZEluZGV4X1tmZWF0dXJlS2V5XTtcbiAgICAgICAgdGhpcy5pZEluZGV4X1tzaWRdID0gZmVhdHVyZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlkSW5kZXhfW3NpZF0gIT09IGZlYXR1cmUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUZyb21JZEluZGV4XyhmZWF0dXJlKTtcbiAgICAgICAgICB0aGlzLmlkSW5kZXhfW3NpZF0gPSBmZWF0dXJlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKGZlYXR1cmVLZXkgaW4gdGhpcy51bmRlZklkSW5kZXhfKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21JZEluZGV4XyhmZWF0dXJlKTtcbiAgICAgICAgdGhpcy51bmRlZklkSW5kZXhfW2ZlYXR1cmVLZXldID0gZmVhdHVyZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBWZWN0b3JTb3VyY2VFdmVudChcbiAgICAgIFZlY3RvckV2ZW50VHlwZS5DSEFOR0VGRUFUVVJFLCBmZWF0dXJlKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSGFzIGZlYXR1cmUuXG4gICAqIEBhcGlcbiAgICovXG4gIGhhc0ZlYXR1cmUoZmVhdHVyZSkge1xuICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpO1xuICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaWQgaW4gdGhpcy5pZEluZGV4XztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFVpZChmZWF0dXJlKSBpbiB0aGlzLnVuZGVmSWRJbmRleF87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGVtcHR5LlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1J0cmVlXy5pc0VtcHR5KCkgJiYgaXNFbXB0eSh0aGlzLm51bGxHZW9tZXRyeUZlYXR1cmVzXyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICovXG4gIGxvYWRGZWF0dXJlcyhleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pIHtcbiAgICBjb25zdCBsb2FkZWRFeHRlbnRzUnRyZWUgPSB0aGlzLmxvYWRlZEV4dGVudHNSdHJlZV87XG4gICAgY29uc3QgZXh0ZW50c1RvTG9hZCA9IHRoaXMuc3RyYXRlZ3lfKGV4dGVudCwgcmVzb2x1dGlvbik7XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZXh0ZW50c1RvTG9hZC5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBleHRlbnRUb0xvYWQgPSBleHRlbnRzVG9Mb2FkW2ldO1xuICAgICAgY29uc3QgYWxyZWFkeUxvYWRlZCA9IGxvYWRlZEV4dGVudHNSdHJlZS5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50VG9Mb2FkLFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHt7ZXh0ZW50OiBpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fX0gb2JqZWN0IE9iamVjdC5cbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gY29udGFpbnNFeHRlbnQob2JqZWN0LmV4dGVudCwgZXh0ZW50VG9Mb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAoIWFscmVhZHlMb2FkZWQpIHtcbiAgICAgICAgdGhpcy5sb2FkZXJfLmNhbGwodGhpcywgZXh0ZW50VG9Mb2FkLCByZXNvbHV0aW9uLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgbG9hZGVkRXh0ZW50c1J0cmVlLmluc2VydChleHRlbnRUb0xvYWQsIHtleHRlbnQ6IGV4dGVudFRvTG9hZC5zbGljZSgpfSk7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRoaXMubG9hZGVyXyAhPT0gVk9JRDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXh0ZW50IGZyb20gdGhlIGxpc3Qgb2YgbG9hZGVkIGV4dGVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlTG9hZGVkRXh0ZW50KGV4dGVudCkge1xuICAgIGNvbnN0IGxvYWRlZEV4dGVudHNSdHJlZSA9IHRoaXMubG9hZGVkRXh0ZW50c1J0cmVlXztcbiAgICBsZXQgb2JqO1xuICAgIGxvYWRlZEV4dGVudHNSdHJlZS5mb3JFYWNoSW5FeHRlbnQoZXh0ZW50LCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChlcXVhbHMob2JqZWN0LmV4dGVudCwgZXh0ZW50KSkge1xuICAgICAgICBvYmogPSBvYmplY3Q7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChvYmopIHtcbiAgICAgIGxvYWRlZEV4dGVudHNSdHJlZS5yZW1vdmUob2JqKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzaW5nbGUgZmVhdHVyZSBmcm9tIHRoZSBzb3VyY2UuICBJZiB5b3Ugd2FudCB0byByZW1vdmUgYWxsIGZlYXR1cmVzXG4gICAqIGF0IG9uY2UsIHVzZSB0aGUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yflZlY3RvclNvdXJjZSNjbGVhciAjY2xlYXIoKX0gbWV0aG9kXG4gICAqIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUgdG8gcmVtb3ZlLlxuICAgKiBAYXBpXG4gICAqL1xuICByZW1vdmVGZWF0dXJlKGZlYXR1cmUpIHtcbiAgICBjb25zdCBmZWF0dXJlS2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgIGlmIChmZWF0dXJlS2V5IGluIHRoaXMubnVsbEdlb21ldHJ5RmVhdHVyZXNfKSB7XG4gICAgICBkZWxldGUgdGhpcy5udWxsR2VvbWV0cnlGZWF0dXJlc19bZmVhdHVyZUtleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzUnRyZWVfKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXNSdHJlZV8ucmVtb3ZlKGZlYXR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbW92ZUZlYXR1cmVJbnRlcm5hbChmZWF0dXJlKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmZWF0dXJlIHdpdGhvdXQgZmlyaW5nIGEgYGNoYW5nZWAgZXZlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHJlbW92ZUZlYXR1cmVJbnRlcm5hbChmZWF0dXJlKSB7XG4gICAgY29uc3QgZmVhdHVyZUtleSA9IGdldFVpZChmZWF0dXJlKTtcbiAgICB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XS5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIGRlbGV0ZSB0aGlzLmZlYXR1cmVDaGFuZ2VLZXlzX1tmZWF0dXJlS2V5XTtcbiAgICBjb25zdCBpZCA9IGZlYXR1cmUuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHRoaXMuaWRJbmRleF9baWQudG9TdHJpbmcoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnVuZGVmSWRJbmRleF9bZmVhdHVyZUtleV07XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVmVjdG9yU291cmNlRXZlbnQoXG4gICAgICBWZWN0b3JFdmVudFR5cGUuUkVNT1ZFRkVBVFVSRSwgZmVhdHVyZSkpO1xuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGEgZmVhdHVyZSBmcm9tIHRoZSBpZCBpbmRleC4gIENhbGxlZCBpbnRlcm5hbGx5IHdoZW4gdGhlIGZlYXR1cmUgaWRcbiAgICogbWF5IGhhdmUgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgVGhlIGZlYXR1cmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJlbW92ZWQgdGhlIGZlYXR1cmUgZnJvbSB0aGUgaW5kZXguXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW1vdmVGcm9tSWRJbmRleF8oZmVhdHVyZSkge1xuICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmlkSW5kZXhfKSB7XG4gICAgICBpZiAodGhpcy5pZEluZGV4X1tpZF0gPT09IGZlYXR1cmUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWRJbmRleF9baWRdO1xuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cblxuICAvKipcbiAgICogU2V0IHRoZSBuZXcgbG9hZGVyIG9mIHRoZSBzb3VyY2UuIFRoZSBuZXh0IGxvYWRGZWF0dXJlcyBjYWxsIHdpbGwgdXNlIHRoZVxuICAgKiBuZXcgbG9hZGVyLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2ZlYXR1cmVsb2FkZXIuanNcIikuRmVhdHVyZUxvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgdG8gc2V0LlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMb2FkZXIobG9hZGVyKSB7XG4gICAgdGhpcy5sb2FkZXJfID0gbG9hZGVyO1xuICB9XG5cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JTb3VyY2U7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Q0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFyREE7QUF1REE7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FDbElBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7OztBQUVBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQW5CQTtBQXFCQTs7Ozs7Ozs7Ozs7QUMxREE7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7OztBQU9BO0FBNUJBOzs7Ozs7QUNQQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQU1BOzs7QUFHQTtBQUVBOzs7Ozs7O0FBTUE7QUFFQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFHQTs7Ozs7OztBQUtBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FDalBBO0FBQUE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUFBO0FBQUE7QUFNQTtBQUVBOzs7Ozs7O0FBT0E7Ozs7O0FBRUE7O0FBakJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUhBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7Ozs7OztBQVdBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUVBOzs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7O0FBT0E7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBTUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBR0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQWRBO0FBQUE7QUFBQTtBQWdCQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBOztBQTV6QkE7QUFDQTtBQSt6QkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///83\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/LayerType.js\nvar LayerType = __webpack_require__(53);\n\n// EXTERNAL MODULE: ./node_modules/ol/layer/Layer.js\nvar layer_Layer = __webpack_require__(55);\n\n// CONCATENATED MODULE: ./node_modules/ol/layer/VectorRenderType.js\n/**\n * @module ol/layer/VectorRenderType\n */\n\n/**\n * @enum {string}\n * Render mode for vector layers:\n *  * `\'image\'`: Vector layers are rendered as images. Great performance, but\n *    point symbols and texts are always rotated with the view and pixels are\n *    scaled during zoom animations.\n *  * `\'vector\'`: Vector layers are rendered as vectors. Most accurate rendering\n *    even during animations, but slower performance.\n * @api\n */\n/* harmony default export */ var VectorRenderType = ({\n  IMAGE: \'image\',\n  VECTOR: \'vector\'\n});\n// EXTERNAL MODULE: ./node_modules/ol/obj.js\nvar obj = __webpack_require__(12);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/Style.js\nvar Style = __webpack_require__(72);\n\n// CONCATENATED MODULE: ./node_modules/ol/layer/Vector.js\n/**\n * @module ol/layer/Vector\n */\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map\'s `layers` collection, or `Infinity` when the layer\'s `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n * renderer when getting features from the vector source for the rendering or hit-detection.\n * Recommended value: the size of the largest symbol, line width or label.\n * @property {import("./VectorRenderType.js").default|string} [renderMode=\'vector\'] Render mode for vector layers:\n *  * `\'image\'`: Vector layers are rendered as images. Great performance, but point symbols and\n *    texts are always rotated with the view and pixels are scaled during zoom animations.\n *  * `\'vector\'`: Vector layers are rendered as vectors. Most accurate rendering even during\n *    animations, but slower performance.\n * @property {import("../source/Vector.js").default} [source] Source.\n * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map#addLayer}.\n * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all\n * image and text styles, and the priority is defined by the z-index of the style. Lower z-index\n * means higher priority.\n * @property {import("../style/Style.js").StyleLike} [style] Layer style. See\n * {@link module:ol/style} for default style which will be used if this is not defined.\n * @property {boolean} [updateWhileAnimating=false] When set to `true` and `renderMode`\n * is `vector`, feature batches will be recreated during animations. This means that no\n * vectors will be shown clipped, but the setting will have a performance impact for large\n * amounts of vector data. When set to `false`, batches will be recreated when no animation\n * is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true` and `renderMode`\n * is `vector`, feature batches will be recreated during interactions. See also\n * `updateWhileAnimating`.\n */\n\n/**\n * @enum {string}\n * @private\n */\n\nvar Property = {\n  RENDER_ORDER: \'renderOrder\'\n};\n/**\n * @classdesc\n * Vector data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: \'My Title\'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @api\n */\n\nvar Vector_VectorLayer =\n/*@__PURE__*/\nfunction (Layer) {\n  function VectorLayer(opt_options) {\n    var options = opt_options ? opt_options :\n    /** @type {Options} */\n    {};\n    var baseOptions = Object(obj["a" /* assign */])({}, options);\n    delete baseOptions.style;\n    delete baseOptions.renderBuffer;\n    delete baseOptions.updateWhileAnimating;\n    delete baseOptions.updateWhileInteracting;\n    Layer.call(this, baseOptions);\n    /**\n    * @private\n    * @type {boolean}\n    */\n\n    this.declutter_ = options.declutter !== undefined ? options.declutter : false;\n    /**\n    * @type {number}\n    * @private\n    */\n\n    this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;\n    /**\n    * User provided style.\n    * @type {import("../style/Style.js").StyleLike}\n    * @private\n    */\n\n    this.style_ = null;\n    /**\n    * Style function for use within the library.\n    * @type {import("../style/Style.js").StyleFunction|undefined}\n    * @private\n    */\n\n    this.styleFunction_ = undefined;\n    this.setStyle(options.style);\n    /**\n    * @type {boolean}\n    * @private\n    */\n\n    this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;\n    /**\n    * @type {boolean}\n    * @private\n    */\n\n    this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;\n    /**\n    * @private\n    * @type {import("./VectorTileRenderType.js").default|string}\n    */\n\n    this.renderMode_ = options.renderMode || VectorRenderType.VECTOR;\n    /**\n    * The layer type.\n    * @protected\n    * @type {import("../LayerType.js").default}\n    */\n\n    this.type = LayerType["a" /* default */].VECTOR;\n  }\n\n  if (Layer) VectorLayer.__proto__ = Layer;\n  VectorLayer.prototype = Object.create(Layer && Layer.prototype);\n  VectorLayer.prototype.constructor = VectorLayer;\n  /**\n  * @return {boolean} Declutter.\n  */\n\n  VectorLayer.prototype.getDeclutter = function getDeclutter() {\n    return this.declutter_;\n  };\n  /**\n  * @param {boolean} declutter Declutter.\n  */\n\n\n  VectorLayer.prototype.setDeclutter = function setDeclutter(declutter) {\n    this.declutter_ = declutter;\n  };\n  /**\n  * @return {number|undefined} Render buffer.\n  */\n\n\n  VectorLayer.prototype.getRenderBuffer = function getRenderBuffer() {\n    return this.renderBuffer_;\n  };\n  /**\n  * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render\n  *     order.\n  */\n\n\n  VectorLayer.prototype.getRenderOrder = function getRenderOrder() {\n    return (\n      /** @type {import("../render.js").OrderFunction|null|undefined} */\n      this.get(Property.RENDER_ORDER)\n    );\n  };\n  /**\n  * Get the style for features.  This returns whatever was passed to the `style`\n  * option at construction or to the `setStyle` method.\n  * @return {import("../style/Style.js").StyleLike}\n  *     Layer style.\n  * @api\n  */\n\n\n  VectorLayer.prototype.getStyle = function getStyle() {\n    return this.style_;\n  };\n  /**\n  * Get the style function.\n  * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.\n  * @api\n  */\n\n\n  VectorLayer.prototype.getStyleFunction = function getStyleFunction() {\n    return this.styleFunction_;\n  };\n  /**\n  * @return {boolean} Whether the rendered layer should be updated while\n  *     animating.\n  */\n\n\n  VectorLayer.prototype.getUpdateWhileAnimating = function getUpdateWhileAnimating() {\n    return this.updateWhileAnimating_;\n  };\n  /**\n  * @return {boolean} Whether the rendered layer should be updated while\n  *     interacting.\n  */\n\n\n  VectorLayer.prototype.getUpdateWhileInteracting = function getUpdateWhileInteracting() {\n    return this.updateWhileInteracting_;\n  };\n  /**\n  * @param {import("../render.js").OrderFunction|null|undefined} renderOrder\n  *     Render order.\n  */\n\n\n  VectorLayer.prototype.setRenderOrder = function setRenderOrder(renderOrder) {\n    this.set(Property.RENDER_ORDER, renderOrder);\n  };\n  /**\n  * Set the style for features.  This can be a single style object, an array\n  * of styles, or a function that takes a feature and resolution and returns\n  * an array of styles. If it is `undefined` the default style is used. If\n  * it is `null` the layer has no style (a `null` style), so only features\n  * that have their own styles will be rendered in the layer. See\n  * {@link module:ol/style} for information on the default style.\n  * @param {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null|undefined} style Layer style.\n  * @api\n  */\n\n\n  VectorLayer.prototype.setStyle = function setStyle(style) {\n    this.style_ = style !== undefined ? style : Style["createDefaultStyle"];\n    this.styleFunction_ = style === null ? undefined : Object(Style["toFunction"])(this.style_);\n    this.changed();\n  };\n  /**\n  * @return {import("./VectorRenderType.js").default|string} The render mode.\n  */\n\n\n  VectorLayer.prototype.getRenderMode = function getRenderMode() {\n    return this.renderMode_;\n  };\n\n  return VectorLayer;\n}(layer_Layer["a" /* default */]);\n/**\n * Return the associated {@link module:ol/source/Vector vectorsource} of the layer.\n * @function\n * @return {import("../source/Vector.js").default} Source.\n * @api\n */\n\n\nVector_VectorLayer.prototype.getSource;\n/* harmony default export */ var Vector = __webpack_exports__["default"] = (Vector_VectorLayer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2xheWVyL1ZlY3RvclJlbmRlclR5cGUuanM/YmU1YSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2xheWVyL1ZlY3Rvci5qcz9mYzBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9WZWN0b3JSZW5kZXJUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogUmVuZGVyIG1vZGUgZm9yIHZlY3RvciBsYXllcnM6XG4gKiAgKiBgJ2ltYWdlJ2A6IFZlY3RvciBsYXllcnMgYXJlIHJlbmRlcmVkIGFzIGltYWdlcy4gR3JlYXQgcGVyZm9ybWFuY2UsIGJ1dFxuICogICAgcG9pbnQgc3ltYm9scyBhbmQgdGV4dHMgYXJlIGFsd2F5cyByb3RhdGVkIHdpdGggdGhlIHZpZXcgYW5kIHBpeGVscyBhcmVcbiAqICAgIHNjYWxlZCBkdXJpbmcgem9vbSBhbmltYXRpb25zLlxuICogICogYCd2ZWN0b3InYDogVmVjdG9yIGxheWVycyBhcmUgcmVuZGVyZWQgYXMgdmVjdG9ycy4gTW9zdCBhY2N1cmF0ZSByZW5kZXJpbmdcbiAqICAgIGV2ZW4gZHVyaW5nIGFuaW1hdGlvbnMsIGJ1dCBzbG93ZXIgcGVyZm9ybWFuY2UuXG4gKiBAYXBpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgSU1BR0U6ICdpbWFnZScsXG4gIFZFQ1RPUjogJ3ZlY3Rvcidcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVmVjdG9yXG4gKi9cbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBWZWN0b3JSZW5kZXJUeXBlIGZyb20gJy4vVmVjdG9yUmVuZGVyVHlwZS5qcyc7XG5pbXBvcnQge2Fzc2lnbn0gZnJvbSAnLi4vb2JqLmpzJztcbmltcG9ydCB7Y3JlYXRlRGVmYXVsdFN0eWxlLCB0b0Z1bmN0aW9uIGFzIHRvU3R5bGVGdW5jdGlvbn0gZnJvbSAnLi4vc3R5bGUvU3R5bGUuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvcGFjaXR5PTFdIE9wYWNpdHkgKDAsIDEpLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdmlzaWJsZT10cnVlXSBWaXNpYmlsaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBbZXh0ZW50XSBUaGUgYm91bmRpbmcgZXh0ZW50IGZvciBsYXllciByZW5kZXJpbmcuICBUaGUgbGF5ZXIgd2lsbCBub3QgYmVcbiAqIHJlbmRlcmVkIG91dHNpZGUgb2YgdGhpcyBleHRlbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleF0gVGhlIHotaW5kZXggZm9yIGxheWVyIHJlbmRlcmluZy4gIEF0IHJlbmRlcmluZyB0aW1lLCB0aGUgbGF5ZXJzXG4gKiB3aWxsIGJlIG9yZGVyZWQsIGZpcnN0IGJ5IFotaW5kZXggYW5kIHRoZW4gYnkgcG9zaXRpb24uIFdoZW4gYHVuZGVmaW5lZGAsIGEgYHpJbmRleGAgb2YgMCBpcyBhc3N1bWVkXG4gKiBmb3IgbGF5ZXJzIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBtYXAncyBgbGF5ZXJzYCBjb2xsZWN0aW9uLCBvciBgSW5maW5pdHlgIHdoZW4gdGhlIGxheWVyJ3MgYHNldE1hcCgpYFxuICogbWV0aG9kIHdhcyB1c2VkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uXSBUaGUgbWluaW11bSByZXNvbHV0aW9uIChpbmNsdXNpdmUpIGF0IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbCBiZVxuICogdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiAoZXhjbHVzaXZlKSBiZWxvdyB3aGljaCB0aGlzIGxheWVyIHdpbGxcbiAqIGJlIHZpc2libGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufSBbcmVuZGVyT3JkZXJdIFJlbmRlciBvcmRlci4gRnVuY3Rpb24gdG8gYmUgdXNlZCB3aGVuIHNvcnRpbmdcbiAqIGZlYXR1cmVzIGJlZm9yZSByZW5kZXJpbmcuIEJ5IGRlZmF1bHQgZmVhdHVyZXMgYXJlIGRyYXduIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXJlIGNyZWF0ZWQuIFVzZVxuICogYG51bGxgIHRvIGF2b2lkIHRoZSBzb3J0LCBidXQgZ2V0IGFuIHVuZGVmaW5lZCBkcmF3IG9yZGVyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZW5kZXJCdWZmZXI9MTAwXSBUaGUgYnVmZmVyIGluIHBpeGVscyBhcm91bmQgdGhlIHZpZXdwb3J0IGV4dGVudCB1c2VkIGJ5IHRoZVxuICogcmVuZGVyZXIgd2hlbiBnZXR0aW5nIGZlYXR1cmVzIGZyb20gdGhlIHZlY3RvciBzb3VyY2UgZm9yIHRoZSByZW5kZXJpbmcgb3IgaGl0LWRldGVjdGlvbi5cbiAqIFJlY29tbWVuZGVkIHZhbHVlOiB0aGUgc2l6ZSBvZiB0aGUgbGFyZ2VzdCBzeW1ib2wsIGxpbmUgd2lkdGggb3IgbGFiZWwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVmVjdG9yUmVuZGVyVHlwZS5qc1wiKS5kZWZhdWx0fHN0cmluZ30gW3JlbmRlck1vZGU9J3ZlY3RvciddIFJlbmRlciBtb2RlIGZvciB2ZWN0b3IgbGF5ZXJzOlxuICogICogYCdpbWFnZSdgOiBWZWN0b3IgbGF5ZXJzIGFyZSByZW5kZXJlZCBhcyBpbWFnZXMuIEdyZWF0IHBlcmZvcm1hbmNlLCBidXQgcG9pbnQgc3ltYm9scyBhbmRcbiAqICAgIHRleHRzIGFyZSBhbHdheXMgcm90YXRlZCB3aXRoIHRoZSB2aWV3IGFuZCBwaXhlbHMgYXJlIHNjYWxlZCBkdXJpbmcgem9vbSBhbmltYXRpb25zLlxuICogICogYCd2ZWN0b3InYDogVmVjdG9yIGxheWVycyBhcmUgcmVuZGVyZWQgYXMgdmVjdG9ycy4gTW9zdCBhY2N1cmF0ZSByZW5kZXJpbmcgZXZlbiBkdXJpbmdcbiAqICAgIGFuaW1hdGlvbnMsIGJ1dCBzbG93ZXIgcGVyZm9ybWFuY2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NvdXJjZS9WZWN0b3IuanNcIikuZGVmYXVsdH0gW3NvdXJjZV0gU291cmNlLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gW21hcF0gU2V0cyB0aGUgbGF5ZXIgYXMgb3ZlcmxheSBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsIG5vdCBtYW5hZ2VcbiAqIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIHRlbXBvcmFyeSBsYXllcnMuIFRoZSBzdGFuZGFyZCB3YXkgdG8gYWRkIGEgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwIGlzIHRvXG4gKiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9NYXAjYWRkTGF5ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVjbHV0dGVyPWZhbHNlXSBEZWNsdXR0ZXIgaW1hZ2VzIGFuZCB0ZXh0LiBEZWNsdXR0ZXJpbmcgaXMgYXBwbGllZCB0byBhbGxcbiAqIGltYWdlIGFuZCB0ZXh0IHN0eWxlcywgYW5kIHRoZSBwcmlvcml0eSBpcyBkZWZpbmVkIGJ5IHRoZSB6LWluZGV4IG9mIHRoZSBzdHlsZS4gTG93ZXIgei1pbmRleFxuICogbWVhbnMgaGlnaGVyIHByaW9yaXR5LlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5TdHlsZUxpa2V9IFtzdHlsZV0gTGF5ZXIgc3R5bGUuIFNlZVxuICoge0BsaW5rIG1vZHVsZTpvbC9zdHlsZX0gZm9yIGRlZmF1bHQgc3R5bGUgd2hpY2ggd2lsbCBiZSB1c2VkIGlmIHRoaXMgaXMgbm90IGRlZmluZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUFuaW1hdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIGFuZCBgcmVuZGVyTW9kZWBcbiAqIGlzIGB2ZWN0b3JgLCBmZWF0dXJlIGJhdGNoZXMgd2lsbCBiZSByZWNyZWF0ZWQgZHVyaW5nIGFuaW1hdGlvbnMuIFRoaXMgbWVhbnMgdGhhdCBub1xuICogdmVjdG9ycyB3aWxsIGJlIHNob3duIGNsaXBwZWQsIGJ1dCB0aGUgc2V0dGluZyB3aWxsIGhhdmUgYSBwZXJmb3JtYW5jZSBpbXBhY3QgZm9yIGxhcmdlXG4gKiBhbW91bnRzIG9mIHZlY3RvciBkYXRhLiBXaGVuIHNldCB0byBgZmFsc2VgLCBiYXRjaGVzIHdpbGwgYmUgcmVjcmVhdGVkIHdoZW4gbm8gYW5pbWF0aW9uXG4gKiBpcyBhY3RpdmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1cGRhdGVXaGlsZUludGVyYWN0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAgYW5kIGByZW5kZXJNb2RlYFxuICogaXMgYHZlY3RvcmAsIGZlYXR1cmUgYmF0Y2hlcyB3aWxsIGJlIHJlY3JlYXRlZCBkdXJpbmcgaW50ZXJhY3Rpb25zLiBTZWUgYWxzb1xuICogYHVwZGF0ZVdoaWxlQW5pbWF0aW5nYC5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFByb3BlcnR5ID0ge1xuICBSRU5ERVJfT1JERVI6ICdyZW5kZXJPcmRlcidcbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBWZWN0b3IgZGF0YSB0aGF0IGlzIHJlbmRlcmVkIGNsaWVudC1zaWRlLlxuICogTm90ZSB0aGF0IGFueSBwcm9wZXJ0eSBzZXQgaW4gdGhlIG9wdGlvbnMgaXMgc2V0IGFzIGEge0BsaW5rIG1vZHVsZTpvbC9PYmplY3R+QmFzZU9iamVjdH1cbiAqIHByb3BlcnR5IG9uIHRoZSBsYXllciBvYmplY3Q7IGZvciBleGFtcGxlLCBzZXR0aW5nIGB0aXRsZTogJ015IFRpdGxlJ2AgaW4gdGhlXG4gKiBvcHRpb25zIG1lYW5zIHRoYXQgYHRpdGxlYCBpcyBvYnNlcnZhYmxlLCBhbmQgaGFzIGdldC9zZXQgYWNjZXNzb3JzLlxuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgVmVjdG9yTGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X29wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gb3B0X29wdGlvbnMgP1xuICAgICAgb3B0X29wdGlvbnMgOiAvKiogQHR5cGUge09wdGlvbnN9ICovICh7fSk7XG5cbiAgICBjb25zdCBiYXNlT3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgICBkZWxldGUgYmFzZU9wdGlvbnMuc3R5bGU7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnJlbmRlckJ1ZmZlcjtcbiAgICBkZWxldGUgYmFzZU9wdGlvbnMudXBkYXRlV2hpbGVBbmltYXRpbmc7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLnVwZGF0ZVdoaWxlSW50ZXJhY3Rpbmc7XG4gICAgc3VwZXIoYmFzZU9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlcl8gPSBvcHRpb25zLmRlY2x1dHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWNsdXR0ZXIgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnJlbmRlckJ1ZmZlcl8gPSBvcHRpb25zLnJlbmRlckJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucmVuZGVyQnVmZmVyIDogMTAwO1xuXG4gICAgLyoqXG4gICAgKiBVc2VyIHByb3ZpZGVkIHN0eWxlLlxuICAgICogQHR5cGUge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlTGlrZX1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnN0eWxlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAqIFN0eWxlIGZ1bmN0aW9uIGZvciB1c2Ugd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICogQHR5cGUge2ltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258dW5kZWZpbmVkfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuc3R5bGVGdW5jdGlvbl8gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnNldFN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnVwZGF0ZVdoaWxlQW5pbWF0aW5nXyA9IG9wdGlvbnMudXBkYXRlV2hpbGVBbmltYXRpbmcgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnVwZGF0ZVdoaWxlQW5pbWF0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMudXBkYXRlV2hpbGVJbnRlcmFjdGluZ18gPSBvcHRpb25zLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcgOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1ZlY3RvclRpbGVSZW5kZXJUeXBlLmpzXCIpLmRlZmF1bHR8c3RyaW5nfVxuICAgICovXG4gICAgdGhpcy5yZW5kZXJNb2RlXyA9IG9wdGlvbnMucmVuZGVyTW9kZSB8fCBWZWN0b3JSZW5kZXJUeXBlLlZFQ1RPUjtcblxuICAgIC8qKlxuICAgICogVGhlIGxheWVyIHR5cGUuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTGF5ZXJUeXBlLmpzXCIpLmRlZmF1bHR9XG4gICAgKi9cbiAgICB0aGlzLnR5cGUgPSBMYXllclR5cGUuVkVDVE9SO1xuXG4gIH1cblxuICAvKipcbiAgKiBAcmV0dXJuIHtib29sZWFufSBEZWNsdXR0ZXIuXG4gICovXG4gIGdldERlY2x1dHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsdXR0ZXJfO1xuICB9XG5cbiAgLyoqXG4gICogQHBhcmFtIHtib29sZWFufSBkZWNsdXR0ZXIgRGVjbHV0dGVyLlxuICAqL1xuICBzZXREZWNsdXR0ZXIoZGVjbHV0dGVyKSB7XG4gICAgdGhpcy5kZWNsdXR0ZXJfID0gZGVjbHV0dGVyO1xuICB9XG5cbiAgLyoqXG4gICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gUmVuZGVyIGJ1ZmZlci5cbiAgKi9cbiAgZ2V0UmVuZGVyQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlckJ1ZmZlcl87XG4gIH1cblxuICAvKipcbiAgKiBAcmV0dXJuIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IG51bWJlcnxudWxsfHVuZGVmaW5lZH0gUmVuZGVyXG4gICogICAgIG9yZGVyLlxuICAqL1xuICBnZXRSZW5kZXJPcmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcmVuZGVyLmpzXCIpLk9yZGVyRnVuY3Rpb258bnVsbHx1bmRlZmluZWR9ICovICh0aGlzLmdldChQcm9wZXJ0eS5SRU5ERVJfT1JERVIpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgKiBHZXQgdGhlIHN0eWxlIGZvciBmZWF0dXJlcy4gIFRoaXMgcmV0dXJucyB3aGF0ZXZlciB3YXMgcGFzc2VkIHRvIHRoZSBgc3R5bGVgXG4gICogb3B0aW9uIGF0IGNvbnN0cnVjdGlvbiBvciB0byB0aGUgYHNldFN0eWxlYCBtZXRob2QuXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVMaWtlfVxuICAqICAgICBMYXllciBzdHlsZS5cbiAgKiBAYXBpXG4gICovXG4gIGdldFN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlXztcbiAgfVxuXG4gIC8qKlxuICAqIEdldCB0aGUgc3R5bGUgZnVuY3Rpb24uXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuU3R5bGVGdW5jdGlvbnx1bmRlZmluZWR9IExheWVyIHN0eWxlIGZ1bmN0aW9uLlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0U3R5bGVGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZUZ1bmN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlbmRlcmVkIGxheWVyIHNob3VsZCBiZSB1cGRhdGVkIHdoaWxlXG4gICogICAgIGFuaW1hdGluZy5cbiAgKi9cbiAgZ2V0VXBkYXRlV2hpbGVBbmltYXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlV2hpbGVBbmltYXRpbmdfO1xuICB9XG5cbiAgLyoqXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVuZGVyZWQgbGF5ZXIgc2hvdWxkIGJlIHVwZGF0ZWQgd2hpbGVcbiAgKiAgICAgaW50ZXJhY3RpbmcuXG4gICovXG4gIGdldFVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlV2hpbGVJbnRlcmFjdGluZ187XG4gIH1cblxuICAvKipcbiAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufG51bGx8dW5kZWZpbmVkfSByZW5kZXJPcmRlclxuICAqICAgICBSZW5kZXIgb3JkZXIuXG4gICovXG4gIHNldFJlbmRlck9yZGVyKHJlbmRlck9yZGVyKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuUkVOREVSX09SREVSLCByZW5kZXJPcmRlcik7XG4gIH1cblxuICAvKipcbiAgKiBTZXQgdGhlIHN0eWxlIGZvciBmZWF0dXJlcy4gIFRoaXMgY2FuIGJlIGEgc2luZ2xlIHN0eWxlIG9iamVjdCwgYW4gYXJyYXlcbiAgKiBvZiBzdHlsZXMsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGZlYXR1cmUgYW5kIHJlc29sdXRpb24gYW5kIHJldHVybnNcbiAgKiBhbiBhcnJheSBvZiBzdHlsZXMuIElmIGl0IGlzIGB1bmRlZmluZWRgIHRoZSBkZWZhdWx0IHN0eWxlIGlzIHVzZWQuIElmXG4gICogaXQgaXMgYG51bGxgIHRoZSBsYXllciBoYXMgbm8gc3R5bGUgKGEgYG51bGxgIHN0eWxlKSwgc28gb25seSBmZWF0dXJlc1xuICAqIHRoYXQgaGF2ZSB0aGVpciBvd24gc3R5bGVzIHdpbGwgYmUgcmVuZGVyZWQgaW4gdGhlIGxheWVyLiBTZWVcbiAgKiB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlfSBmb3IgaW5mb3JtYXRpb24gb24gdGhlIGRlZmF1bHQgc3R5bGUuXG4gICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fEFycmF5PGltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fGltcG9ydChcIi4uL3N0eWxlL1N0eWxlLmpzXCIpLlN0eWxlRnVuY3Rpb258bnVsbHx1bmRlZmluZWR9IHN0eWxlIExheWVyIHN0eWxlLlxuICAqIEBhcGlcbiAgKi9cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlXyA9IHN0eWxlICE9PSB1bmRlZmluZWQgPyBzdHlsZSA6IGNyZWF0ZURlZmF1bHRTdHlsZTtcbiAgICB0aGlzLnN0eWxlRnVuY3Rpb25fID0gc3R5bGUgPT09IG51bGwgP1xuICAgICAgdW5kZWZpbmVkIDogdG9TdHlsZUZ1bmN0aW9uKHRoaXMuc3R5bGVfKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAqIEByZXR1cm4ge2ltcG9ydChcIi4vVmVjdG9yUmVuZGVyVHlwZS5qc1wiKS5kZWZhdWx0fHN0cmluZ30gVGhlIHJlbmRlciBtb2RlLlxuICAqL1xuICBnZXRSZW5kZXJNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlck1vZGVfO1xuICB9XG59XG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGFzc29jaWF0ZWQge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVmVjdG9yIHZlY3RvcnNvdXJjZX0gb2YgdGhlIGxheWVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9IFNvdXJjZS5cbiAqIEBhcGlcbiAqL1xuVmVjdG9yTGF5ZXIucHJvdG90eXBlLmdldFNvdXJjZTtcblxuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JMYXllcjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBRkE7Ozs7Ozs7O0FDZEE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFEQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7O0FBY0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7OztBQVFBOzs7Ozs7O0FBT0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU9BOzs7Ozs7QUFPQTs7Ozs7OztBQU9BOzs7OztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBR0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBNUtBOzs7Ozs7Ozs7QUFxTEE7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84\n')},function(module,exports){eval("module.exports = (window.proj4 || {defs: function(){}});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCIod2luZG93LnByb2o0IHx8IHtkZWZzOiBmdW5jdGlvbigpe319KVwiP2Y4ZTAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAod2luZG93LnByb2o0IHx8IHtkZWZzOiBmdW5jdGlvbigpe319KTsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///85\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export unByKey */\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\n/**\n * @module ol/Observable\n */\n\n\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link module:ol/Observable~Observable#changed}.\n *\n * @fires import("./events/Event.js").Event\n * @api\n */\n\nvar Observable =\n/*@__PURE__*/\nfunction (EventTarget) {\n  function Observable() {\n    EventTarget.call(this);\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.revision_ = 0;\n  }\n\n  if (EventTarget) Observable.__proto__ = EventTarget;\n  Observable.prototype = Object.create(EventTarget && EventTarget.prototype);\n  Observable.prototype.constructor = Observable;\n  /**\n   * Increases the revision counter and dispatches a \'change\' event.\n   * @api\n   */\n\n  Observable.prototype.changed = function changed() {\n    ++this.revision_;\n    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].CHANGE);\n  };\n  /**\n   * Get the version number for this object.  Each time the object is modified,\n   * its version number will be incremented.\n   * @return {number} Revision.\n   * @api\n   */\n\n\n  Observable.prototype.getRevision = function getRevision() {\n    return this.revision_;\n  };\n  /**\n   * Listen for a certain type of event.\n   * @param {string|Array<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n\n\n  Observable.prototype.on = function on(type, listener) {\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* listen */ "a"])(this, type[i], listener);\n      }\n\n      return keys;\n    } else {\n      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* listen */ "a"])(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n  /**\n   * Listen once for a certain type of event.\n   * @param {string|Array<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n\n\n  Observable.prototype.once = function once(type, listener) {\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        keys[i] = Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* listenOnce */ "b"])(this, type[i], listener);\n      }\n\n      return keys;\n    } else {\n      return Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* listenOnce */ "b"])(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n  /**\n   * Unlisten for a certain type of event.\n   * @param {string|Array<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @api\n   */\n\n\n  Observable.prototype.un = function un(type, listener) {\n    if (Array.isArray(type)) {\n      for (var i = 0, ii = type.length; i < ii; ++i) {\n        Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* unlisten */ "c"])(this, type[i], listener);\n      }\n\n      return;\n    } else {\n      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* unlisten */ "c"])(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n\n  return Observable;\n}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\n\n\nfunction unByKey(key) {\n  if (Array.isArray(key)) {\n    for (var i = 0, ii = key.length; i < ii; ++i) {\n      Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* unlistenByKey */ "e"])(key[i]);\n    }\n  } else {\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_0__[/* unlistenByKey */ "e"])(\n    /** @type {import("./events.js").EventsKey} */\n    key);\n  }\n}\n/* harmony default export */ __webpack_exports__["a"] = (Observable);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL09ic2VydmFibGUuanM/YjNkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvT2JzZXJ2YWJsZVxuICovXG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleSwgdW5saXN0ZW4sIGxpc3Rlbk9uY2V9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEFuIGV2ZW50IHRhcmdldCBwcm92aWRpbmcgY29udmVuaWVudCBtZXRob2RzIGZvciBsaXN0ZW5lciByZWdpc3RyYXRpb25cbiAqIGFuZCB1bnJlZ2lzdHJhdGlvbi4gQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIGFsd2F5cyBhdmFpbGFibGUgdGhyb3VnaFxuICoge0BsaW5rIG1vZHVsZTpvbC9PYnNlcnZhYmxlfk9ic2VydmFibGUjY2hhbmdlZH0uXG4gKlxuICogQGZpcmVzIGltcG9ydChcIi4vZXZlbnRzL0V2ZW50LmpzXCIpLkV2ZW50XG4gKiBAYXBpXG4gKi9cbmNsYXNzIE9ic2VydmFibGUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJldmlzaW9uXyA9IDA7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZWFzZXMgdGhlIHJldmlzaW9uIGNvdW50ZXIgYW5kIGRpc3BhdGNoZXMgYSAnY2hhbmdlJyBldmVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgY2hhbmdlZCgpIHtcbiAgICArK3RoaXMucmV2aXNpb25fO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZlcnNpb24gbnVtYmVyIGZvciB0aGlzIG9iamVjdC4gIEVhY2ggdGltZSB0aGUgb2JqZWN0IGlzIG1vZGlmaWVkLFxuICAgKiBpdHMgdmVyc2lvbiBudW1iZXIgd2lsbCBiZSBpbmNyZW1lbnRlZC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSZXZpc2lvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmV2aXNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2aXNpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiBmb3IgYSBjZXJ0YWluIHR5cGUgb2YgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IHR5cGUgVGhlIGV2ZW50IHR5cGUgb3IgYXJyYXkgb2YgZXZlbnQgdHlwZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6ID99IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fEFycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59IFVuaXF1ZSBrZXkgZm9yIHRoZSBsaXN0ZW5lci4gSWZcbiAgICogICAgIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIGV2ZW50IHR5cGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIHJldHVyblxuICAgKiAgICAgd2lsbCBiZSBhbiBhcnJheSBvZiBrZXlzLlxuICAgKiBAYXBpXG4gICAqL1xuICBvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICBjb25zdCBsZW4gPSB0eXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAga2V5c1tpXSA9IGxpc3Rlbih0aGlzLCB0eXBlW2ldLCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxpc3Rlbih0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiBvbmNlIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbig/KTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0gVW5pcXVlIGtleSBmb3IgdGhlIGxpc3RlbmVyLiBJZlxuICAgKiAgICAgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgcmV0dXJuXG4gICAqICAgICB3aWxsIGJlIGFuIGFycmF5IG9mIGtleXMuXG4gICAqIEBhcGlcbiAgICovXG4gIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgY29uc3QgbGVuID0gdHlwZS5sZW5ndGg7XG4gICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIGtleXNbaV0gPSBsaXN0ZW5PbmNlKHRoaXMsIHR5cGVbaV0sIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlzdGVuT25jZSh0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVubGlzdGVuIGZvciBhIGNlcnRhaW4gdHlwZSBvZiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gdHlwZSBUaGUgZXZlbnQgdHlwZSBvciBhcnJheSBvZiBldmVudCB0eXBlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbig/KTogP30gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICB1bih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0eXBlLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdW5saXN0ZW4odGhpcywgdHlwZVtpXSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bmxpc3Rlbih0aGlzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKHR5cGUpLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIHVzaW5nIHRoZSBrZXkgcmV0dXJuZWQgYnkgYG9uKClgIG9yIGBvbmNlKClgLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl8QXJyYXk8aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn0ga2V5IFRoZSBrZXkgcmV0dXJuZWQgYnkgYG9uKClgXG4gKiAgICAgb3IgYG9uY2UoKWAgKG9yIGFuIGFycmF5IG9mIGtleXMpLlxuICogQGFwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5CeUtleShrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGtleS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KGtleVtpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVubGlzdGVuQnlLZXkoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9ICovIChrZXkpKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE9ic2VydmFibGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQU1BOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBNUZBOzs7Ozs7Ozs7QUFxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///86\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/**\n * @module ol/AssertionError\n */\n\n/**\n * Error object thrown when an assertion failed. This is an ECMA-262 Error,\n * extended with a `code` property.\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.\n */\n\nvar AssertionError =\n/*@__PURE__*/\nfunction (Error) {\n  function AssertionError(code) {\n    var path = _util_js__WEBPACK_IMPORTED_MODULE_0__[/* VERSION */ \"a\"] === 'latest' ? _util_js__WEBPACK_IMPORTED_MODULE_0__[/* VERSION */ \"a\"] : 'v' + _util_js__WEBPACK_IMPORTED_MODULE_0__[/* VERSION */ \"a\"].split('-')[0];\n    var message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';\n    Error.call(this, message);\n    /**\n     * Error code. The meaning of the code can be found on\n     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with\n     * the version found in the OpenLayers script's header comment if a version\n     * other than the latest is used).\n     * @type {number}\n     * @api\n     */\n\n    this.code = code;\n    /**\n     * @type {string}\n     */\n\n    this.name = 'AssertionError'; // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40\n\n    this.message = message;\n  }\n\n  if (Error) AssertionError.__proto__ = Error;\n  AssertionError.prototype = Object.create(Error && Error.prototype);\n  AssertionError.prototype.constructor = AssertionError;\n  return AssertionError;\n}(Error);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (AssertionError);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL0Fzc2VydGlvbkVycm9yLmpzP2I2M2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL0Fzc2VydGlvbkVycm9yXG4gKi9cbmltcG9ydCB7VkVSU0lPTn0gZnJvbSAnLi91dGlsLmpzJztcblxuLyoqXG4gKiBFcnJvciBvYmplY3QgdGhyb3duIHdoZW4gYW4gYXNzZXJ0aW9uIGZhaWxlZC4gVGhpcyBpcyBhbiBFQ01BLTI2MiBFcnJvcixcbiAqIGV4dGVuZGVkIHdpdGggYSBgY29kZWAgcHJvcGVydHkuXG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IuXG4gKi9cbmNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZSBFcnJvciBjb2RlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIGNvbnN0IHBhdGggPSBWRVJTSU9OID09PSAnbGF0ZXN0JyA/IFZFUlNJT04gOiAndicgKyBWRVJTSU9OLnNwbGl0KCctJylbMF07XG4gICAgY29uc3QgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkLiBTZWUgaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi8nICsgcGF0aCArXG4gICAgJy9kb2MvZXJyb3JzLyMnICsgY29kZSArICcgZm9yIGRldGFpbHMuJztcblxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZS4gVGhlIG1lYW5pbmcgb2YgdGhlIGNvZGUgY2FuIGJlIGZvdW5kIG9uXG4gICAgICogaHR0cHM6Ly9vcGVubGF5ZXJzLm9yZy9lbi9sYXRlc3QvZG9jL2Vycm9ycy8gKHJlcGxhY2UgYGxhdGVzdGAgd2l0aFxuICAgICAqIHRoZSB2ZXJzaW9uIGZvdW5kIGluIHRoZSBPcGVuTGF5ZXJzIHNjcmlwdCdzIGhlYWRlciBjb21tZW50IGlmIGEgdmVyc2lvblxuICAgICAqIG90aGVyIHRoYW4gdGhlIGxhdGVzdCBpcyB1c2VkKS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuXG4gICAgLy8gUmUtYXNzaWduIG1lc3NhZ2UsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vUmljaC1IYXJyaXMvYnVibGUvaXNzdWVzLzQwXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFzc2VydGlvbkVycm9yO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7QUFHQTs7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7Ozs7O0FBVUE7Ozs7O0FBS0E7QUFDQTtBQUVBOzs7OztBQUNBOztBQTdCQTtBQUNBO0FBZ0NBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///87\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);\n/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(34);\n/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);\n/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(26);\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);\n/**\n * @module ol/geom/Geometry\n */\n\n\n\n\n\n\n\n/**\n * @type {import("../transform.js").Transform}\n */\n\nvar tmpTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__[/* create */ "c"])();\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\n\nvar Geometry =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function Geometry() {\n    BaseObject.call(this);\n    /**\n     * @private\n     * @type {import("../extent.js").Extent}\n     */\n\n    this.extent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["createEmpty"])();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.extentRevision_ = -1;\n    /**\n     * @protected\n     * @type {Object<string, Geometry>}\n     */\n\n    this.simplifiedGeometryCache = {};\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.simplifiedGeometryRevision = 0;\n  }\n\n  if (BaseObject) Geometry.__proto__ = BaseObject;\n  Geometry.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Geometry.prototype.constructor = Geometry;\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n\n  Geometry.prototype.clone = function clone() {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n\n\n  Geometry.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n\n\n  Geometry.prototype.containsXY = function containsXY(x, y) {\n    return false;\n  };\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import("../coordinate.js").Coordinate} point Point.\n   * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.\n   * @return {import("../coordinate.js").Coordinate} Closest point.\n   * @api\n   */\n\n\n  Geometry.prototype.getClosestPoint = function getClosestPoint(point, opt_closestPoint) {\n    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  };\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n\n\n  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  };\n  /**\n   * @abstract\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @protected\n   * @return {import("../extent.js").Extent} extent Extent.\n   */\n\n\n  Geometry.prototype.computeExtent = function computeExtent(extent) {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Get the extent of the geometry.\n   * @param {import("../extent.js").Extent=} opt_extent Extent.\n   * @return {import("../extent.js").Extent} extent Extent.\n   * @api\n   */\n\n\n  Geometry.prototype.getExtent = function getExtent(opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      this.extent_ = this.computeExtent(this.extent_);\n      this.extentRevision_ = this.getRevision();\n    }\n\n    return Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["returnOrUpdate"])(this.extent_, opt_extent);\n  };\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.\n   * @api\n   */\n\n\n  Geometry.prototype.rotate = function rotate(angle, anchor) {\n    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n   *     sx).\n   * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n\n\n  Geometry.prototype.scale = function scale(sx, opt_sy, opt_anchor) {\n    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the the {@link\n   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n   * Douglas Peucker} algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n\n\n  Geometry.prototype.simplify = function simplify(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  };\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n\n\n  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry(squaredTolerance) {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {import("./GeometryType.js").default} Geometry type.\n   */\n\n\n  Geometry.prototype.getType = function getType() {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Apply a transform function to each coordinate of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import("../proj.js").TransformFunction} transformFn Transform.\n   */\n\n\n  Geometry.prototype.applyTransform = function applyTransform(transformFn) {\n    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n\n\n  Geometry.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n\n\n  Geometry.prototype.translate = function translate(deltaX, deltaY) {\n    Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n\n\n  Geometry.prototype.transform = function transform(source, destination) {\n    /** @type {import("../proj/Projection.js").default} */\n    var sourceProj = Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["get"])(source);\n    var transformFn = sourceProj.getUnits() == _proj_Units_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "b"].TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {\n      var pixelExtent = sourceProj.getExtent();\n      var projectedExtent = sourceProj.getWorldExtent();\n      var scale = Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(projectedExtent) / Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["getHeight"])(pixelExtent);\n      Object(_transform_js__WEBPACK_IMPORTED_MODULE_6__[/* compose */ "b"])(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n      Object(_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__[/* transform2D */ "c"])(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n      return Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n    } : Object(_proj_js__WEBPACK_IMPORTED_MODULE_4__["getTransform"])(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  };\n\n  return Geometry;\n}(_Object_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["a"] = (Geometry);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2dlb20vR2VvbWV0cnkuanM/ODJiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9HZW9tZXRyeVxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2NyZWF0ZUVtcHR5LCBnZXRIZWlnaHQsIHJldHVybk9yVXBkYXRlfSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi9mbGF0L3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9uLCBnZXRUcmFuc2Zvcm19IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4uL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uL3RyYW5zZm9ybS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KFwiLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAqL1xuY29uc3QgdG1wVHJhbnNmb3JtID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzOyBub3JtYWxseSBvbmx5IHVzZWQgZm9yIGNyZWF0aW5nIHN1YmNsYXNzZXMgYW5kIG5vdFxuICogaW5zdGFudGlhdGVkIGluIGFwcHMuXG4gKiBCYXNlIGNsYXNzIGZvciB2ZWN0b3IgZ2VvbWV0cmllcy5cbiAqXG4gKiBUbyBnZXQgbm90aWZpZWQgb2YgY2hhbmdlcyB0byB0aGUgZ2VvbWV0cnksIHJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIHRoZVxuICogZ2VuZXJpYyBgY2hhbmdlYCBldmVudCBvbiB5b3VyIGdlb21ldHJ5IGluc3RhbmNlLlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGFwaVxuICovXG5jbGFzcyBHZW9tZXRyeSBleHRlbmRzIEJhc2VPYmplY3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnRSZXZpc2lvbl8gPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgR2VvbWV0cnk+fVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5Q2FjaGUgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2ltcGxpZmllZEdlb21ldHJ5TWF4TWluU3F1YXJlZFRvbGVyYW5jZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNpbXBsaWZpZWRHZW9tZXRyeVJldmlzaW9uID0gMDtcblxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBjb21wbGV0ZSBjb3B5IG9mIHRoZSBnZW9tZXRyeS5cbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4geyFHZW9tZXRyeX0gQ2xvbmUuXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgWS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNsb3Nlc3RQb2ludCBDbG9zZXN0IHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluU3F1YXJlZERpc3RhbmNlIE1pbmltdW0gc3F1YXJlZCBkaXN0YW5jZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNaW5pbXVtIHNxdWFyZWQgZGlzdGFuY2UuXG4gICAqL1xuICBjbG9zZXN0UG9pbnRYWSh4LCB5LCBjbG9zZXN0UG9pbnQsIG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENvbnRhaW5zICh4LCB5KS5cbiAgICovXG4gIGNvbnRhaW5zWFkoeCwgeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNsb3Nlc3QgcG9pbnQgb2YgdGhlIGdlb21ldHJ5IHRvIHRoZSBwYXNzZWQgcG9pbnQgYXNcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9jb29yZGluYXRlfkNvb3JkaW5hdGUgY29vcmRpbmF0ZX0uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBwb2ludCBQb2ludC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU9fSBvcHRfY2xvc2VzdFBvaW50IENsb3Nlc3QgcG9pbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gQ2xvc2VzdCBwb2ludC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Q2xvc2VzdFBvaW50KHBvaW50LCBvcHRfY2xvc2VzdFBvaW50KSB7XG4gICAgY29uc3QgY2xvc2VzdFBvaW50ID0gb3B0X2Nsb3Nlc3RQb2ludCA/IG9wdF9jbG9zZXN0UG9pbnQgOiBbTmFOLCBOYU5dO1xuICAgIHRoaXMuY2xvc2VzdFBvaW50WFkocG9pbnRbMF0sIHBvaW50WzFdLCBjbG9zZXN0UG9pbnQsIEluZmluaXR5KTtcbiAgICByZXR1cm4gY2xvc2VzdFBvaW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGdlb21ldHJ5IGluY2x1ZGVzIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZS4gSWYgdGhlXG4gICAqIGNvb3JkaW5hdGUgaXMgb24gdGhlIGJvdW5kYXJ5IG9mIHRoZSBnZW9tZXRyeSwgcmV0dXJucyBmYWxzZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29udGFpbnMgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgaW50ZXJzZWN0c0Nvb3JkaW5hdGUoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zWFkoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKi9cbiAgY29tcHV0ZUV4dGVudChleHRlbnQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiB0aGUgZ2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudD19IG9wdF9leHRlbnQgRXh0ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQob3B0X2V4dGVudCkge1xuICAgIGlmICh0aGlzLmV4dGVudFJldmlzaW9uXyAhPSB0aGlzLmdldFJldmlzaW9uKCkpIHtcbiAgICAgIHRoaXMuZXh0ZW50XyA9IHRoaXMuY29tcHV0ZUV4dGVudCh0aGlzLmV4dGVudF8pO1xuICAgICAgdGhpcy5leHRlbnRSZXZpc2lvbl8gPSB0aGlzLmdldFJldmlzaW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5PclVwZGF0ZSh0aGlzLmV4dGVudF8sIG9wdF9leHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdGF0ZSB0aGUgZ2VvbWV0cnkgYXJvdW5kIGEgZ2l2ZW4gY29vcmRpbmF0ZS4gVGhpcyBtb2RpZmllcyB0aGUgZ2VvbWV0cnlcbiAgICogY29vcmRpbmF0ZXMgaW4gcGxhY2UuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFucy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGFuY2hvciBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICByb3RhdGUoYW5nbGUsIGFuY2hvcikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhlIGdlb21ldHJ5ICh3aXRoIGFuIG9wdGlvbmFsIG9yaWdpbikuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeVxuICAgKiBjb29yZGluYXRlcyBpbiBwbGFjZS5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzeCBUaGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHgtZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9zeSBUaGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHktZGlyZWN0aW9uIChkZWZhdWx0cyB0b1xuICAgKiAgICAgc3gpLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT19IG9wdF9hbmNob3IgVGhlIHNjYWxlIG9yaWdpbiAoZGVmYXVsdHMgdG8gdGhlIGNlbnRlclxuICAgKiAgICAgb2YgdGhlIGdlb21ldHJ5IGV4dGVudCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHNjYWxlKHN4LCBvcHRfc3ksIG9wdF9hbmNob3IpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB0aGlzIGdlb21ldHJ5LiAgRm9yIGxpbmVzdHJpbmdzLCB0aGlzIHVzZXNcbiAgICogdGhlIHRoZSB7QGxpbmtcbiAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXItRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxuICAgKiBEb3VnbGFzIFBldWNrZXJ9IGFsZ29yaXRobS4gIEZvciBwb2x5Z29ucywgYSBxdWFudGl6YXRpb24tYmFzZWRcbiAgICogc2ltcGxpZmljYXRpb24gaXMgdXNlZCB0byBwcmVzZXJ2ZSB0b3BvbG9neS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRvbGVyYW5jZSBUaGUgdG9sZXJhbmNlIGRpc3RhbmNlIGZvciBzaW1wbGlmaWNhdGlvbi5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IEEgbmV3LCBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhlIG9yaWdpbmFsIGdlb21ldHJ5LlxuICAgKiBAYXBpXG4gICAqL1xuICBzaW1wbGlmeSh0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTaW1wbGlmaWVkR2VvbWV0cnkodG9sZXJhbmNlICogdG9sZXJhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgdGhpcyBnZW9tZXRyeSB1c2luZyB0aGUgRG91Z2xhcyBQZXVja2VyXG4gICAqIGFsZ29yaXRobS5cbiAgICogU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JhbWVyLURvdWdsYXMtUGV1Y2tlcl9hbGdvcml0aG0uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc3F1YXJlZFRvbGVyYW5jZSBTcXVhcmVkIHRvbGVyYW5jZS5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFNpbXBsaWZpZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBnZXRTaW1wbGlmaWVkR2VvbWV0cnkoc3F1YXJlZFRvbGVyYW5jZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHlwZSBvZiB0aGlzIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9HZW9tZXRyeVR5cGUuanNcIikuZGVmYXVsdH0gR2VvbWV0cnkgdHlwZS5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gZWFjaCBjb29yZGluYXRlIG9mIHRoZSBnZW9tZXRyeS5cbiAgICogVGhlIGdlb21ldHJ5IGlzIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBJZiB5b3UgZG8gbm90IHdhbnQgdGhlIGdlb21ldHJ5IG1vZGlmaWVkIGluIHBsYWNlLCBmaXJzdCBgY2xvbmUoKWAgaXQgYW5kXG4gICAqIHRoZW4gdXNlIHRoaXMgZnVuY3Rpb24gb24gdGhlIGNsb25lLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufSB0cmFuc2Zvcm1GbiBUcmFuc2Zvcm0uXG4gICAqL1xuICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbikge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBpZiB0aGUgZ2VvbWV0cnkgYW5kIHRoZSBwYXNzZWQgZXh0ZW50IGludGVyc2VjdC5cbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gZXh0ZW50IEV4dGVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBnZW9tZXRyeSBhbmQgdGhlIGV4dGVudCBpbnRlcnNlY3QuXG4gICAqL1xuICBpbnRlcnNlY3RzRXh0ZW50KGV4dGVudCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZSB0aGUgZ2VvbWV0cnkuICBUaGlzIG1vZGlmaWVzIHRoZSBnZW9tZXRyeSBjb29yZGluYXRlcyBpbiBwbGFjZS4gIElmXG4gICAqIGluc3RlYWQgeW91IHdhbnQgYSBuZXcgZ2VvbWV0cnksIGZpcnN0IGBjbG9uZSgpYCB0aGlzIGdlb21ldHJ5LlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhWCBEZWx0YSBYLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFZIERlbHRhIFkuXG4gICAqIEBhcGlcbiAgICovXG4gIHRyYW5zbGF0ZShkZWx0YVgsIGRlbHRhWSkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIGVhY2ggY29vcmRpbmF0ZSBvZiB0aGUgZ2VvbWV0cnkgZnJvbSBvbmUgY29vcmRpbmF0ZSByZWZlcmVuY2VcbiAgICogc3lzdGVtIHRvIGFub3RoZXIuIFRoZSBnZW9tZXRyeSBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICogRm9yIGV4YW1wbGUsIGEgbGluZSB3aWxsIGJlIHRyYW5zZm9ybWVkIHRvIGEgbGluZSBhbmQgYSBjaXJjbGUgdG8gYSBjaXJjbGUuXG4gICAqIElmIHlvdSBkbyBub3Qgd2FudCB0aGUgZ2VvbWV0cnkgbW9kaWZpZWQgaW4gcGxhY2UsIGZpcnN0IGBjbG9uZSgpYCBpdCBhbmRcbiAgICogdGhlbiB1c2UgdGhpcyBmdW5jdGlvbiBvbiB0aGUgY2xvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gc291cmNlIFRoZSBjdXJyZW50IHByb2plY3Rpb24uICBDYW4gYmUgYVxuICAgKiAgICAgc3RyaW5nIGlkZW50aWZpZXIgb3IgYSB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn5Qcm9qZWN0aW9ufSBvYmplY3QuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gZGVzdGluYXRpb24gVGhlIGRlc2lyZWQgcHJvamVjdGlvbi4gIENhbiBiZSBhXG4gICAqICAgICBzdHJpbmcgaWRlbnRpZmllciBvciBhIHtAbGluayBtb2R1bGU6b2wvcHJvai9Qcm9qZWN0aW9uflByb2plY3Rpb259IG9iamVjdC5cbiAgICogQHJldHVybiB7R2VvbWV0cnl9IFRoaXMgZ2VvbWV0cnkuICBOb3RlIHRoYXQgb3JpZ2luYWwgZ2VvbWV0cnkgaXNcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKiBAYXBpXG4gICAqL1xuICB0cmFuc2Zvcm0oc291cmNlLCBkZXN0aW5hdGlvbikge1xuICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovXG4gICAgY29uc3Qgc291cmNlUHJvaiA9IGdldFByb2plY3Rpb24oc291cmNlKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IHNvdXJjZVByb2ouZ2V0VW5pdHMoKSA9PSBVbml0cy5USUxFX1BJWEVMUyA/XG4gICAgICBmdW5jdGlvbihpbkNvb3JkaW5hdGVzLCBvdXRDb29yZGluYXRlcywgc3RyaWRlKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsRXh0ZW50ID0gc291cmNlUHJvai5nZXRFeHRlbnQoKTtcbiAgICAgICAgY29uc3QgcHJvamVjdGVkRXh0ZW50ID0gc291cmNlUHJvai5nZXRXb3JsZEV4dGVudCgpO1xuICAgICAgICBjb25zdCBzY2FsZSA9IGdldEhlaWdodChwcm9qZWN0ZWRFeHRlbnQpIC8gZ2V0SGVpZ2h0KHBpeGVsRXh0ZW50KTtcbiAgICAgICAgY29tcG9zZVRyYW5zZm9ybSh0bXBUcmFuc2Zvcm0sXG4gICAgICAgICAgcHJvamVjdGVkRXh0ZW50WzBdLCBwcm9qZWN0ZWRFeHRlbnRbM10sXG4gICAgICAgICAgc2NhbGUsIC1zY2FsZSwgMCxcbiAgICAgICAgICAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtMkQoaW5Db29yZGluYXRlcywgMCwgaW5Db29yZGluYXRlcy5sZW5ndGgsIHN0cmlkZSxcbiAgICAgICAgICB0bXBUcmFuc2Zvcm0sIG91dENvb3JkaW5hdGVzKTtcbiAgICAgICAgcmV0dXJuIGdldFRyYW5zZm9ybShzb3VyY2VQcm9qLCBkZXN0aW5hdGlvbikoaW5Db29yZGluYXRlcywgb3V0Q29vcmRpbmF0ZXMsIHN0cmlkZSk7XG4gICAgICB9IDpcbiAgICAgIGdldFRyYW5zZm9ybShzb3VyY2VQcm9qLCBkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5hcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm1Gbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEdlb21ldHJ5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7QUFlQTtBQUFBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQXZQQTtBQUNBO0FBMFBBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///88\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Geocoder = _interopRequireDefault(__webpack_require__(111));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/CensusGeocoder\r\n */\n\n\nvar proj4 = _["default"].proj4;\n/**\r\n * @desc A class for geocoding using the New York City Geoclient API\r\n * @public\r\n * @class\r\n * @extends module:nyc/Geocoder~Geocoder\r\n * @fires module:nyc/Locator~Locator#geocoded\r\n * @fires module:nyc/Locator~Locator#geolocated\r\n * @fires module:nyc/Locator~Locator#ambiguous\r\n * @fires module:nyc/Locator~Locator#error\r\n * @see https://developer.cityofnewyork.us/api/geoclient-api\r\n */\n\nvar CensusGeocoder =\n/*#__PURE__*/\nfunction (_Geocoder$default) {\n  _inherits(CensusGeocoder, _Geocoder$default);\n\n  /**\r\n   * @desc Create an instance of Geoclient\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/Geoclient~Geoclient.Options} options Constructor options\r\n   */\n  function CensusGeocoder(options) {\n    var _this;\n\n    _classCallCheck(this, CensusGeocoder);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CensusGeocoder).call(this, options));\n    /**\r\n     * @private\r\n     * @member {string}\r\n     */\n\n    _this.url = \'https://geocoding.geo.census.gov/geocoder/locations/onelineaddress?format=json&benchmark=4&vintage=4&address=\';\n    /**\r\n     * @desc The epsg code\r\n     * @public\r\n     * @member {string}\r\n     */\n\n    _this.projection = options && options.projection ? options.projection : \'EPSG:3857\';\n    return _this;\n  }\n  /**\r\n   * @desc Geocode an input string representing a location\r\n   * @public\r\n   * @override\r\n   * @method\r\n   * @param {string} input The value to geocode\r\n   * @returns {Promise<module:nyc/Locator~Locator.Result|module:nyc/Locator~Locator.Ambiguous>} The result of the search request\r\n   */\n\n\n  _createClass(CensusGeocoder, [{\n    key: "search",\n    value: function search(input) {\n      var _this2 = this;\n\n      var me = this;\n      return new Promise(function (resolve, reject) {\n        input = input.trim();\n\n        if (input.length === 5 && !isNaN(input)) {\n          _this2.resolveZip(input, resolve);\n        } else if (input.length) {\n          input = input.replace(/"/g, \'\').replace(/\'/g, \'\').replace(/&/g, \' and \');\n\n          _jquery["default"].ajax({\n            url: "".concat(me.url).concat(input),\n            dataType: \'jsonp\',\n            success: function success(response) {\n              me.census(response, resolve);\n            },\n            error: me.error\n          });\n        }\n      });\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Array<number>} coordinate Coordinate\r\n     * @return {Array<number>} Reprojected coordinate\r\n     */\n\n  }, {\n    key: "project",\n    value: function project(coordinate) {\n      if (coordinate && this.projection !== \'EPSG:4326\') {\n        return proj4(\'EPSG:4326\', this.projection, coordinate);\n      }\n\n      return coordinate;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} response Response object\r\n     * @param {function} resolve Resolve\r\n     */\n\n  }, {\n    key: "census",\n    value: function census(response, resolve) {\n      var result = response.result;\n      var addressMatches = result.addressMatches;\n      var nothing = {\n        type: \'ambiguous\',\n        input: result.input.address.address,\n        possible: []\n      };\n\n      if (addressMatches.length) {\n        if (addressMatches.length === 1) {\n          var location = this.parse(addressMatches[0]);\n\n          if (location) {\n            location.type = \'geocoded\';\n            resolve(location);\n            this.trigger(\'geocoded\', location);\n          } else {\n            resolve(nothing);\n            this.trigger(\'ambiguous\', nothing);\n          }\n        } else {\n          var ambiguous = {\n            type: \'ambiguous\',\n            input: nothing.input,\n            possible: this.possible(addressMatches)\n          };\n          resolve(ambiguous);\n          this.trigger(\'ambiguous\', ambiguous);\n        }\n      } else {\n        resolve(nothing);\n        this.trigger(\'ambiguous\', nothing);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Array<module:nyc.Locator~Locator.Ambiguous>} results Results\r\n     * @returns {Array} Possible results\r\n     */\n\n  }, {\n    key: "possible",\n    value: function possible(results) {\n      var _this3 = this;\n\n      var possible = [];\n      results.forEach(function (result) {\n        var location = _this3.parse(result);\n\n        if (location) {\n          possible.push(location);\n        }\n      });\n      return possible;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} result Result\r\n     * @return {Locator.Result} Locator result\r\n     */\n\n  }, {\n    key: "parse",\n    value: function parse(result) {\n      var p = [result.coordinates.x, result.coordinates.y];\n      return {\n        type: \'geocoded\',\n        coordinate: this.project(p),\n        data: result,\n        name: result.matchedAddress\n      };\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {function} reject Resolve\r\n     */\n\n  }, {\n    key: "error",\n    value: function error(reject) {\n      var error = {\n        type: \'error\',\n        error: arguments\n      };\n      console.error(\'Geoclient error\', arguments);\n      reject(error);\n      this.trigger(\'error\', error);\n    }\n  }]);\n\n  return CensusGeocoder;\n}(_Geocoder["default"]);\n/**\r\n * @desc Constructor options for {@link module:nyc/CensusGeocoder~CensusGeocoder}\r\n * @public\r\n * @typedef {Object}\r\n * @property {string} [projection=EPSG:3857] The EPSG code of the projection for output geometries (i.e. EPSG:2263)\r\n */\n\n\nCensusGeocoder.Options;\nvar _default = CensusGeocoder;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbnljLWxpYi9ueWMvQ2Vuc3VzR2VvY29kZXIuanM/ZTcyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1wiKSk7XG5cbnZhciBfanF1ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwianF1ZXJ5XCIpKTtcblxudmFyIF9HZW9jb2RlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vR2VvY29kZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogQG1vZHVsZSBueWMvQ2Vuc3VzR2VvY29kZXJcclxuICovXG5jb25zdCBwcm9qNCA9IF8uZGVmYXVsdC5wcm9qNDtcbi8qKlxyXG4gKiBAZGVzYyBBIGNsYXNzIGZvciBnZW9jb2RpbmcgdXNpbmcgdGhlIE5ldyBZb3JrIENpdHkgR2VvY2xpZW50IEFQSVxyXG4gKiBAcHVibGljXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBtb2R1bGU6bnljL0dlb2NvZGVyfkdlb2NvZGVyXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNnZW9jb2RlZFxyXG4gKiBAZmlyZXMgbW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IjZ2VvbG9jYXRlZFxyXG4gKiBAZmlyZXMgbW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IjYW1iaWd1b3VzXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNlcnJvclxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmNpdHlvZm5ld3lvcmsudXMvYXBpL2dlb2NsaWVudC1hcGlcclxuICovXG5cbmNsYXNzIENlbnN1c0dlb2NvZGVyIGV4dGVuZHMgX0dlb2NvZGVyLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgR2VvY2xpZW50XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9HZW9jbGllbnR+R2VvY2xpZW50Lk9wdGlvbnN9IG9wdGlvbnMgQ29uc3RydWN0b3Igb3B0aW9uc1xyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXG5cbiAgICB0aGlzLnVybCA9ICdodHRwczovL2dlb2NvZGluZy5nZW8uY2Vuc3VzLmdvdi9nZW9jb2Rlci9sb2NhdGlvbnMvb25lbGluZWFkZHJlc3M/Zm9ybWF0PWpzb24mYmVuY2htYXJrPTQmdmludGFnZT00JmFkZHJlc3M9JztcbiAgICAvKipcclxuICAgICAqIEBkZXNjIFRoZSBlcHNnIGNvZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLnByb2plY3Rpb24gPyBvcHRpb25zLnByb2plY3Rpb24gOiAnRVBTRzozODU3JztcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBHZW9jb2RlIGFuIGlucHV0IHN0cmluZyByZXByZXNlbnRpbmcgYSBsb2NhdGlvblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSB2YWx1ZSB0byBnZW9jb2RlXHJcbiAgICogQHJldHVybnMge1Byb21pc2U8bW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IuUmVzdWx0fG1vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLkFtYmlndW91cz59IFRoZSByZXN1bHQgb2YgdGhlIHNlYXJjaCByZXF1ZXN0XHJcbiAgICovXG5cblxuICBzZWFyY2goaW5wdXQpIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlucHV0ID0gaW5wdXQudHJpbSgpO1xuXG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID09PSA1ICYmICFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlWmlwKGlucHV0LCByZXNvbHZlKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXCIvZywgJycpLnJlcGxhY2UoLycvZywgJycpLnJlcGxhY2UoLyYvZywgJyBhbmQgJyk7XG5cbiAgICAgICAgX2pxdWVyeS5kZWZhdWx0LmFqYXgoe1xuICAgICAgICAgIHVybDogYCR7bWUudXJsfSR7aW5wdXR9YCxcbiAgICAgICAgICBkYXRhVHlwZTogJ2pzb25wJyxcbiAgICAgICAgICBzdWNjZXNzOiByZXNwb25zZSA9PiB7XG4gICAgICAgICAgICBtZS5jZW5zdXMocmVzcG9uc2UsIHJlc29sdmUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IG1lLmVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRpbmF0ZSBDb29yZGluYXRlXHJcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUmVwcm9qZWN0ZWQgY29vcmRpbmF0ZVxyXG4gICAqL1xuXG5cbiAgcHJvamVjdChjb29yZGluYXRlKSB7XG4gICAgaWYgKGNvb3JkaW5hdGUgJiYgdGhpcy5wcm9qZWN0aW9uICE9PSAnRVBTRzo0MzI2Jykge1xuICAgICAgcmV0dXJuIHByb2o0KCdFUFNHOjQzMjYnLCB0aGlzLnByb2plY3Rpb24sIGNvb3JkaW5hdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZGluYXRlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBSZXNwb25zZSBvYmplY3RcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlIFJlc29sdmVcclxuICAgKi9cblxuXG4gIGNlbnN1cyhyZXNwb25zZSwgcmVzb2x2ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICBjb25zdCBhZGRyZXNzTWF0Y2hlcyA9IHJlc3VsdC5hZGRyZXNzTWF0Y2hlcztcbiAgICBjb25zdCBub3RoaW5nID0ge1xuICAgICAgdHlwZTogJ2FtYmlndW91cycsXG4gICAgICBpbnB1dDogcmVzdWx0LmlucHV0LmFkZHJlc3MuYWRkcmVzcyxcbiAgICAgIHBvc3NpYmxlOiBbXVxuICAgIH07XG5cbiAgICBpZiAoYWRkcmVzc01hdGNoZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoYWRkcmVzc01hdGNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5wYXJzZShhZGRyZXNzTWF0Y2hlc1swXSk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgbG9jYXRpb24udHlwZSA9ICdnZW9jb2RlZCc7XG4gICAgICAgICAgcmVzb2x2ZShsb2NhdGlvbik7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdnZW9jb2RlZCcsIGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKG5vdGhpbmcpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignYW1iaWd1b3VzJywgbm90aGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFtYmlndW91cyA9IHtcbiAgICAgICAgICB0eXBlOiAnYW1iaWd1b3VzJyxcbiAgICAgICAgICBpbnB1dDogbm90aGluZy5pbnB1dCxcbiAgICAgICAgICBwb3NzaWJsZTogdGhpcy5wb3NzaWJsZShhZGRyZXNzTWF0Y2hlcylcbiAgICAgICAgfTtcbiAgICAgICAgcmVzb2x2ZShhbWJpZ3VvdXMpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2FtYmlndW91cycsIGFtYmlndW91cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUobm90aGluZyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2FtYmlndW91cycsIG5vdGhpbmcpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge0FycmF5PG1vZHVsZTpueWMuTG9jYXRvcn5Mb2NhdG9yLkFtYmlndW91cz59IHJlc3VsdHMgUmVzdWx0c1xyXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUG9zc2libGUgcmVzdWx0c1xyXG4gICAqL1xuXG5cbiAgcG9zc2libGUocmVzdWx0cykge1xuICAgIGNvbnN0IHBvc3NpYmxlID0gW107XG4gICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMucGFyc2UocmVzdWx0KTtcblxuICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgIHBvc3NpYmxlLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwb3NzaWJsZTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFJlc3VsdFxyXG4gICAqIEByZXR1cm4ge0xvY2F0b3IuUmVzdWx0fSBMb2NhdG9yIHJlc3VsdFxyXG4gICAqL1xuXG5cbiAgcGFyc2UocmVzdWx0KSB7XG4gICAgY29uc3QgcCA9IFtyZXN1bHQuY29vcmRpbmF0ZXMueCwgcmVzdWx0LmNvb3JkaW5hdGVzLnldO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZ2VvY29kZWQnLFxuICAgICAgY29vcmRpbmF0ZTogdGhpcy5wcm9qZWN0KHApLFxuICAgICAgZGF0YTogcmVzdWx0LFxuICAgICAgbmFtZTogcmVzdWx0Lm1hdGNoZWRBZGRyZXNzXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZWplY3QgUmVzb2x2ZVxyXG4gICAqL1xuXG5cbiAgZXJyb3IocmVqZWN0KSB7XG4gICAgY29uc3QgZXJyb3IgPSB7XG4gICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgZXJyb3I6IGFyZ3VtZW50c1xuICAgIH07XG4gICAgY29uc29sZS5lcnJvcignR2VvY2xpZW50IGVycm9yJywgYXJndW1lbnRzKTtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHRoaXMudHJpZ2dlcignZXJyb3InLCBlcnJvcik7XG4gIH1cblxufVxuLyoqXHJcbiAqIEBkZXNjIENvbnN0cnVjdG9yIG9wdGlvbnMgZm9yIHtAbGluayBtb2R1bGU6bnljL0NlbnN1c0dlb2NvZGVyfkNlbnN1c0dlb2NvZGVyfVxyXG4gKiBAcHVibGljXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvamVjdGlvbj1FUFNHOjM4NTddIFRoZSBFUFNHIGNvZGUgb2YgdGhlIHByb2plY3Rpb24gZm9yIG91dHB1dCBnZW9tZXRyaWVzIChpLmUuIEVQU0c6MjI2MylcclxuICovXG5cblxuQ2Vuc3VzR2VvY29kZXIuT3B0aW9ucztcbnZhciBfZGVmYXVsdCA9IENlbnN1c0dlb2NvZGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7Ozs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7O0FBTUE7QUFkQTtBQWVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFuS0E7QUFzS0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);\n/**\n * @module ol/structs/LRUCache\n */\n\n\n\n/**\n * @typedef {Object} Entry\n * @property {string} key_\n * @property {Object} newer\n * @property {Object} older\n * @property {*} value_\n */\n\n/**\n * @classdesc\n * Implements a Least-Recently-Used cache where the keys do not conflict with\n * Object\'s properties (e.g. \'hasOwnProperty\' is not allowed as a key). Expiring\n * items from the cache is the responsibility of the user.\n *\n * @fires import("../events/Event.js").Event\n * @template T\n */\n\nvar LRUCache =\n/*@__PURE__*/\nfunction (EventTarget) {\n  function LRUCache(opt_highWaterMark) {\n    EventTarget.call(this);\n    /**\n     * @type {number}\n     */\n\n    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.count_ = 0;\n    /**\n     * @private\n     * @type {!Object<string, Entry>}\n     */\n\n    this.entries_ = {};\n    /**\n     * @private\n     * @type {?Entry}\n     */\n\n    this.oldest_ = null;\n    /**\n     * @private\n     * @type {?Entry}\n     */\n\n    this.newest_ = null;\n  }\n\n  if (EventTarget) LRUCache.__proto__ = EventTarget;\n  LRUCache.prototype = Object.create(EventTarget && EventTarget.prototype);\n  LRUCache.prototype.constructor = LRUCache;\n  /**\n   * @return {boolean} Can expire cache.\n   */\n\n  LRUCache.prototype.canExpireCache = function canExpireCache() {\n    return this.getCount() > this.highWaterMark;\n  };\n  /**\n   * FIXME empty description for jsdoc\n   */\n\n\n  LRUCache.prototype.clear = function clear() {\n    this.count_ = 0;\n    this.entries_ = {};\n    this.oldest_ = null;\n    this.newest_ = null;\n    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].CLEAR);\n  };\n  /**\n   * @param {string} key Key.\n   * @return {boolean} Contains key.\n   */\n\n\n  LRUCache.prototype.containsKey = function containsKey(key) {\n    return this.entries_.hasOwnProperty(key);\n  };\n  /**\n   * @param {function(this: S, T, string, LRUCache): ?} f The function\n   *     to call for every entry from the oldest to the newer. This function takes\n   *     3 arguments (the entry value, the entry key and the LRUCache object).\n   *     The return value is ignored.\n   * @param {S=} opt_this The object to use as `this` in `f`.\n   * @template S\n   */\n\n\n  LRUCache.prototype.forEach = function forEach(f, opt_this) {\n    var entry = this.oldest_;\n\n    while (entry) {\n      f.call(opt_this, entry.value_, entry.key_, this);\n      entry = entry.newer;\n    }\n  };\n  /**\n   * @param {string} key Key.\n   * @return {T} Value.\n   */\n\n\n  LRUCache.prototype.get = function get(key) {\n    var entry = this.entries_[key];\n    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n    if (entry === this.newest_) {\n      return entry.value_;\n    } else if (entry === this.oldest_) {\n      this.oldest_ =\n      /** @type {Entry} */\n      this.oldest_.newer;\n      this.oldest_.older = null;\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n\n    entry.newer = null;\n    entry.older = this.newest_;\n    this.newest_.newer = entry;\n    this.newest_ = entry;\n    return entry.value_;\n  };\n  /**\n   * Remove an entry from the cache.\n   * @param {string} key The entry key.\n   * @return {T} The removed entry.\n   */\n\n\n  LRUCache.prototype.remove = function remove(key) {\n    var entry = this.entries_[key];\n    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache\n\n    if (entry === this.newest_) {\n      this.newest_ =\n      /** @type {Entry} */\n      entry.older;\n\n      if (this.newest_) {\n        this.newest_.newer = null;\n      }\n    } else if (entry === this.oldest_) {\n      this.oldest_ =\n      /** @type {Entry} */\n      entry.newer;\n\n      if (this.oldest_) {\n        this.oldest_.older = null;\n      }\n    } else {\n      entry.newer.older = entry.older;\n      entry.older.newer = entry.newer;\n    }\n\n    delete this.entries_[key];\n    --this.count_;\n    return entry.value_;\n  };\n  /**\n   * @return {number} Count.\n   */\n\n\n  LRUCache.prototype.getCount = function getCount() {\n    return this.count_;\n  };\n  /**\n   * @return {Array<string>} Keys.\n   */\n\n\n  LRUCache.prototype.getKeys = function getKeys() {\n    var keys = new Array(this.count_);\n    var i = 0;\n    var entry;\n\n    for (entry = this.newest_; entry; entry = entry.older) {\n      keys[i++] = entry.key_;\n    }\n\n    return keys;\n  };\n  /**\n   * @return {Array<T>} Values.\n   */\n\n\n  LRUCache.prototype.getValues = function getValues() {\n    var values = new Array(this.count_);\n    var i = 0;\n    var entry;\n\n    for (entry = this.newest_; entry; entry = entry.older) {\n      values[i++] = entry.value_;\n    }\n\n    return values;\n  };\n  /**\n   * @return {T} Last value.\n   */\n\n\n  LRUCache.prototype.peekLast = function peekLast() {\n    return this.oldest_.value_;\n  };\n  /**\n   * @return {string} Last key.\n   */\n\n\n  LRUCache.prototype.peekLastKey = function peekLastKey() {\n    return this.oldest_.key_;\n  };\n  /**\n   * Get the key of the newest item in the cache.  Throws if the cache is empty.\n   * @return {string} The newest key.\n   */\n\n\n  LRUCache.prototype.peekFirstKey = function peekFirstKey() {\n    return this.newest_.key_;\n  };\n  /**\n   * @return {T} value Value.\n   */\n\n\n  LRUCache.prototype.pop = function pop() {\n    var entry = this.oldest_;\n    delete this.entries_[entry.key_];\n\n    if (entry.newer) {\n      entry.newer.older = null;\n    }\n\n    this.oldest_ =\n    /** @type {Entry} */\n    entry.newer;\n\n    if (!this.oldest_) {\n      this.newest_ = null;\n    }\n\n    --this.count_;\n    return entry.value_;\n  };\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n\n\n  LRUCache.prototype.replace = function replace(key, value) {\n    this.get(key); // update `newest_`\n\n    this.entries_[key].value_ = value;\n  };\n  /**\n   * @param {string} key Key.\n   * @param {T} value Value.\n   */\n\n\n  LRUCache.prototype.set = function set(key, value) {\n    Object(_asserts_js__WEBPACK_IMPORTED_MODULE_0__[/* assert */ "a"])(!(key in this.entries_), 16); // Tried to set a value for a key that is used already\n\n    var entry =\n    /** @type {Entry} */\n    {\n      key_: key,\n      newer: null,\n      older: this.newest_,\n      value_: value\n    };\n\n    if (!this.newest_) {\n      this.oldest_ = entry;\n    } else {\n      this.newest_.newer = entry;\n    }\n\n    this.newest_ = entry;\n    this.entries_[key] = entry;\n    ++this.count_;\n  };\n  /**\n   * Set a maximum number of entries for the cache.\n   * @param {number} size Cache size.\n   * @api\n   */\n\n\n  LRUCache.prototype.setSize = function setSize(size) {\n    this.highWaterMark = size;\n  };\n  /**\n   * Prune the cache.\n   */\n\n\n  LRUCache.prototype.prune = function prune() {\n    while (this.canExpireCache()) {\n      this.pop();\n    }\n  };\n\n  return LRUCache;\n}(_events_Target_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["a"] = (LRUCache);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0cnVjdHMvTFJVQ2FjaGUuanM/Zjc0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3RydWN0cy9MUlVDYWNoZVxuICovXG5cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCBFdmVudFRhcmdldCBmcm9tICcuLi9ldmVudHMvVGFyZ2V0LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBFbnRyeVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleV9cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBuZXdlclxuICogQHByb3BlcnR5IHtPYmplY3R9IG9sZGVyXG4gKiBAcHJvcGVydHkgeyp9IHZhbHVlX1xuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBJbXBsZW1lbnRzIGEgTGVhc3QtUmVjZW50bHktVXNlZCBjYWNoZSB3aGVyZSB0aGUga2V5cyBkbyBub3QgY29uZmxpY3Qgd2l0aFxuICogT2JqZWN0J3MgcHJvcGVydGllcyAoZS5nLiAnaGFzT3duUHJvcGVydHknIGlzIG5vdCBhbGxvd2VkIGFzIGEga2V5KS4gRXhwaXJpbmdcbiAqIGl0ZW1zIGZyb20gdGhlIGNhY2hlIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdXNlci5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLkV2ZW50XG4gKiBAdGVtcGxhdGUgVFxuICovXG5jbGFzcyBMUlVDYWNoZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaGlnaFdhdGVyTWFyayBIaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfaGlnaFdhdGVyTWFyaykge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gb3B0X2hpZ2hXYXRlck1hcmsgIT09IHVuZGVmaW5lZCA/IG9wdF9oaWdoV2F0ZXJNYXJrIDogMjA0ODtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvdW50XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgRW50cnk+fVxuICAgICAqL1xuICAgIHRoaXMuZW50cmllc18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9FbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLm9sZGVzdF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P0VudHJ5fVxuICAgICAqL1xuICAgIHRoaXMubmV3ZXN0XyA9IG51bGw7XG5cbiAgfVxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IENhbiBleHBpcmUgY2FjaGUuXG4gICAqL1xuICBjYW5FeHBpcmVDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb3VudCgpID4gdGhpcy5oaWdoV2F0ZXJNYXJrO1xuICB9XG5cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmNvdW50XyA9IDA7XG4gICAgdGhpcy5lbnRyaWVzXyA9IHt9O1xuICAgIHRoaXMub2xkZXN0XyA9IG51bGw7XG4gICAgdGhpcy5uZXdlc3RfID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNMRUFSKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBDb250YWlucyBrZXkuXG4gICAqL1xuICBjb250YWluc0tleShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzXy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBULCBzdHJpbmcsIExSVUNhY2hlKTogP30gZiBUaGUgZnVuY3Rpb25cbiAgICogICAgIHRvIGNhbGwgZm9yIGV2ZXJ5IGVudHJ5IGZyb20gdGhlIG9sZGVzdCB0byB0aGUgbmV3ZXIuIFRoaXMgZnVuY3Rpb24gdGFrZXNcbiAgICogICAgIDMgYXJndW1lbnRzICh0aGUgZW50cnkgdmFsdWUsIHRoZSBlbnRyeSBrZXkgYW5kIHRoZSBMUlVDYWNoZSBvYmplY3QpLlxuICAgKiAgICAgVGhlIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge1M9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIHVzZSBhcyBgdGhpc2AgaW4gYGZgLlxuICAgKiBAdGVtcGxhdGUgU1xuICAgKi9cbiAgZm9yRWFjaChmLCBvcHRfdGhpcykge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub2xkZXN0XztcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGYuY2FsbChvcHRfdGhpcywgZW50cnkudmFsdWVfLCBlbnRyeS5rZXlfLCB0aGlzKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBLZXkuXG4gICAqIEByZXR1cm4ge1R9IFZhbHVlLlxuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIGFzc2VydChlbnRyeSAhPT0gdW5kZWZpbmVkLFxuICAgICAgMTUpOyAvLyBUcmllZCB0byBnZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgY2FjaGVcbiAgICBpZiAoZW50cnkgPT09IHRoaXMubmV3ZXN0Xykge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlXztcbiAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSB0aGlzLm9sZGVzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0XyA9IC8qKiBAdHlwZSB7RW50cnl9ICovICh0aGlzLm9sZGVzdF8ubmV3ZXIpO1xuICAgICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcbiAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGVudHJ5Lm5ld2VyID0gbnVsbDtcbiAgICBlbnRyeS5vbGRlciA9IHRoaXMubmV3ZXN0XztcbiAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBlbnRyeTtcbiAgICB0aGlzLm5ld2VzdF8gPSBlbnRyeTtcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGNhY2hlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBlbnRyeSBrZXkuXG4gICAqIEByZXR1cm4ge1R9IFRoZSByZW1vdmVkIGVudHJ5LlxuICAgKi9cbiAgcmVtb3ZlKGtleSkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbnRyaWVzX1trZXldO1xuICAgIGFzc2VydChlbnRyeSAhPT0gdW5kZWZpbmVkLCAxNSk7IC8vIFRyaWVkIHRvIGdldCBhIHZhbHVlIGZvciBhIGtleSB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBjYWNoZVxuICAgIGlmIChlbnRyeSA9PT0gdGhpcy5uZXdlc3RfKSB7XG4gICAgICB0aGlzLm5ld2VzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoZW50cnkub2xkZXIpO1xuICAgICAgaWYgKHRoaXMubmV3ZXN0Xykge1xuICAgICAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW50cnkgPT09IHRoaXMub2xkZXN0Xykge1xuICAgICAgdGhpcy5vbGRlc3RfID0gLyoqIEB0eXBlIHtFbnRyeX0gKi8gKGVudHJ5Lm5ld2VyKTtcbiAgICAgIGlmICh0aGlzLm9sZGVzdF8pIHtcbiAgICAgICAgdGhpcy5vbGRlc3RfLm9sZGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBlbnRyeS5vbGRlcjtcbiAgICAgIGVudHJ5Lm9sZGVyLm5ld2VyID0gZW50cnkubmV3ZXI7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmVudHJpZXNfW2tleV07XG4gICAgLS10aGlzLmNvdW50XztcbiAgICByZXR1cm4gZW50cnkudmFsdWVfO1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBDb3VudC5cbiAgICovXG4gIGdldENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmNvdW50XztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEtleXMuXG4gICAqL1xuICBnZXRLZXlzKCkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgQXJyYXkodGhpcy5jb3VudF8pO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZW50cnk7XG4gICAgZm9yIChlbnRyeSA9IHRoaXMubmV3ZXN0XzsgZW50cnk7IGVudHJ5ID0gZW50cnkub2xkZXIpIHtcbiAgICAgIGtleXNbaSsrXSA9IGVudHJ5LmtleV87XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8VD59IFZhbHVlcy5cbiAgICovXG4gIGdldFZhbHVlcygpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5jb3VudF8pO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgZW50cnk7XG4gICAgZm9yIChlbnRyeSA9IHRoaXMubmV3ZXN0XzsgZW50cnk7IGVudHJ5ID0gZW50cnkub2xkZXIpIHtcbiAgICAgIHZhbHVlc1tpKytdID0gZW50cnkudmFsdWVfO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybiB7VH0gTGFzdCB2YWx1ZS5cbiAgICovXG4gIHBlZWtMYXN0KCkge1xuICAgIHJldHVybiB0aGlzLm9sZGVzdF8udmFsdWVfO1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBMYXN0IGtleS5cbiAgICovXG4gIHBlZWtMYXN0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLm9sZGVzdF8ua2V5XztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEdldCB0aGUga2V5IG9mIHRoZSBuZXdlc3QgaXRlbSBpbiB0aGUgY2FjaGUuICBUaHJvd3MgaWYgdGhlIGNhY2hlIGlzIGVtcHR5LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuZXdlc3Qga2V5LlxuICAgKi9cbiAgcGVla0ZpcnN0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLm5ld2VzdF8ua2V5XztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1R9IHZhbHVlIFZhbHVlLlxuICAgKi9cbiAgcG9wKCkge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5vbGRlc3RfO1xuICAgIGRlbGV0ZSB0aGlzLmVudHJpZXNfW2VudHJ5LmtleV9dO1xuICAgIGlmIChlbnRyeS5uZXdlcikge1xuICAgICAgZW50cnkubmV3ZXIub2xkZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm9sZGVzdF8gPSAvKiogQHR5cGUge0VudHJ5fSAqLyAoZW50cnkubmV3ZXIpO1xuICAgIGlmICghdGhpcy5vbGRlc3RfKSB7XG4gICAgICB0aGlzLm5ld2VzdF8gPSBudWxsO1xuICAgIH1cbiAgICAtLXRoaXMuY291bnRfO1xuICAgIHJldHVybiBlbnRyeS52YWx1ZV87XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHJlcGxhY2Uoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuZ2V0KGtleSk7IC8vIHVwZGF0ZSBgbmV3ZXN0X2BcbiAgICB0aGlzLmVudHJpZXNfW2tleV0udmFsdWVfID0gdmFsdWU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleS5cbiAgICogQHBhcmFtIHtUfSB2YWx1ZSBWYWx1ZS5cbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgYXNzZXJ0KCEoa2V5IGluIHRoaXMuZW50cmllc18pLFxuICAgICAgMTYpOyAvLyBUcmllZCB0byBzZXQgYSB2YWx1ZSBmb3IgYSBrZXkgdGhhdCBpcyB1c2VkIGFscmVhZHlcbiAgICBjb25zdCBlbnRyeSA9IC8qKiBAdHlwZSB7RW50cnl9ICovICh7XG4gICAgICBrZXlfOiBrZXksXG4gICAgICBuZXdlcjogbnVsbCxcbiAgICAgIG9sZGVyOiB0aGlzLm5ld2VzdF8sXG4gICAgICB2YWx1ZV86IHZhbHVlXG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLm5ld2VzdF8pIHtcbiAgICAgIHRoaXMub2xkZXN0XyA9IGVudHJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5ld2VzdF8ubmV3ZXIgPSBlbnRyeTtcbiAgICB9XG4gICAgdGhpcy5uZXdlc3RfID0gZW50cnk7XG4gICAgdGhpcy5lbnRyaWVzX1trZXldID0gZW50cnk7XG4gICAgKyt0aGlzLmNvdW50XztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNldCBhIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgZm9yIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQ2FjaGUgc2l6ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0U2l6ZShzaXplKSB7XG4gICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gc2l6ZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFBydW5lIHRoZSBjYWNoZS5cbiAgICovXG4gIHBydW5lKCkge1xuICAgIHdoaWxlICh0aGlzLmNhbkV4cGlyZUNhY2hlKCkpIHtcbiAgICAgIHRoaXMucG9wKCk7XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgTFJVQ2FjaGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFBQTtBQUFBO0FBS0E7QUFFQTs7Ozs7QUFLQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBL1FBO0FBQ0E7QUFpUkEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///90\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/**\n * @module ol/style/Image\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} opacity\n * @property {boolean} rotateWithView\n * @property {number} rotation\n * @property {number} scale\n */\n\n/**\n * @classdesc\n * A base class used for creating subclasses and not instantiated in\n * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and\n * {@link module:ol/style/RegularShape~RegularShape}.\n * @abstract\n * @api\n */\n\nvar ImageStyle = function ImageStyle(options) {\n  /**\n   * @private\n   * @type {number}\n   */\n  this.opacity_ = options.opacity;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this.rotateWithView_ = options.rotateWithView;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.rotation_ = options.rotation;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this.scale_ = options.scale;\n};\n/**\n * Clones the style.\n * @return {ImageStyle} The cloned style.\n * @api\n */\n\n\nImageStyle.prototype.clone = function clone() {\n  return new ImageStyle({\n    opacity: this.getOpacity(),\n    scale: this.getScale(),\n    rotation: this.getRotation(),\n    rotateWithView: this.getRotateWithView()\n  });\n};\n/**\n * Get the symbolizer opacity.\n * @return {number} Opacity.\n * @api\n */\n\n\nImageStyle.prototype.getOpacity = function getOpacity() {\n  return this.opacity_;\n};\n/**\n * Determine whether the symbolizer rotates with the map.\n * @return {boolean} Rotate with map.\n * @api\n */\n\n\nImageStyle.prototype.getRotateWithView = function getRotateWithView() {\n  return this.rotateWithView_;\n};\n/**\n * Get the symoblizer rotation.\n * @return {number} Rotation.\n * @api\n */\n\n\nImageStyle.prototype.getRotation = function getRotation() {\n  return this.rotation_;\n};\n/**\n * Get the symbolizer scale.\n * @return {number} Scale.\n * @api\n */\n\n\nImageStyle.prototype.getScale = function getScale() {\n  return this.scale_;\n};\n/**\n * This method is deprecated and always returns false.\n * @return {boolean} false.\n * @deprecated\n * @api\n */\n\n\nImageStyle.prototype.getSnapToPixel = function getSnapToPixel() {\n  return false;\n};\n/**\n * Get the anchor point in pixels. The anchor determines the center point for the\n * symbolizer.\n * @abstract\n * @return {Array<number>} Anchor.\n */\n\n\nImageStyle.prototype.getAnchor = function getAnchor() {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * Get the image element for the symbolizer.\n * @abstract\n * @param {number} pixelRatio Pixel ratio.\n * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.\n */\n\n\nImageStyle.prototype.getImage = function getImage(pixelRatio) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * @abstract\n * @param {number} pixelRatio Pixel ratio.\n * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.\n */\n\n\nImageStyle.prototype.getHitDetectionImage = function getHitDetectionImage(pixelRatio) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * @abstract\n * @return {import("../ImageState.js").default} Image state.\n */\n\n\nImageStyle.prototype.getImageState = function getImageState() {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * @abstract\n * @return {import("../size.js").Size} Image size.\n */\n\n\nImageStyle.prototype.getImageSize = function getImageSize() {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * @abstract\n * @return {import("../size.js").Size} Size of the hit-detection image.\n */\n\n\nImageStyle.prototype.getHitDetectionImageSize = function getHitDetectionImageSize() {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * Get the origin of the symbolizer.\n * @abstract\n * @return {Array<number>} Origin.\n */\n\n\nImageStyle.prototype.getOrigin = function getOrigin() {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * Get the size of the symbolizer (in pixels).\n * @abstract\n * @return {import("../size.js").Size} Size.\n */\n\n\nImageStyle.prototype.getSize = function getSize() {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * Set the opacity.\n *\n * @param {number} opacity Opacity.\n * @api\n */\n\n\nImageStyle.prototype.setOpacity = function setOpacity(opacity) {\n  this.opacity_ = opacity;\n};\n/**\n * Set whether to rotate the style with the view.\n *\n * @param {boolean} rotateWithView Rotate with map.\n * @api\n */\n\n\nImageStyle.prototype.setRotateWithView = function setRotateWithView(rotateWithView) {\n  this.rotateWithView_ = rotateWithView;\n};\n/**\n * Set the rotation.\n *\n * @param {number} rotation Rotation.\n * @api\n */\n\n\nImageStyle.prototype.setRotation = function setRotation(rotation) {\n  this.rotation_ = rotation;\n};\n/**\n * Set the scale.\n *\n * @param {number} scale Scale.\n * @api\n */\n\n\nImageStyle.prototype.setScale = function setScale(scale) {\n  this.scale_ = scale;\n};\n/**\n * This method is deprecated and does nothing.\n * @param {boolean} snapToPixel Snap to pixel?\n * @deprecated\n * @api\n */\n\n\nImageStyle.prototype.setSnapToPixel = function setSnapToPixel(snapToPixel) {};\n/**\n * @abstract\n * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.\n * @param {T} thisArg Value to use as `this` when executing `listener`.\n * @return {import("../events.js").EventsKey|undefined} Listener key.\n * @template T\n */\n\n\nImageStyle.prototype.listenImageChange = function listenImageChange(listener, thisArg) {\n  return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * Load not yet loaded URI.\n * @abstract\n */\n\n\nImageStyle.prototype.load = function load() {\n  Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n/**\n * @abstract\n * @param {function(this: T, import("../events/Event.js").default)} listener Listener function.\n * @param {T} thisArg Value to use as `this` when executing `listener`.\n * @template T\n */\n\n\nImageStyle.prototype.unlistenImageChange = function unlistenImageChange(listener, thisArg) {\n  Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n};\n\n/* harmony default export */ __webpack_exports__["a"] = (ImageStyle);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL0ltYWdlLmpzPzkzMTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ltYWdlXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uL3V0aWwuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG9wYWNpdHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcm90YXRlV2l0aFZpZXdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3RhdGlvblxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNjYWxlXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEEgYmFzZSBjbGFzcyB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3QgaW5zdGFudGlhdGVkIGluXG4gKiBhcHBzLiBCYXNlIGNsYXNzIGZvciB7QGxpbmsgbW9kdWxlOm9sL3N0eWxlL0ljb25+SWNvbn0sIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvQ2lyY2xlfkNpcmNsZVN0eWxlfSBhbmRcbiAqIHtAbGluayBtb2R1bGU6b2wvc3R5bGUvUmVndWxhclNoYXBlflJlZ3VsYXJTaGFwZX0uXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgSW1hZ2VTdHlsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm9wYWNpdHlfID0gb3B0aW9ucy5vcGFjaXR5O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IG9wdGlvbnMucm90YXRlV2l0aFZpZXc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbl8gPSBvcHRpb25zLnJvdGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGVfID0gb3B0aW9ucy5zY2FsZTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuXG4gICAqIEByZXR1cm4ge0ltYWdlU3R5bGV9IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgSW1hZ2VTdHlsZSh7XG4gICAgICBvcGFjaXR5OiB0aGlzLmdldE9wYWNpdHkoKSxcbiAgICAgIHNjYWxlOiB0aGlzLmdldFNjYWxlKCksXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBvcGFjaXR5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wYWNpdHkuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eV87XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHN5bWJvbGl6ZXIgcm90YXRlcyB3aXRoIHRoZSBtYXAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJvdGF0ZSB3aXRoIG1hcC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRlV2l0aFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlV2l0aFZpZXdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltb2JsaXplciByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBSb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3ltYm9saXplciBzY2FsZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBTY2FsZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIGFsd2F5cyByZXR1cm5zIGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBmYWxzZS5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U25hcFRvUGl4ZWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5jaG9yIHBvaW50IGluIHBpeGVscy4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gQW5jaG9yLlxuICAgKi9cbiAgZ2V0QW5jaG9yKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaW1hZ2UgZWxlbWVudCBmb3IgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SW1hZ2UocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fSBJbWFnZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uSW1hZ2UocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0YXRlLlxuICAgKi9cbiAgZ2V0SW1hZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBJbWFnZSBzaXplLlxuICAgKi9cbiAgZ2V0SW1hZ2VTaXplKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFNpemUgb2YgdGhlIGhpdC1kZXRlY3Rpb24gaW1hZ2UuXG4gICAqL1xuICBnZXRIaXREZXRlY3Rpb25JbWFnZVNpemUoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gb2YgdGhlIHN5bWJvbGl6ZXIuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBPcmlnaW4uXG4gICAqL1xuICBnZXRPcmlnaW4oKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBzeW1ib2xpemVyIChpbiBwaXhlbHMpLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBTaXplLlxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG9wYWNpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGFjaXR5IE9wYWNpdHkuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9wYWNpdHkob3BhY2l0eSkge1xuICAgIHRoaXMub3BhY2l0eV8gPSBvcGFjaXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRvIHJvdGF0ZSB0aGUgc3R5bGUgd2l0aCB0aGUgdmlldy5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSByb3RhdGVXaXRoVmlldyBSb3RhdGUgd2l0aCBtYXAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0ZVdpdGhWaWV3KHJvdGF0ZVdpdGhWaWV3KSB7XG4gICAgdGhpcy5yb3RhdGVXaXRoVmlld18gPSByb3RhdGVXaXRoVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gUm90YXRpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgdGhpcy5yb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzY2FsZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIFNjYWxlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIHRoaXMuc2NhbGVfID0gc2NhbGU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgZG9lcyBub3RoaW5nLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNuYXBUb1BpeGVsIFNuYXAgdG8gcGl4ZWw/XG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNuYXBUb1BpeGVsKHNuYXBUb1BpeGVsKSB7fVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdCl9IGxpc3RlbmVyIExpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1R9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGlzdGVuZXJgLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fHVuZGVmaW5lZH0gTGlzdGVuZXIga2V5LlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgbGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIG5vdCB5ZXQgbG9hZGVkIFVSSS5cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBsb2FkKCkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVCwgaW1wb3J0KFwiLi4vZXZlbnRzL0V2ZW50LmpzXCIpLmRlZmF1bHQpfSBsaXN0ZW5lciBMaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtUfSB0aGlzQXJnIFZhbHVlIHRvIHVzZSBhcyBgdGhpc2Agd2hlbiBleGVjdXRpbmcgYGxpc3RlbmVyYC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIHVubGlzdGVuSW1hZ2VDaGFuZ2UobGlzdGVuZXIsIHRoaXNBcmcpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlU3R5bGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7OztBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFNQTs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQU1BO0FBRUE7Ozs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///91\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/**\n * @module ol/style/TextPlacement\n */\n\n/**\n * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that\n * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},\n * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or\n * {@link module:ol/geom/MultiPolygon~MultiPolygon}.\n * @enum {string}\n */\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  POINT: 'point',\n  LINE: 'line'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL1RleHRQbGFjZW1lbnQuanM/YTdhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvVGV4dFBsYWNlbWVudFxuICovXG5cbi8qKlxuICogVGV4dCBwbGFjZW1lbnQuIE9uZSBvZiBgJ3BvaW50J2AsIGAnbGluZSdgLiBEZWZhdWx0IGlzIGAncG9pbnQnYC4gTm90ZSB0aGF0XG4gKiBgJ2xpbmUnYCByZXF1aXJlcyB0aGUgdW5kZXJseWluZyBnZW9tZXRyeSB0byBiZSBhIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9MaW5lU3RyaW5nfkxpbmVTdHJpbmd9LFxuICoge0BsaW5rIG1vZHVsZTpvbC9nZW9tL1BvbHlnb25+UG9seWdvbn0sIHtAbGluayBtb2R1bGU6b2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmd+TXVsdGlMaW5lU3RyaW5nfSBvclxuICoge0BsaW5rIG1vZHVsZTpvbC9nZW9tL011bHRpUG9seWdvbn5NdWx0aVBvbHlnb259LlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBQT0lOVDogJ3BvaW50JyxcbiAgTElORTogJ2xpbmUnXG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFGQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///92\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);\n/* harmony import */ var _Property_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);\n/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);\n/**\n * @module ol/layer/Base\n */\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map\'s `layers` collection, or `Infinity` when the layer\'s `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in\n * the options is set as a {@link module:ol/Object} property on the layer object, so\n * is observable, and has get/set accessors.\n *\n * @api\n */\n\nvar BaseLayer =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function BaseLayer(options) {\n    BaseObject.call(this);\n    /**\n     * @type {Object<string, *>}\n     */\n\n    var properties = Object(_obj_js__WEBPACK_IMPORTED_MODULE_4__[/* assign */ "a"])({}, options);\n    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].OPACITY] = options.opacity !== undefined ? options.opacity : 1;\n    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].VISIBLE] = options.visible !== undefined ? options.visible : true;\n    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Z_INDEX] = options.zIndex;\n    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;\n    properties[_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;\n    this.setProperties(properties);\n    /**\n     * @type {import("./Layer.js").State}\n     * @private\n     */\n\n    this.state_ = null;\n    /**\n     * The layer type.\n     * @type {import("../LayerType.js").default}\n     * @protected;\n     */\n\n    this.type;\n  }\n\n  if (BaseObject) BaseLayer.__proto__ = BaseObject;\n  BaseLayer.prototype = Object.create(BaseObject && BaseObject.prototype);\n  BaseLayer.prototype.constructor = BaseLayer;\n  /**\n   * Get the layer type (used when creating a layer renderer).\n   * @return {import("../LayerType.js").default} The layer type.\n   */\n\n  BaseLayer.prototype.getType = function getType() {\n    return this.type;\n  };\n  /**\n   * @return {import("./Layer.js").State} Layer state.\n   */\n\n\n  BaseLayer.prototype.getLayerState = function getLayerState() {\n    /** @type {import("./Layer.js").State} */\n    var state = this.state_ ||\n    /** @type {?} */\n    {\n      layer: this,\n      managed: true\n    };\n    state.opacity = Object(_math_js__WEBPACK_IMPORTED_MODULE_3__[/* clamp */ "a"])(this.getOpacity(), 0, 1);\n    state.sourceState = this.getSourceState();\n    state.visible = this.getVisible();\n    state.extent = this.getExtent();\n    state.zIndex = this.getZIndex() || 0;\n    state.maxResolution = this.getMaxResolution();\n    state.minResolution = Math.max(this.getMinResolution(), 0);\n    this.state_ = state;\n    return state;\n  };\n  /**\n   * @abstract\n   * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be\n   *     modified in place).\n   * @return {Array<import("./Layer.js").default>} Array of layers.\n   */\n\n\n  BaseLayer.prototype.getLayersArray = function getLayersArray(opt_array) {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * @abstract\n   * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer\n   *     states (to be modified in place).\n   * @return {Array<import("./Layer.js").State>} List of layer states.\n   */\n\n\n  BaseLayer.prototype.getLayerStatesArray = function getLayerStatesArray(opt_states) {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it\n   * will be visible regardless of extent.\n   * @return {import("../extent.js").Extent|undefined} The layer extent.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.getExtent = function getExtent() {\n    return (\n      /** @type {import("../extent.js").Extent|undefined} */\n      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].EXTENT)\n    );\n  };\n  /**\n   * Return the maximum resolution of the layer.\n   * @return {number} The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.getMaxResolution = function getMaxResolution() {\n    return (\n      /** @type {number} */\n      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MAX_RESOLUTION)\n    );\n  };\n  /**\n   * Return the minimum resolution of the layer.\n   * @return {number} The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.getMinResolution = function getMinResolution() {\n    return (\n      /** @type {number} */\n      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MIN_RESOLUTION)\n    );\n  };\n  /**\n   * Return the opacity of the layer (between 0 and 1).\n   * @return {number} The opacity of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.getOpacity = function getOpacity() {\n    return (\n      /** @type {number} */\n      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].OPACITY)\n    );\n  };\n  /**\n   * @abstract\n   * @return {import("../source/State.js").default} Source state.\n   */\n\n\n  BaseLayer.prototype.getSourceState = function getSourceState() {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Return the visibility of the layer (`true` or `false`).\n   * @return {boolean} The visibility of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.getVisible = function getVisible() {\n    return (\n      /** @type {boolean} */\n      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].VISIBLE)\n    );\n  };\n  /**\n   * Return the Z-index of the layer, which is used to order layers before\n   * rendering. The default Z-index is 0.\n   * @return {number} The Z-index of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.getZIndex = function getZIndex() {\n    return (\n      /** @type {number} */\n      this.get(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Z_INDEX)\n    );\n  };\n  /**\n   * Set the extent at which the layer is visible.  If `undefined`, the layer\n   * will be visible at all extents.\n   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.setExtent = function setExtent(extent) {\n    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].EXTENT, extent);\n  };\n  /**\n   * Set the maximum resolution at which the layer is visible.\n   * @param {number} maxResolution The maximum resolution of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.setMaxResolution = function setMaxResolution(maxResolution) {\n    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MAX_RESOLUTION, maxResolution);\n  };\n  /**\n   * Set the minimum resolution at which the layer is visible.\n   * @param {number} minResolution The minimum resolution of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.setMinResolution = function setMinResolution(minResolution) {\n    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].MIN_RESOLUTION, minResolution);\n  };\n  /**\n   * Set the opacity of the layer, allowed values range from 0 to 1.\n   * @param {number} opacity The opacity of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.setOpacity = function setOpacity(opacity) {\n    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].OPACITY, opacity);\n  };\n  /**\n   * Set the visibility of the layer (`true` or `false`).\n   * @param {boolean} visible The visibility of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.setVisible = function setVisible(visible) {\n    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].VISIBLE, visible);\n  };\n  /**\n   * Set Z-index of the layer, which is used to order layers before rendering.\n   * The default Z-index is 0.\n   * @param {number} zindex The z-index of the layer.\n   * @observable\n   * @api\n   */\n\n\n  BaseLayer.prototype.setZIndex = function setZIndex(zindex) {\n    this.set(_Property_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Z_INDEX, zindex);\n  };\n\n  return BaseLayer;\n}(_Object_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["a"] = (BaseLayer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2xheWVyL0Jhc2UuanM/ZmMxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvQmFzZVxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQgTGF5ZXJQcm9wZXJ0eSBmcm9tICcuL1Byb3BlcnR5LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4uL29iai5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWJzdHJhY3QgYmFzZSBjbGFzczsgbm9ybWFsbHkgb25seSB1c2VkIGZvciBjcmVhdGluZyBzdWJjbGFzc2VzIGFuZCBub3RcbiAqIGluc3RhbnRpYXRlZCBpbiBhcHBzLlxuICogTm90ZSB0aGF0IHdpdGgge0BsaW5rIG1vZHVsZTpvbC9sYXllci9CYXNlfSBhbmQgYWxsIGl0cyBzdWJjbGFzc2VzLCBhbnkgcHJvcGVydHkgc2V0IGluXG4gKiB0aGUgb3B0aW9ucyBpcyBzZXQgYXMgYSB7QGxpbmsgbW9kdWxlOm9sL09iamVjdH0gcHJvcGVydHkgb24gdGhlIGxheWVyIG9iamVjdCwgc29cbiAqIGlzIG9ic2VydmFibGUsIGFuZCBoYXMgZ2V0L3NldCBhY2Nlc3NvcnMuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBCYXNlTGF5ZXIgZXh0ZW5kcyBCYXNlT2JqZWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBMYXllciBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuT1BBQ0lUWV0gPVxuICAgICAgIG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vcGFjaXR5IDogMTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuVklTSUJMRV0gPVxuICAgICAgIG9wdGlvbnMudmlzaWJsZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy52aXNpYmxlIDogdHJ1ZTtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuWl9JTkRFWF0gPSBvcHRpb25zLnpJbmRleDtcbiAgICBwcm9wZXJ0aWVzW0xheWVyUHJvcGVydHkuTUFYX1JFU09MVVRJT05dID1cbiAgICAgICBvcHRpb25zLm1heFJlc29sdXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4UmVzb2x1dGlvbiA6IEluZmluaXR5O1xuICAgIHByb3BlcnRpZXNbTGF5ZXJQcm9wZXJ0eS5NSU5fUkVTT0xVVElPTl0gPVxuICAgICAgIG9wdGlvbnMubWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5SZXNvbHV0aW9uIDogMDtcblxuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5zdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxheWVyIHR5cGUuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL0xheWVyVHlwZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcm90ZWN0ZWQ7XG4gICAgICovXG4gICAgdGhpcy50eXBlO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllciB0eXBlICh1c2VkIHdoZW4gY3JlYXRpbmcgYSBsYXllciByZW5kZXJlcikuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL0xheWVyVHlwZS5qc1wiKS5kZWZhdWx0fSBUaGUgbGF5ZXIgdHlwZS5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlfSBMYXllciBzdGF0ZS5cbiAgICovXG4gIGdldExheWVyU3RhdGUoKSB7XG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlfSAqL1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZV8gfHwgLyoqIEB0eXBlIHs/fSAqLyAoe1xuICAgICAgbGF5ZXI6IHRoaXMsXG4gICAgICBtYW5hZ2VkOiB0cnVlXG4gICAgfSk7XG4gICAgc3RhdGUub3BhY2l0eSA9IGNsYW1wKHRoaXMuZ2V0T3BhY2l0eSgpLCAwLCAxKTtcbiAgICBzdGF0ZS5zb3VyY2VTdGF0ZSA9IHRoaXMuZ2V0U291cmNlU3RhdGUoKTtcbiAgICBzdGF0ZS52aXNpYmxlID0gdGhpcy5nZXRWaXNpYmxlKCk7XG4gICAgc3RhdGUuZXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICBzdGF0ZS56SW5kZXggPSB0aGlzLmdldFpJbmRleCgpIHx8IDA7XG4gICAgc3RhdGUubWF4UmVzb2x1dGlvbiA9IHRoaXMuZ2V0TWF4UmVzb2x1dGlvbigpO1xuICAgIHN0YXRlLm1pblJlc29sdXRpb24gPSBNYXRoLm1heCh0aGlzLmdldE1pblJlc29sdXRpb24oKSwgMCk7XG4gICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHQ+PX0gb3B0X2FycmF5IEFycmF5IG9mIGxheWVycyAodG8gYmVcbiAgICogICAgIG1vZGlmaWVkIGluIHBsYWNlKS5cbiAgICogQHJldHVybiB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gQXJyYXkgb2YgbGF5ZXJzLlxuICAgKi9cbiAgZ2V0TGF5ZXJzQXJyYXkob3B0X2FycmF5KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KFwiLi9MYXllci5qc1wiKS5TdGF0ZT49fSBvcHRfc3RhdGVzIE9wdGlvbmFsIGxpc3Qgb2YgbGF5ZXJcbiAgICogICAgIHN0YXRlcyAodG8gYmUgbW9kaWZpZWQgaW4gcGxhY2UpLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0xheWVyLmpzXCIpLlN0YXRlPn0gTGlzdCBvZiBsYXllciBzdGF0ZXMuXG4gICAqL1xuICBnZXRMYXllclN0YXRlc0FycmF5KG9wdF9zdGF0ZXMpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHtAbGluayBtb2R1bGU6b2wvZXh0ZW50fkV4dGVudCBleHRlbnR9IG9mIHRoZSBsYXllciBvciBgdW5kZWZpbmVkYCBpZiBpdFxuICAgKiB3aWxsIGJlIHZpc2libGUgcmVnYXJkbGVzcyBvZiBleHRlbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR8dW5kZWZpbmVkfSBUaGUgbGF5ZXIgZXh0ZW50LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRFeHRlbnQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5LkVYVEVOVCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluUmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBvcGFjaXR5IG9mIHRoZSBsYXllciAoYmV0d2VlbiAwIGFuZCAxKS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5PUEFDSVRZKSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NvdXJjZS9TdGF0ZS5qc1wiKS5kZWZhdWx0fSBTb3VyY2Ugc3RhdGUuXG4gICAqL1xuICBnZXRTb3VyY2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZpc2liaWxpdHkgb2YgdGhlIGxheWVyIChgdHJ1ZWAgb3IgYGZhbHNlYCkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VmlzaWJsZSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodGhpcy5nZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBaLWluZGV4IG9mIHRoZSBsYXllciwgd2hpY2ggaXMgdXNlZCB0byBvcmRlciBsYXllcnMgYmVmb3JlXG4gICAqIHJlbmRlcmluZy4gVGhlIGRlZmF1bHQgWi1pbmRleCBpcyAwLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBaLWluZGV4IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0WkluZGV4KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0KExheWVyUHJvcGVydHkuWl9JTkRFWCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZXh0ZW50IGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLiAgSWYgYHVuZGVmaW5lZGAsIHRoZSBsYXllclxuICAgKiB3aWxsIGJlIHZpc2libGUgYXQgYWxsIGV4dGVudHMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudHx1bmRlZmluZWR9IGV4dGVudCBUaGUgZXh0ZW50IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0RXh0ZW50KGV4dGVudCkge1xuICAgIHRoaXMuc2V0KExheWVyUHJvcGVydHkuRVhURU5ULCBleHRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4aW11bSByZXNvbHV0aW9uIGF0IHdoaWNoIHRoZSBsYXllciBpcyB2aXNpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmVzb2x1dGlvbiBUaGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWF4UmVzb2x1dGlvbihtYXhSZXNvbHV0aW9uKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5NQVhfUkVTT0xVVElPTiwgbWF4UmVzb2x1dGlvbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBtaW5pbXVtIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIGxheWVyIGlzIHZpc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5SZXNvbHV0aW9uIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRNaW5SZXNvbHV0aW9uKG1pblJlc29sdXRpb24pIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk1JTl9SRVNPTFVUSU9OLCBtaW5SZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLCBhbGxvd2VkIHZhbHVlcyByYW5nZSBmcm9tIDAgdG8gMS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHkgVGhlIG9wYWNpdHkgb2YgdGhlIGxheWVyLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5Lk9QQUNJVFksIG9wYWNpdHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbGF5ZXIgKGB0cnVlYCBvciBgZmFsc2VgKS5cbiAgICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsYXllci5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0VmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgdGhpcy5zZXQoTGF5ZXJQcm9wZXJ0eS5WSVNJQkxFLCB2aXNpYmxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgWi1pbmRleCBvZiB0aGUgbGF5ZXIsIHdoaWNoIGlzIHVzZWQgdG8gb3JkZXIgbGF5ZXJzIGJlZm9yZSByZW5kZXJpbmcuXG4gICAqIFRoZSBkZWZhdWx0IFotaW5kZXggaXMgMC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHppbmRleCBUaGUgei1pbmRleCBvZiB0aGUgbGF5ZXIuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFpJbmRleCh6aW5kZXgpIHtcbiAgICB0aGlzLnNldChMYXllclByb3BlcnR5LlpfSU5ERVgsIHppbmRleCk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBCYXNlTGF5ZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTtBQUFBO0FBQUE7QUFJQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUdBOzs7Ozs7QUFNQTs7Ozs7OztBQU9BOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQUtBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFHQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7QUE3TkE7QUFDQTtBQStOQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///93\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);\n/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);\n/* harmony import */ var _State_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);\n/**\n * @module ol/source/Source\n */\n\n\n\n\n/**\n * A function that returns a string or an array of strings representing source\n * attributions.\n *\n * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution\n */\n\n/**\n * A type that can be used to provide attribution information for data sources.\n *\n * It represents either\n * * a simple string (e.g. `\' Acme Inc.\'`)\n * * an array of simple strings (e.g. `[\' Acme Inc.\', \' Bacme Inc.\']`)\n * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)\n *\n * @typedef {string|Array<string>|Attribution} AttributionLike\n */\n\n/**\n * @typedef {Object} Options\n * @property {AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {import("../proj.js").ProjectionLike} projection\n * @property {SourceState} [state=\'ready\']\n * @property {boolean} [wrapX=false]\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for {@link module:ol/layer/Layer~Layer} sources.\n *\n * A generic `change` event is triggered when the state of the source changes.\n * @abstract\n * @api\n */\n\nvar Source =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function Source(options) {\n    BaseObject.call(this);\n    /**\n     * @private\n     * @type {import("../proj/Projection.js").default}\n     */\n\n    this.projection_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_2__["get"])(options.projection);\n    /**\n     * @private\n     * @type {?Attribution}\n     */\n\n    this.attributions_ = adaptAttributions(options.attributions);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;\n    /**\n     * This source is currently loading data. Sources that defer loading to the\n     * map\'s tile queue never set this to `true`.\n     * @type {boolean}\n     */\n\n    this.loading = false;\n    /**\n     * @private\n     * @type {SourceState}\n     */\n\n    this.state_ = options.state !== undefined ? options.state : _State_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].READY;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;\n  }\n\n  if (BaseObject) Source.__proto__ = BaseObject;\n  Source.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Source.prototype.constructor = Source;\n  /**\n   * Get the attribution function for the source.\n   * @return {?Attribution} Attribution function.\n   */\n\n  Source.prototype.getAttributions = function getAttributions() {\n    return this.attributions_;\n  };\n  /**\n   * @return {boolean} Aattributions are collapsible.\n   */\n\n\n  Source.prototype.getAttributionsCollapsible = function getAttributionsCollapsible() {\n    return this.attributionsCollapsible_;\n  };\n  /**\n   * Get the projection of the source.\n   * @return {import("../proj/Projection.js").default} Projection.\n   * @api\n   */\n\n\n  Source.prototype.getProjection = function getProjection() {\n    return this.projection_;\n  };\n  /**\n   * @abstract\n   * @return {Array<number>|undefined} Resolutions.\n   */\n\n\n  Source.prototype.getResolutions = function getResolutions() {\n    return Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* abstract */ "b"])();\n  };\n  /**\n   * Get the state of the source, see {@link module:ol/source/State~State} for possible states.\n   * @return {SourceState} State.\n   * @api\n   */\n\n\n  Source.prototype.getState = function getState() {\n    return this.state_;\n  };\n  /**\n   * @return {boolean|undefined} Wrap X.\n   */\n\n\n  Source.prototype.getWrapX = function getWrapX() {\n    return this.wrapX_;\n  };\n  /**\n   * Refreshes the source and finally dispatches a \'change\' event.\n   * @api\n   */\n\n\n  Source.prototype.refresh = function refresh() {\n    this.changed();\n  };\n  /**\n   * Set the attributions of the source.\n   * @param {AttributionLike|undefined} attributions Attributions.\n   *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,\n   *     or `undefined`.\n   * @api\n   */\n\n\n  Source.prototype.setAttributions = function setAttributions(attributions) {\n    this.attributions_ = adaptAttributions(attributions);\n    this.changed();\n  };\n  /**\n   * Set the state of the source.\n   * @param {SourceState} state State.\n   * @protected\n   */\n\n\n  Source.prototype.setState = function setState(state) {\n    this.state_ = state;\n    this.changed();\n  };\n\n  return Source;\n}(_Object_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n/**\n * Turns the attributions option into an attributions function.\n * @param {AttributionLike|undefined} attributionLike The attribution option.\n * @return {?Attribution} An attribution function (or null).\n */\n\n\nfunction adaptAttributions(attributionLike) {\n  if (!attributionLike) {\n    return null;\n  }\n\n  if (Array.isArray(attributionLike)) {\n    return function (frameState) {\n      return attributionLike;\n    };\n  }\n\n  if (typeof attributionLike === \'function\') {\n    return attributionLike;\n  }\n\n  return function (frameState) {\n    return [attributionLike];\n  };\n}\n\n/* harmony default export */ __webpack_exports__["a"] = (Source);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3NvdXJjZS9Tb3VyY2UuanM/NGRlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1NvdXJjZVxuICovXG5pbXBvcnQge2Fic3RyYWN0fSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0IGZyb20gJy4uL09iamVjdC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9ufSBmcm9tICcuLi9wcm9qLmpzJztcbmltcG9ydCBTb3VyY2VTdGF0ZSBmcm9tICcuL1N0YXRlLmpzJztcblxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHNvdXJjZVxuICogYXR0cmlidXRpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZSk6IChzdHJpbmd8QXJyYXk8c3RyaW5nPil9IEF0dHJpYnV0aW9uXG4gKi9cblxuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb3ZpZGUgYXR0cmlidXRpb24gaW5mb3JtYXRpb24gZm9yIGRhdGEgc291cmNlcy5cbiAqXG4gKiBJdCByZXByZXNlbnRzIGVpdGhlclxuICogKiBhIHNpbXBsZSBzdHJpbmcgKGUuZy4gYCfCqSBBY21lIEluYy4nYClcbiAqICogYW4gYXJyYXkgb2Ygc2ltcGxlIHN0cmluZ3MgKGUuZy4gYFsnwqkgQWNtZSBJbmMuJywgJ8KpIEJhY21lIEluYy4nXWApXG4gKiAqIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgKGB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9Tb3VyY2V+QXR0cmlidXRpb259YClcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfEFycmF5PHN0cmluZz58QXR0cmlidXRpb259IEF0dHJpYnV0aW9uTGlrZVxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge0F0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb25cbiAqIEBwcm9wZXJ0eSB7U291cmNlU3RhdGV9IFtzdGF0ZT0ncmVhZHknXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9ZmFsc2VdXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXJ9IHNvdXJjZXMuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlIGNoYW5nZXMuXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgU291cmNlIGV4dGVuZHMgQmFzZU9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgU291cmNlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5wcm9qZWN0aW9uXyA9IGdldFByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9BdHRyaWJ1dGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0aW9uc18gPSBhZGFwdEF0dHJpYnV0aW9ucyhvcHRpb25zLmF0dHJpYnV0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRpb25zQ29sbGFwc2libGVfID0gb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGUgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBzb3VyY2UgaXMgY3VycmVudGx5IGxvYWRpbmcgZGF0YS4gU291cmNlcyB0aGF0IGRlZmVyIGxvYWRpbmcgdG8gdGhlXG4gICAgICogbWFwJ3MgdGlsZSBxdWV1ZSBuZXZlciBzZXQgdGhpcyB0byBgdHJ1ZWAuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtTb3VyY2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlXyA9IG9wdGlvbnMuc3RhdGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnN0YXRlIDogU291cmNlU3RhdGUuUkVBRFk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMud3JhcFhfID0gb3B0aW9ucy53cmFwWCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwWCA6IGZhbHNlO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhdHRyaWJ1dGlvbiBmdW5jdGlvbiBmb3IgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7P0F0dHJpYnV0aW9ufSBBdHRyaWJ1dGlvbiBmdW5jdGlvbi5cbiAgICovXG4gIGdldEF0dHJpYnV0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGlvbnNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEFhdHRyaWJ1dGlvbnMgYXJlIGNvbGxhcHNpYmxlLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRpb25zQ29sbGFwc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRpb25zQ29sbGFwc2libGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJvamVjdGlvbiBvZiB0aGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gUHJvamVjdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IFJlc29sdXRpb25zLlxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBvZiB0aGUgc291cmNlLCBzZWUge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvU3RhdGV+U3RhdGV9IGZvciBwb3NzaWJsZSBzdGF0ZXMuXG4gICAqIEByZXR1cm4ge1NvdXJjZVN0YXRlfSBTdGF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfSBXcmFwIFguXG4gICAqL1xuICBnZXRXcmFwWCgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwWF87XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaGVzIHRoZSBzb3VyY2UgYW5kIGZpbmFsbHkgZGlzcGF0Y2hlcyBhICdjaGFuZ2UnIGV2ZW50LlxuICAgKiBAYXBpXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXR0cmlidXRpb25zIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7QXR0cmlidXRpb25MaWtlfHVuZGVmaW5lZH0gYXR0cmlidXRpb25zIEF0dHJpYnV0aW9ucy5cbiAgICogICAgIENhbiBiZSBwYXNzZWQgYXMgYHN0cmluZ2AsIGBBcnJheTxzdHJpbmc+YCwgYHtAbGluayBtb2R1bGU6b2wvc291cmNlL1NvdXJjZX5BdHRyaWJ1dGlvbn1gLFxuICAgKiAgICAgb3IgYHVuZGVmaW5lZGAuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEF0dHJpYnV0aW9ucyhhdHRyaWJ1dGlvbnMpIHtcbiAgICB0aGlzLmF0dHJpYnV0aW9uc18gPSBhZGFwdEF0dHJpYnV0aW9ucyhhdHRyaWJ1dGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtTb3VyY2VTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogVHVybnMgdGhlIGF0dHJpYnV0aW9ucyBvcHRpb24gaW50byBhbiBhdHRyaWJ1dGlvbnMgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0F0dHJpYnV0aW9uTGlrZXx1bmRlZmluZWR9IGF0dHJpYnV0aW9uTGlrZSBUaGUgYXR0cmlidXRpb24gb3B0aW9uLlxuICogQHJldHVybiB7P0F0dHJpYnV0aW9ufSBBbiBhdHRyaWJ1dGlvbiBmdW5jdGlvbiAob3IgbnVsbCkuXG4gKi9cbmZ1bmN0aW9uIGFkYXB0QXR0cmlidXRpb25zKGF0dHJpYnV0aW9uTGlrZSkge1xuICBpZiAoIWF0dHJpYnV0aW9uTGlrZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0aW9uTGlrZSkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZnJhbWVTdGF0ZSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0aW9uTGlrZTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGlvbkxpa2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gYXR0cmlidXRpb25MaWtlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZyYW1lU3RhdGUpIHtcbiAgICByZXR1cm4gW2F0dHJpYnV0aW9uTGlrZV07XG4gIH07XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgU291cmNlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBO0FBQUE7QUFBQTtBQUlBO0FBRUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFRQTs7Ozs7O0FBTUE7Ozs7OztBQU9BOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTlIQTs7Ozs7Ozs7QUFzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///94\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return forEach; });\n/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(this: S, import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function\n *     called for each segment.\n * @param {S=} opt_this The object to be used as the value of \'this\'\n *     within callback.\n * @return {T|boolean} Value.\n * @template T,S\n */\nfunction forEach(flatCoordinates, offset, end, stride, callback, opt_this) {\n  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n  var point2 = [];\n  var ret;\n\n  for (; offset + stride < end; offset += stride) {\n    point2[0] = flatCoordinates[offset + stride];\n    point2[1] = flatCoordinates[offset + stride + 1];\n    ret = callback.call(opt_this, point1, point2);\n\n    if (ret) {\n      return ret;\n    }\n\n    point1[0] = point2[0];\n    point1[1] = point2[1];\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9zZWdtZW50cy5qcz8yNThlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9nZW9tL2ZsYXQvc2VnbWVudHNcbiAqL1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYWxscyBgY2FsbGJhY2tgIGZvciBlYWNoIHNlZ21lbnQgb2YgdGhlIGZsYXQgY29vcmRpbmF0ZXNcbiAqIGFycmF5LiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGF0XG4gKiB2YWx1ZSBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuLi8uLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGUsIGltcG9ydChcIi4uLy4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSk6IFR9IGNhbGxiYWNrIEZ1bmN0aW9uXG4gKiAgICAgY2FsbGVkIGZvciBlYWNoIHNlZ21lbnQuXG4gKiBAcGFyYW0ge1M9fSBvcHRfdGhpcyBUaGUgb2JqZWN0IHRvIGJlIHVzZWQgYXMgdGhlIHZhbHVlIG9mICd0aGlzJ1xuICogICAgIHdpdGhpbiBjYWxsYmFjay5cbiAqIEByZXR1cm4ge1R8Ym9vbGVhbn0gVmFsdWUuXG4gKiBAdGVtcGxhdGUgVCxTXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgY2FsbGJhY2ssIG9wdF90aGlzKSB7XG4gIGNvbnN0IHBvaW50MSA9IFtmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XSwgZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdXTtcbiAgY29uc3QgcG9pbnQyID0gW107XG4gIGxldCByZXQ7XG4gIGZvciAoOyAob2Zmc2V0ICsgc3RyaWRlKSA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgIHBvaW50MlswXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGVdO1xuICAgIHBvaW50MlsxXSA9IGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyBzdHJpZGUgKyAxXTtcbiAgICByZXQgPSBjYWxsYmFjay5jYWxsKG9wdF90aGlzLCBwb2ludDEsIHBvaW50Mik7XG4gICAgaWYgKHJldCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcG9pbnQxWzBdID0gcG9pbnQyWzBdO1xuICAgIHBvaW50MVsxXSA9IHBvaW50MlsxXTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///95\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return lineStringLength; });\n/* unused harmony export linearRingLength */\n/**\n * @module ol/geom/flat/length\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nfunction lineStringLength(flatCoordinates, offset, end, stride) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  var length = 0;\n\n  for (var i = offset + stride; i < end; i += stride) {\n    var x2 = flatCoordinates[i];\n    var y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n\n  return length;\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\n\nfunction linearRingLength(flatCoordinates, offset, end, stride) {\n  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9sZW5ndGguanM/ZGY3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZ2VvbS9mbGF0L2xlbmd0aFxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICogQHJldHVybiB7bnVtYmVyfSBMZW5ndGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lU3RyaW5nTGVuZ3RoKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICBsZXQgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbb2Zmc2V0XTtcbiAgbGV0IHkxID0gZmxhdENvb3JkaW5hdGVzW29mZnNldCArIDFdO1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IG9mZnNldCArIHN0cmlkZTsgaSA8IGVuZDsgaSArPSBzdHJpZGUpIHtcbiAgICBjb25zdCB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICBjb25zdCB5MiA9IGZsYXRDb29yZGluYXRlc1tpICsgMV07XG4gICAgbGVuZ3RoICs9IE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgfVxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEByZXR1cm4ge251bWJlcn0gUGVyaW1ldGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUmluZ0xlbmd0aChmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCBzdHJpZGUpIHtcbiAgbGV0IHBlcmltZXRlciA9IGxpbmVTdHJpbmdMZW5ndGgoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKTtcbiAgY29uc3QgZHggPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXSAtIGZsYXRDb29yZGluYXRlc1tvZmZzZXRdO1xuICBjb25zdCBkeSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXSAtIGZsYXRDb29yZGluYXRlc1tvZmZzZXQgKyAxXTtcbiAgcGVyaW1ldGVyICs9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHJldHVybiBwZXJpbWV0ZXI7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///96\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getInteriorPointOfArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getInteriorPointsOfMultiArray; });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);\n/**\n * @module ol/geom/flat/interiorpoint\n */\n\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS\'s com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\n\nfunction getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n  var i, ii, x, x1, x2, y1, y2;\n  var y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n\n  var intersections = []; // Calculate intersections with the horizontal line\n\n  for (var r = 0, rr = ends.length; r < rr; ++r) {\n    var end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n\n      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {\n        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n\n      x1 = x2;\n      y1 = y2;\n    }\n  } // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n\n\n  var pointX = NaN;\n  var maxSegmentLength = -Infinity;\n  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__[/* numberSafeCompareFunction */ "g"]);\n  x1 = intersections[0];\n\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    var segmentLength = Math.abs(x2 - x1);\n\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n\n      if (Object(_contains_js__WEBPACK_IMPORTED_MODULE_1__[/* linearRingsContainsXY */ "c"])(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n\n    x1 = x2;\n  }\n\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring\'s extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n\n  if (opt_dest) {\n    opt_dest.push(pointX, y, maxSegmentLength);\n    return opt_dest;\n  } else {\n    return [pointX, y, maxSegmentLength];\n  }\n}\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\n\nfunction getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\n  var interiorPoints = [];\n\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n    offset = ends[ends.length - 1];\n  }\n\n  return interiorPoints;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL2dlb20vZmxhdC9pbnRlcmlvcnBvaW50LmpzPzU5M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2dlb20vZmxhdC9pbnRlcmlvcnBvaW50XG4gKi9cbmltcG9ydCB7bnVtYmVyU2FmZUNvbXBhcmVGdW5jdGlvbn0gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtsaW5lYXJSaW5nc0NvbnRhaW5zWFl9IGZyb20gJy4vY29udGFpbnMuanMnO1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIHBvaW50IHRoYXQgaXMgbGlrZWx5IHRvIGxpZSBpbiB0aGUgaW50ZXJpb3Igb2YgdGhlIGxpbmVhciByaW5ncy5cbiAqIEluc3BpcmVkIGJ5IEpUUydzIGNvbS52aXZpZHNvbHV0aW9ucy5qdHMuZ2VvbS5HZW9tZXRyeSNnZXRJbnRlcmlvclBvaW50LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBlbmRzIEVuZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENlbnRlcnMgRmxhdCBjZW50ZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYXRDZW50ZXJzT2Zmc2V0IEZsYXQgY2VudGVyIG9mZnNldC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPj19IG9wdF9kZXN0IERlc3RpbmF0aW9uLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gRGVzdGluYXRpb24gcG9pbnQgYXMgWFlNIGNvb3JkaW5hdGUsIHdoZXJlIE0gaXMgdGhlXG4gKiBsZW5ndGggb2YgdGhlIGhvcml6b250YWwgaW50ZXJzZWN0aW9uIHRoYXQgdGhlIHBvaW50IGJlbG9uZ3MgdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcmlvclBvaW50T2ZBcnJheShmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCxcbiAgZW5kcywgc3RyaWRlLCBmbGF0Q2VudGVycywgZmxhdENlbnRlcnNPZmZzZXQsIG9wdF9kZXN0KSB7XG4gIGxldCBpLCBpaSwgeCwgeDEsIHgyLCB5MSwgeTI7XG4gIGNvbnN0IHkgPSBmbGF0Q2VudGVyc1tmbGF0Q2VudGVyc09mZnNldCArIDFdO1xuICAvKiogQHR5cGUge0FycmF5PG51bWJlcj59ICovXG4gIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgLy8gQ2FsY3VsYXRlIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lXG4gIGZvciAobGV0IHIgPSAwLCByciA9IGVuZHMubGVuZ3RoOyByIDwgcnI7ICsrcikge1xuICAgIGNvbnN0IGVuZCA9IGVuZHNbcl07XG4gICAgeDEgPSBmbGF0Q29vcmRpbmF0ZXNbZW5kIC0gc3RyaWRlXTtcbiAgICB5MSA9IGZsYXRDb29yZGluYXRlc1tlbmQgLSBzdHJpZGUgKyAxXTtcbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB4MiA9IGZsYXRDb29yZGluYXRlc1tpXTtcbiAgICAgIHkyID0gZmxhdENvb3JkaW5hdGVzW2kgKyAxXTtcbiAgICAgIGlmICgoeSA8PSB5MSAmJiB5MiA8PSB5KSB8fCAoeTEgPD0geSAmJiB5IDw9IHkyKSkge1xuICAgICAgICB4ID0gKHkgLSB5MSkgLyAoeTIgLSB5MSkgKiAoeDIgLSB4MSkgKyB4MTtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKHgpO1xuICAgICAgfVxuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfVxuICB9XG4gIC8vIEZpbmQgdGhlIGxvbmdlc3Qgc2VnbWVudCBvZiB0aGUgaG9yaXpvbnRhbCBsaW5lIHRoYXQgaGFzIGl0cyBjZW50ZXIgcG9pbnRcbiAgLy8gaW5zaWRlIHRoZSBsaW5lYXIgcmluZy5cbiAgbGV0IHBvaW50WCA9IE5hTjtcbiAgbGV0IG1heFNlZ21lbnRMZW5ndGggPSAtSW5maW5pdHk7XG4gIGludGVyc2VjdGlvbnMuc29ydChudW1iZXJTYWZlQ29tcGFyZUZ1bmN0aW9uKTtcbiAgeDEgPSBpbnRlcnNlY3Rpb25zWzBdO1xuICBmb3IgKGkgPSAxLCBpaSA9IGludGVyc2VjdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHgyID0gaW50ZXJzZWN0aW9uc1tpXTtcbiAgICBjb25zdCBzZWdtZW50TGVuZ3RoID0gTWF0aC5hYnMoeDIgLSB4MSk7XG4gICAgaWYgKHNlZ21lbnRMZW5ndGggPiBtYXhTZWdtZW50TGVuZ3RoKSB7XG4gICAgICB4ID0gKHgxICsgeDIpIC8gMjtcbiAgICAgIGlmIChsaW5lYXJSaW5nc0NvbnRhaW5zWFkoZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHMsIHN0cmlkZSwgeCwgeSkpIHtcbiAgICAgICAgcG9pbnRYID0geDtcbiAgICAgICAgbWF4U2VnbWVudExlbmd0aCA9IHNlZ21lbnRMZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHgxID0geDI7XG4gIH1cbiAgaWYgKGlzTmFOKHBvaW50WCkpIHtcbiAgICAvLyBUaGVyZSBpcyBubyBob3Jpem9udGFsIGxpbmUgdGhhdCBoYXMgaXRzIGNlbnRlciBwb2ludCBpbnNpZGUgdGhlIGxpbmVhclxuICAgIC8vIHJpbmcuICBVc2UgdGhlIGNlbnRlciBvZiB0aGUgdGhlIGxpbmVhciByaW5nJ3MgZXh0ZW50LlxuICAgIHBvaW50WCA9IGZsYXRDZW50ZXJzW2ZsYXRDZW50ZXJzT2Zmc2V0XTtcbiAgfVxuICBpZiAob3B0X2Rlc3QpIHtcbiAgICBvcHRfZGVzdC5wdXNoKHBvaW50WCwgeSwgbWF4U2VnbWVudExlbmd0aCk7XG4gICAgcmV0dXJuIG9wdF9kZXN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbcG9pbnRYLCB5LCBtYXhTZWdtZW50TGVuZ3RoXTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBmbGF0Q29vcmRpbmF0ZXMgRmxhdCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZW5kc3MgRW5kc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIFN0cmlkZS5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENlbnRlcnMgRmxhdCBjZW50ZXJzLlxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gSW50ZXJpb3IgcG9pbnRzIGFzIFhZTSBjb29yZGluYXRlcywgd2hlcmUgTSBpcyB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgaG9yaXpvbnRhbCBpbnRlcnNlY3Rpb24gdGhhdCB0aGUgcG9pbnQgYmVsb25ncyB0by5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyaW9yUG9pbnRzT2ZNdWx0aUFycmF5KGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzcywgc3RyaWRlLCBmbGF0Q2VudGVycykge1xuICBsZXQgaW50ZXJpb3JQb2ludHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kc3MubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICBpbnRlcmlvclBvaW50cyA9IGdldEludGVyaW9yUG9pbnRPZkFycmF5KGZsYXRDb29yZGluYXRlcyxcbiAgICAgIG9mZnNldCwgZW5kcywgc3RyaWRlLCBmbGF0Q2VudGVycywgMiAqIGksIGludGVyaW9yUG9pbnRzKTtcbiAgICBvZmZzZXQgPSBlbmRzW2VuZHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGludGVyaW9yUG9pbnRzO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var _colorlike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);\n/* harmony import */ var _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);\n/* harmony import */ var _geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31);\n/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);\n/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19);\n/* harmony import */ var _VectorContext_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(99);\n/* harmony import */ var _canvas_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(4);\n/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9);\n/**\n * @module ol/render/canvas/Immediate\n */\n// FIXME test, especially polygons with holes and multipolygons\n// FIXME need to handle large thick features (where pixel size matters)\n// FIXME add offset and end to ol/geom/flat/transform~transform2D?\n\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * A concrete subclass of {@link module:ol/render/VectorContext} that implements\n * direct rendering of features and geometries to an HTML5 Canvas context.\n * Instances of this class are created internally by the library and\n * provided to application code as vectorContext member of the\n * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and\n * render events emitted by layers and maps.\n */\n\nvar CanvasImmediateRenderer =\n/*@__PURE__*/\nfunction (VectorContext) {\n  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation) {\n    VectorContext.call(this);\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.context_ = context;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {import("../../extent.js").Extent}\n     */\n\n    this.extent_ = extent;\n    /**\n     * @private\n     * @type {import("../../transform.js").Transform}\n     */\n\n    this.transform_ = transform;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.viewRotation_ = viewRotation;\n    /**\n     * @private\n     * @type {?import("../canvas.js").FillState}\n     */\n\n    this.contextFillState_ = null;\n    /**\n     * @private\n     * @type {?import("../canvas.js").StrokeState}\n     */\n\n    this.contextStrokeState_ = null;\n    /**\n     * @private\n     * @type {?import("../canvas.js").TextState}\n     */\n\n    this.contextTextState_ = null;\n    /**\n     * @private\n     * @type {?import("../canvas.js").FillState}\n     */\n\n    this.fillState_ = null;\n    /**\n     * @private\n     * @type {?import("../canvas.js").StrokeState}\n     */\n\n    this.strokeState_ = null;\n    /**\n     * @private\n     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}\n     */\n\n    this.image_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageAnchorX_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageAnchorY_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageHeight_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageOpacity_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageOriginX_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageOriginY_ = 0;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.imageRotateWithView_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageRotation_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageScale_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.imageWidth_ = 0;\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.text_ = \'\';\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textOffsetX_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textOffsetY_ = 0;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.textRotateWithView_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textRotation_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.textScale_ = 0;\n    /**\n     * @private\n     * @type {?import("../canvas.js").FillState}\n     */\n\n    this.textFillState_ = null;\n    /**\n     * @private\n     * @type {?import("../canvas.js").StrokeState}\n     */\n\n    this.textStrokeState_ = null;\n    /**\n     * @private\n     * @type {?import("../canvas.js").TextState}\n     */\n\n    this.textState_ = null;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.pixelCoordinates_ = [];\n    /**\n     * @private\n     * @type {import("../../transform.js").Transform}\n     */\n\n    this.tmpLocalTransform_ = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__[/* create */ "c"])();\n  }\n\n  if (VectorContext) CanvasImmediateRenderer.__proto__ = VectorContext;\n  CanvasImmediateRenderer.prototype = Object.create(VectorContext && VectorContext.prototype);\n  CanvasImmediateRenderer.prototype.constructor = CanvasImmediateRenderer;\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   */\n\n  CanvasImmediateRenderer.prototype.drawImages_ = function drawImages_(flatCoordinates, offset, end, stride) {\n    if (!this.image_) {\n      return;\n    }\n\n    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__[/* transform2D */ "c"])(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);\n    var context = this.context_;\n    var localTransform = this.tmpLocalTransform_;\n    var alpha = context.globalAlpha;\n\n    if (this.imageOpacity_ != 1) {\n      context.globalAlpha = alpha * this.imageOpacity_;\n    }\n\n    var rotation = this.imageRotation_;\n\n    if (this.imageRotateWithView_) {\n      rotation += this.viewRotation_;\n    }\n\n    for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {\n      var x = pixelCoordinates[i] - this.imageAnchorX_;\n      var y = pixelCoordinates[i + 1] - this.imageAnchorY_;\n\n      if (rotation !== 0 || this.imageScale_ != 1) {\n        var centerX = x + this.imageAnchorX_;\n        var centerY = y + this.imageAnchorY_;\n        Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__[/* compose */ "b"])(localTransform, centerX, centerY, this.imageScale_, this.imageScale_, rotation, -centerX, -centerY);\n        context.setTransform.apply(context, localTransform);\n      }\n\n      context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);\n    }\n\n    if (rotation !== 0 || this.imageScale_ != 1) {\n      context.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    if (this.imageOpacity_ != 1) {\n      context.globalAlpha = alpha;\n    }\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @private\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawText_ = function drawText_(flatCoordinates, offset, end, stride) {\n    if (!this.textState_ || this.text_ === \'\') {\n      return;\n    }\n\n    if (this.textFillState_) {\n      this.setContextFillState_(this.textFillState_);\n    }\n\n    if (this.textStrokeState_) {\n      this.setContextStrokeState_(this.textStrokeState_);\n    }\n\n    this.setContextTextState_(this.textState_);\n    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__[/* transform2D */ "c"])(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);\n    var context = this.context_;\n    var rotation = this.textRotation_;\n\n    if (this.textRotateWithView_) {\n      rotation += this.viewRotation_;\n    }\n\n    for (; offset < end; offset += stride) {\n      var x = pixelCoordinates[offset] + this.textOffsetX_;\n      var y = pixelCoordinates[offset + 1] + this.textOffsetY_;\n\n      if (rotation !== 0 || this.textScale_ != 1) {\n        var localTransform = Object(_transform_js__WEBPACK_IMPORTED_MODULE_9__[/* compose */ "b"])(this.tmpLocalTransform_, x, y, this.textScale_, this.textScale_, rotation, -x, -y);\n        context.setTransform.apply(context, localTransform);\n      }\n\n      if (this.textStrokeState_) {\n        context.strokeText(this.text_, x, y);\n      }\n\n      if (this.textFillState_) {\n        context.fillText(this.text_, x, y);\n      }\n    }\n\n    if (rotation !== 0 || this.textScale_ != 1) {\n      context.setTransform(1, 0, 0, 1, 0, 0);\n    }\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} close Close.\n   * @private\n   * @return {number} end End.\n   */\n\n\n  CanvasImmediateRenderer.prototype.moveToLineTo_ = function moveToLineTo_(flatCoordinates, offset, end, stride, close) {\n    var context = this.context_;\n    var pixelCoordinates = Object(_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_5__[/* transform2D */ "c"])(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);\n    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);\n    var length = pixelCoordinates.length;\n\n    if (close) {\n      length -= 2;\n    }\n\n    for (var i = 2; i < length; i += 2) {\n      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);\n    }\n\n    if (close) {\n      context.closePath();\n    }\n\n    return end;\n  };\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @private\n   * @return {number} End.\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawRings_ = function drawRings_(flatCoordinates, offset, ends, stride) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);\n    }\n\n    return offset;\n  };\n  /**\n   * Render a circle geometry into the canvas.  Rendering is immediate and uses\n   * the current fill and stroke styles.\n   *\n   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.\n   * @override\n   * @api\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawCircle = function drawCircle(geometry) {\n    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {\n      return;\n    }\n\n    if (this.fillState_ || this.strokeState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n\n      var pixelCoordinates = Object(_geom_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__[/* transformGeom2D */ "b"])(geometry, this.transform_, this.pixelCoordinates_);\n      var dx = pixelCoordinates[2] - pixelCoordinates[0];\n      var dy = pixelCoordinates[3] - pixelCoordinates[1];\n      var radius = Math.sqrt(dx * dx + dy * dy);\n      var context = this.context_;\n      context.beginPath();\n      context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);\n\n      if (this.fillState_) {\n        context.fill();\n      }\n\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n\n    if (this.text_ !== \'\') {\n      this.drawText_(geometry.getCenter(), 0, 2, 2);\n    }\n  };\n  /**\n   * Set the rendering style.  Note that since this is an immediate rendering API,\n   * any `zIndex` on the provided style will be ignored.\n   *\n   * @param {import("../../style/Style.js").default} style The rendering style.\n   * @override\n   * @api\n   */\n\n\n  CanvasImmediateRenderer.prototype.setStyle = function setStyle(style) {\n    this.setFillStrokeStyle(style.getFill(), style.getStroke());\n    this.setImageStyle(style.getImage());\n    this.setTextStyle(style.getText());\n  };\n  /**\n   * Render a geometry into the canvas.  Call\n   * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.\n   *\n   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.\n   * @override\n   * @api\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawGeometry = function drawGeometry(geometry) {\n    var type = geometry.getType();\n\n    switch (type) {\n      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].POINT:\n        this.drawPoint(\n        /** @type {import("../../geom/Point.js").default} */\n        geometry);\n        break;\n\n      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LINE_STRING:\n        this.drawLineString(\n        /** @type {import("../../geom/LineString.js").default} */\n        geometry);\n        break;\n\n      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].POLYGON:\n        this.drawPolygon(\n        /** @type {import("../../geom/Polygon.js").default} */\n        geometry);\n        break;\n\n      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].MULTI_POINT:\n        this.drawMultiPoint(\n        /** @type {import("../../geom/MultiPoint.js").default} */\n        geometry);\n        break;\n\n      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].MULTI_LINE_STRING:\n        this.drawMultiLineString(\n        /** @type {import("../../geom/MultiLineString.js").default} */\n        geometry);\n        break;\n\n      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].MULTI_POLYGON:\n        this.drawMultiPolygon(\n        /** @type {import("../../geom/MultiPolygon.js").default} */\n        geometry);\n        break;\n\n      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].GEOMETRY_COLLECTION:\n        this.drawGeometryCollection(\n        /** @type {import("../../geom/GeometryCollection.js").default} */\n        geometry);\n        break;\n\n      case _geom_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].CIRCLE:\n        this.drawCircle(\n        /** @type {import("../../geom/Circle.js").default} */\n        geometry);\n        break;\n\n      default:\n    }\n  };\n  /**\n   * Render a feature into the canvas.  Note that any `zIndex` on the provided\n   * style will be ignored - features are rendered immediately in the order that\n   * this method is called.  If you need `zIndex` support, you should be using an\n   * {@link module:ol/layer/Vector~VectorLayer} instead.\n   *\n   * @param {import("../../Feature.js").default} feature Feature.\n   * @param {import("../../style/Style.js").default} style Style.\n   * @override\n   * @api\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawFeature = function drawFeature(feature, style) {\n    var geometry = style.getGeometryFunction()(feature);\n\n    if (!geometry || !Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {\n      return;\n    }\n\n    this.setStyle(style);\n    this.drawGeometry(geometry);\n  };\n  /**\n   * Render a GeometryCollection to the canvas.  Rendering is immediate and\n   * uses the current styles appropriate for each geometry in the collection.\n   *\n   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawGeometryCollection = function drawGeometryCollection(geometry) {\n    var geometries = geometry.getGeometriesArray();\n\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      this.drawGeometry(geometries[i]);\n    }\n  };\n  /**\n   * Render a Point geometry into the canvas.  Rendering is immediate and uses\n   * the current style.\n   *\n   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawPoint = function drawPoint(geometry) {\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n\n    if (this.image_) {\n      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n\n    if (this.text_ !== \'\') {\n      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n  };\n  /**\n   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and\n   * uses the current style.\n   *\n   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawMultiPoint = function drawMultiPoint(geometry) {\n    var flatCoordinates = geometry.getFlatCoordinates();\n    var stride = geometry.getStride();\n\n    if (this.image_) {\n      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n\n    if (this.text_ !== \'\') {\n      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);\n    }\n  };\n  /**\n   * Render a LineString into the canvas.  Rendering is immediate and uses\n   * the current style.\n   *\n   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawLineString = function drawLineString(geometry) {\n    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {\n      return;\n    }\n\n    if (this.strokeState_) {\n      this.setContextStrokeState_(this.strokeState_);\n      var context = this.context_;\n      var flatCoordinates = geometry.getFlatCoordinates();\n      context.beginPath();\n      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);\n      context.stroke();\n    }\n\n    if (this.text_ !== \'\') {\n      var flatMidpoint = geometry.getFlatMidpoint();\n      this.drawText_(flatMidpoint, 0, 2, 2);\n    }\n  };\n  /**\n   * Render a MultiLineString geometry into the canvas.  Rendering is immediate\n   * and uses the current style.\n   *\n   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawMultiLineString = function drawMultiLineString(geometry) {\n    var geometryExtent = geometry.getExtent();\n\n    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometryExtent)) {\n      return;\n    }\n\n    if (this.strokeState_) {\n      this.setContextStrokeState_(this.strokeState_);\n      var context = this.context_;\n      var flatCoordinates = geometry.getFlatCoordinates();\n      var offset = 0;\n      var ends =\n      /** @type {Array<number>} */\n      geometry.getEnds();\n      var stride = geometry.getStride();\n      context.beginPath();\n\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);\n      }\n\n      context.stroke();\n    }\n\n    if (this.text_ !== \'\') {\n      var flatMidpoints = geometry.getFlatMidpoints();\n      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);\n    }\n  };\n  /**\n   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses\n   * the current style.\n   *\n   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawPolygon = function drawPolygon(geometry) {\n    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {\n      return;\n    }\n\n    if (this.strokeState_ || this.fillState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n\n      var context = this.context_;\n      context.beginPath();\n      this.drawRings_(geometry.getOrientedFlatCoordinates(), 0,\n      /** @type {Array<number>} */\n      geometry.getEnds(), geometry.getStride());\n\n      if (this.fillState_) {\n        context.fill();\n      }\n\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n\n    if (this.text_ !== \'\') {\n      var flatInteriorPoint = geometry.getFlatInteriorPoint();\n      this.drawText_(flatInteriorPoint, 0, 2, 2);\n    }\n  };\n  /**\n   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and\n   * uses the current style.\n   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.drawMultiPolygon = function drawMultiPolygon(geometry) {\n    if (!Object(_extent_js__WEBPACK_IMPORTED_MODULE_2__["intersects"])(this.extent_, geometry.getExtent())) {\n      return;\n    }\n\n    if (this.strokeState_ || this.fillState_) {\n      if (this.fillState_) {\n        this.setContextFillState_(this.fillState_);\n      }\n\n      if (this.strokeState_) {\n        this.setContextStrokeState_(this.strokeState_);\n      }\n\n      var context = this.context_;\n      var flatCoordinates = geometry.getOrientedFlatCoordinates();\n      var offset = 0;\n      var endss = geometry.getEndss();\n      var stride = geometry.getStride();\n      context.beginPath();\n\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var ends = endss[i];\n        offset = this.drawRings_(flatCoordinates, offset, ends, stride);\n      }\n\n      if (this.fillState_) {\n        context.fill();\n      }\n\n      if (this.strokeState_) {\n        context.stroke();\n      }\n    }\n\n    if (this.text_ !== \'\') {\n      var flatInteriorPoints = geometry.getFlatInteriorPoints();\n      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);\n    }\n  };\n  /**\n   * @param {import("../canvas.js").FillState} fillState Fill state.\n   * @private\n   */\n\n\n  CanvasImmediateRenderer.prototype.setContextFillState_ = function setContextFillState_(fillState) {\n    var context = this.context_;\n    var contextFillState = this.contextFillState_;\n\n    if (!contextFillState) {\n      context.fillStyle = fillState.fillStyle;\n      this.contextFillState_ = {\n        fillStyle: fillState.fillStyle\n      };\n    } else {\n      if (contextFillState.fillStyle != fillState.fillStyle) {\n        contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;\n      }\n    }\n  };\n  /**\n   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.\n   * @private\n   */\n\n\n  CanvasImmediateRenderer.prototype.setContextStrokeState_ = function setContextStrokeState_(strokeState) {\n    var context = this.context_;\n    var contextStrokeState = this.contextStrokeState_;\n\n    if (!contextStrokeState) {\n      context.lineCap =\n      /** @type {CanvasLineCap} */\n      strokeState.lineCap;\n\n      if (_has_js__WEBPACK_IMPORTED_MODULE_6__[/* CANVAS_LINE_DASH */ "a"]) {\n        context.setLineDash(strokeState.lineDash);\n        context.lineDashOffset = strokeState.lineDashOffset;\n      }\n\n      context.lineJoin =\n      /** @type {CanvasLineJoin} */\n      strokeState.lineJoin;\n      context.lineWidth = strokeState.lineWidth;\n      context.miterLimit = strokeState.miterLimit;\n      context.strokeStyle = strokeState.strokeStyle;\n      this.contextStrokeState_ = {\n        lineCap: strokeState.lineCap,\n        lineDash: strokeState.lineDash,\n        lineDashOffset: strokeState.lineDashOffset,\n        lineJoin: strokeState.lineJoin,\n        lineWidth: strokeState.lineWidth,\n        miterLimit: strokeState.miterLimit,\n        strokeStyle: strokeState.strokeStyle\n      };\n    } else {\n      if (contextStrokeState.lineCap != strokeState.lineCap) {\n        contextStrokeState.lineCap = context.lineCap =\n        /** @type {CanvasLineCap} */\n        strokeState.lineCap;\n      }\n\n      if (_has_js__WEBPACK_IMPORTED_MODULE_6__[/* CANVAS_LINE_DASH */ "a"]) {\n        if (!Object(_array_js__WEBPACK_IMPORTED_MODULE_0__[/* equals */ "b"])(contextStrokeState.lineDash, strokeState.lineDash)) {\n          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);\n        }\n\n        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {\n          contextStrokeState.lineDashOffset = context.lineDashOffset = strokeState.lineDashOffset;\n        }\n      }\n\n      if (contextStrokeState.lineJoin != strokeState.lineJoin) {\n        contextStrokeState.lineJoin = context.lineJoin =\n        /** @type {CanvasLineJoin} */\n        strokeState.lineJoin;\n      }\n\n      if (contextStrokeState.lineWidth != strokeState.lineWidth) {\n        contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;\n      }\n\n      if (contextStrokeState.miterLimit != strokeState.miterLimit) {\n        contextStrokeState.miterLimit = context.miterLimit = strokeState.miterLimit;\n      }\n\n      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {\n        contextStrokeState.strokeStyle = context.strokeStyle = strokeState.strokeStyle;\n      }\n    }\n  };\n  /**\n   * @param {import("../canvas.js").TextState} textState Text state.\n   * @private\n   */\n\n\n  CanvasImmediateRenderer.prototype.setContextTextState_ = function setContextTextState_(textState) {\n    var context = this.context_;\n    var contextTextState = this.contextTextState_;\n    var textAlign = textState.textAlign ? textState.textAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultTextAlign */ "l"];\n\n    if (!contextTextState) {\n      context.font = textState.font;\n      context.textAlign =\n      /** @type {CanvasTextAlign} */\n      textAlign;\n      context.textBaseline =\n      /** @type {CanvasTextBaseline} */\n      textState.textBaseline;\n      this.contextTextState_ = {\n        font: textState.font,\n        textAlign: textAlign,\n        textBaseline: textState.textBaseline\n      };\n    } else {\n      if (contextTextState.font != textState.font) {\n        contextTextState.font = context.font = textState.font;\n      }\n\n      if (contextTextState.textAlign != textAlign) {\n        contextTextState.textAlign = context.textAlign =\n        /** @type {CanvasTextAlign} */\n        textAlign;\n      }\n\n      if (contextTextState.textBaseline != textState.textBaseline) {\n        contextTextState.textBaseline = context.textBaseline =\n        /** @type {CanvasTextBaseline} */\n        textState.textBaseline;\n      }\n    }\n  };\n  /**\n   * Set the fill and stroke style for subsequent draw operations.  To clear\n   * either fill or stroke styles, pass null for the appropriate parameter.\n   *\n   * @param {import("../../style/Fill.js").default} fillStyle Fill style.\n   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n    if (!fillStyle) {\n      this.fillState_ = null;\n    } else {\n      var fillStyleColor = fillStyle.getColor();\n      this.fillState_ = {\n        fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__[/* asColorLike */ "a"])(fillStyleColor ? fillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultFillStyle */ "b"])\n      };\n    }\n\n    if (!strokeStyle) {\n      this.strokeState_ = null;\n    } else {\n      var strokeStyleColor = strokeStyle.getColor();\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      var strokeStyleWidth = strokeStyle.getWidth();\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      this.strokeState_ = {\n        lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineCap */ "d"],\n        lineDash: strokeStyleLineDash ? strokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineDash */ "e"],\n        lineDashOffset: strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineDashOffset */ "f"],\n        lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineJoin */ "g"],\n        lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineWidth */ "h"]),\n        miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultMiterLimit */ "i"],\n        strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__[/* asColorLike */ "a"])(strokeStyleColor ? strokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultStrokeStyle */ "k"])\n      };\n    }\n  };\n  /**\n   * Set the image style for subsequent draw operations.  Pass null to remove\n   * the image style.\n   *\n   * @param {import("../../style/Image.js").default} imageStyle Image style.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.setImageStyle = function setImageStyle(imageStyle) {\n    if (!imageStyle) {\n      this.image_ = null;\n    } else {\n      var imageAnchor = imageStyle.getAnchor(); // FIXME pixel ratio\n\n      var imageImage = imageStyle.getImage(1);\n      var imageOrigin = imageStyle.getOrigin();\n      var imageSize = imageStyle.getSize();\n      this.imageAnchorX_ = imageAnchor[0];\n      this.imageAnchorY_ = imageAnchor[1];\n      this.imageHeight_ = imageSize[1];\n      this.image_ = imageImage;\n      this.imageOpacity_ = imageStyle.getOpacity();\n      this.imageOriginX_ = imageOrigin[0];\n      this.imageOriginY_ = imageOrigin[1];\n      this.imageRotateWithView_ = imageStyle.getRotateWithView();\n      this.imageRotation_ = imageStyle.getRotation();\n      this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;\n      this.imageWidth_ = imageSize[0];\n    }\n  };\n  /**\n   * Set the text style for subsequent draw operations.  Pass null to\n   * remove the text style.\n   *\n   * @param {import("../../style/Text.js").default} textStyle Text style.\n   * @override\n   */\n\n\n  CanvasImmediateRenderer.prototype.setTextStyle = function setTextStyle(textStyle) {\n    if (!textStyle) {\n      this.text_ = \'\';\n    } else {\n      var textFillStyle = textStyle.getFill();\n\n      if (!textFillStyle) {\n        this.textFillState_ = null;\n      } else {\n        var textFillStyleColor = textFillStyle.getColor();\n        this.textFillState_ = {\n          fillStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__[/* asColorLike */ "a"])(textFillStyleColor ? textFillStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultFillStyle */ "b"])\n        };\n      }\n\n      var textStrokeStyle = textStyle.getStroke();\n\n      if (!textStrokeStyle) {\n        this.textStrokeState_ = null;\n      } else {\n        var textStrokeStyleColor = textStrokeStyle.getColor();\n        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();\n        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();\n        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();\n        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();\n        var textStrokeStyleWidth = textStrokeStyle.getWidth();\n        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();\n        this.textStrokeState_ = {\n          lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineCap */ "d"],\n          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineDash */ "e"],\n          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineDashOffset */ "f"],\n          lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineJoin */ "g"],\n          lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultLineWidth */ "h"],\n          miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultMiterLimit */ "i"],\n          strokeStyle: Object(_colorlike_js__WEBPACK_IMPORTED_MODULE_1__[/* asColorLike */ "a"])(textStrokeStyleColor ? textStrokeStyleColor : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultStrokeStyle */ "k"])\n        };\n      }\n\n      var textFont = textStyle.getFont();\n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      var textScale = textStyle.getScale();\n      var textText = textStyle.getText();\n      var textTextAlign = textStyle.getTextAlign();\n      var textTextBaseline = textStyle.getTextBaseline();\n      this.textState_ = {\n        font: textFont !== undefined ? textFont : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultFont */ "c"],\n        textAlign: textTextAlign !== undefined ? textTextAlign : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultTextAlign */ "l"],\n        textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvas_js__WEBPACK_IMPORTED_MODULE_8__[/* defaultTextBaseline */ "m"]\n      };\n      this.text_ = textText !== undefined ? textText : \'\';\n      this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;\n      this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;\n      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;\n      this.textRotation_ = textRotation !== undefined ? textRotation : 0;\n      this.textScale_ = this.pixelRatio_ * (textScale !== undefined ? textScale : 1);\n    }\n  };\n\n  return CanvasImmediateRenderer;\n}(_VectorContext_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["a"] = (CanvasImmediateRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlLmpzPzFjYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlXG4gKi9cbi8vIEZJWE1FIHRlc3QsIGVzcGVjaWFsbHkgcG9seWdvbnMgd2l0aCBob2xlcyBhbmQgbXVsdGlwb2x5Z29uc1xuLy8gRklYTUUgbmVlZCB0byBoYW5kbGUgbGFyZ2UgdGhpY2sgZmVhdHVyZXMgKHdoZXJlIHBpeGVsIHNpemUgbWF0dGVycylcbi8vIEZJWE1FIGFkZCBvZmZzZXQgYW5kIGVuZCB0byBvbC9nZW9tL2ZsYXQvdHJhbnNmb3JtfnRyYW5zZm9ybTJEP1xuXG5pbXBvcnQge2VxdWFsc30gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHthc0NvbG9yTGlrZX0gZnJvbSAnLi4vLi4vY29sb3JsaWtlLmpzJztcbmltcG9ydCB7aW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi4vLi4vZ2VvbS9HZW9tZXRyeVR5cGUuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm1HZW9tMkR9IGZyb20gJy4uLy4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanMnO1xuaW1wb3J0IHt0cmFuc2Zvcm0yRH0gZnJvbSAnLi4vLi4vZ2VvbS9mbGF0L3RyYW5zZm9ybS5qcyc7XG5pbXBvcnQge0NBTlZBU19MSU5FX0RBU0h9IGZyb20gJy4uLy4uL2hhcy5qcyc7XG5pbXBvcnQgVmVjdG9yQ29udGV4dCBmcm9tICcuLi9WZWN0b3JDb250ZXh0LmpzJztcbmltcG9ydCB7ZGVmYXVsdFRleHRBbGlnbiwgZGVmYXVsdEZpbGxTdHlsZSwgZGVmYXVsdExpbmVDYXAsIGRlZmF1bHRMaW5lRGFzaCwgZGVmYXVsdExpbmVEYXNoT2Zmc2V0LCBkZWZhdWx0TGluZUpvaW4sIGRlZmF1bHRMaW5lV2lkdGgsIGRlZmF1bHRNaXRlckxpbWl0LCBkZWZhdWx0U3Ryb2tlU3R5bGUsIGRlZmF1bHRUZXh0QmFzZWxpbmUsIGRlZmF1bHRGb250fSBmcm9tICcuLi9jYW52YXMuanMnO1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBjb25jcmV0ZSBzdWJjbGFzcyBvZiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9WZWN0b3JDb250ZXh0fSB0aGF0IGltcGxlbWVudHNcbiAqIGRpcmVjdCByZW5kZXJpbmcgb2YgZmVhdHVyZXMgYW5kIGdlb21ldHJpZXMgdG8gYW4gSFRNTDUgQ2FudmFzIGNvbnRleHQuXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyBhcmUgY3JlYXRlZCBpbnRlcm5hbGx5IGJ5IHRoZSBsaWJyYXJ5IGFuZFxuICogcHJvdmlkZWQgdG8gYXBwbGljYXRpb24gY29kZSBhcyB2ZWN0b3JDb250ZXh0IG1lbWJlciBvZiB0aGVcbiAqIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL0V2ZW50flJlbmRlckV2ZW50fSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHBvc3Rjb21wb3NlLCBwcmVjb21wb3NlIGFuZFxuICogcmVuZGVyIGV2ZW50cyBlbWl0dGVkIGJ5IGxheWVycyBhbmQgbWFwcy5cbiAqL1xuY2xhc3MgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIgZXh0ZW5kcyBWZWN0b3JDb250ZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdSb3RhdGlvbiBWaWV3IHJvdGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGV4dCwgcGl4ZWxSYXRpbywgZXh0ZW50LCB0cmFuc2Zvcm0sIHZpZXdSb3RhdGlvbikge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0XyA9IGNvbnRleHQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IHBpeGVsUmF0aW87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW50XyA9IGV4dGVudDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1fID0gdHJhbnNmb3JtO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudmlld1JvdGF0aW9uXyA9IHZpZXdSb3RhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dEZpbGxTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHRTdHJva2VTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5UZXh0U3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0VGV4dFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLkZpbGxTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5TdHJva2VTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEhUTUxJbWFnZUVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VBbmNob3JYXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZUFuY2hvcllfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlSGVpZ2h0XyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZU9wYWNpdHlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlT3JpZ2luWF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VPcmlnaW5ZXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VSb3RhdGVXaXRoVmlld18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlUm90YXRpb25fID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlU2NhbGVfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlV2lkdGhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnRleHRfID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0T2Zmc2V0WF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGV4dE9mZnNldFlfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRlV2l0aFZpZXdfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50ZXh0Um90YXRpb25fID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTY2FsZV8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2NhbnZhcy5qc1wiKS5GaWxsU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlN0cm9rZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLnRleHRTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMudG1wTG9jYWxUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhd0ltYWdlc18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlKSB7XG4gICAgaWYgKCF0aGlzLmltYWdlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtMkQoXG4gICAgICBmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kLCAyLCB0aGlzLnRyYW5zZm9ybV8sXG4gICAgICB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICBjb25zdCBsb2NhbFRyYW5zZm9ybSA9IHRoaXMudG1wTG9jYWxUcmFuc2Zvcm1fO1xuICAgIGNvbnN0IGFscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICBpZiAodGhpcy5pbWFnZU9wYWNpdHlfICE9IDEpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYSAqIHRoaXMuaW1hZ2VPcGFjaXR5XztcbiAgICB9XG4gICAgbGV0IHJvdGF0aW9uID0gdGhpcy5pbWFnZVJvdGF0aW9uXztcbiAgICBpZiAodGhpcy5pbWFnZVJvdGF0ZVdpdGhWaWV3Xykge1xuICAgICAgcm90YXRpb24gKz0gdGhpcy52aWV3Um90YXRpb25fO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwaXhlbENvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHggPSBwaXhlbENvb3JkaW5hdGVzW2ldIC0gdGhpcy5pbWFnZUFuY2hvclhfO1xuICAgICAgY29uc3QgeSA9IHBpeGVsQ29vcmRpbmF0ZXNbaSArIDFdIC0gdGhpcy5pbWFnZUFuY2hvcllfO1xuICAgICAgaWYgKHJvdGF0aW9uICE9PSAwIHx8IHRoaXMuaW1hZ2VTY2FsZV8gIT0gMSkge1xuICAgICAgICBjb25zdCBjZW50ZXJYID0geCArIHRoaXMuaW1hZ2VBbmNob3JYXztcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyB0aGlzLmltYWdlQW5jaG9yWV87XG4gICAgICAgIGNvbXBvc2VUcmFuc2Zvcm0obG9jYWxUcmFuc2Zvcm0sXG4gICAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgICB0aGlzLmltYWdlU2NhbGVfLCB0aGlzLmltYWdlU2NhbGVfLFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIC1jZW50ZXJYLCAtY2VudGVyWSk7XG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtLmFwcGx5KGNvbnRleHQsIGxvY2FsVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1hZ2VfLCB0aGlzLmltYWdlT3JpZ2luWF8sIHRoaXMuaW1hZ2VPcmlnaW5ZXyxcbiAgICAgICAgdGhpcy5pbWFnZVdpZHRoXywgdGhpcy5pbWFnZUhlaWdodF8sIHgsIHksXG4gICAgICAgIHRoaXMuaW1hZ2VXaWR0aF8sIHRoaXMuaW1hZ2VIZWlnaHRfKTtcbiAgICB9XG4gICAgaWYgKHJvdGF0aW9uICE9PSAwIHx8IHRoaXMuaW1hZ2VTY2FsZV8gIT0gMSkge1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlT3BhY2l0eV8gIT0gMSkge1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZsYXRDb29yZGluYXRlcyBGbGF0IGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgU3RyaWRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZHJhd1RleHRfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSkge1xuICAgIGlmICghdGhpcy50ZXh0U3RhdGVfIHx8IHRoaXMudGV4dF8gPT09ICcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRGaWxsU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRGaWxsU3RhdGVfKHRoaXMudGV4dEZpbGxTdGF0ZV8pO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0U3Ryb2tlU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy50ZXh0U3Ryb2tlU3RhdGVfKTtcbiAgICB9XG4gICAgdGhpcy5zZXRDb250ZXh0VGV4dFN0YXRlXyh0aGlzLnRleHRTdGF0ZV8pO1xuICAgIGNvbnN0IHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm0yRChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgbGV0IHJvdGF0aW9uID0gdGhpcy50ZXh0Um90YXRpb25fO1xuICAgIGlmICh0aGlzLnRleHRSb3RhdGVXaXRoVmlld18pIHtcbiAgICAgIHJvdGF0aW9uICs9IHRoaXMudmlld1JvdGF0aW9uXztcbiAgICB9XG4gICAgZm9yICg7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHN0cmlkZSkge1xuICAgICAgY29uc3QgeCA9IHBpeGVsQ29vcmRpbmF0ZXNbb2Zmc2V0XSArIHRoaXMudGV4dE9mZnNldFhfO1xuICAgICAgY29uc3QgeSA9IHBpeGVsQ29vcmRpbmF0ZXNbb2Zmc2V0ICsgMV0gKyB0aGlzLnRleHRPZmZzZXRZXztcbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCB8fCB0aGlzLnRleHRTY2FsZV8gIT0gMSkge1xuICAgICAgICBjb25zdCBsb2NhbFRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcy50bXBMb2NhbFRyYW5zZm9ybV8sXG4gICAgICAgICAgeCwgeSxcbiAgICAgICAgICB0aGlzLnRleHRTY2FsZV8sIHRoaXMudGV4dFNjYWxlXyxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAteCwgLXkpO1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybS5hcHBseShjb250ZXh0LCBsb2NhbFRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50ZXh0U3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0aGlzLnRleHRfLCB4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRleHRGaWxsU3RhdGVfKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGhpcy50ZXh0XywgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyb3RhdGlvbiAhPT0gMCB8fCB0aGlzLnRleHRTY2FsZV8gIT0gMSkge1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2UgQ2xvc2UuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gZW5kIEVuZC5cbiAgICovXG4gIG1vdmVUb0xpbmVUb18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZCwgc3RyaWRlLCBjbG9zZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIGNvbnN0IHBpeGVsQ29vcmRpbmF0ZXMgPSB0cmFuc2Zvcm0yRChcbiAgICAgIGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmQsIHN0cmlkZSwgdGhpcy50cmFuc2Zvcm1fLFxuICAgICAgdGhpcy5waXhlbENvb3JkaW5hdGVzXyk7XG4gICAgY29udGV4dC5tb3ZlVG8ocGl4ZWxDb29yZGluYXRlc1swXSwgcGl4ZWxDb29yZGluYXRlc1sxXSk7XG4gICAgbGV0IGxlbmd0aCA9IHBpeGVsQ29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGlmIChjbG9zZSkge1xuICAgICAgbGVuZ3RoIC09IDI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnRleHQubGluZVRvKHBpeGVsQ29vcmRpbmF0ZXNbaV0sIHBpeGVsQ29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgICB9XG4gICAgaWYgKGNsb3NlKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZmxhdENvb3JkaW5hdGVzIEZsYXQgY29vcmRpbmF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgT2Zmc2V0LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGVuZHMgRW5kcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSBTdHJpZGUuXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge251bWJlcn0gRW5kLlxuICAgKi9cbiAgZHJhd1JpbmdzXyhmbGF0Q29vcmRpbmF0ZXMsIG9mZnNldCwgZW5kcywgc3RyaWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZW5kcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLm1vdmVUb0xpbmVUb18oZmxhdENvb3JkaW5hdGVzLCBvZmZzZXQsIGVuZHNbaV0sIHN0cmlkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgY2lyY2xlIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGUgYW5kIHVzZXNcbiAgICogdGhlIGN1cnJlbnQgZmlsbCBhbmQgc3Ryb2tlIHN0eWxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0NpcmNsZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBDaXJjbGUgZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBkcmF3Q2lyY2xlKGdlb21ldHJ5KSB7XG4gICAgaWYgKCFpbnRlcnNlY3RzKHRoaXMuZXh0ZW50XywgZ2VvbWV0cnkuZ2V0RXh0ZW50KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8gfHwgdGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0RmlsbFN0YXRlXyh0aGlzLmZpbGxTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwaXhlbENvb3JkaW5hdGVzID0gdHJhbnNmb3JtR2VvbTJEKFxuICAgICAgICBnZW9tZXRyeSwgdGhpcy50cmFuc2Zvcm1fLCB0aGlzLnBpeGVsQ29vcmRpbmF0ZXNfKTtcbiAgICAgIGNvbnN0IGR4ID0gcGl4ZWxDb29yZGluYXRlc1syXSAtIHBpeGVsQ29vcmRpbmF0ZXNbMF07XG4gICAgICBjb25zdCBkeSA9IHBpeGVsQ29vcmRpbmF0ZXNbM10gLSBwaXhlbENvb3JkaW5hdGVzWzFdO1xuICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICBwaXhlbENvb3JkaW5hdGVzWzBdLCBwaXhlbENvb3JkaW5hdGVzWzFdLCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhnZW9tZXRyeS5nZXRDZW50ZXIoKSwgMCwgMiwgMik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmVuZGVyaW5nIHN0eWxlLiAgTm90ZSB0aGF0IHNpbmNlIHRoaXMgaXMgYW4gaW1tZWRpYXRlIHJlbmRlcmluZyBBUEksXG4gICAqIGFueSBgekluZGV4YCBvbiB0aGUgcHJvdmlkZWQgc3R5bGUgd2lsbCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR9IHN0eWxlIFRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdHlsZShzdHlsZSkge1xuICAgIHRoaXMuc2V0RmlsbFN0cm9rZVN0eWxlKHN0eWxlLmdldEZpbGwoKSwgc3R5bGUuZ2V0U3Ryb2tlKCkpO1xuICAgIHRoaXMuc2V0SW1hZ2VTdHlsZShzdHlsZS5nZXRJbWFnZSgpKTtcbiAgICB0aGlzLnNldFRleHRTdHlsZShzdHlsZS5nZXRUZXh0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIENhbGxcbiAgICoge0BsaW5rIG1vZHVsZTpvbC9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZSNzZXRTdHlsZX0gZmlyc3QgdG8gc2V0IHRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9HZW9tZXRyeS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5IHRvIHJlbmRlci5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIGRyYXdHZW9tZXRyeShnZW9tZXRyeSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZW9tZXRyeS5nZXRUeXBlKCk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEdlb21ldHJ5VHlwZS5QT0lOVDpcbiAgICAgICAgdGhpcy5kcmF3UG9pbnQoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkxJTkVfU1RSSU5HOlxuICAgICAgICB0aGlzLmRyYXdMaW5lU3RyaW5nKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9MaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLlBPTFlHT046XG4gICAgICAgIHRoaXMuZHJhd1BvbHlnb24oLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfUE9JTlQ6XG4gICAgICAgIHRoaXMuZHJhd011bHRpUG9pbnQoLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBHZW9tZXRyeVR5cGUuTVVMVElfTElORV9TVFJJTkc6XG4gICAgICAgIHRoaXMuZHJhd011bHRpTGluZVN0cmluZygvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLk1VTFRJX1BPTFlHT046XG4gICAgICAgIHRoaXMuZHJhd011bHRpUG9seWdvbigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkdFT01FVFJZX0NPTExFQ1RJT046XG4gICAgICAgIHRoaXMuZHJhd0dlb21ldHJ5Q29sbGVjdGlvbigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2dlb20vR2VvbWV0cnlDb2xsZWN0aW9uLmpzXCIpLmRlZmF1bHR9ICovIChnZW9tZXRyeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgR2VvbWV0cnlUeXBlLkNJUkNMRTpcbiAgICAgICAgdGhpcy5kcmF3Q2lyY2xlKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9DaXJjbGUuanNcIikuZGVmYXVsdH0gKi8gKGdlb21ldHJ5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgZmVhdHVyZSBpbnRvIHRoZSBjYW52YXMuICBOb3RlIHRoYXQgYW55IGB6SW5kZXhgIG9uIHRoZSBwcm92aWRlZFxuICAgKiBzdHlsZSB3aWxsIGJlIGlnbm9yZWQgLSBmZWF0dXJlcyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgaW4gdGhlIG9yZGVyIHRoYXRcbiAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkLiAgSWYgeW91IG5lZWQgYHpJbmRleGAgc3VwcG9ydCwgeW91IHNob3VsZCBiZSB1c2luZyBhblxuICAgKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL1ZlY3Rvcn5WZWN0b3JMYXllcn0gaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fSBzdHlsZSBTdHlsZS5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIGRyYXdGZWF0dXJlKGZlYXR1cmUsIHN0eWxlKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBzdHlsZS5nZXRHZW9tZXRyeUZ1bmN0aW9uKCkoZmVhdHVyZSk7XG4gICAgaWYgKCFnZW9tZXRyeSB8fCAhaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNldFN0eWxlKHN0eWxlKTtcbiAgICB0aGlzLmRyYXdHZW9tZXRyeShnZW9tZXRyeSk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgR2VvbWV0cnlDb2xsZWN0aW9uIHRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZFxuICAgKiB1c2VzIHRoZSBjdXJyZW50IHN0eWxlcyBhcHByb3ByaWF0ZSBmb3IgZWFjaCBnZW9tZXRyeSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBHZW9tZXRyeSBjb2xsZWN0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRyYXdHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBnZW9tZXRyaWVzID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cmllc0FycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICB0aGlzLmRyYXdHZW9tZXRyeShnZW9tZXRyaWVzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgUG9pbnQgZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmQgdXNlc1xuICAgKiB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL1BvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBQb2ludCBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkcmF3UG9pbnQoZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBpZiAodGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuZHJhd0ltYWdlc18oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgTXVsdGlQb2ludCBnZW9tZXRyeSAgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmRcbiAgICogdXNlcyB0aGUgY3VycmVudCBzdHlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9pbnQuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IE11bHRpUG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZHJhd011bHRpUG9pbnQoZ2VvbWV0cnkpIHtcbiAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBpZiAodGhpcy5pbWFnZV8pIHtcbiAgICAgIHRoaXMuZHJhd0ltYWdlc18oZmxhdENvb3JkaW5hdGVzLCAwLCBmbGF0Q29vcmRpbmF0ZXMubGVuZ3RoLCBzdHJpZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRDb29yZGluYXRlcywgMCwgZmxhdENvb3JkaW5hdGVzLmxlbmd0aCwgc3RyaWRlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgTGluZVN0cmluZyBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZCB1c2VzXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vTGluZVN0cmluZy5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgTGluZVN0cmluZyBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkcmF3TGluZVN0cmluZyhnZW9tZXRyeSkge1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dFN0cm9rZVN0YXRlXyh0aGlzLnN0cm9rZVN0YXRlXyk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICAgIGNvbnN0IGZsYXRDb29yZGluYXRlcyA9IGdlb21ldHJ5LmdldEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMubW92ZVRvTGluZVRvXyhmbGF0Q29vcmRpbmF0ZXMsIDAsIGZsYXRDb29yZGluYXRlcy5sZW5ndGgsXG4gICAgICAgIGdlb21ldHJ5LmdldFN0cmlkZSgpLCBmYWxzZSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZsYXRNaWRwb2ludCA9IGdlb21ldHJ5LmdldEZsYXRNaWRwb2ludCgpO1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdE1pZHBvaW50LCAwLCAyLCAyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgTXVsdGlMaW5lU3RyaW5nIGdlb21ldHJ5IGludG8gdGhlIGNhbnZhcy4gIFJlbmRlcmluZyBpcyBpbW1lZGlhdGVcbiAgICogYW5kIHVzZXMgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGdlb21ldHJ5IE11bHRpTGluZVN0cmluZyBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkcmF3TXVsdGlMaW5lU3RyaW5nKGdlb21ldHJ5KSB7XG4gICAgY29uc3QgZ2VvbWV0cnlFeHRlbnQgPSBnZW9tZXRyeS5nZXRFeHRlbnQoKTtcbiAgICBpZiAoIWludGVyc2VjdHModGhpcy5leHRlbnRfLCBnZW9tZXRyeUV4dGVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlU3RhdGVfKSB7XG4gICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRGbGF0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgY29uc3QgZW5kcyA9IC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGdlb21ldHJ5LmdldEVuZHMoKSk7XG4gICAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5tb3ZlVG9MaW5lVG9fKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzW2ldLCBzdHJpZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRleHRfICE9PSAnJykge1xuICAgICAgY29uc3QgZmxhdE1pZHBvaW50cyA9IGdlb21ldHJ5LmdldEZsYXRNaWRwb2ludHMoKTtcbiAgICAgIHRoaXMuZHJhd1RleHRfKGZsYXRNaWRwb2ludHMsIDAsIGZsYXRNaWRwb2ludHMubGVuZ3RoLCAyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIGEgUG9seWdvbiBnZW9tZXRyeSBpbnRvIHRoZSBjYW52YXMuICBSZW5kZXJpbmcgaXMgaW1tZWRpYXRlIGFuZCB1c2VzXG4gICAqIHRoZSBjdXJyZW50IHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgUG9seWdvbiBnZW9tZXRyeS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBkcmF3UG9seWdvbihnZW9tZXRyeSkge1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8gfHwgdGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy5maWxsU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgdGhpcy5kcmF3UmluZ3NfKGdlb21ldHJ5LmdldE9yaWVudGVkRmxhdENvb3JkaW5hdGVzKCksXG4gICAgICAgIDAsIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi8gKGdlb21ldHJ5LmdldEVuZHMoKSksIGdlb21ldHJ5LmdldFN0cmlkZSgpKTtcbiAgICAgIGlmICh0aGlzLmZpbGxTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8pIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudGV4dF8gIT09ICcnKSB7XG4gICAgICBjb25zdCBmbGF0SW50ZXJpb3JQb2ludCA9IGdlb21ldHJ5LmdldEZsYXRJbnRlcmlvclBvaW50KCk7XG4gICAgICB0aGlzLmRyYXdUZXh0XyhmbGF0SW50ZXJpb3JQb2ludCwgMCwgMiwgMik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBNdWx0aVBvbHlnb24gZ2VvbWV0cnkgaW50byB0aGUgY2FudmFzLiAgUmVuZGVyaW5nIGlzIGltbWVkaWF0ZSBhbmRcbiAgICogdXNlcyB0aGUgY3VycmVudCBzdHlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9nZW9tL011bHRpUG9seWdvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeSBNdWx0aVBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZHJhd011bHRpUG9seWdvbihnZW9tZXRyeSkge1xuICAgIGlmICghaW50ZXJzZWN0cyh0aGlzLmV4dGVudF8sIGdlb21ldHJ5LmdldEV4dGVudCgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdHJva2VTdGF0ZV8gfHwgdGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICBpZiAodGhpcy5maWxsU3RhdGVfKSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dEZpbGxTdGF0ZV8odGhpcy5maWxsU3RhdGVfKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICB0aGlzLnNldENvbnRleHRTdHJva2VTdGF0ZV8odGhpcy5zdHJva2VTdGF0ZV8pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dF87XG4gICAgICBjb25zdCBmbGF0Q29vcmRpbmF0ZXMgPSBnZW9tZXRyeS5nZXRPcmllbnRlZEZsYXRDb29yZGluYXRlcygpO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBjb25zdCBlbmRzcyA9IGdlb21ldHJ5LmdldEVuZHNzKCk7XG4gICAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlbmRzcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGVuZHMgPSBlbmRzc1tpXTtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5kcmF3UmluZ3NfKGZsYXRDb29yZGluYXRlcywgb2Zmc2V0LCBlbmRzLCBzdHJpZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmlsbFN0YXRlXykge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0cm9rZVN0YXRlXykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0XyAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZsYXRJbnRlcmlvclBvaW50cyA9IGdlb21ldHJ5LmdldEZsYXRJbnRlcmlvclBvaW50cygpO1xuICAgICAgdGhpcy5kcmF3VGV4dF8oZmxhdEludGVyaW9yUG9pbnRzLCAwLCBmbGF0SW50ZXJpb3JQb2ludHMubGVuZ3RoLCAyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuRmlsbFN0YXRlfSBmaWxsU3RhdGUgRmlsbCBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldENvbnRleHRGaWxsU3RhdGVfKGZpbGxTdGF0ZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIGNvbnN0IGNvbnRleHRGaWxsU3RhdGUgPSB0aGlzLmNvbnRleHRGaWxsU3RhdGVfO1xuICAgIGlmICghY29udGV4dEZpbGxTdGF0ZSkge1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBmaWxsU3RhdGUuZmlsbFN0eWxlO1xuICAgICAgdGhpcy5jb250ZXh0RmlsbFN0YXRlXyA9IHtcbiAgICAgICAgZmlsbFN0eWxlOiBmaWxsU3RhdGUuZmlsbFN0eWxlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dEZpbGxTdGF0ZS5maWxsU3R5bGUgIT0gZmlsbFN0YXRlLmZpbGxTdHlsZSkge1xuICAgICAgICBjb250ZXh0RmlsbFN0YXRlLmZpbGxTdHlsZSA9IGNvbnRleHQuZmlsbFN0eWxlID0gZmlsbFN0YXRlLmZpbGxTdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jYW52YXMuanNcIikuU3Ryb2tlU3RhdGV9IHN0cm9rZVN0YXRlIFN0cm9rZSBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldENvbnRleHRTdHJva2VTdGF0ZV8oc3Ryb2tlU3RhdGUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICBjb25zdCBjb250ZXh0U3Ryb2tlU3RhdGUgPSB0aGlzLmNvbnRleHRTdHJva2VTdGF0ZV87XG4gICAgaWYgKCFjb250ZXh0U3Ryb2tlU3RhdGUpIHtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUNhcH0gKi8gKHN0cm9rZVN0YXRlLmxpbmVDYXApO1xuICAgICAgaWYgKENBTlZBU19MSU5FX0RBU0gpIHtcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChzdHJva2VTdGF0ZS5saW5lRGFzaCk7XG4gICAgICAgIGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSAvKiogQHR5cGUge0NhbnZhc0xpbmVKb2lufSAqLyAoc3Ryb2tlU3RhdGUubGluZUpvaW4pO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHJva2VTdGF0ZS5saW5lV2lkdGg7XG4gICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0O1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlO1xuICAgICAgdGhpcy5jb250ZXh0U3Ryb2tlU3RhdGVfID0ge1xuICAgICAgICBsaW5lQ2FwOiBzdHJva2VTdGF0ZS5saW5lQ2FwLFxuICAgICAgICBsaW5lRGFzaDogc3Ryb2tlU3RhdGUubGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHJva2VTdGF0ZS5saW5lRGFzaE9mZnNldCxcbiAgICAgICAgbGluZUpvaW46IHN0cm9rZVN0YXRlLmxpbmVKb2luLFxuICAgICAgICBsaW5lV2lkdGg6IHN0cm9rZVN0YXRlLmxpbmVXaWR0aCxcbiAgICAgICAgbWl0ZXJMaW1pdDogc3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCxcbiAgICAgICAgc3Ryb2tlU3R5bGU6IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLmxpbmVDYXAgIT0gc3Ryb2tlU3RhdGUubGluZUNhcCkge1xuICAgICAgICBjb250ZXh0U3Ryb2tlU3RhdGUubGluZUNhcCA9IGNvbnRleHQubGluZUNhcCA9IC8qKiBAdHlwZSB7Q2FudmFzTGluZUNhcH0gKi8gKHN0cm9rZVN0YXRlLmxpbmVDYXApO1xuICAgICAgfVxuICAgICAgaWYgKENBTlZBU19MSU5FX0RBU0gpIHtcbiAgICAgICAgaWYgKCFlcXVhbHMoY29udGV4dFN0cm9rZVN0YXRlLmxpbmVEYXNoLCBzdHJva2VTdGF0ZS5saW5lRGFzaCkpIHtcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lRGFzaCA9IHN0cm9rZVN0YXRlLmxpbmVEYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ICE9IHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgICAgY29udGV4dFN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0ID0gY29udGV4dC5saW5lRGFzaE9mZnNldCA9XG4gICAgICAgICAgICAgIHN0cm9rZVN0YXRlLmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLmxpbmVKb2luICE9IHN0cm9rZVN0YXRlLmxpbmVKb2luKSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5saW5lSm9pbiA9IGNvbnRleHQubGluZUpvaW4gPSAvKiogQHR5cGUge0NhbnZhc0xpbmVKb2lufSAqLyAoc3Ryb2tlU3RhdGUubGluZUpvaW4pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRTdHJva2VTdGF0ZS5saW5lV2lkdGggIT0gc3Ryb2tlU3RhdGUubGluZVdpZHRoKSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5saW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aCA9IHN0cm9rZVN0YXRlLmxpbmVXaWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0U3Ryb2tlU3RhdGUubWl0ZXJMaW1pdCAhPSBzdHJva2VTdGF0ZS5taXRlckxpbWl0KSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5taXRlckxpbWl0ID0gY29udGV4dC5taXRlckxpbWl0ID1cbiAgICAgICAgICAgIHN0cm9rZVN0YXRlLm1pdGVyTGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dFN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlICE9IHN0cm9rZVN0YXRlLnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIGNvbnRleHRTdHJva2VTdGF0ZS5zdHJva2VTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGUgPVxuICAgICAgICAgICAgc3Ryb2tlU3RhdGUuc3Ryb2tlU3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY2FudmFzLmpzXCIpLlRleHRTdGF0ZX0gdGV4dFN0YXRlIFRleHQgc3RhdGUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRDb250ZXh0VGV4dFN0YXRlXyh0ZXh0U3RhdGUpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0XztcbiAgICBjb25zdCBjb250ZXh0VGV4dFN0YXRlID0gdGhpcy5jb250ZXh0VGV4dFN0YXRlXztcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSB0ZXh0U3RhdGUudGV4dEFsaWduID9cbiAgICAgIHRleHRTdGF0ZS50ZXh0QWxpZ24gOiBkZWZhdWx0VGV4dEFsaWduO1xuICAgIGlmICghY29udGV4dFRleHRTdGF0ZSkge1xuICAgICAgY29udGV4dC5mb250ID0gdGV4dFN0YXRlLmZvbnQ7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9IC8qKiBAdHlwZSB7Q2FudmFzVGV4dEFsaWdufSAqLyAodGV4dEFsaWduKTtcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gLyoqIEB0eXBlIHtDYW52YXNUZXh0QmFzZWxpbmV9ICovICh0ZXh0U3RhdGUudGV4dEJhc2VsaW5lKTtcbiAgICAgIHRoaXMuY29udGV4dFRleHRTdGF0ZV8gPSB7XG4gICAgICAgIGZvbnQ6IHRleHRTdGF0ZS5mb250LFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiB0ZXh0U3RhdGUudGV4dEJhc2VsaW5lXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29udGV4dFRleHRTdGF0ZS5mb250ICE9IHRleHRTdGF0ZS5mb250KSB7XG4gICAgICAgIGNvbnRleHRUZXh0U3RhdGUuZm9udCA9IGNvbnRleHQuZm9udCA9IHRleHRTdGF0ZS5mb250O1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRUZXh0U3RhdGUudGV4dEFsaWduICE9IHRleHRBbGlnbikge1xuICAgICAgICBjb250ZXh0VGV4dFN0YXRlLnRleHRBbGlnbiA9IGNvbnRleHQudGV4dEFsaWduID0gLyoqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ259ICovICh0ZXh0QWxpZ24pO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHRUZXh0U3RhdGUudGV4dEJhc2VsaW5lICE9IHRleHRTdGF0ZS50ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY29udGV4dFRleHRTdGF0ZS50ZXh0QmFzZWxpbmUgPSBjb250ZXh0LnRleHRCYXNlbGluZSA9XG4gICAgICAgICAgLyoqIEB0eXBlIHtDYW52YXNUZXh0QmFzZWxpbmV9ICovICh0ZXh0U3RhdGUudGV4dEJhc2VsaW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBmaWxsIGFuZCBzdHJva2Ugc3R5bGUgZm9yIHN1YnNlcXVlbnQgZHJhdyBvcGVyYXRpb25zLiAgVG8gY2xlYXJcbiAgICogZWl0aGVyIGZpbGwgb3Igc3Ryb2tlIHN0eWxlcywgcGFzcyBudWxsIGZvciB0aGUgYXBwcm9wcmlhdGUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL0ZpbGwuanNcIikuZGVmYXVsdH0gZmlsbFN0eWxlIEZpbGwgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IHN0cm9rZVN0eWxlIFN0cm9rZSBzdHlsZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRGaWxsU3Ryb2tlU3R5bGUoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSkge1xuICAgIGlmICghZmlsbFN0eWxlKSB7XG4gICAgICB0aGlzLmZpbGxTdGF0ZV8gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaWxsU3R5bGVDb2xvciA9IGZpbGxTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgdGhpcy5maWxsU3RhdGVfID0ge1xuICAgICAgICBmaWxsU3R5bGU6IGFzQ29sb3JMaWtlKGZpbGxTdHlsZUNvbG9yID9cbiAgICAgICAgICBmaWxsU3R5bGVDb2xvciA6IGRlZmF1bHRGaWxsU3R5bGUpXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXN0cm9rZVN0eWxlKSB7XG4gICAgICB0aGlzLnN0cm9rZVN0YXRlXyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlQ29sb3IgPSBzdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lQ2FwID0gc3Ryb2tlU3R5bGUuZ2V0TGluZUNhcCgpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVMaW5lRGFzaCA9IHN0cm9rZVN0eWxlLmdldExpbmVEYXNoKCk7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZUxpbmVEYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgIGNvbnN0IHN0cm9rZVN0eWxlTGluZUpvaW4gPSBzdHJva2VTdHlsZS5nZXRMaW5lSm9pbigpO1xuICAgICAgY29uc3Qgc3Ryb2tlU3R5bGVXaWR0aCA9IHN0cm9rZVN0eWxlLmdldFdpZHRoKCk7XG4gICAgICBjb25zdCBzdHJva2VTdHlsZU1pdGVyTGltaXQgPSBzdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICB0aGlzLnN0cm9rZVN0YXRlXyA9IHtcbiAgICAgICAgbGluZUNhcDogc3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZUNhcCA6IGRlZmF1bHRMaW5lQ2FwLFxuICAgICAgICBsaW5lRGFzaDogc3Ryb2tlU3R5bGVMaW5lRGFzaCA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVMaW5lRGFzaCA6IGRlZmF1bHRMaW5lRGFzaCxcbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICAgIGxpbmVKb2luOiBzdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTGluZUpvaW4gOiBkZWZhdWx0TGluZUpvaW4sXG4gICAgICAgIGxpbmVXaWR0aDogdGhpcy5waXhlbFJhdGlvXyAqIChzdHJva2VTdHlsZVdpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlV2lkdGggOiBkZWZhdWx0TGluZVdpZHRoKSxcbiAgICAgICAgbWl0ZXJMaW1pdDogc3Ryb2tlU3R5bGVNaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgIHN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA6IGRlZmF1bHRNaXRlckxpbWl0LFxuICAgICAgICBzdHJva2VTdHlsZTogYXNDb2xvckxpa2Uoc3Ryb2tlU3R5bGVDb2xvciA/XG4gICAgICAgICAgc3Ryb2tlU3R5bGVDb2xvciA6IGRlZmF1bHRTdHJva2VTdHlsZSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgaW1hZ2Ugc3R5bGUgZm9yIHN1YnNlcXVlbnQgZHJhdyBvcGVyYXRpb25zLiAgUGFzcyBudWxsIHRvIHJlbW92ZVxuICAgKiB0aGUgaW1hZ2Ugc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvSW1hZ2UuanNcIikuZGVmYXVsdH0gaW1hZ2VTdHlsZSBJbWFnZSBzdHlsZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRJbWFnZVN0eWxlKGltYWdlU3R5bGUpIHtcbiAgICBpZiAoIWltYWdlU3R5bGUpIHtcbiAgICAgIHRoaXMuaW1hZ2VfID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW1hZ2VBbmNob3IgPSBpbWFnZVN0eWxlLmdldEFuY2hvcigpO1xuICAgICAgLy8gRklYTUUgcGl4ZWwgcmF0aW9cbiAgICAgIGNvbnN0IGltYWdlSW1hZ2UgPSBpbWFnZVN0eWxlLmdldEltYWdlKDEpO1xuICAgICAgY29uc3QgaW1hZ2VPcmlnaW4gPSBpbWFnZVN0eWxlLmdldE9yaWdpbigpO1xuICAgICAgY29uc3QgaW1hZ2VTaXplID0gaW1hZ2VTdHlsZS5nZXRTaXplKCk7XG4gICAgICB0aGlzLmltYWdlQW5jaG9yWF8gPSBpbWFnZUFuY2hvclswXTtcbiAgICAgIHRoaXMuaW1hZ2VBbmNob3JZXyA9IGltYWdlQW5jaG9yWzFdO1xuICAgICAgdGhpcy5pbWFnZUhlaWdodF8gPSBpbWFnZVNpemVbMV07XG4gICAgICB0aGlzLmltYWdlXyA9IGltYWdlSW1hZ2U7XG4gICAgICB0aGlzLmltYWdlT3BhY2l0eV8gPSBpbWFnZVN0eWxlLmdldE9wYWNpdHkoKTtcbiAgICAgIHRoaXMuaW1hZ2VPcmlnaW5YXyA9IGltYWdlT3JpZ2luWzBdO1xuICAgICAgdGhpcy5pbWFnZU9yaWdpbllfID0gaW1hZ2VPcmlnaW5bMV07XG4gICAgICB0aGlzLmltYWdlUm90YXRlV2l0aFZpZXdfID0gaW1hZ2VTdHlsZS5nZXRSb3RhdGVXaXRoVmlldygpO1xuICAgICAgdGhpcy5pbWFnZVJvdGF0aW9uXyA9IGltYWdlU3R5bGUuZ2V0Um90YXRpb24oKTtcbiAgICAgIHRoaXMuaW1hZ2VTY2FsZV8gPSBpbWFnZVN0eWxlLmdldFNjYWxlKCkgKiB0aGlzLnBpeGVsUmF0aW9fO1xuICAgICAgdGhpcy5pbWFnZVdpZHRoXyA9IGltYWdlU2l6ZVswXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0ZXh0IHN0eWxlIGZvciBzdWJzZXF1ZW50IGRyYXcgb3BlcmF0aW9ucy4gIFBhc3MgbnVsbCB0b1xuICAgKiByZW1vdmUgdGhlIHRleHQgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vc3R5bGUvVGV4dC5qc1wiKS5kZWZhdWx0fSB0ZXh0U3R5bGUgVGV4dCBzdHlsZS5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzZXRUZXh0U3R5bGUodGV4dFN0eWxlKSB7XG4gICAgaWYgKCF0ZXh0U3R5bGUpIHtcbiAgICAgIHRoaXMudGV4dF8gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGV4dEZpbGxTdHlsZSA9IHRleHRTdHlsZS5nZXRGaWxsKCk7XG4gICAgICBpZiAoIXRleHRGaWxsU3R5bGUpIHtcbiAgICAgICAgdGhpcy50ZXh0RmlsbFN0YXRlXyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0RmlsbFN0eWxlQ29sb3IgPSB0ZXh0RmlsbFN0eWxlLmdldENvbG9yKCk7XG4gICAgICAgIHRoaXMudGV4dEZpbGxTdGF0ZV8gPSB7XG4gICAgICAgICAgZmlsbFN0eWxlOiBhc0NvbG9yTGlrZSh0ZXh0RmlsbFN0eWxlQ29sb3IgP1xuICAgICAgICAgICAgdGV4dEZpbGxTdHlsZUNvbG9yIDogZGVmYXVsdEZpbGxTdHlsZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHRTdHJva2VTdHlsZSA9IHRleHRTdHlsZS5nZXRTdHJva2UoKTtcbiAgICAgIGlmICghdGV4dFN0cm9rZVN0eWxlKSB7XG4gICAgICAgIHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVDb2xvciA9IHRleHRTdHJva2VTdHlsZS5nZXRDb2xvcigpO1xuICAgICAgICBjb25zdCB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwID0gdGV4dFN0cm9rZVN0eWxlLmdldExpbmVDYXAoKTtcbiAgICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlTGluZURhc2ggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZURhc2goKTtcbiAgICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZURhc2hPZmZzZXQoKTtcbiAgICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlTGluZUpvaW4gPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0TGluZUpvaW4oKTtcbiAgICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlV2lkdGggPSB0ZXh0U3Ryb2tlU3R5bGUuZ2V0V2lkdGgoKTtcbiAgICAgICAgY29uc3QgdGV4dFN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA9IHRleHRTdHJva2VTdHlsZS5nZXRNaXRlckxpbWl0KCk7XG4gICAgICAgIHRoaXMudGV4dFN0cm9rZVN0YXRlXyA9IHtcbiAgICAgICAgICBsaW5lQ2FwOiB0ZXh0U3Ryb2tlU3R5bGVMaW5lQ2FwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTGluZUNhcCA6IGRlZmF1bHRMaW5lQ2FwLFxuICAgICAgICAgIGxpbmVEYXNoOiB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaCA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVMaW5lRGFzaCA6IGRlZmF1bHRMaW5lRGFzaCxcbiAgICAgICAgICBsaW5lRGFzaE9mZnNldDogdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTGluZURhc2hPZmZzZXQgOiBkZWZhdWx0TGluZURhc2hPZmZzZXQsXG4gICAgICAgICAgbGluZUpvaW46IHRleHRTdHJva2VTdHlsZUxpbmVKb2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTGluZUpvaW4gOiBkZWZhdWx0TGluZUpvaW4sXG4gICAgICAgICAgbGluZVdpZHRoOiB0ZXh0U3Ryb2tlU3R5bGVXaWR0aCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHRleHRTdHJva2VTdHlsZVdpZHRoIDogZGVmYXVsdExpbmVXaWR0aCxcbiAgICAgICAgICBtaXRlckxpbWl0OiB0ZXh0U3Ryb2tlU3R5bGVNaXRlckxpbWl0ICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGV4dFN0cm9rZVN0eWxlTWl0ZXJMaW1pdCA6IGRlZmF1bHRNaXRlckxpbWl0LFxuICAgICAgICAgIHN0cm9rZVN0eWxlOiBhc0NvbG9yTGlrZSh0ZXh0U3Ryb2tlU3R5bGVDb2xvciA/XG4gICAgICAgICAgICB0ZXh0U3Ryb2tlU3R5bGVDb2xvciA6IGRlZmF1bHRTdHJva2VTdHlsZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleHRGb250ID0gdGV4dFN0eWxlLmdldEZvbnQoKTtcbiAgICAgIGNvbnN0IHRleHRPZmZzZXRYID0gdGV4dFN0eWxlLmdldE9mZnNldFgoKTtcbiAgICAgIGNvbnN0IHRleHRPZmZzZXRZID0gdGV4dFN0eWxlLmdldE9mZnNldFkoKTtcbiAgICAgIGNvbnN0IHRleHRSb3RhdGVXaXRoVmlldyA9IHRleHRTdHlsZS5nZXRSb3RhdGVXaXRoVmlldygpO1xuICAgICAgY29uc3QgdGV4dFJvdGF0aW9uID0gdGV4dFN0eWxlLmdldFJvdGF0aW9uKCk7XG4gICAgICBjb25zdCB0ZXh0U2NhbGUgPSB0ZXh0U3R5bGUuZ2V0U2NhbGUoKTtcbiAgICAgIGNvbnN0IHRleHRUZXh0ID0gdGV4dFN0eWxlLmdldFRleHQoKTtcbiAgICAgIGNvbnN0IHRleHRUZXh0QWxpZ24gPSB0ZXh0U3R5bGUuZ2V0VGV4dEFsaWduKCk7XG4gICAgICBjb25zdCB0ZXh0VGV4dEJhc2VsaW5lID0gdGV4dFN0eWxlLmdldFRleHRCYXNlbGluZSgpO1xuICAgICAgdGhpcy50ZXh0U3RhdGVfID0ge1xuICAgICAgICBmb250OiB0ZXh0Rm9udCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0ZXh0Rm9udCA6IGRlZmF1bHRGb250LFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRUZXh0QWxpZ24gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgdGV4dFRleHRBbGlnbiA6IGRlZmF1bHRUZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogdGV4dFRleHRCYXNlbGluZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICB0ZXh0VGV4dEJhc2VsaW5lIDogZGVmYXVsdFRleHRCYXNlbGluZVxuICAgICAgfTtcbiAgICAgIHRoaXMudGV4dF8gPSB0ZXh0VGV4dCAhPT0gdW5kZWZpbmVkID8gdGV4dFRleHQgOiAnJztcbiAgICAgIHRoaXMudGV4dE9mZnNldFhfID1cbiAgICAgICAgICB0ZXh0T2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gKHRoaXMucGl4ZWxSYXRpb18gKiB0ZXh0T2Zmc2V0WCkgOiAwO1xuICAgICAgdGhpcy50ZXh0T2Zmc2V0WV8gPVxuICAgICAgICAgIHRleHRPZmZzZXRZICE9PSB1bmRlZmluZWQgPyAodGhpcy5waXhlbFJhdGlvXyAqIHRleHRPZmZzZXRZKSA6IDA7XG4gICAgICB0aGlzLnRleHRSb3RhdGVXaXRoVmlld18gPSB0ZXh0Um90YXRlV2l0aFZpZXcgIT09IHVuZGVmaW5lZCA/IHRleHRSb3RhdGVXaXRoVmlldyA6IGZhbHNlO1xuICAgICAgdGhpcy50ZXh0Um90YXRpb25fID0gdGV4dFJvdGF0aW9uICE9PSB1bmRlZmluZWQgPyB0ZXh0Um90YXRpb24gOiAwO1xuICAgICAgdGhpcy50ZXh0U2NhbGVfID0gdGhpcy5waXhlbFJhdGlvXyAqICh0ZXh0U2NhbGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgIHRleHRTY2FsZSA6IDEpO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQUE7QUFRQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUF6QkE7QUEyQkE7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQWJBO0FBZ0JBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFiQTtBQWdCQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFMQTtBQVFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUF0NEJBO0FBQ0E7QUF3NEJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///98\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/**\n * @module ol/render/VectorContext\n */\n\n/**\n * @classdesc\n * Context for drawing geometries.  A vector context is available on render\n * events and does not need to be constructed directly.\n * @api\n */\nvar VectorContext = function VectorContext() {};\n\nVectorContext.prototype.drawCustom = function drawCustom(geometry, feature, renderer) {};\n/**\n * Render a geometry.\n *\n * @param {import("../geom/Geometry.js").default} geometry The geometry to render.\n */\n\n\nVectorContext.prototype.drawGeometry = function drawGeometry(geometry) {};\n/**\n * Set the rendering style.\n *\n * @param {import("../style/Style.js").default} style The rendering style.\n */\n\n\nVectorContext.prototype.setStyle = function setStyle(style) {};\n/**\n * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.\n * @param {import("../Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawCircle = function drawCircle(circleGeometry, feature) {};\n/**\n * @param {import("../Feature.js").default} feature Feature.\n * @param {import("../style/Style.js").default} style Style.\n */\n\n\nVectorContext.prototype.drawFeature = function drawFeature(feature, style) {};\n/**\n * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.\n * @param {import("../Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawGeometryCollection = function drawGeometryCollection(geometryCollectionGeometry, feature) {};\n/**\n * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.\n * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawLineString = function drawLineString(lineStringGeometry, feature) {};\n/**\n * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.\n * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawMultiLineString = function drawMultiLineString(multiLineStringGeometry, feature) {};\n/**\n * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.\n * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawMultiPoint = function drawMultiPoint(multiPointGeometry, feature) {};\n/**\n * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.\n * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawMultiPolygon = function drawMultiPolygon(multiPolygonGeometry, feature) {};\n/**\n * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.\n * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawPoint = function drawPoint(pointGeometry, feature) {};\n/**\n * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.\n * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawPolygon = function drawPolygon(polygonGeometry, feature) {};\n/**\n * @param {import("../geom/Geometry.js").default|import("./Feature.js").default} geometry Geometry.\n * @param {import("../Feature.js").default|import("./Feature.js").default} feature Feature.\n */\n\n\nVectorContext.prototype.drawText = function drawText(geometry, feature) {};\n/**\n * @param {import("../style/Fill.js").default} fillStyle Fill style.\n * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.\n */\n\n\nVectorContext.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {};\n/**\n * @param {import("../style/Image.js").default} imageStyle Image style.\n * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.\n */\n\n\nVectorContext.prototype.setImageStyle = function setImageStyle(imageStyle, opt_declutterGroup) {};\n/**\n * @param {import("../style/Text.js").default} textStyle Text style.\n * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.\n */\n\n\nVectorContext.prototype.setTextStyle = function setTextStyle(textStyle, opt_declutterGroup) {};\n\n/* harmony default export */ __webpack_exports__["a"] = (VectorContext);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3JlbmRlci9WZWN0b3JDb250ZXh0LmpzPzVlOTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlci9WZWN0b3JDb250ZXh0XG4gKi9cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDb250ZXh0IGZvciBkcmF3aW5nIGdlb21ldHJpZXMuICBBIHZlY3RvciBjb250ZXh0IGlzIGF2YWlsYWJsZSBvbiByZW5kZXJcbiAqIGV2ZW50cyBhbmQgZG9lcyBub3QgbmVlZCB0byBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseS5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgVmVjdG9yQ29udGV4dCB7XG4gIC8qKlxuICAgKiBSZW5kZXIgYSBnZW9tZXRyeSB3aXRoIGEgY3VzdG9tIHJlbmRlcmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbmRlcmVyIFJlbmRlcmVyLlxuICAgKi9cbiAgZHJhd0N1c3RvbShnZW9tZXRyeSwgZmVhdHVyZSwgcmVuZGVyZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIGdlb21ldHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgVGhlIGdlb21ldHJ5IHRvIHJlbmRlci5cbiAgICovXG4gIGRyYXdHZW9tZXRyeShnZW9tZXRyeSkge31cblxuICAvKipcbiAgICogU2V0IHRoZSByZW5kZXJpbmcgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgVGhlIHJlbmRlcmluZyBzdHlsZS5cbiAgICovXG4gIHNldFN0eWxlKHN0eWxlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vQ2lyY2xlLmpzXCIpLmRlZmF1bHR9IGNpcmNsZUdlb21ldHJ5IENpcmNsZSBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdDaXJjbGUoY2lyY2xlR2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdH0gc3R5bGUgU3R5bGUuXG4gICAqL1xuICBkcmF3RmVhdHVyZShmZWF0dXJlLCBzdHlsZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0fSBnZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeSBHZW9tZXRyeSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd0dlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyeUNvbGxlY3Rpb25HZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9nZW9tL0xpbmVTdHJpbmcuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gbGluZVN0cmluZ0dlb21ldHJ5IExpbmUgc3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd0xpbmVTdHJpbmcobGluZVN0cmluZ0dlb21ldHJ5LCBmZWF0dXJlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlMaW5lU3RyaW5nLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IG11bHRpTGluZVN0cmluZ0dlb21ldHJ5IE11bHRpTGluZVN0cmluZyBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdNdWx0aUxpbmVTdHJpbmcobXVsdGlMaW5lU3RyaW5nR2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9NdWx0aVBvaW50LmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IG11bHRpUG9pbnRHZW9tZXRyeSBNdWx0aVBvaW50IGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd011bHRpUG9pbnQobXVsdGlQb2ludEdlb21ldHJ5LCBmZWF0dXJlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vTXVsdGlQb2x5Z29uLmpzXCIpLmRlZmF1bHR9IG11bHRpUG9seWdvbkdlb21ldHJ5IE11bHRpUG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIGRyYXdNdWx0aVBvbHlnb24obXVsdGlQb2x5Z29uR2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2ludC5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBwb2ludEdlb21ldHJ5IFBvaW50IGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1BvaW50KHBvaW50R2VvbWV0cnksIGZlYXR1cmUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IHBvbHlnb25HZW9tZXRyeSBQb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKi9cbiAgZHJhd1BvbHlnb24ocG9seWdvbkdlb21ldHJ5LCBmZWF0dXJlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2dlb20vR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZ2VvbWV0cnkgR2VvbWV0cnkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqL1xuICBkcmF3VGV4dChnZW9tZXRyeSwgZmVhdHVyZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9GaWxsLmpzXCIpLmRlZmF1bHR9IGZpbGxTdHlsZSBGaWxsIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBzdHJva2VTdHlsZSBTdHJva2Ugc3R5bGUuXG4gICAqL1xuICBzZXRGaWxsU3Ryb2tlU3R5bGUoZmlsbFN0eWxlLCBzdHJva2VTdHlsZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zdHlsZS9JbWFnZS5qc1wiKS5kZWZhdWx0fSBpbWFnZVN0eWxlIEltYWdlIHN0eWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY2FudmFzLmpzXCIpLkRlY2x1dHRlckdyb3VwPX0gb3B0X2RlY2x1dHRlckdyb3VwIERlY2x1dHRlci5cbiAgICovXG4gIHNldEltYWdlU3R5bGUoaW1hZ2VTdHlsZSwgb3B0X2RlY2x1dHRlckdyb3VwKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3N0eWxlL1RleHQuanNcIikuZGVmYXVsdH0gdGV4dFN0eWxlIFRleHQgc3R5bGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jYW52YXMuanNcIikuRGVjbHV0dGVyR3JvdXA9fSBvcHRfZGVjbHV0dGVyR3JvdXAgRGVjbHV0dGVyLlxuICAgKi9cbiAgc2V0VGV4dFN0eWxlKHRleHRTdHlsZSwgb3B0X2RlY2x1dHRlckdyb3VwKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBWZWN0b3JDb250ZXh0O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFPQTtBQUVBOzs7Ozs7O0FBS0E7QUFFQTs7Ozs7OztBQUtBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7OztBQUlBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///99\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);\n/**\n * @module ol/render/Event\n */\n\n\nvar RenderEvent =\n/*@__PURE__*/\nfunction (Event) {\n  function RenderEvent(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {\n    Event.call(this, type);\n    /**\n     * For canvas, this is an instance of {@link module:ol/render/canvas/Immediate}.\n     * @type {import("./VectorContext.js").default|undefined}\n     * @api\n     */\n\n    this.vectorContext = opt_vectorContext;\n    /**\n     * An object representing the current render frame state.\n     * @type {import("../PluggableMap.js").FrameState|undefined}\n     * @api\n     */\n\n    this.frameState = opt_frameState;\n    /**\n     * Canvas context. Only available when a Canvas renderer is used, null\n     * otherwise.\n     * @type {CanvasRenderingContext2D|null|undefined}\n     * @api\n     */\n\n    this.context = opt_context;\n    /**\n     * WebGL context. Only available when a WebGL renderer is used, null\n     * otherwise.\n     * @type {import("../webgl/Context.js").default|null|undefined}\n     * @api\n     */\n\n    this.glContext = opt_glContext;\n  }\n\n  if (Event) RenderEvent.__proto__ = Event;\n  RenderEvent.prototype = Object.create(Event && Event.prototype);\n  RenderEvent.prototype.constructor = RenderEvent;\n  return RenderEvent;\n}(_events_Event_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["a"] = (RenderEvent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXIvRXZlbnQuanM/N2Y1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyL0V2ZW50XG4gKi9cblxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5cbmNsYXNzIFJlbmRlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgVHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1ZlY3RvckNvbnRleHQuanNcIikuZGVmYXVsdD19IG9wdF92ZWN0b3JDb250ZXh0IFZlY3RvciBjb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlPX0gb3B0X2ZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7P0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRD19IG9wdF9jb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4uL3dlYmdsL0NvbnRleHQuanNcIikuZGVmYXVsdD19IG9wdF9nbENvbnRleHQgV2ViR0wgQ29udGV4dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdF92ZWN0b3JDb250ZXh0LCBvcHRfZnJhbWVTdGF0ZSwgb3B0X2NvbnRleHQsIG9wdF9nbENvbnRleHQpIHtcblxuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGNhbnZhcywgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgbW9kdWxlOm9sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlfS5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9WZWN0b3JDb250ZXh0LmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnZlY3RvckNvbnRleHQgPSBvcHRfdmVjdG9yQ29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGZyYW1lIHN0YXRlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZXx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZSA9IG9wdF9mcmFtZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2FudmFzIGNvbnRleHQuIE9ubHkgYXZhaWxhYmxlIHdoZW4gYSBDYW52YXMgcmVuZGVyZXIgaXMgdXNlZCwgbnVsbFxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx8dW5kZWZpbmVkfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBvcHRfY29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIFdlYkdMIGNvbnRleHQuIE9ubHkgYXZhaWxhYmxlIHdoZW4gYSBXZWJHTCByZW5kZXJlciBpcyB1c2VkLCBudWxsXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi93ZWJnbC9Db250ZXh0LmpzXCIpLmRlZmF1bHR8bnVsbHx1bmRlZmluZWR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZ2xDb250ZXh0ID0gb3B0X2dsQ29udGV4dDtcblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyRXZlbnQ7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFTQTtBQUVBOzs7Ozs7O0FBT0E7Ozs7Ozs7QUFPQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7QUFFQTs7QUEzQ0E7QUFDQTtBQThDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///100\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/functions.js\nvar functions = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/Event.js\nvar Event = __webpack_require__(100);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/EventType.js\nvar EventType = __webpack_require__(38);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js\nvar canvas = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/canvas/Immediate.js\nvar Immediate = __webpack_require__(98);\n\n// EXTERNAL MODULE: ./node_modules/ol/ImageState.js\nvar ImageState = __webpack_require__(22);\n\n// EXTERNAL MODULE: ./node_modules/ol/Observable.js\nvar ol_Observable = __webpack_require__(86);\n\n// EXTERNAL MODULE: ./node_modules/ol/TileState.js\nvar TileState = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar events_EventType = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/ol/source/State.js\nvar State = __webpack_require__(45);\n\n// CONCATENATED MODULE: ./node_modules/ol/renderer/Layer.js\n/**\n * @module ol/renderer/Layer\n */\n\n\n\n\n\n\n\n\nvar Layer_LayerRenderer =\n/*@__PURE__*/\nfunction (Observable) {\n  function LayerRenderer(layer) {\n    Observable.call(this);\n    /**\n     * @private\n     * @type {import("../layer/Layer.js").default}\n     */\n\n    this.layer_ = layer;\n  }\n\n  if (Observable) LayerRenderer.__proto__ = Observable;\n  LayerRenderer.prototype = Object.create(Observable && Observable.prototype);\n  LayerRenderer.prototype.constructor = LayerRenderer;\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import("../source/Tile.js").default} source Tile source.\n   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n\n  LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import("../TileRange.js").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      function (zoom, tileRange) {\n        /**\n         * @param {import("../Tile.js").default} tile Tile.\n         */\n        function callback(tile) {\n          if (!tiles[zoom]) {\n            tiles[zoom] = {};\n          }\n\n          tiles[zoom][tile.tileCoord.toString()] = tile;\n        }\n\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  };\n  /**\n   * @abstract\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default): T} callback Feature callback.\n   * @return {T|void} Callback result.\n   * @template T\n   */\n\n\n  LayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback) {};\n  /**\n   * @return {import("../layer/Layer.js").default} Layer.\n   */\n\n\n  LayerRenderer.prototype.getLayer = function getLayer() {\n    return this.layer_;\n  };\n  /**\n   * Handle changes in image state.\n   * @param {import("../events/Event.js").default} event Image change event.\n   * @private\n   */\n\n\n  LayerRenderer.prototype.handleImageChange_ = function handleImageChange_(event) {\n    var image =\n    /** @type {import("../Image.js").default} */\n    event.target;\n\n    if (image.getState() === ImageState["a" /* default */].LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n  /**\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n   * @return {boolean} Is there a feature at the given coordinate?\n   */\n\n\n  LayerRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate(coordinate, frameState) {\n    return false;\n  };\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import("../ImageBase.js").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.loadImage = function loadImage(image) {\n    var imageState = image.getState();\n\n    if (imageState != ImageState["a" /* default */].LOADED && imageState != ImageState["a" /* default */].ERROR) {\n      Object(events["a" /* listen */])(image, events_EventType["a" /* default */].CHANGE, this.handleImageChange_, this);\n    }\n\n    if (imageState == ImageState["a" /* default */].IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n\n    return imageState == ImageState["a" /* default */].LOADED;\n  };\n  /**\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible() {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && layer.getSourceState() == State["a" /* default */].READY) {\n      this.changed();\n    }\n  };\n  /**\n   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../source/Tile.js").default} tileSource Tile source.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import("../source/Tile.js").default} tileSource Tile source.\n       * @param {import("../PluggableMap.js").default} map Map.\n       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function (tileSource, map, frameState) {\n        var tileSourceKey = Object(util["c" /* getUid */])(tileSource);\n\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n      /** @type {import("../PluggableMap.js").PostRenderFunction} */\n      postRenderFunction);\n    }\n  };\n  /**\n   * @param {!Object<string, !Object<string, import("../TileRange.js").default>>} usedTiles Used tiles.\n   * @param {import("../source/Tile.js").default} tileSource Tile source.\n   * @param {number} z Z.\n   * @param {import("../TileRange.js").default} tileRange Tile range.\n   * @protected\n   */\n\n\n  LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles(usedTiles, tileSource, z, tileRange) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = Object(util["c" /* getUid */])(tileSource);\n    var zKey = z.toString();\n\n    if (tileSourceKey in usedTiles) {\n      if (zKey in usedTiles[tileSourceKey]) {\n        usedTiles[tileSourceKey][zKey].extend(tileRange);\n      } else {\n        usedTiles[tileSourceKey][zKey] = tileRange;\n      }\n    } else {\n      usedTiles[tileSourceKey] = {};\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  };\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../source/Tile.js").default} tileSource Tile source.\n   * @param {import("../tilegrid/TileGrid.js").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @param {import("../extent.js").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to \'preload\' levels.\n   * @param {function(this: T, import("../Tile.js").default)=} opt_tileCallback Tile callback.\n   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n   * @protected\n   * @template T\n   */\n\n\n  LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {\n    var tileSourceKey = Object(util["c" /* getUid */])(tileSource);\n\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tile, tileRange, tileResolution, x, y, z;\n\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n            if (tile.getState() == TileState["a" /* default */].IDLE) {\n              wantedTiles[tile.getKey()] = true;\n\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback.call(opt_this, tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n  };\n\n  return LayerRenderer;\n}(ol_Observable["a" /* default */]);\n\n/* harmony default export */ var Layer = (Layer_LayerRenderer);\n// EXTERNAL MODULE: ./node_modules/ol/transform.js\nvar ol_transform = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/Layer.js\n/**\n * @module ol/renderer/canvas/Layer\n */\n\n\n\n\n\n\n\n\n\n/**\n * @abstract\n */\n\nvar Layer_CanvasLayerRenderer =\n/*@__PURE__*/\nfunction (LayerRenderer) {\n  function CanvasLayerRenderer(layer) {\n    LayerRenderer.call(this, layer);\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.renderedResolution;\n    /**\n     * @private\n     * @type {import("../../transform.js").Transform}\n     */\n\n    this.transform_ = Object(ol_transform["c" /* create */])();\n  }\n\n  if (LayerRenderer) CanvasLayerRenderer.__proto__ = LayerRenderer;\n  CanvasLayerRenderer.prototype = Object.create(LayerRenderer && LayerRenderer.prototype);\n  CanvasLayerRenderer.prototype.constructor = CanvasLayerRenderer;\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../extent.js").Extent} extent Clip extent.\n   * @protected\n   */\n\n  CanvasLayerRenderer.prototype.clip = function clip(context, frameState, extent) {\n    var pixelRatio = frameState.pixelRatio;\n    var width = frameState.size[0] * pixelRatio;\n    var height = frameState.size[1] * pixelRatio;\n    var rotation = frameState.viewState.rotation;\n    var topLeft = Object(ol_extent["getTopLeft"])(extent);\n    var topRight = Object(ol_extent["getTopRight"])(extent);\n    var bottomRight = Object(ol_extent["getBottomRight"])(extent);\n    var bottomLeft = Object(ol_extent["getBottomLeft"])(extent);\n    Object(ol_transform["a" /* apply */])(frameState.coordinateToPixelTransform, topLeft);\n    Object(ol_transform["a" /* apply */])(frameState.coordinateToPixelTransform, topRight);\n    Object(ol_transform["a" /* apply */])(frameState.coordinateToPixelTransform, bottomRight);\n    Object(ol_transform["a" /* apply */])(frameState.coordinateToPixelTransform, bottomLeft);\n    context.save();\n    Object(canvas["s" /* rotateAtOffset */])(context, -rotation, width / 2, height / 2);\n    context.beginPath();\n    context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);\n    context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);\n    context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);\n    context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);\n    context.clip();\n    Object(canvas["s" /* rotateAtOffset */])(context, rotation, width / 2, height / 2);\n  };\n  /**\n   * @param {import("../../render/EventType.js").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../transform.js").Transform=} opt_transform Transform.\n   * @private\n   */\n\n\n  CanvasLayerRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_(type, context, frameState, opt_transform) {\n    var layer = this.getLayer();\n\n    if (layer.hasListener(type)) {\n      var width = frameState.size[0] * frameState.pixelRatio;\n      var height = frameState.size[1] * frameState.pixelRatio;\n      var rotation = frameState.viewState.rotation;\n      Object(canvas["s" /* rotateAtOffset */])(context, -rotation, width / 2, height / 2);\n      var transform = opt_transform !== undefined ? opt_transform : this.getTransform(frameState, 0);\n      var render = new Immediate["a" /* default */](context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation);\n      var composeEvent = new Event["a" /* default */](type, render, frameState, context, null);\n      layer.dispatchEvent(composeEvent);\n      Object(canvas["s" /* rotateAtOffset */])(context, rotation, width / 2, height / 2);\n    }\n  };\n  /**\n   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(this: S, import("../../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n   *     callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n\n\n  CanvasLayerRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, functions["b" /* TRUE */]);\n\n    if (hasFeature) {\n      return callback.call(thisArg, this.getLayer(), null);\n    } else {\n      return undefined;\n    }\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../layer/Layer.js").State} layerState Layer state.\n   * @param {import("../../transform.js").Transform=} opt_transform Transform.\n   * @protected\n   */\n\n\n  CanvasLayerRenderer.prototype.postCompose = function postCompose(context, frameState, layerState, opt_transform) {\n    this.dispatchComposeEvent_(EventType["a" /* default */].POSTCOMPOSE, context, frameState, opt_transform);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../transform.js").Transform=} opt_transform Transform.\n   * @protected\n   */\n\n\n  CanvasLayerRenderer.prototype.preCompose = function preCompose(context, frameState, opt_transform) {\n    this.dispatchComposeEvent_(EventType["a" /* default */].PRECOMPOSE, context, frameState, opt_transform);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../transform.js").Transform=} opt_transform Transform.\n   * @protected\n   */\n\n\n  CanvasLayerRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent(context, frameState, opt_transform) {\n    this.dispatchComposeEvent_(EventType["a" /* default */].RENDER, context, frameState, opt_transform);\n  };\n  /**\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import("../../transform.js").Transform} Transform.\n   */\n\n\n  CanvasLayerRenderer.prototype.getTransform = function getTransform(frameState, offsetX) {\n    var viewState = frameState.viewState;\n    var pixelRatio = frameState.pixelRatio;\n    var dx1 = pixelRatio * frameState.size[0] / 2;\n    var dy1 = pixelRatio * frameState.size[1] / 2;\n    var sx = pixelRatio / viewState.resolution;\n    var sy = -sx;\n    var angle = -viewState.rotation;\n    var dx2 = -viewState.center[0] + offsetX;\n    var dy2 = -viewState.center[1];\n    return Object(ol_transform["b" /* compose */])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\n  };\n  /**\n   * @abstract\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../layer/Layer.js").State} layerState Layer state.\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n\n\n  CanvasLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    Object(util["b" /* abstract */])();\n  };\n  /**\n   * @abstract\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../layer/Layer.js").State} layerState Layer state.\n   * @return {boolean} whether composeFrame should be called.\n   */\n\n\n  CanvasLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    return Object(util["b" /* abstract */])();\n  };\n\n  return CanvasLayerRenderer;\n}(Layer);\n\n/* harmony default export */ var canvas_Layer = __webpack_exports__["a"] = (Layer_CanvasLayerRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXJlci9MYXllci5qcz8yOWFhIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi9zcmMvb2wvcmVuZGVyZXIvY2FudmFzL0xheWVyLmpzPzhhODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL0xheWVyXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IE9ic2VydmFibGUgZnJvbSAnLi4vT2JzZXJ2YWJsZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgU291cmNlU3RhdGUgZnJvbSAnLi4vc291cmNlL1N0YXRlLmpzJztcblxuY2xhc3MgTGF5ZXJSZW5kZXJlciBleHRlbmRzIE9ic2VydmFibGUge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IobGF5ZXIpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJfID0gbGF5ZXI7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IGFkZHMgbG9hZGVkIHRpbGVzIHRvIHRoZSB0aWxlIGxvb2t1cC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSBzb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbiBvZiB0aGUgdGlsZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0PG51bWJlciwgT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0Pj59IHRpbGVzIExvb2t1cCBvZiBsb2FkZWQgdGlsZXMgYnkgem9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyLCBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdCk6Ym9vbGVhbn0gQSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICAgKiAgICAgY2FsbGVkIHdpdGggYSB6b29tIGxldmVsIGFuZCBhIHRpbGUgcmFuZ2UgdG8gYWRkIGxvYWRlZCB0aWxlcyB0byB0aGUgbG9va3VwLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjcmVhdGVMb2FkZWRUaWxlRmluZGVyKHNvdXJjZSwgcHJvamVjdGlvbiwgdGlsZXMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdH0gdGlsZVJhbmdlIFRpbGUgcmFuZ2UuXG4gICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdGlsZSByYW5nZSBpcyBmdWxseSBsb2FkZWQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKHpvb20sIHRpbGVSYW5nZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKHRpbGUpIHtcbiAgICAgICAgICBpZiAoIXRpbGVzW3pvb21dKSB7XG4gICAgICAgICAgICB0aWxlc1t6b29tXSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aWxlc1t6b29tXVt0aWxlLnRpbGVDb29yZC50b1N0cmluZygpXSA9IHRpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5mb3JFYWNoTG9hZGVkVGlsZShwcm9qZWN0aW9uLCB6b29tLCB0aWxlUmFuZ2UsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2UsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJuIHtUfHZvaWR9IENhbGxiYWNrIHJlc3VsdC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2spIHt9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IExheWVyLlxuICAgKi9cbiAgZ2V0TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIGluIGltYWdlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBJbWFnZSBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVJbWFnZUNoYW5nZV8oZXZlbnQpIHtcbiAgICBjb25zdCBpbWFnZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2UuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgaWYgKGltYWdlLmdldFN0YXRlKCkgPT09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHRoZXJlIGEgZmVhdHVyZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZT9cbiAgICovXG4gIGhhc0ZlYXR1cmVBdENvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBpZiBub3QgYWxyZWFkeSBsb2FkZWQsIGFuZCByZWdpc3RlciB0aGUgaW1hZ2UgY2hhbmdlXG4gICAqIGxpc3RlbmVyIGlmIG5lZWRlZC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9JbWFnZUJhc2UuanNcIikuZGVmYXVsdH0gaW1hZ2UgSW1hZ2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgaW1hZ2UgaXMgYWxyZWFkeSBsb2FkZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBsb2FkSW1hZ2UoaW1hZ2UpIHtcbiAgICBsZXQgaW1hZ2VTdGF0ZSA9IGltYWdlLmdldFN0YXRlKCk7XG4gICAgaWYgKGltYWdlU3RhdGUgIT0gSW1hZ2VTdGF0ZS5MT0FERUQgJiYgaW1hZ2VTdGF0ZSAhPSBJbWFnZVN0YXRlLkVSUk9SKSB7XG4gICAgICBsaXN0ZW4oaW1hZ2UsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlSW1hZ2VDaGFuZ2VfLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5JRExFKSB7XG4gICAgICBpbWFnZS5sb2FkKCk7XG4gICAgICBpbWFnZVN0YXRlID0gaW1hZ2UuZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlU3RhdGUgPT0gSW1hZ2VTdGF0ZS5MT0FERUQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcmVuZGVySWZSZWFkeUFuZFZpc2libGUoKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgaWYgKGxheWVyLmdldFZpc2libGUoKSAmJiBsYXllci5nZXRTb3VyY2VTdGF0ZSgpID09IFNvdXJjZVN0YXRlLlJFQURZKSB7XG4gICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlU291cmNlIFRpbGUgc291cmNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzY2hlZHVsZUV4cGlyZUNhY2hlKGZyYW1lU3RhdGUsIHRpbGVTb3VyY2UpIHtcbiAgICBpZiAodGlsZVNvdXJjZS5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZVNvdXJjZSBUaWxlIHNvdXJjZS5cbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgICAgICovXG4gICAgICBjb25zdCBwb3N0UmVuZGVyRnVuY3Rpb24gPSBmdW5jdGlvbih0aWxlU291cmNlLCBtYXAsIGZyYW1lU3RhdGUpIHtcbiAgICAgICAgY29uc3QgdGlsZVNvdXJjZUtleSA9IGdldFVpZCh0aWxlU291cmNlKTtcbiAgICAgICAgaWYgKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS51c2VkVGlsZXMpIHtcbiAgICAgICAgICB0aWxlU291cmNlLmV4cGlyZUNhY2hlKGZyYW1lU3RhdGUudmlld1N0YXRlLnByb2plY3Rpb24sXG4gICAgICAgICAgICBmcmFtZVN0YXRlLnVzZWRUaWxlc1t0aWxlU291cmNlS2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZChudWxsLCB0aWxlU291cmNlKTtcblxuICAgICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zLnB1c2goXG4gICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLlBvc3RSZW5kZXJGdW5jdGlvbn0gKi8gKHBvc3RSZW5kZXJGdW5jdGlvbilcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9UaWxlUmFuZ2UuanNcIikuZGVmYXVsdD4+fSB1c2VkVGlsZXMgVXNlZCB0aWxlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlU291cmNlIFRpbGUgc291cmNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlVXNlZFRpbGVzKHVzZWRUaWxlcywgdGlsZVNvdXJjZSwgeiwgdGlsZVJhbmdlKSB7XG4gICAgLy8gRklYTUUgc2hvdWxkIHdlIHVzZSB0aWxlc1RvRHJhd0J5WiBpbnN0ZWFkP1xuICAgIGNvbnN0IHRpbGVTb3VyY2VLZXkgPSBnZXRVaWQodGlsZVNvdXJjZSk7XG4gICAgY29uc3QgektleSA9IHoudG9TdHJpbmcoKTtcbiAgICBpZiAodGlsZVNvdXJjZUtleSBpbiB1c2VkVGlsZXMpIHtcbiAgICAgIGlmICh6S2V5IGluIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XSkge1xuICAgICAgICB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV1bektleV0uZXh0ZW5kKHRpbGVSYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1c2VkVGlsZXNbdGlsZVNvdXJjZUtleV1bektleV0gPSB0aWxlUmFuZ2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVzZWRUaWxlc1t0aWxlU291cmNlS2V5XSA9IHt9O1xuICAgICAgdXNlZFRpbGVzW3RpbGVTb3VyY2VLZXldW3pLZXldID0gdGlsZVJhbmdlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGlsZSBweXJhbWlkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIGEgbnVtYmVyIG9mIGZ1bmN0aW9ucyByZWxhdGVkIHRvIHRoZSB0aWxlcyBhdCB0aGVcbiAgICogY3VycmVudCB6b29tIGFuZCBsb3dlciB6b29tIGxldmVsczpcbiAgICogLSByZWdpc3RlcnMgaWRsZSB0aWxlcyBpbiBmcmFtZVN0YXRlLndhbnRlZFRpbGVzIHNvIHRoYXQgdGhleSBhcmUgbm90XG4gICAqICAgZGlzY2FyZGVkIGJ5IHRoZSB0aWxlIHF1ZXVlXG4gICAqIC0gZW5xdWV1ZXMgbWlzc2luZyB0aWxlc1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGVTb3VyY2UgVGlsZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWdyaWQvVGlsZUdyaWQuanNcIikuZGVmYXVsdH0gdGlsZUdyaWQgVGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50WiBDdXJyZW50IFouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmVsb2FkIExvYWQgbG93IHJlc29sdXRpb24gdGlsZXMgdXAgdG8gJ3ByZWxvYWQnIGxldmVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBULCBpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHQpPX0gb3B0X3RpbGVDYWxsYmFjayBUaWxlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge1Q9fSBvcHRfdGhpcyBPYmplY3QgdG8gdXNlIGFzIGB0aGlzYCBpbiBgb3B0X3RpbGVDYWxsYmFja2AuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIG1hbmFnZVRpbGVQeXJhbWlkKFxuICAgIGZyYW1lU3RhdGUsXG4gICAgdGlsZVNvdXJjZSxcbiAgICB0aWxlR3JpZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIHByb2plY3Rpb24sXG4gICAgZXh0ZW50LFxuICAgIGN1cnJlbnRaLFxuICAgIHByZWxvYWQsXG4gICAgb3B0X3RpbGVDYWxsYmFjayxcbiAgICBvcHRfdGhpc1xuICApIHtcbiAgICBjb25zdCB0aWxlU291cmNlS2V5ID0gZ2V0VWlkKHRpbGVTb3VyY2UpO1xuICAgIGlmICghKHRpbGVTb3VyY2VLZXkgaW4gZnJhbWVTdGF0ZS53YW50ZWRUaWxlcykpIHtcbiAgICAgIGZyYW1lU3RhdGUud2FudGVkVGlsZXNbdGlsZVNvdXJjZUtleV0gPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgd2FudGVkVGlsZXMgPSBmcmFtZVN0YXRlLndhbnRlZFRpbGVzW3RpbGVTb3VyY2VLZXldO1xuICAgIGNvbnN0IHRpbGVRdWV1ZSA9IGZyYW1lU3RhdGUudGlsZVF1ZXVlO1xuICAgIGNvbnN0IG1pblpvb20gPSB0aWxlR3JpZC5nZXRNaW5ab29tKCk7XG4gICAgbGV0IHRpbGUsIHRpbGVSYW5nZSwgdGlsZVJlc29sdXRpb24sIHgsIHksIHo7XG4gICAgZm9yICh6ID0gbWluWm9vbTsgeiA8PSBjdXJyZW50WjsgKyt6KSB7XG4gICAgICB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeiwgdGlsZVJhbmdlKTtcbiAgICAgIHRpbGVSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih6KTtcbiAgICAgIGZvciAoeCA9IHRpbGVSYW5nZS5taW5YOyB4IDw9IHRpbGVSYW5nZS5tYXhYOyArK3gpIHtcbiAgICAgICAgZm9yICh5ID0gdGlsZVJhbmdlLm1pblk7IHkgPD0gdGlsZVJhbmdlLm1heFk7ICsreSkge1xuICAgICAgICAgIGlmIChjdXJyZW50WiAtIHogPD0gcHJlbG9hZCkge1xuICAgICAgICAgICAgdGlsZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgICAgd2FudGVkVGlsZXNbdGlsZS5nZXRLZXkoKV0gPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoIXRpbGVRdWV1ZS5pc0tleVF1ZXVlZCh0aWxlLmdldEtleSgpKSkge1xuICAgICAgICAgICAgICAgIHRpbGVRdWV1ZS5lbnF1ZXVlKFt0aWxlLCB0aWxlU291cmNlS2V5LFxuICAgICAgICAgICAgICAgICAgdGlsZUdyaWQuZ2V0VGlsZUNvb3JkQ2VudGVyKHRpbGUudGlsZUNvb3JkKSwgdGlsZVJlc29sdXRpb25dKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdF90aWxlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBvcHRfdGlsZUNhbGxiYWNrLmNhbGwob3B0X3RoaXMsIHRpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWxlU291cmNlLnVzZVRpbGUoeiwgeCwgeSwgcHJvamVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExheWVyUmVuZGVyZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL0xheWVyXG4gKi9cbmltcG9ydCB7YWJzdHJhY3R9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IHtnZXRCb3R0b21MZWZ0LCBnZXRCb3R0b21SaWdodCwgZ2V0VG9wTGVmdCwgZ2V0VG9wUmlnaHR9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnQgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50LmpzJztcbmltcG9ydCBSZW5kZXJFdmVudFR5cGUgZnJvbSAnLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge3JvdGF0ZUF0T2Zmc2V0fSBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzLmpzJztcbmltcG9ydCBDYW52YXNJbW1lZGlhdGVSZW5kZXJlciBmcm9tICcuLi8uLi9yZW5kZXIvY2FudmFzL0ltbWVkaWF0ZS5qcyc7XG5pbXBvcnQgTGF5ZXJSZW5kZXJlciBmcm9tICcuLi9MYXllci5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGFwcGx5IGFzIGFwcGx5VHJhbnNmb3JtLCBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIENhbnZhc0xheWVyUmVuZGVyZXIgZXh0ZW5kcyBMYXllclJlbmRlcmVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxheWVyKSB7XG5cbiAgICBzdXBlcihsYXllcik7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBDbGlwIGV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY2xpcChjb250ZXh0LCBmcmFtZVN0YXRlLCBleHRlbnQpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgIGNvbnN0IHdpZHRoID0gZnJhbWVTdGF0ZS5zaXplWzBdICogcGl4ZWxSYXRpbztcbiAgICBjb25zdCBoZWlnaHQgPSBmcmFtZVN0YXRlLnNpemVbMV0gKiBwaXhlbFJhdGlvO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucm90YXRpb247XG4gICAgY29uc3QgdG9wTGVmdCA9IGdldFRvcExlZnQoZXh0ZW50KTtcbiAgICBjb25zdCB0b3BSaWdodCA9IGdldFRvcFJpZ2h0KGV4dGVudCk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBnZXRCb3R0b21SaWdodChleHRlbnQpO1xuICAgIGNvbnN0IGJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KGV4dGVudCk7XG5cbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BMZWZ0KTtcbiAgICBhcHBseVRyYW5zZm9ybShmcmFtZVN0YXRlLmNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtLCB0b3BSaWdodCk7XG4gICAgYXBwbHlUcmFuc2Zvcm0oZnJhbWVTdGF0ZS5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSwgYm90dG9tUmlnaHQpO1xuICAgIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGJvdHRvbUxlZnQpO1xuXG4gICAgY29udGV4dC5zYXZlKCk7XG4gICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgLXJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8odG9wTGVmdFswXSAqIHBpeGVsUmF0aW8sIHRvcExlZnRbMV0gKiBwaXhlbFJhdGlvKTtcbiAgICBjb250ZXh0LmxpbmVUbyh0b3BSaWdodFswXSAqIHBpeGVsUmF0aW8sIHRvcFJpZ2h0WzFdICogcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5saW5lVG8oYm90dG9tUmlnaHRbMF0gKiBwaXhlbFJhdGlvLCBib3R0b21SaWdodFsxXSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQubGluZVRvKGJvdHRvbUxlZnRbMF0gKiBwaXhlbFJhdGlvLCBib3R0b21MZWZ0WzFdICogcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5jbGlwKCk7XG4gICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgcm90YXRpb24sIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvRXZlbnRUeXBlLmpzXCIpLmRlZmF1bHR9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgQ29udGV4dC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtPX0gb3B0X3RyYW5zZm9ybSBUcmFuc2Zvcm0uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaENvbXBvc2VFdmVudF8odHlwZSwgY29udGV4dCwgZnJhbWVTdGF0ZSwgb3B0X3RyYW5zZm9ybSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGlmIChsYXllci5oYXNMaXN0ZW5lcih0eXBlKSkge1xuICAgICAgY29uc3Qgd2lkdGggPSBmcmFtZVN0YXRlLnNpemVbMF0gKiBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgICBjb25zdCBoZWlnaHQgPSBmcmFtZVN0YXRlLnNpemVbMV0gKiBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgICBjb25zdCByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgLXJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gb3B0X3RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgb3B0X3RyYW5zZm9ybSA6IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIDApO1xuICAgICAgY29uc3QgcmVuZGVyID0gbmV3IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyKFxuICAgICAgICBjb250ZXh0LCBmcmFtZVN0YXRlLnBpeGVsUmF0aW8sIGZyYW1lU3RhdGUuZXh0ZW50LCB0cmFuc2Zvcm0sXG4gICAgICAgIGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IGNvbXBvc2VFdmVudCA9IG5ldyBSZW5kZXJFdmVudCh0eXBlLCByZW5kZXIsIGZyYW1lU3RhdGUsXG4gICAgICAgIGNvbnRleHQsIG51bGwpO1xuICAgICAgbGF5ZXIuZGlzcGF0Y2hFdmVudChjb21wb3NlRXZlbnQpO1xuICAgICAgcm90YXRlQXRPZmZzZXQoY29udGV4dCwgcm90YXRpb24sIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0LCAoVWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheSkpOiBUfSBjYWxsYmFjayBMYXllclxuICAgKiAgICAgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBTLFQsVVxuICAgKi9cbiAgZm9yRWFjaExheWVyQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBjb25zdCBoYXNGZWF0dXJlID0gdGhpcy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIFRSVUUpO1xuXG4gICAgaWYgKGhhc0ZlYXR1cmUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0TGF5ZXIoKSwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybT19IG9wdF90cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwb3N0Q29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBvcHRfdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5kaXNwYXRjaENvbXBvc2VFdmVudF8oUmVuZGVyRXZlbnRUeXBlLlBPU1RDT01QT1NFLCBjb250ZXh0LCBmcmFtZVN0YXRlLCBvcHRfdHJhbnNmb3JtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm09fSBvcHRfdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJlQ29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlLCBvcHRfdHJhbnNmb3JtKSB7XG4gICAgdGhpcy5kaXNwYXRjaENvbXBvc2VFdmVudF8oUmVuZGVyRXZlbnRUeXBlLlBSRUNPTVBPU0UsIGNvbnRleHQsIGZyYW1lU3RhdGUsIG9wdF90cmFuc2Zvcm0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybT19IG9wdF90cmFuc2Zvcm0gVHJhbnNmb3JtLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50KGNvbnRleHQsIGZyYW1lU3RhdGUsIG9wdF90cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRpc3BhdGNoQ29tcG9zZUV2ZW50XyhSZW5kZXJFdmVudFR5cGUuUkVOREVSLCBjb250ZXh0LCBmcmFtZVN0YXRlLCBvcHRfdHJhbnNmb3JtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCBPZmZzZXQgb24gdGhlIHgtYXhpcyBpbiB2aWV3IGNvb3JkaW5hdGVzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBUcmFuc2Zvcm0uXG4gICAqL1xuICBnZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgb2Zmc2V0WCkge1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3QgZHgxID0gcGl4ZWxSYXRpbyAqIGZyYW1lU3RhdGUuc2l6ZVswXSAvIDI7XG4gICAgY29uc3QgZHkxID0gcGl4ZWxSYXRpbyAqIGZyYW1lU3RhdGUuc2l6ZVsxXSAvIDI7XG4gICAgY29uc3Qgc3ggPSBwaXhlbFJhdGlvIC8gdmlld1N0YXRlLnJlc29sdXRpb247XG4gICAgY29uc3Qgc3kgPSAtc3g7XG4gICAgY29uc3QgYW5nbGUgPSAtdmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGNvbnN0IGR4MiA9IC12aWV3U3RhdGUuY2VudGVyWzBdICsgb2Zmc2V0WDtcbiAgICBjb25zdCBkeTIgPSAtdmlld1N0YXRlLmNlbnRlclsxXTtcbiAgICByZXR1cm4gY29tcG9zZVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybV8sIGR4MSwgZHkxLCBzeCwgc3ksIGFuZ2xlLCBkeDIsIGR5Mik7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0IENvbnRleHQuXG4gICAqL1xuICBjb21wb3NlRnJhbWUoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgY29udGV4dCkge1xuICAgIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGV9IGxheWVyU3RhdGUgTGF5ZXIgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgY29tcG9zZUZyYW1lIHNob3VsZCBiZSBjYWxsZWQuXG4gICAqL1xuICBwcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc0xheWVyUmVuZGVyZXI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFLQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBOzs7Ozs7QUFNQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBakJBO0FBbUJBOzs7Ozs7Ozs7Ozs7QUFXQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTs7Ozs7Ozs7OztBQVNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBO0FBWUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXJPQTtBQUNBO0FBc09BOzs7OztBQ2xQQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQUE7QUFBQTtBQUtBO0FBRUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQTFLQTtBQUNBO0FBMktBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///101\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _2 = _interopRequireDefault(__webpack_require__(40));\n\nvar _Container = _interopRequireDefault(__webpack_require__(69));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/Choice\r\n */\n\n/**\r\n * @desc Class for creating checkbox and radio input widgets\r\n * @public\r\n * @class\r\n * @extends {module:nyc/Container~Container}\r\n * @fires module:nyc/Choice~Choice#change\r\n */\n\n\nvar Choice =\n/*#__PURE__*/\nfunction (_Container$default) {\n  _inherits(Choice, _Container$default);\n\n  /**\r\n   * @desc Create an instance of Choice\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/Choice~Choice.Options} options Choice options\r\n   */\n  function Choice(options) {\n    var _this;\n\n    _classCallCheck(this, Choice);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Choice).call(this, options.target));\n\n    _this.getContainer().addClass(\'chc rad-all\');\n    /**\r\n     * @private\r\n     * @member {boolean}\r\n     */\n\n\n    _this.radio = options.radio;\n    /**\r\n     * @private\r\n     * @member {Array<JQuery>}\r\n     */\n\n    _this.inputs = null;\n    /**\r\n     * @private\r\n     * @member {Array<module:nyc/Choice~Choice.Choice>}\r\n     */\n\n    _this.choices = options.choices;\n\n    _this.setChoices(_this.choices);\n\n    return _this;\n  }\n  /**\r\n   * @desc Set the available choices\r\n   * @public\r\n   * @method\r\n   * @param {Array<module:nyc/Choice~Choice.Choice>} choices The choices\r\n   */\n\n\n  _createClass(Choice, [{\n    key: "setChoices",\n    value: function setChoices(choices) {\n      var _this2 = this;\n\n      var type = \'checkbox\';\n\n      if (this.radio) {\n        this.getContainer().attr(\'role\', \'radiogroup\');\n        type = \'radio\';\n      } else {\n        this.getContainer().attr(\'role\', \'group\');\n      }\n\n      this.getContainer().empty();\n      choices.forEach(function (choice, i) {\n        var div = (0, _jquery["default"])(Choice.HTML);\n\n        var id = _2["default"].nextId(\'chc-chc\');\n\n        var input = div.find(\'input\');\n        div.addClass(_this2.radio ? "".concat(choice.name, "-").concat(i) : choice.name);\n        input.attr({\n          id: id,\n          name: choice.name,\n          type: type,\n          role: type,\n          \'aria-checked\': choice.checked === true\n        }).prop(\'checked\', choice.checked === true).data(\'choice\', choice).change(_jquery["default"].proxy(_this2.change, _this2));\n        div.find(\'label\').html(choice.label).attr(\'for\', id);\n\n        _this2.append(div);\n\n        _this2.extend(choice);\n      });\n      this.inputs = this.find(\'input\');\n    }\n    /**\r\n     * @desc Get or set the seleced choices\r\n     * @public\r\n     * @method\r\n     * @param {Array<module:nyc/Choice~Choice.Choice>} choices The choices\r\n     * @return {Array} Chosen options\r\n     */\n\n  }, {\n    key: "val",\n    value: function val(choices) {\n      var _this3 = this;\n\n      if (choices) {\n        choices.forEach(function (choice) {\n          _this3.extend(choice);\n        });\n\n        _jquery["default"].each(this.inputs, function (_, input) {\n          (0, _jquery["default"])(input).prop(\'checked\', false);\n          choices.some(function (chosen) {\n            var choice = (0, _jquery["default"])(input).data(\'choice\');\n\n            if (chosen.eq(choice)) {\n              (0, _jquery["default"])(input).prop(\'checked\', true);\n              return true;\n            }\n          });\n        });\n\n        return this.val();\n      } else {\n        var chosen = [];\n\n        _jquery["default"].each(this.inputs, function (_, input) {\n          if ((0, _jquery["default"])(input).prop(\'checked\')) {\n            chosen.push((0, _jquery["default"])(input).data(\'choice\'));\n          }\n        });\n\n        return chosen;\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: "change",\n    value: function change(event) {\n      _jquery["default"].each(this.inputs, function (_, input) {\n        (0, _jquery["default"])(input).attr(\'aria-checked\', (0, _jquery["default"])(input).prop(\'checked\'));\n      });\n\n      this.trigger(\'change\', this);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {module:nyc/Choice~Choice.Choice} choice Choice\r\n     */\n\n  }, {\n    key: "extend",\n    value: function extend(choice) {\n      _jquery["default"].extend(choice, {\n        eq: function eq(another) {\n          return this.name === another.name && this.label === another.label && JSON.stringify(this.value) === JSON.stringify(another.value);\n        }\n      });\n    }\n  }]);\n\n  return Choice;\n}(_Container["default"]);\n/**\r\n * @desc A choice for {@link module:nyc/Choice~Choice}\r\n * @public\r\n * @typedef {Object}\r\n * @property {string} name The name for the choice\r\n * @property {string} label The label for the choice\r\n * @property {Array<Object>} value The value of the choice\r\n * @property {boolean} [checked=false] The value of the checked state of the choice\r\n */\n\n\nChoice.Choice;\n/**\r\n * @desc Constructor options for {@link module:nyc/Choice~Choice}\r\n * @public\r\n * @typedef {Object}\r\n * @property {jQuery|Element|string} target The target DOM node for creating the choice control\r\n * @property {Array<module:nyc/Choice~Choice.Choice>} choices The choices\r\n * @property {boolean} [radio=false] Checkbox or radio button\r\n */\n\nChoice.Options;\n/**\r\n * @desc The change event\r\n * @event module:nyc/Choice~Choice#change\r\n * @type {module:nyc/Choice~Choice}\r\n */\n\n/**\r\n  * @private\r\n  * @const\r\n  * @type {string}\r\n  */\n\nChoice.HTML = \'<div class="chc-chc"><input><label></label></div>\';\nvar _default = Choice;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0Nob2ljZS5qcz9mNjJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbnZhciBfMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vXCIpKTtcblxudmFyIF9Db250YWluZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9DaG9pY2VcclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBDbGFzcyBmb3IgY3JlYXRpbmcgY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0IHdpZGdldHNcclxuICogQHB1YmxpY1xyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMge21vZHVsZTpueWMvQ29udGFpbmVyfkNvbnRhaW5lcn1cclxuICogQGZpcmVzIG1vZHVsZTpueWMvQ2hvaWNlfkNob2ljZSNjaGFuZ2VcclxuICovXG5jbGFzcyBDaG9pY2UgZXh0ZW5kcyBfQ29udGFpbmVyLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQ2hvaWNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9DaG9pY2V+Q2hvaWNlLk9wdGlvbnN9IG9wdGlvbnMgQ2hvaWNlIG9wdGlvbnNcclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMudGFyZ2V0KTtcbiAgICB0aGlzLmdldENvbnRhaW5lcigpLmFkZENsYXNzKCdjaGMgcmFkLWFsbCcpO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cblxuICAgIHRoaXMucmFkaW8gPSBvcHRpb25zLnJhZGlvO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge0FycmF5PEpRdWVyeT59XHJcbiAgICAgKi9cblxuICAgIHRoaXMuaW5wdXRzID0gbnVsbDtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtBcnJheTxtb2R1bGU6bnljL0Nob2ljZX5DaG9pY2UuQ2hvaWNlPn1cclxuICAgICAqL1xuXG4gICAgdGhpcy5jaG9pY2VzID0gb3B0aW9ucy5jaG9pY2VzO1xuICAgIHRoaXMuc2V0Q2hvaWNlcyh0aGlzLmNob2ljZXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFNldCB0aGUgYXZhaWxhYmxlIGNob2ljZXNcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7QXJyYXk8bW9kdWxlOm55Yy9DaG9pY2V+Q2hvaWNlLkNob2ljZT59IGNob2ljZXMgVGhlIGNob2ljZXNcclxuICAgKi9cblxuXG4gIHNldENob2ljZXMoY2hvaWNlcykge1xuICAgIGxldCB0eXBlID0gJ2NoZWNrYm94JztcblxuICAgIGlmICh0aGlzLnJhZGlvKSB7XG4gICAgICB0aGlzLmdldENvbnRhaW5lcigpLmF0dHIoJ3JvbGUnLCAncmFkaW9ncm91cCcpO1xuICAgICAgdHlwZSA9ICdyYWRpbyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuYXR0cigncm9sZScsICdncm91cCcpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuZW1wdHkoKTtcbiAgICBjaG9pY2VzLmZvckVhY2goKGNob2ljZSwgaSkgPT4ge1xuICAgICAgY29uc3QgZGl2ID0gKDAsIF9qcXVlcnkuZGVmYXVsdCkoQ2hvaWNlLkhUTUwpO1xuXG4gICAgICBjb25zdCBpZCA9IF8yLmRlZmF1bHQubmV4dElkKCdjaGMtY2hjJyk7XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gZGl2LmZpbmQoJ2lucHV0Jyk7XG4gICAgICBkaXYuYWRkQ2xhc3ModGhpcy5yYWRpbyA/IGAke2Nob2ljZS5uYW1lfS0ke2l9YCA6IGNob2ljZS5uYW1lKTtcbiAgICAgIGlucHV0LmF0dHIoe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIG5hbWU6IGNob2ljZS5uYW1lLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICByb2xlOiB0eXBlLFxuICAgICAgICAnYXJpYS1jaGVja2VkJzogY2hvaWNlLmNoZWNrZWQgPT09IHRydWVcbiAgICAgIH0pLnByb3AoJ2NoZWNrZWQnLCBjaG9pY2UuY2hlY2tlZCA9PT0gdHJ1ZSkuZGF0YSgnY2hvaWNlJywgY2hvaWNlKS5jaGFuZ2UoX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMuY2hhbmdlLCB0aGlzKSk7XG4gICAgICBkaXYuZmluZCgnbGFiZWwnKS5odG1sKGNob2ljZS5sYWJlbCkuYXR0cignZm9yJywgaWQpO1xuICAgICAgdGhpcy5hcHBlbmQoZGl2KTtcbiAgICAgIHRoaXMuZXh0ZW5kKGNob2ljZSk7XG4gICAgfSk7XG4gICAgdGhpcy5pbnB1dHMgPSB0aGlzLmZpbmQoJ2lucHV0Jyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgR2V0IG9yIHNldCB0aGUgc2VsZWNlZCBjaG9pY2VzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge0FycmF5PG1vZHVsZTpueWMvQ2hvaWNlfkNob2ljZS5DaG9pY2U+fSBjaG9pY2VzIFRoZSBjaG9pY2VzXHJcbiAgICogQHJldHVybiB7QXJyYXl9IENob3NlbiBvcHRpb25zXHJcbiAgICovXG5cblxuICB2YWwoY2hvaWNlcykge1xuICAgIGlmIChjaG9pY2VzKSB7XG4gICAgICBjaG9pY2VzLmZvckVhY2goY2hvaWNlID0+IHtcbiAgICAgICAgdGhpcy5leHRlbmQoY2hvaWNlKTtcbiAgICAgIH0pO1xuXG4gICAgICBfanF1ZXJ5LmRlZmF1bHQuZWFjaCh0aGlzLmlucHV0cywgKF8sIGlucHV0KSA9PiB7XG4gICAgICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGlucHV0KS5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xuICAgICAgICBjaG9pY2VzLnNvbWUoY2hvc2VuID0+IHtcbiAgICAgICAgICBjb25zdCBjaG9pY2UgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KShpbnB1dCkuZGF0YSgnY2hvaWNlJyk7XG5cbiAgICAgICAgICBpZiAoY2hvc2VuLmVxKGNob2ljZSkpIHtcbiAgICAgICAgICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGlucHV0KS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnZhbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaG9zZW4gPSBbXTtcblxuICAgICAgX2pxdWVyeS5kZWZhdWx0LmVhY2godGhpcy5pbnB1dHMsIChfLCBpbnB1dCkgPT4ge1xuICAgICAgICBpZiAoKDAsIF9qcXVlcnkuZGVmYXVsdCkoaW5wdXQpLnByb3AoJ2NoZWNrZWQnKSkge1xuICAgICAgICAgIGNob3Nlbi5wdXNoKCgwLCBfanF1ZXJ5LmRlZmF1bHQpKGlucHV0KS5kYXRhKCdjaG9pY2UnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY2hvc2VuO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XHJcbiAgICovXG5cblxuICBjaGFuZ2UoZXZlbnQpIHtcbiAgICBfanF1ZXJ5LmRlZmF1bHQuZWFjaCh0aGlzLmlucHV0cywgKF8sIGlucHV0KSA9PiB7XG4gICAgICAoMCwgX2pxdWVyeS5kZWZhdWx0KShpbnB1dCkuYXR0cignYXJpYS1jaGVja2VkJywgKDAsIF9qcXVlcnkuZGVmYXVsdCkoaW5wdXQpLnByb3AoJ2NoZWNrZWQnKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9DaG9pY2V+Q2hvaWNlLkNob2ljZX0gY2hvaWNlIENob2ljZVxyXG4gICAqL1xuXG5cbiAgZXh0ZW5kKGNob2ljZSkge1xuICAgIF9qcXVlcnkuZGVmYXVsdC5leHRlbmQoY2hvaWNlLCB7XG4gICAgICBlcShhbm90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT09IGFub3RoZXIubmFtZSAmJiB0aGlzLmxhYmVsID09PSBhbm90aGVyLmxhYmVsICYmIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpID09PSBKU09OLnN0cmluZ2lmeShhbm90aGVyLnZhbHVlKTtcbiAgICAgIH1cblxuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBAZGVzYyBBIGNob2ljZSBmb3Ige0BsaW5rIG1vZHVsZTpueWMvQ2hvaWNlfkNob2ljZX1cclxuICogQHB1YmxpY1xyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBmb3IgdGhlIGNob2ljZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFiZWwgVGhlIGxhYmVsIGZvciB0aGUgY2hvaWNlXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8T2JqZWN0Pn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjaG9pY2VcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2hlY2tlZD1mYWxzZV0gVGhlIHZhbHVlIG9mIHRoZSBjaGVja2VkIHN0YXRlIG9mIHRoZSBjaG9pY2VcclxuICovXG5cblxuQ2hvaWNlLkNob2ljZTtcbi8qKlxyXG4gKiBAZGVzYyBDb25zdHJ1Y3RvciBvcHRpb25zIGZvciB7QGxpbmsgbW9kdWxlOm55Yy9DaG9pY2V+Q2hvaWNlfVxyXG4gKiBAcHVibGljXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGhlIHRhcmdldCBET00gbm9kZSBmb3IgY3JlYXRpbmcgdGhlIGNob2ljZSBjb250cm9sXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bW9kdWxlOm55Yy9DaG9pY2V+Q2hvaWNlLkNob2ljZT59IGNob2ljZXMgVGhlIGNob2ljZXNcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmFkaW89ZmFsc2VdIENoZWNrYm94IG9yIHJhZGlvIGJ1dHRvblxyXG4gKi9cblxuQ2hvaWNlLk9wdGlvbnM7XG4vKipcclxuICogQGRlc2MgVGhlIGNoYW5nZSBldmVudFxyXG4gKiBAZXZlbnQgbW9kdWxlOm55Yy9DaG9pY2V+Q2hvaWNlI2NoYW5nZVxyXG4gKiBAdHlwZSB7bW9kdWxlOm55Yy9DaG9pY2V+Q2hvaWNlfVxyXG4gKi9cblxuLyoqXHJcbiAgKiBAcHJpdmF0ZVxyXG4gICogQGNvbnN0XHJcbiAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICovXG5cbkNob2ljZS5IVE1MID0gJzxkaXYgY2xhc3M9XCJjaGMtY2hjXCI+PGlucHV0PjxsYWJlbD48L2xhYmVsPjwvZGl2Pic7XG52YXIgX2RlZmF1bHQgPSBDaG9pY2U7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBSUE7Ozs7Ozs7OztBQU9BOzs7OztBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQXRCQTtBQXNCQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTs7OztBQXpJQTtBQTRJQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///102\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _EventHandling = _interopRequireDefault(__webpack_require__(64));\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/Locator\r\n */\n\n\nvar proj4 = _["default"].proj4;\n/**\r\n * @desc An abstract class for geocoding and geolocating\r\n * @public\r\n * @abstract\r\n * @class\r\n * @extends {module:nyc/EventHandling~EventHandling}\r\n * @fires module:nyc/Locator~Locator#geocoded\r\n * @fires module:nyc/Locator~Locator#geolocated\r\n * @fires module:nyc/Locator~Locator#ambiguous\r\n * @fires module:nyc/Locator~Locator#error\r\n */\n\nvar Locator =\n/*#__PURE__*/\nfunction (_EventHandling$defaul) {\n  _inherits(Locator, _EventHandling$defaul);\n\n  /**\r\n   * @desc Creates an instance of Locator\r\n   * @access protected\r\n   * @param {module:nyc/Locator~Locator.Options} options Construction options\r\n   */\n  function Locator(options) {\n    var _this;\n\n    _classCallCheck(this, Locator);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Locator).call(this));\n    /**\r\n     * @desc The geocder\r\n     * @public\r\n     * @member {module:nyc/Geocoder~Geocoder}\r\n     */\n\n    _this.geocoder = options.geocoder;\n    /**\r\n     * @desc The epsg code\r\n     * @public\r\n     * @member {string}\r\n     */\n\n    _this.projection = options.projection || \'EPSG:3857\';\n\n    _this.hookupEvents();\n\n    return _this;\n  }\n  /**\r\n   * @desc Get a distance for an accuracy enumerator based on the projections\r\n   * @public\r\n   * @method\r\n   * @return {number} The meters per map unit\r\n   */\n\n\n  _createClass(Locator, [{\n    key: "metersPerUnit",\n    value: function metersPerUnit() {\n      return proj4.defs[this.projection].to_meter;\n    }\n    /**\r\n     * @desc Get a distance for an accuracy enumerator based on the Locator projection\r\n     * @access protected\r\n     * @method\r\n     * @param {module:nyc/Locator~Locator.Accuracy} accuracy Locator accuracy\r\n     * @return {number} The accurcy in map units\r\n     */\n\n  }, {\n    key: "accuracyDistance",\n    value: function accuracyDistance(accuracy) {\n      if (this.projection === \'EPSG:3857\') {\n        return accuracy;\n      }\n\n      return accuracy / this.metersPerUnit();\n    }\n    /**\r\n     * @desc Geocode an input string representing a location\r\n     * @public\r\n     * @abstract\r\n     * @method\r\n     * @param {string} input The value to geocode\r\n     */\n\n  }, {\n    key: "search",\n    value: function search(input) {\n      this.geocoder.search(input);\n    }\n    /**\r\n     * @desc Locate once using device geolocation\r\n      * @public\r\n      * @abstract\r\n      * @method\r\n      */\n\n  }, {\n    key: "locate",\n    value: function locate() {\n      throw \'Not implemented\';\n    }\n    /**\r\n     * @desc Track using device geolocation\r\n     * @public\r\n     * @abstract\r\n     * @method\r\n     * @param {boolean} track Track or not\r\n     */\n\n  }, {\n    key: "track",\n    value: function track() {\n      throw \'Not implemented\';\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} event The event object\r\n     */\n\n  }, {\n    key: "proxyEvent",\n    value: function proxyEvent(event) {\n      this.trigger(event.type, event);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "hookupEvents",\n    value: function hookupEvents() {\n      this.geocoder.on(\'geocoded\', this.proxyEvent, this);\n      this.geocoder.on(\'ambiguous\', this.proxyEvent, this);\n      this.geocoder.on(\'error\', this.proxyEvent, this);\n    }\n  }]);\n\n  return Locator;\n}(_EventHandling["default"]);\n/**\r\n * @desc Constructor options for {@link module:nyc/Locator~Locator}\r\n * @public\r\n * @typedef {Object}\r\n * @property {module:nyc/Geocoder~Geocoder} geocoder A geocoder\r\n * @property {string} [projection=EPSG:3857] The EPSG code of the projection for output geometries (i.e. EPSG:2263)\r\n */\n\n\nLocator.Options;\n/**\r\n * @desc Enumeration for approximate Geocoder accuracy in meters\r\n * @public\r\n * @enum {number}\r\n */\n\nLocator.Accuracy = {\n  /**\r\n   * @desc High accuracy\r\n   */\n  HIGH: 0,\n\n  /**\r\n   * @desc Medium accuracy\r\n   */\n  MEDIUM: 50,\n\n  /**\r\n   * @desc Low accuracy\r\n   */\n  LOW: 500,\n\n  /**\r\n   * @desc ZIP Code accuracy\r\n   */\n  ZIP_CODE: 1000\n  /**\r\n   * @desc Object type to hold data about a successful result of a geocoder search or device geolocation\r\n   * @public\r\n   * @typedef {Object}\r\n   * @property {string} name The formatted name of the geocoded location\r\n   * @property {string} type The event type\r\n   * @property {(Array<number>|undefined)} coordinate The geocoded location coordinate\r\n   * @property {number} accuracy The accuracy of the geocoded location in meters or units of a specified projection\r\n   * @property {string} type They type of result (geocoded or geolocated)\r\n   * @property {boolean=} zip Is this the geocoded location a ZIP Code center point\r\n   * @property {Object=} geometry A geoJSON representation of the geocoded location coordinates\r\n   * @property {Object=} data Additional properties provided by the geocoder\r\n   */\n\n};\nLocator.Result;\n/**\r\n * @desc Object type to hold data about possible locations resulting from a search request\r\n * @public\r\n * @typedef {Object}\r\n * @property {string} input The input string on which the geocoding attempt was made\r\n * @property {string} type The event type\r\n * @property {Array<module:nyc/Locator~Locator.Result>} possible An array of possible results to the request\r\n */\n\nLocator.Ambiguous;\n/**\r\n * @desc The result of a search request\r\n * @event module:nyc/Locator~Locator#geocoded\r\n * @type {module:nyc/Locator~Locator.Location}\r\n */\n\n/**\r\n * @desc The result of a locate request\r\n * @event module:nyc/Locator~Locator#geolocated\r\n * @type {module:nyc/Locator~Locator.Location}\r\n */\n\n/**\r\n * @desc The result of an inconclusive search request\r\n * @event module:nyc/Locator~Locator#ambiguous\r\n * @type {module:nyc/Locator~Locator.Ambiguous}\r\n */\n\n/**\r\n * @desc The error object from a locate request error\r\n * @event module:nyc/Locator~Locator#error\r\n * @type {Object}\r\n */\n\nvar _default = Locator;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0xvY2F0b3IuanM/NTIyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9FdmVudEhhbmRsaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9FdmVudEhhbmRsaW5nXCIpKTtcblxudmFyIF8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9Mb2NhdG9yXHJcbiAqL1xuY29uc3QgcHJvajQgPSBfLmRlZmF1bHQucHJvajQ7XG4vKipcclxuICogQGRlc2MgQW4gYWJzdHJhY3QgY2xhc3MgZm9yIGdlb2NvZGluZyBhbmQgZ2VvbG9jYXRpbmdcclxuICogQHB1YmxpY1xyXG4gKiBAYWJzdHJhY3RcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIHttb2R1bGU6bnljL0V2ZW50SGFuZGxpbmd+RXZlbnRIYW5kbGluZ31cclxuICogQGZpcmVzIG1vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yI2dlb2NvZGVkXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNnZW9sb2NhdGVkXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNhbWJpZ3VvdXNcclxuICogQGZpcmVzIG1vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yI2Vycm9yXHJcbiAqL1xuXG5jbGFzcyBMb2NhdG9yIGV4dGVuZHMgX0V2ZW50SGFuZGxpbmcuZGVmYXVsdCB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTG9jYXRvclxyXG4gICAqIEBhY2Nlc3MgcHJvdGVjdGVkXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5PcHRpb25zfSBvcHRpb25zIENvbnN0cnVjdGlvbiBvcHRpb25zXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxyXG4gICAgICogQGRlc2MgVGhlIGdlb2NkZXJcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBtZW1iZXIge21vZHVsZTpueWMvR2VvY29kZXJ+R2VvY29kZXJ9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuZ2VvY29kZXIgPSBvcHRpb25zLmdlb2NvZGVyO1xuICAgIC8qKlxyXG4gICAgICogQGRlc2MgVGhlIGVwc2cgY29kZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXG5cbiAgICB0aGlzLnByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gfHwgJ0VQU0c6Mzg1Nyc7XG4gICAgdGhpcy5ob29rdXBFdmVudHMoKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBHZXQgYSBkaXN0YW5jZSBmb3IgYW4gYWNjdXJhY3kgZW51bWVyYXRvciBiYXNlZCBvbiB0aGUgcHJvamVjdGlvbnNcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1ldGVycyBwZXIgbWFwIHVuaXRcclxuICAgKi9cblxuXG4gIG1ldGVyc1BlclVuaXQoKSB7XG4gICAgcmV0dXJuIHByb2o0LmRlZnNbdGhpcy5wcm9qZWN0aW9uXS50b19tZXRlcjtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBHZXQgYSBkaXN0YW5jZSBmb3IgYW4gYWNjdXJhY3kgZW51bWVyYXRvciBiYXNlZCBvbiB0aGUgTG9jYXRvciBwcm9qZWN0aW9uXHJcbiAgICogQGFjY2VzcyBwcm90ZWN0ZWRcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5BY2N1cmFjeX0gYWNjdXJhY3kgTG9jYXRvciBhY2N1cmFjeVxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFjY3VyY3kgaW4gbWFwIHVuaXRzXHJcbiAgICovXG5cblxuICBhY2N1cmFjeURpc3RhbmNlKGFjY3VyYWN5KSB7XG4gICAgaWYgKHRoaXMucHJvamVjdGlvbiA9PT0gJ0VQU0c6Mzg1NycpIHtcbiAgICAgIHJldHVybiBhY2N1cmFjeTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjdXJhY3kgLyB0aGlzLm1ldGVyc1BlclVuaXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBHZW9jb2RlIGFuIGlucHV0IHN0cmluZyByZXByZXNlbnRpbmcgYSBsb2NhdGlvblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSB2YWx1ZSB0byBnZW9jb2RlXHJcbiAgICovXG5cblxuICBzZWFyY2goaW5wdXQpIHtcbiAgICB0aGlzLmdlb2NvZGVyLnNlYXJjaChpbnB1dCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgTG9jYXRlIG9uY2UgdXNpbmcgZGV2aWNlIGdlb2xvY2F0aW9uXHJcbiAgICAqIEBwdWJsaWNcclxuICAgICogQGFic3RyYWN0XHJcbiAgICAqIEBtZXRob2RcclxuICAgICovXG5cblxuICBsb2NhdGUoKSB7XG4gICAgdGhyb3cgJ05vdCBpbXBsZW1lbnRlZCc7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgVHJhY2sgdXNpbmcgZGV2aWNlIGdlb2xvY2F0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYWNrIFRyYWNrIG9yIG5vdFxyXG4gICAqL1xuXG5cbiAgdHJhY2soKSB7XG4gICAgdGhyb3cgJ05vdCBpbXBsZW1lbnRlZCc7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBldmVudCBvYmplY3RcclxuICAgKi9cblxuXG4gIHByb3h5RXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIoZXZlbnQudHlwZSwgZXZlbnQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqL1xuXG5cbiAgaG9va3VwRXZlbnRzKCkge1xuICAgIHRoaXMuZ2VvY29kZXIub24oJ2dlb2NvZGVkJywgdGhpcy5wcm94eUV2ZW50LCB0aGlzKTtcbiAgICB0aGlzLmdlb2NvZGVyLm9uKCdhbWJpZ3VvdXMnLCB0aGlzLnByb3h5RXZlbnQsIHRoaXMpO1xuICAgIHRoaXMuZ2VvY29kZXIub24oJ2Vycm9yJywgdGhpcy5wcm94eUV2ZW50LCB0aGlzKTtcbiAgfVxuXG59XG4vKipcclxuICogQGRlc2MgQ29uc3RydWN0b3Igb3B0aW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yfVxyXG4gKiBAcHVibGljXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm55Yy9HZW9jb2Rlcn5HZW9jb2Rlcn0gZ2VvY29kZXIgQSBnZW9jb2RlclxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Byb2plY3Rpb249RVBTRzozODU3XSBUaGUgRVBTRyBjb2RlIG9mIHRoZSBwcm9qZWN0aW9uIGZvciBvdXRwdXQgZ2VvbWV0cmllcyAoaS5lLiBFUFNHOjIyNjMpXHJcbiAqL1xuXG5cbkxvY2F0b3IuT3B0aW9ucztcbi8qKlxyXG4gKiBAZGVzYyBFbnVtZXJhdGlvbiBmb3IgYXBwcm94aW1hdGUgR2VvY29kZXIgYWNjdXJhY3kgaW4gbWV0ZXJzXHJcbiAqIEBwdWJsaWNcclxuICogQGVudW0ge251bWJlcn1cclxuICovXG5cbkxvY2F0b3IuQWNjdXJhY3kgPSB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIEhpZ2ggYWNjdXJhY3lcclxuICAgKi9cbiAgSElHSDogMCxcblxuICAvKipcclxuICAgKiBAZGVzYyBNZWRpdW0gYWNjdXJhY3lcclxuICAgKi9cbiAgTUVESVVNOiA1MCxcblxuICAvKipcclxuICAgKiBAZGVzYyBMb3cgYWNjdXJhY3lcclxuICAgKi9cbiAgTE9XOiA1MDAsXG5cbiAgLyoqXHJcbiAgICogQGRlc2MgWklQIENvZGUgYWNjdXJhY3lcclxuICAgKi9cbiAgWklQX0NPREU6IDEwMDBcbiAgLyoqXHJcbiAgICogQGRlc2MgT2JqZWN0IHR5cGUgdG8gaG9sZCBkYXRhIGFib3V0IGEgc3VjY2Vzc2Z1bCByZXN1bHQgb2YgYSBnZW9jb2RlciBzZWFyY2ggb3IgZGV2aWNlIGdlb2xvY2F0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9XHJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIGZvcm1hdHRlZCBuYW1lIG9mIHRoZSBnZW9jb2RlZCBsb2NhdGlvblxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlXHJcbiAgICogQHByb3BlcnR5IHsoQXJyYXk8bnVtYmVyPnx1bmRlZmluZWQpfSBjb29yZGluYXRlIFRoZSBnZW9jb2RlZCBsb2NhdGlvbiBjb29yZGluYXRlXHJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFjY3VyYWN5IFRoZSBhY2N1cmFjeSBvZiB0aGUgZ2VvY29kZWQgbG9jYXRpb24gaW4gbWV0ZXJzIG9yIHVuaXRzIG9mIGEgc3BlY2lmaWVkIHByb2plY3Rpb25cclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBUaGV5IHR5cGUgb2YgcmVzdWx0IChnZW9jb2RlZCBvciBnZW9sb2NhdGVkKVxyXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbj19IHppcCBJcyB0aGlzIHRoZSBnZW9jb2RlZCBsb2NhdGlvbiBhIFpJUCBDb2RlIGNlbnRlciBwb2ludFxyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0PX0gZ2VvbWV0cnkgQSBnZW9KU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnZW9jb2RlZCBsb2NhdGlvbiBjb29yZGluYXRlc1xyXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0PX0gZGF0YSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgcHJvdmlkZWQgYnkgdGhlIGdlb2NvZGVyXHJcbiAgICovXG5cbn07XG5Mb2NhdG9yLlJlc3VsdDtcbi8qKlxyXG4gKiBAZGVzYyBPYmplY3QgdHlwZSB0byBob2xkIGRhdGEgYWJvdXQgcG9zc2libGUgbG9jYXRpb25zIHJlc3VsdGluZyBmcm9tIGEgc2VhcmNoIHJlcXVlc3RcclxuICogQHB1YmxpY1xyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW5wdXQgVGhlIGlucHV0IHN0cmluZyBvbiB3aGljaCB0aGUgZ2VvY29kaW5nIGF0dGVtcHQgd2FzIG1hZGVcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGVcclxuICogQHByb3BlcnR5IHtBcnJheTxtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5SZXN1bHQ+fSBwb3NzaWJsZSBBbiBhcnJheSBvZiBwb3NzaWJsZSByZXN1bHRzIHRvIHRoZSByZXF1ZXN0XHJcbiAqL1xuXG5Mb2NhdG9yLkFtYmlndW91cztcbi8qKlxyXG4gKiBAZGVzYyBUaGUgcmVzdWx0IG9mIGEgc2VhcmNoIHJlcXVlc3RcclxuICogQGV2ZW50IG1vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yI2dlb2NvZGVkXHJcbiAqIEB0eXBlIHttb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5Mb2NhdGlvbn1cclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBUaGUgcmVzdWx0IG9mIGEgbG9jYXRlIHJlcXVlc3RcclxuICogQGV2ZW50IG1vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yI2dlb2xvY2F0ZWRcclxuICogQHR5cGUge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLkxvY2F0aW9ufVxyXG4gKi9cblxuLyoqXHJcbiAqIEBkZXNjIFRoZSByZXN1bHQgb2YgYW4gaW5jb25jbHVzaXZlIHNlYXJjaCByZXF1ZXN0XHJcbiAqIEBldmVudCBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNhbWJpZ3VvdXNcclxuICogQHR5cGUge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLkFtYmlndW91c31cclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBUaGUgZXJyb3Igb2JqZWN0IGZyb20gYSBsb2NhdGUgcmVxdWVzdCBlcnJvclxyXG4gKiBAZXZlbnQgbW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IjZXJyb3JcclxuICogQHR5cGUge09iamVjdH1cclxuICovXG5cbnZhciBfZGVmYXVsdCA9IExvY2F0b3I7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7O0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBakJBO0FBaUJBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUExR0E7QUE2R0E7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBcEJBO0FBbUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///103\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nvar _tilegrid = __webpack_require__(56);\n\nvar _proj = __webpack_require__(112);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol\r\n */\n\n\n(0, _proj.register)(_["default"].proj4);\n/**\r\n * @desc Namespace for NYC mapping functionality for OpenLayers\r\n * @public\r\n * @namespace\r\n */\n\nvar ol = {\n  TILE_HOSTS: \'maps{1-4}.nyc.gov\',\n\n  /**\r\n  * @desc The tile grid for NYC tiled layers\r\n  * @public\r\n  * @const {ol.tilegrid.TileGrid}\r\n  */\n  TILE_GRID: (0, _tilegrid.createXYZ)({\n    minZoom: 8,\n    maxZoom: 21\n  })\n};\nvar _default = ol;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL2luZGV4LmpzP2U3NjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi8uLlwiKSk7XG5cbnZhciBfdGlsZWdyaWQgPSByZXF1aXJlKFwib2wvdGlsZWdyaWRcIik7XG5cbnZhciBfcHJvaiA9IHJlcXVpcmUoXCJvbC9wcm9qL3Byb2o0XCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogQG1vZHVsZSBueWMvb2xcclxuICovXG4oMCwgX3Byb2oucmVnaXN0ZXIpKF8uZGVmYXVsdC5wcm9qNCk7XG4vKipcclxuICogQGRlc2MgTmFtZXNwYWNlIGZvciBOWUMgbWFwcGluZyBmdW5jdGlvbmFsaXR5IGZvciBPcGVuTGF5ZXJzXHJcbiAqIEBwdWJsaWNcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cblxuY29uc3Qgb2wgPSB7XG4gIFRJTEVfSE9TVFM6ICdtYXBzezEtNH0ubnljLmdvdicsXG5cbiAgLyoqXHJcbiAgKiBAZGVzYyBUaGUgdGlsZSBncmlkIGZvciBOWUMgdGlsZWQgbGF5ZXJzXHJcbiAgKiBAcHVibGljXHJcbiAgKiBAY29uc3Qge29sLnRpbGVncmlkLlRpbGVHcmlkfVxyXG4gICovXG4gIFRJTEVfR1JJRDogKDAsIF90aWxlZ3JpZC5jcmVhdGVYWVopKHtcbiAgICBtaW5ab29tOiA4LFxuICAgIG1heFpvb206IDIxXG4gIH0pXG59O1xudmFyIF9kZWZhdWx0ID0gb2w7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7OztBQUdBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBUkE7QUFhQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///104\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/LocalStorage\r\n */\n\n/**\r\n * @desc Class to provide access to localStorage and filesystem\r\n * @public\r\n * @class\r\n */\n\n\nvar LocalStorage =\n/*#__PURE__*/\nfunction () {\n  function LocalStorage() {\n    _classCallCheck(this, LocalStorage);\n  }\n\n  _createClass(LocalStorage, [{\n    key: "canDownload",\n\n    /**\r\n     * @desc Check if download is available\r\n     * @public\r\n     * @method\r\n     * @return {boolean} True if download is available\r\n     */\n    value: function canDownload() {\n      return \'download\' in (0, _jquery["default"])(\'<a></a>\').get(0);\n    }\n    /**\r\n     * @desc Save GeoJSON data to a file prompting the user with a file dialog\r\n     * @public\r\n     * @method\r\n     * @param {string} name File name\r\n     * @param {string} data JSON data to write to file\r\n     */\n\n  }, {\n    key: "saveGeoJson",\n    value: function saveGeoJson(name, data) {\n      var href = "data:application/jsoncharset=utf-8,".concat(encodeURIComponent(data));\n      var a = (0, _jquery["default"])(\'<a class="file-dwn"><img></a>\');\n      (0, _jquery["default"])(\'body\').append(a);\n      a.attr({\n        href: href,\n        download: name\n      }).find(\'img\').trigger(\'click\');\n      a.remove();\n    }\n    /**\r\n     * @desc Set data in browser\'s localStorage if available\r\n     * @public\r\n     * @method\r\n     * @param {string} key Storage key\r\n     * @param {string} data Data to store\r\n     */\n\n  }, {\n    key: "setItem",\n    value: function setItem(key, data) {\n      if (\'localStorage\' in window) {\n        localStorage.setItem(key, data);\n      }\n    }\n    /**\r\n     * @desc Get data from browser\'s localStorage if available\r\n     * @public\r\n     * @method\r\n     * @param {string} key Storage key\r\n     * @return {string} The value of the key in local storage\r\n     */\n\n  }, {\n    key: "getItem",\n    value: function getItem(key) {\n      if (\'localStorage\' in window) {\n        return localStorage.getItem(key);\n      }\n    }\n    /**\r\n     * @desc Remove data from browser\'s localStorage if available\r\n     * @public\r\n     * @method\r\n     * @param {string} key Storage key\r\n     */\n\n  }, {\n    key: "removeItem",\n    value: function removeItem(key) {\n      if (\'localStorage\' in window) {\n        localStorage.removeItem(key);\n      }\n    }\n    /**\r\n     * @desc Open a text file from filesystem\r\n     * @public\r\n     * @method\r\n     * @param {module:nyc/LocalStorage~LocalStorage#readTextFileCallback} callback The callback function to receive file content\r\n     * @param {File=} file File - if not provided the user will be prompted with a file dialog\r\n     */\n\n  }, {\n    key: "readTextFile",\n    value: function readTextFile(callback, file) {\n      var reader = new FileReader();\n\n      reader.onload = function () {\n        callback(reader.result);\n      };\n\n      if (!file) {\n        var input = (0, _jquery["default"])(\'<input class="file-in" type="file">\');\n        (0, _jquery["default"])(\'body\').append(input);\n        input.change(function (event) {\n          input.remove();\n          reader.readAsText(event.target.files[0]);\n        });\n        input.trigger(\'click\');\n      } else {\n        reader.readAsText(file);\n      }\n    }\n    /**\r\n     * @desc Open a GeoJSON file from filesystem\r\n     * @public\r\n     * @method\r\n     * @param {ol.Map|L.Map} map The map in which the data will be displayed\r\n     * @param {module:nyc/LocalStorage~LocalStorage#loadGeoJsonFileCallback} callback The callback function to receive the new layer\r\n     * @param {File=} file File - if not provided the user will be prompted with a file dialog\r\n     */\n\n  }, {\n    key: "loadGeoJsonFile",\n    value: function loadGeoJsonFile(map, callback, file) {\n      var _this = this;\n\n      this.readTextFile(function (geoJson) {\n        var layer = _this.addToMap(map, geoJson);\n\n        if (callback) {\n          callback(layer);\n        }\n      }, file);\n    }\n    /**\r\n     * @desc Open a shapefile from filesystem\r\n     * @public\r\n     * @method\r\n     * @param {ol.Map|L.Map} map The map in which the data will be displayed\r\n     * @param {module:nyc/LocalStorage~LocalStorage#loadShapeFileCallback} callback The callback function to receive the new layer\r\n     * @param {FileList=} files Files (.shp, .dbf, .prj) - if not provided the user will be prompted with a file dialog\r\n     * @see https://github.com/mbostock/shapefile\r\n     */\n\n  }, {\n    key: "loadShapeFile",\n    value: function loadShapeFile(map, callback, files) {\n      if (!files) {\n        var me = this;\n        var input = (0, _jquery["default"])(\'<input class="file-in" type="file" multiple>\');\n        (0, _jquery["default"])(\'body\').append(input);\n        input.change(function (event) {\n          me.getShpDbfPrj(map, event.target.files, callback);\n          input.remove();\n        });\n        input.trigger(\'click\');\n      } else {\n        this.getShpDbfPrj(map, files, callback);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {ol.Map|L.Map} map The map\r\n     * @param {FileList} files List of files\r\n     * @param {function} callback Callback function\r\n    */\n\n  }, {\n    key: "getShpDbfPrj",\n    value: function getShpDbfPrj(map, files, callback) {\n      var _this2 = this;\n\n      var shp, dbf, prj;\n      Object.values(files).forEach(function (file) {\n        var name = file.name;\n        var ext = name.substr(name.length - 4).toLowerCase();\n\n        if (ext === \'.shp\') {\n          shp = file;\n        } else if (ext === \'.dbf\') {\n          dbf = file;\n        } else if (ext === \'.prj\') {\n          prj = file;\n        }\n      });\n\n      if (shp) {\n        this.readPrj(prj, function (projcs) {\n          _this2.readShpDbf(map, shp, dbf, projcs, callback);\n        });\n      } else if (callback) {\n        callback();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {File} prj Prj file\r\n     * @param {function} callback Callback function\r\n    */\n\n  }, {\n    key: "readPrj",\n    value: function readPrj(prj, callback) {\n      if (prj) {\n        this.readTextFile(callback, prj);\n      } else {\n        callback();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {ol.Map|L.Map} map The map\r\n     * @param {File} shp The shp file\r\n     * @param {File} dbf The dbf file\r\n     * @param {string} projcs Proj coordinate reference system\r\n     * @param {function} callback Callback function\r\n    */\n\n  }, {\n    key: "readShpDbf",\n    value: function readShpDbf(map, shp, dbf, projcs, callback) {\n      var _this3 = this;\n\n      var shpBuffer, dbfBuffer;\n      var shpReader = new FileReader();\n\n      shpReader.onload = function (event) {\n        shpBuffer = event.target.result;\n\n        if (dbfBuffer || !dbf) {\n          _this3.readShp(map, shpBuffer, dbfBuffer, projcs, callback);\n        }\n      };\n\n      var dbfReader = new FileReader();\n\n      dbfReader.onload = function (event) {\n        dbfBuffer = event.target.result;\n\n        if (shpBuffer) {\n          _this3.readShp(map, shpBuffer, dbfBuffer, projcs, callback);\n        }\n      };\n\n      shpReader.readAsArrayBuffer(shp);\n\n      if (dbf) {\n        dbfReader.readAsArrayBuffer(dbf);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {ol.Map|L.Map} map The map\r\n     * @param {string|ArrayBuffer} shp The shp file\r\n     * @param {string|ArrayBuffer} dbf The dbf file\r\n     * @param {string} projcs Proj coordinate reference system\r\n     * @param {function} callback Callback function\r\n    */\n\n  }, {\n    key: "readShp",\n    value: function readShp(map, shp, dbf, projcs, callback) {\n      var me = this;\n      var features = [];\n      LocalStorage.shapefile.open(shp, dbf).then(function (source) {\n        source.read().then(function collect(result) {\n          if (result.done) {\n            var layer = me.addToMap(map, features, projcs);\n\n            if (callback) {\n              callback(layer);\n            }\n\n            return;\n          } else {\n            features.push(result.value);\n          }\n\n          return source.read().then(collect);\n        });\n      })["catch"](function (error) {\n        console.error(error);\n      });\n    }\n    /**\r\n     * @public\r\n     * @abstract\r\n     * @method\r\n     * @param {ol.Map|L.Map} map The map on which to display the new layer\r\n     * @param {string|Array<Object>} features The features from which to create the new layer\r\n     * @param {string=} projcs The projection\r\n     * @return {ol.layer.Vector|L.Layer} The new layer\r\n    */\n\n  }, {\n    key: "addToMap",\n    value: function addToMap(map, features, projcs) {\n      throw \'Not implemented\';\n    }\n    /**\r\n     * @desc Add a new projection to proj4 and return the code\r\n     * @access protected\r\n     * @method\r\n     * @param {string} projcs The projecion as defined in a prj file\r\n     * @param {Object} proj4 The proj4 instance\r\n     * @return {string|undefined} The code for the new projection\r\n     */\n\n  }, {\n    key: "customProj",\n    value: function customProj(projcs, proj4) {\n      if (projcs) {\n        var code = _["default"].nextId(\'shp:prj\');\n\n        proj4.defs(code, projcs);\n        return code;\n      }\n    }\n  }]);\n\n  return LocalStorage;\n}();\n/**\r\n * @desc Callback for {@link module:nyc/LocalStorage~LocalStorage#readTextFile}\r\n * @public\r\n * @callback module:nyc/LocalStorage~LocalStorage#readTextFileCallback\r\n * @param {string} fileContents The text contained in the file\r\n */\n\n/**\r\n * @desc Callback for {@link module:nyc/LocalStorage~LocalStorage#loadGeoJsonFile}\r\n * @public\r\n * @callback module:nyc/LocalStorage~LocalStorage#loadGeoJsonFileCallback\r\n * @param {ol.layer.Vector|L.Layer} layer The layer created from the GeoJSON file\r\n */\n\n/**\r\n * @desc Callback for {@link module:nyc/LocalStorage~LocalStorage#loadShapeFile}\r\n * @public\r\n * @callback module:nyc/LocalStorage~LocalStorage#loadShapeFileCallback\r\n * @param {ol.layer.Vector|L.Layer} layer The layer created from the shapefile\r\n */\n\n\nLocalStorage.shapefile = __webpack_require__(128);\nvar _default = LocalStorage;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0xvY2FsU3RvcmFnZS5qcz85ZTVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbnZhciBfID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9cIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogQG1vZHVsZSBueWMvTG9jYWxTdG9yYWdlXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQ2xhc3MgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gbG9jYWxTdG9yYWdlIGFuZCBmaWxlc3lzdGVtXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqL1xuY2xhc3MgTG9jYWxTdG9yYWdlIHtcbiAgLyoqXHJcbiAgICogQGRlc2MgQ2hlY2sgaWYgZG93bmxvYWQgaXMgYXZhaWxhYmxlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGRvd25sb2FkIGlzIGF2YWlsYWJsZVxyXG4gICAqL1xuICBjYW5Eb3dubG9hZCgpIHtcbiAgICByZXR1cm4gJ2Rvd25sb2FkJyBpbiAoMCwgX2pxdWVyeS5kZWZhdWx0KSgnPGE+PC9hPicpLmdldCgwKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBTYXZlIEdlb0pTT04gZGF0YSB0byBhIGZpbGUgcHJvbXB0aW5nIHRoZSB1c2VyIHdpdGggYSBmaWxlIGRpYWxvZ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmlsZSBuYW1lXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgSlNPTiBkYXRhIHRvIHdyaXRlIHRvIGZpbGVcclxuICAgKi9cblxuXG4gIHNhdmVHZW9Kc29uKG5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBocmVmID0gYGRhdGE6YXBwbGljYXRpb24vanNvbmNoYXJzZXQ9dXRmLTgsJHtlbmNvZGVVUklDb21wb25lbnQoZGF0YSl9YDtcbiAgICBjb25zdCBhID0gKDAsIF9qcXVlcnkuZGVmYXVsdCkoJzxhIGNsYXNzPVwiZmlsZS1kd25cIj48aW1nPjwvYT4nKTtcbiAgICAoMCwgX2pxdWVyeS5kZWZhdWx0KSgnYm9keScpLmFwcGVuZChhKTtcbiAgICBhLmF0dHIoe1xuICAgICAgaHJlZjogaHJlZixcbiAgICAgIGRvd25sb2FkOiBuYW1lXG4gICAgfSkuZmluZCgnaW1nJykudHJpZ2dlcignY2xpY2snKTtcbiAgICBhLnJlbW92ZSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFNldCBkYXRhIGluIGJyb3dzZXIncyBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFN0b3JhZ2Uga2V5XHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgRGF0YSB0byBzdG9yZVxyXG4gICAqL1xuXG5cbiAgc2V0SXRlbShrZXksIGRhdGEpIHtcbiAgICBpZiAoJ2xvY2FsU3RvcmFnZScgaW4gd2luZG93KSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIGRhdGEpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBHZXQgZGF0YSBmcm9tIGJyb3dzZXIncyBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFN0b3JhZ2Uga2V5XHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIGtleSBpbiBsb2NhbCBzdG9yYWdlXHJcbiAgICovXG5cblxuICBnZXRJdGVtKGtleSkge1xuICAgIGlmICgnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cpIHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBSZW1vdmUgZGF0YSBmcm9tIGJyb3dzZXIncyBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFN0b3JhZ2Uga2V5XHJcbiAgICovXG5cblxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIGlmICgnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIE9wZW4gYSB0ZXh0IGZpbGUgZnJvbSBmaWxlc3lzdGVtXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvTG9jYWxTdG9yYWdlfkxvY2FsU3RvcmFnZSNyZWFkVGV4dEZpbGVDYWxsYmFja30gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlY2VpdmUgZmlsZSBjb250ZW50XHJcbiAgICogQHBhcmFtIHtGaWxlPX0gZmlsZSBGaWxlIC0gaWYgbm90IHByb3ZpZGVkIHRoZSB1c2VyIHdpbGwgYmUgcHJvbXB0ZWQgd2l0aCBhIGZpbGUgZGlhbG9nXHJcbiAgICovXG5cblxuICByZWFkVGV4dEZpbGUoY2FsbGJhY2ssIGZpbGUpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKHJlYWRlci5yZXN1bHQpO1xuICAgIH07XG5cbiAgICBpZiAoIWZpbGUpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gKDAsIF9qcXVlcnkuZGVmYXVsdCkoJzxpbnB1dCBjbGFzcz1cImZpbGUtaW5cIiB0eXBlPVwiZmlsZVwiPicpO1xuICAgICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoJ2JvZHknKS5hcHBlbmQoaW5wdXQpO1xuICAgICAgaW5wdXQuY2hhbmdlKGV2ZW50ID0+IHtcbiAgICAgICAgaW5wdXQucmVtb3ZlKCk7XG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGV2ZW50LnRhcmdldC5maWxlc1swXSk7XG4gICAgICB9KTtcbiAgICAgIGlucHV0LnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBPcGVuIGEgR2VvSlNPTiBmaWxlIGZyb20gZmlsZXN5c3RlbVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtvbC5NYXB8TC5NYXB9IG1hcCBUaGUgbWFwIGluIHdoaWNoIHRoZSBkYXRhIHdpbGwgYmUgZGlzcGxheWVkXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0xvY2FsU3RvcmFnZX5Mb2NhbFN0b3JhZ2UjbG9hZEdlb0pzb25GaWxlQ2FsbGJhY2t9IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZWNlaXZlIHRoZSBuZXcgbGF5ZXJcclxuICAgKiBAcGFyYW0ge0ZpbGU9fSBmaWxlIEZpbGUgLSBpZiBub3QgcHJvdmlkZWQgdGhlIHVzZXIgd2lsbCBiZSBwcm9tcHRlZCB3aXRoIGEgZmlsZSBkaWFsb2dcclxuICAgKi9cblxuXG4gIGxvYWRHZW9Kc29uRmlsZShtYXAsIGNhbGxiYWNrLCBmaWxlKSB7XG4gICAgdGhpcy5yZWFkVGV4dEZpbGUoZ2VvSnNvbiA9PiB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuYWRkVG9NYXAobWFwLCBnZW9Kc29uKTtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKGxheWVyKTtcbiAgICAgIH1cbiAgICB9LCBmaWxlKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBPcGVuIGEgc2hhcGVmaWxlIGZyb20gZmlsZXN5c3RlbVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtvbC5NYXB8TC5NYXB9IG1hcCBUaGUgbWFwIGluIHdoaWNoIHRoZSBkYXRhIHdpbGwgYmUgZGlzcGxheWVkXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0xvY2FsU3RvcmFnZX5Mb2NhbFN0b3JhZ2UjbG9hZFNoYXBlRmlsZUNhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVjZWl2ZSB0aGUgbmV3IGxheWVyXHJcbiAgICogQHBhcmFtIHtGaWxlTGlzdD19IGZpbGVzIEZpbGVzICguc2hwLCAuZGJmLCAucHJqKSAtIGlmIG5vdCBwcm92aWRlZCB0aGUgdXNlciB3aWxsIGJlIHByb21wdGVkIHdpdGggYSBmaWxlIGRpYWxvZ1xyXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL3NoYXBlZmlsZVxyXG4gICAqL1xuXG5cbiAgbG9hZFNoYXBlRmlsZShtYXAsIGNhbGxiYWNrLCBmaWxlcykge1xuICAgIGlmICghZmlsZXMpIHtcbiAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgIGNvbnN0IGlucHV0ID0gKDAsIF9qcXVlcnkuZGVmYXVsdCkoJzxpbnB1dCBjbGFzcz1cImZpbGUtaW5cIiB0eXBlPVwiZmlsZVwiIG11bHRpcGxlPicpO1xuICAgICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoJ2JvZHknKS5hcHBlbmQoaW5wdXQpO1xuICAgICAgaW5wdXQuY2hhbmdlKGV2ZW50ID0+IHtcbiAgICAgICAgbWUuZ2V0U2hwRGJmUHJqKG1hcCwgZXZlbnQudGFyZ2V0LmZpbGVzLCBjYWxsYmFjayk7XG4gICAgICAgIGlucHV0LnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICBpbnB1dC50cmlnZ2VyKCdjbGljaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldFNocERiZlByaihtYXAsIGZpbGVzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7b2wuTWFwfEwuTWFwfSBtYXAgVGhlIG1hcFxyXG4gICAqIEBwYXJhbSB7RmlsZUxpc3R9IGZpbGVzIExpc3Qgb2YgZmlsZXNcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxyXG4gICovXG5cblxuICBnZXRTaHBEYmZQcmoobWFwLCBmaWxlcywgY2FsbGJhY2spIHtcbiAgICBsZXQgc2hwLCBkYmYsIHByajtcbiAgICBPYmplY3QudmFsdWVzKGZpbGVzKS5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGZpbGUubmFtZTtcbiAgICAgIGNvbnN0IGV4dCA9IG5hbWUuc3Vic3RyKG5hbWUubGVuZ3RoIC0gNCkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKGV4dCA9PT0gJy5zaHAnKSB7XG4gICAgICAgIHNocCA9IGZpbGU7XG4gICAgICB9IGVsc2UgaWYgKGV4dCA9PT0gJy5kYmYnKSB7XG4gICAgICAgIGRiZiA9IGZpbGU7XG4gICAgICB9IGVsc2UgaWYgKGV4dCA9PT0gJy5wcmonKSB7XG4gICAgICAgIHByaiA9IGZpbGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2hwKSB7XG4gICAgICB0aGlzLnJlYWRQcmoocHJqLCBwcm9qY3MgPT4ge1xuICAgICAgICB0aGlzLnJlYWRTaHBEYmYobWFwLCBzaHAsIGRiZiwgcHJvamNzLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge0ZpbGV9IHByaiBQcmogZmlsZVxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgKi9cblxuXG4gIHJlYWRQcmoocHJqLCBjYWxsYmFjaykge1xuICAgIGlmIChwcmopIHtcbiAgICAgIHRoaXMucmVhZFRleHRGaWxlKGNhbGxiYWNrLCBwcmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge29sLk1hcHxMLk1hcH0gbWFwIFRoZSBtYXBcclxuICAgKiBAcGFyYW0ge0ZpbGV9IHNocCBUaGUgc2hwIGZpbGVcclxuICAgKiBAcGFyYW0ge0ZpbGV9IGRiZiBUaGUgZGJmIGZpbGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamNzIFByb2ogY29vcmRpbmF0ZSByZWZlcmVuY2Ugc3lzdGVtXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICAqL1xuXG5cbiAgcmVhZFNocERiZihtYXAsIHNocCwgZGJmLCBwcm9qY3MsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHNocEJ1ZmZlciwgZGJmQnVmZmVyO1xuICAgIGNvbnN0IHNocFJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICBzaHBSZWFkZXIub25sb2FkID0gZXZlbnQgPT4ge1xuICAgICAgc2hwQnVmZmVyID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcblxuICAgICAgaWYgKGRiZkJ1ZmZlciB8fCAhZGJmKSB7XG4gICAgICAgIHRoaXMucmVhZFNocChtYXAsIHNocEJ1ZmZlciwgZGJmQnVmZmVyLCBwcm9qY3MsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZGJmUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgIGRiZlJlYWRlci5vbmxvYWQgPSBldmVudCA9PiB7XG4gICAgICBkYmZCdWZmZXIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuXG4gICAgICBpZiAoc2hwQnVmZmVyKSB7XG4gICAgICAgIHRoaXMucmVhZFNocChtYXAsIHNocEJ1ZmZlciwgZGJmQnVmZmVyLCBwcm9qY3MsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2hwUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKHNocCk7XG5cbiAgICBpZiAoZGJmKSB7XG4gICAgICBkYmZSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZGJmKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtvbC5NYXB8TC5NYXB9IG1hcCBUaGUgbWFwXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXlCdWZmZXJ9IHNocCBUaGUgc2hwIGZpbGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheUJ1ZmZlcn0gZGJmIFRoZSBkYmYgZmlsZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qY3MgUHJvaiBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW1cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxyXG4gICovXG5cblxuICByZWFkU2hwKG1hcCwgc2hwLCBkYmYsIHByb2pjcywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICBMb2NhbFN0b3JhZ2Uuc2hhcGVmaWxlLm9wZW4oc2hwLCBkYmYpLnRoZW4oc291cmNlID0+IHtcbiAgICAgIHNvdXJjZS5yZWFkKCkudGhlbihmdW5jdGlvbiBjb2xsZWN0KHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBjb25zdCBsYXllciA9IG1lLmFkZFRvTWFwKG1hcCwgZmVhdHVyZXMsIHByb2pjcyk7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmVhdHVyZXMucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZS5yZWFkKCkudGhlbihjb2xsZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtvbC5NYXB8TC5NYXB9IG1hcCBUaGUgbWFwIG9uIHdoaWNoIHRvIGRpc3BsYXkgdGhlIG5ldyBsYXllclxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PE9iamVjdD59IGZlYXR1cmVzIFRoZSBmZWF0dXJlcyBmcm9tIHdoaWNoIHRvIGNyZWF0ZSB0aGUgbmV3IGxheWVyXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBwcm9qY3MgVGhlIHByb2plY3Rpb25cclxuICAgKiBAcmV0dXJuIHtvbC5sYXllci5WZWN0b3J8TC5MYXllcn0gVGhlIG5ldyBsYXllclxyXG4gICovXG5cblxuICBhZGRUb01hcChtYXAsIGZlYXR1cmVzLCBwcm9qY3MpIHtcbiAgICB0aHJvdyAnTm90IGltcGxlbWVudGVkJztcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBBZGQgYSBuZXcgcHJvamVjdGlvbiB0byBwcm9qNCBhbmQgcmV0dXJuIHRoZSBjb2RlXHJcbiAgICogQGFjY2VzcyBwcm90ZWN0ZWRcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb2pjcyBUaGUgcHJvamVjaW9uIGFzIGRlZmluZWQgaW4gYSBwcmogZmlsZVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9qNCBUaGUgcHJvajQgaW5zdGFuY2VcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgY29kZSBmb3IgdGhlIG5ldyBwcm9qZWN0aW9uXHJcbiAgICovXG5cblxuICBjdXN0b21Qcm9qKHByb2pjcywgcHJvajQpIHtcbiAgICBpZiAocHJvamNzKSB7XG4gICAgICBjb25zdCBjb2RlID0gXy5kZWZhdWx0Lm5leHRJZCgnc2hwOnByaicpO1xuXG4gICAgICBwcm9qNC5kZWZzKGNvZGUsIHByb2pjcyk7XG4gICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gIH1cblxufVxuLyoqXHJcbiAqIEBkZXNjIENhbGxiYWNrIGZvciB7QGxpbmsgbW9kdWxlOm55Yy9Mb2NhbFN0b3JhZ2V+TG9jYWxTdG9yYWdlI3JlYWRUZXh0RmlsZX1cclxuICogQHB1YmxpY1xyXG4gKiBAY2FsbGJhY2sgbW9kdWxlOm55Yy9Mb2NhbFN0b3JhZ2V+TG9jYWxTdG9yYWdlI3JlYWRUZXh0RmlsZUNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlQ29udGVudHMgVGhlIHRleHQgY29udGFpbmVkIGluIHRoZSBmaWxlXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQ2FsbGJhY2sgZm9yIHtAbGluayBtb2R1bGU6bnljL0xvY2FsU3RvcmFnZX5Mb2NhbFN0b3JhZ2UjbG9hZEdlb0pzb25GaWxlfVxyXG4gKiBAcHVibGljXHJcbiAqIEBjYWxsYmFjayBtb2R1bGU6bnljL0xvY2FsU3RvcmFnZX5Mb2NhbFN0b3JhZ2UjbG9hZEdlb0pzb25GaWxlQ2FsbGJhY2tcclxuICogQHBhcmFtIHtvbC5sYXllci5WZWN0b3J8TC5MYXllcn0gbGF5ZXIgVGhlIGxheWVyIGNyZWF0ZWQgZnJvbSB0aGUgR2VvSlNPTiBmaWxlXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQ2FsbGJhY2sgZm9yIHtAbGluayBtb2R1bGU6bnljL0xvY2FsU3RvcmFnZX5Mb2NhbFN0b3JhZ2UjbG9hZFNoYXBlRmlsZX1cclxuICogQHB1YmxpY1xyXG4gKiBAY2FsbGJhY2sgbW9kdWxlOm55Yy9Mb2NhbFN0b3JhZ2V+TG9jYWxTdG9yYWdlI2xvYWRTaGFwZUZpbGVDYWxsYmFja1xyXG4gKiBAcGFyYW0ge29sLmxheWVyLlZlY3RvcnxMLkxheWVyfSBsYXllciBUaGUgbGF5ZXIgY3JlYXRlZCBmcm9tIHRoZSBzaGFwZWZpbGVcclxuICovXG5cblxuTG9jYWxTdG9yYWdlLnNoYXBlZmlsZSA9IHJlcXVpcmUoJ3NoYXBlZmlsZScpO1xudmFyIF9kZWZhdWx0ID0gTG9jYWxTdG9yYWdlO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBSUE7Ozs7Ozs7QUFLQTs7Ozs7Ozs7OztBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUdBOzs7Ozs7O0FBT0E7Ozs7Ozs7QUFPQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///105\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/ol/reproj/common.js\n/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nvar ERROR_THRESHOLD = 0.5;\n/**\n * Enable automatic reprojection of raster sources. Default is `true`.\n * TODO: decide if we want to expose this as a build flag or remove it\n * @type {boolean}\n */\n\nvar ENABLE_RASTER_REPROJECTION = true;\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/TileState.js\nvar TileState = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./node_modules/ol/easing.js\nvar easing = __webpack_require__(28);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/Target.js\nvar Target = __webpack_require__(44);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar EventType = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./node_modules/ol/Tile.js\n/**\n * @module ol/Tile\n */\n\n\n\n\n/**\n * A function that takes an {@link module:ol/Tile} for the tile and a\n * `{string}` for the url as arguments. The default is\n * ```js\n * source.setTileLoadFunction(function(tile, src) {\n *   tile.getImage().src = src;\n * });\n * ```\n * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve\n * error handling:\n *\n * ```js\n * import TileState from \'ol/TileState\';\n *\n * source.setTileLoadFunction(function(tile, src) {\n *   var xhr = new XMLHttpRequest();\n *   xhr.responseType = \'blob\';\n *   xhr.addEventListener(\'loadend\', function (evt) {\n *     var data = this.response;\n *     if (data !== undefined) {\n *       tile.getImage().src = URL.createObjectURL(data);\n *     } else {\n *       tile.setState(TileState.ERROR);\n *     }\n *   });\n *   xhr.addEventListener(\'error\', function () {\n *     tile.setState(TileState.ERROR);\n *   });\n *   xhr.open(\'GET\', src);\n *   xhr.send();\n * });\n * ```\n *\n * @typedef {function(Tile, string)} LoadFunction\n * @api\n */\n\n/**\n * {@link module:ol/source/Tile~Tile} sources use a function of this type to get\n * the url that provides a tile for a given tile coordinate.\n *\n * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile\n * coordinate, a `{number}` representing the pixel ratio and a\n * {@link module:ol/proj/Projection} for the projection  as arguments\n * and returns a `{string}` representing the tile URL, or undefined if no tile\n * should be requested for the passed tile coordinate.\n *\n * @typedef {function(import("./tilecoord.js").TileCoord, number,\n *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction\n * @api\n */\n\n/**\n * @typedef {Object} Options\n * @property {number} [transition=250] A duration for tile opacity\n * transitions in milliseconds. A duration of 0 disables the opacity transition.\n * @api\n */\n\n/**\n * @classdesc\n * Base class for tiles.\n *\n * @abstract\n */\n\nvar Tile_Tile =\n/*@__PURE__*/\nfunction (EventTarget) {\n  function Tile(tileCoord, state, opt_options) {\n    EventTarget.call(this);\n    var options = opt_options ? opt_options : {};\n    /**\n     * @type {import("./tilecoord.js").TileCoord}\n     */\n\n    this.tileCoord = tileCoord;\n    /**\n     * @protected\n     * @type {TileState}\n     */\n\n    this.state = state;\n    /**\n     * An "interim" tile for this tile. The interim tile may be used while this\n     * one is loading, for "smooth" transitions when changing params/dimensions\n     * on the source.\n     * @type {Tile}\n     */\n\n    this.interimTile = null;\n    /**\n     * A key assigned to the tile. This is used by the tile source to determine\n     * if this tile can effectively be used, or if a new tile should be created\n     * and this one be used as an interim tile for this new tile.\n     * @type {string}\n     */\n\n    this.key = \'\';\n    /**\n     * The duration for the opacity transition.\n     * @type {number}\n     */\n\n    this.transition_ = options.transition === undefined ? 250 : options.transition;\n    /**\n     * Lookup of start times for rendering transitions.  If the start time is\n     * equal to -1, the transition is complete.\n     * @type {Object<string, number>}\n     */\n\n    this.transitionStarts_ = {};\n  }\n\n  if (EventTarget) Tile.__proto__ = EventTarget;\n  Tile.prototype = Object.create(EventTarget && EventTarget.prototype);\n  Tile.prototype.constructor = Tile;\n  /**\n   * @protected\n   */\n\n  Tile.prototype.changed = function changed() {\n    this.dispatchEvent(EventType["a" /* default */].CHANGE);\n  };\n  /**\n   * @return {string} Key.\n   */\n\n\n  Tile.prototype.getKey = function getKey() {\n    return this.key + \'/\' + this.tileCoord;\n  };\n  /**\n   * Get the interim tile most suitable for rendering using the chain of interim\n   * tiles. This corresponds to the  most recent tile that has been loaded, if no\n   * such tile exists, the original tile is returned.\n   * @return {!Tile} Best tile for rendering.\n   */\n\n\n  Tile.prototype.getInterimTile = function getInterimTile() {\n    if (!this.interimTile) {\n      //empty chain\n      return this;\n    }\n\n    var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in\n    // decreasing order of creation time, there is no need to search the remainder\n    // of the list (all those tiles correspond to older requests and will be\n    // cleaned up by refreshInterimChain)\n\n    do {\n      if (tile.getState() == TileState["a" /* default */].LOADED) {\n        return tile;\n      }\n\n      tile = tile.interimTile;\n    } while (tile); // we can not find a better tile\n\n\n    return this;\n  };\n  /**\n   * Goes through the chain of interim tiles and discards sections of the chain\n   * that are no longer relevant.\n   */\n\n\n  Tile.prototype.refreshInterimChain = function refreshInterimChain() {\n    if (!this.interimTile) {\n      return;\n    }\n\n    var tile = this.interimTile;\n    var prev =\n    /** @type {Tile} */\n    this;\n\n    do {\n      if (tile.getState() == TileState["a" /* default */].LOADED) {\n        //we have a loaded tile, we can discard the rest of the list\n        //we would could abort any LOADING tile request\n        //older than this tile (i.e. any LOADING tile following this entry in the chain)\n        tile.interimTile = null;\n        break;\n      } else if (tile.getState() == TileState["a" /* default */].LOADING) {\n        //keep this LOADING tile any loaded tiles later in the chain are\n        //older than this tile, so we\'re still interested in the request\n        prev = tile;\n      } else if (tile.getState() == TileState["a" /* default */].IDLE) {\n        //the head of the list is the most current tile, we don\'t need\n        //to start any other requests for this chain\n        prev.interimTile = tile.interimTile;\n      } else {\n        prev = tile;\n      }\n\n      tile = prev.interimTile;\n    } while (tile);\n  };\n  /**\n   * Get the tile coordinate for this tile.\n   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.\n   * @api\n   */\n\n\n  Tile.prototype.getTileCoord = function getTileCoord() {\n    return this.tileCoord;\n  };\n  /**\n   * @return {TileState} State.\n   */\n\n\n  Tile.prototype.getState = function getState() {\n    return this.state;\n  };\n  /**\n   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,\n   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}\n   * when the tile cannot be loaded. Otherwise the tile cannot be removed from\n   * the tile queue and will block other requests.\n   * @param {TileState} state State.\n   * @api\n   */\n\n\n  Tile.prototype.setState = function setState(state) {\n    this.state = state;\n    this.changed();\n  };\n  /**\n   * Load the image or retry if loading previously failed.\n   * Loading is taken care of by the tile queue, and calling this method is\n   * only needed for preloading or for reloading in case of an error.\n   * @abstract\n   * @api\n   */\n\n\n  Tile.prototype.load = function load() {};\n  /**\n   * Get the alpha value for rendering.\n   * @param {string} id An id for the renderer.\n   * @param {number} time The render frame time.\n   * @return {number} A number between 0 and 1.\n   */\n\n\n  Tile.prototype.getAlpha = function getAlpha(id, time) {\n    if (!this.transition_) {\n      return 1;\n    }\n\n    var start = this.transitionStarts_[id];\n\n    if (!start) {\n      start = time;\n      this.transitionStarts_[id] = start;\n    } else if (start === -1) {\n      return 1;\n    }\n\n    var delta = time - start + 1000 / 60; // avoid rendering at 0\n\n    if (delta >= this.transition_) {\n      return 1;\n    }\n\n    return Object(easing["easeIn"])(delta / this.transition_);\n  };\n  /**\n   * Determine if a tile is in an alpha transition.  A tile is considered in\n   * transition if tile.getAlpha() has not yet been called or has been called\n   * and returned 1.\n   * @param {string} id An id for the renderer.\n   * @return {boolean} The tile is in transition.\n   */\n\n\n  Tile.prototype.inTransition = function inTransition(id) {\n    if (!this.transition_) {\n      return false;\n    }\n\n    return this.transitionStarts_[id] !== -1;\n  };\n  /**\n   * Mark a transition as complete.\n   * @param {string} id An id for the renderer.\n   */\n\n\n  Tile.prototype.endTransition = function endTransition(id) {\n    if (this.transition_) {\n      this.transitionStarts_[id] = -1;\n    }\n  };\n\n  return Tile;\n}(Target["a" /* default */]);\n\n/* harmony default export */ var ol_Tile = (Tile_Tile);\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./node_modules/ol/ImageTile.js\n/**\n * @module ol/ImageTile\n */\n\n\n\n\n\n\nvar ImageTile_ImageTile =\n/*@__PURE__*/\nfunction (Tile) {\n  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {\n    Tile.call(this, tileCoord, state, opt_options);\n    /**\n     * @private\n     * @type {?string}\n     */\n\n    this.crossOrigin_ = crossOrigin;\n    /**\n     * Image URI\n     *\n     * @private\n     * @type {string}\n     */\n\n    this.src_ = src;\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n\n    this.image_ = new Image();\n\n    if (crossOrigin !== null) {\n      this.image_.crossOrigin = crossOrigin;\n    }\n    /**\n     * @private\n     * @type {Array<import("./events.js").EventsKey>}\n     */\n\n\n    this.imageListenerKeys_ = null;\n    /**\n     * @private\n     * @type {import("./Tile.js").LoadFunction}\n     */\n\n    this.tileLoadFunction_ = tileLoadFunction;\n  }\n\n  if (Tile) ImageTile.__proto__ = Tile;\n  ImageTile.prototype = Object.create(Tile && Tile.prototype);\n  ImageTile.prototype.constructor = ImageTile;\n  /**\n   * @inheritDoc\n   */\n\n  ImageTile.prototype.disposeInternal = function disposeInternal() {\n    if (this.state == TileState["a" /* default */].LOADING) {\n      this.unlistenImage_();\n      this.image_ = getBlankImage();\n    }\n\n    if (this.interimTile) {\n      this.interimTile.dispose();\n    }\n\n    this.state = TileState["a" /* default */].ABORT;\n    this.changed();\n    Tile.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @api\n   */\n\n\n  ImageTile.prototype.getImage = function getImage() {\n    return this.image_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ImageTile.prototype.getKey = function getKey() {\n    return this.src_;\n  };\n  /**\n   * Tracks loading or read errors.\n   *\n   * @private\n   */\n\n\n  ImageTile.prototype.handleImageError_ = function handleImageError_() {\n    this.state = TileState["a" /* default */].ERROR;\n    this.unlistenImage_();\n    this.image_ = getBlankImage();\n    this.changed();\n  };\n  /**\n   * Tracks successful image load.\n   *\n   * @private\n   */\n\n\n  ImageTile.prototype.handleImageLoad_ = function handleImageLoad_() {\n    var image =\n    /** @type {HTMLImageElement} */\n    this.image_;\n\n    if (image.naturalWidth && image.naturalHeight) {\n      this.state = TileState["a" /* default */].LOADED;\n    } else {\n      this.state = TileState["a" /* default */].EMPTY;\n    }\n\n    this.unlistenImage_();\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  ImageTile.prototype.load = function load() {\n    if (this.state == TileState["a" /* default */].ERROR) {\n      this.state = TileState["a" /* default */].IDLE;\n      this.image_ = new Image();\n\n      if (this.crossOrigin_ !== null) {\n        this.image_.crossOrigin = this.crossOrigin_;\n      }\n    }\n\n    if (this.state == TileState["a" /* default */].IDLE) {\n      this.state = TileState["a" /* default */].LOADING;\n      this.changed();\n      this.imageListenerKeys_ = [Object(events["b" /* listenOnce */])(this.image_, EventType["a" /* default */].ERROR, this.handleImageError_, this), Object(events["b" /* listenOnce */])(this.image_, EventType["a" /* default */].LOAD, this.handleImageLoad_, this)];\n      this.tileLoadFunction_(this, this.src_);\n    }\n  };\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n\n\n  ImageTile.prototype.unlistenImage_ = function unlistenImage_() {\n    this.imageListenerKeys_.forEach(events["e" /* unlistenByKey */]);\n    this.imageListenerKeys_ = null;\n  };\n\n  return ImageTile;\n}(ol_Tile);\n/**\n * Get a 1-pixel blank image.\n * @return {HTMLCanvasElement} Blank image.\n */\n\n\nfunction getBlankImage() {\n  var ctx = Object(dom["a" /* createCanvasContext2D */])(1, 1);\n  ctx.fillStyle = \'rgba(0,0,0,0)\';\n  ctx.fillRect(0, 0, 1, 1);\n  return ctx.canvas;\n}\n\n/* harmony default export */ var ol_ImageTile = (ImageTile_ImageTile);\n// EXTERNAL MODULE: ./node_modules/ol/structs/LRUCache.js\nvar structs_LRUCache = __webpack_require__(90);\n\n// EXTERNAL MODULE: ./node_modules/ol/tilecoord.js\nvar tilecoord = __webpack_require__(33);\n\n// CONCATENATED MODULE: ./node_modules/ol/TileCache.js\n/**\n * @module ol/TileCache\n */\n\n\n\nvar TileCache_TileCache =\n/*@__PURE__*/\nfunction (LRUCache) {\n  function TileCache(opt_highWaterMark) {\n    LRUCache.call(this, opt_highWaterMark);\n  }\n\n  if (LRUCache) TileCache.__proto__ = LRUCache;\n  TileCache.prototype = Object.create(LRUCache && LRUCache.prototype);\n  TileCache.prototype.constructor = TileCache;\n  /**\n   * @param {!Object<string, import("./TileRange.js").default>} usedTiles Used tiles.\n   */\n\n  TileCache.prototype.expireCache = function expireCache(usedTiles) {\n    while (this.canExpireCache()) {\n      var tile = this.peekLast();\n      var zKey = tile.tileCoord[0].toString();\n\n      if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {\n        break;\n      } else {\n        this.pop().dispose();\n      }\n    }\n  };\n  /**\n   * Prune all tiles from the cache that don\'t have the same z as the newest tile.\n   */\n\n\n  TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ() {\n    if (this.getCount() === 0) {\n      return;\n    }\n\n    var key = this.peekFirstKey();\n    var tileCoord = Object(tilecoord["b" /* fromKey */])(key);\n    var z = tileCoord[0];\n    this.forEach(function (tile) {\n      if (tile.tileCoord[0] !== z) {\n        this.remove(Object(tilecoord["c" /* getKey */])(tile.tileCoord));\n        tile.dispose();\n      }\n    }, this);\n  };\n\n  return TileCache;\n}(structs_LRUCache["a" /* default */]);\n\n/* harmony default export */ var ol_TileCache = (TileCache_TileCache);\n// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules\nvar ol_proj = __webpack_require__(10);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./node_modules/ol/reproj.js\n/**\n * @module ol/reproj\n */\n\n\n\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import("./proj/Projection.js").default} sourceProj Source projection.\n * @param {import("./proj/Projection.js").default} targetProj Target projection.\n * @param {import("./coordinate.js").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\n\nfunction calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n  var sourceCenter = Object(ol_proj["transform"])(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data\n\n  var sourceResolution = Object(ol_proj["getPointResolution"])(targetProj, targetResolution, targetCenter);\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  } // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n\n  var sourceExtent = sourceProj.getExtent();\n\n  if (!sourceExtent || Object(ol_extent["containsCoordinate"])(sourceExtent, sourceCenter)) {\n    var compensationFactor = Object(ol_proj["getPointResolution"])(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {import("./coordinate.js").Coordinate} New point 1 px farther from the centroid.\n */\n\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n  var dX = x - centroidX;\n  var dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import("./extent.js").Extent} targetExtent Target extent.\n * @param {import("./reproj/Triangulation.js").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import("./extent.js").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\n\n\nfunction reproj_render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {\n  var context = Object(dom["a" /* createCanvasContext2D */])(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n  var sourceDataExtent = Object(ol_extent["createEmpty"])();\n  sources.forEach(function (src, i, arr) {\n    Object(ol_extent["extend"])(sourceDataExtent, src.extent);\n  });\n  var canvasWidthInUnits = Object(ol_extent["getWidth"])(sourceDataExtent);\n  var canvasHeightInUnits = Object(ol_extent["getHeight"])(sourceDataExtent);\n  var stitchContext = Object(dom["a" /* createCanvasContext2D */])(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n  var stitchScale = pixelRatio / sourceResolution;\n  sources.forEach(function (src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = Object(ol_extent["getWidth"])(src.extent);\n    var srcHeight = Object(ol_extent["getHeight"])(src.extent);\n    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n  var targetTopLeft = Object(ol_extent["getTopLeft"])(targetExtent);\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0],\n        y0 = source[0][1];\n    var x1 = source[1][0],\n        y1 = source[1][1];\n    var x2 = source[2][0],\n        y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution; // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];\n    var affineCoefs = Object(math["e" /* solveLinearSystem */])(augmentedMatrix);\n\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3;\n    var centroidY = (v0 + v1 + v2) / 3;\n    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n    context.strokeStyle = \'black\';\n    context.lineWidth = 1;\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n    context.restore();\n  }\n\n  return context.canvas;\n}\n// CONCATENATED MODULE: ./node_modules/ol/reproj/Triangulation.js\n/**\n * @module ol/reproj/Triangulation\n */\n\n\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import("../coordinate.js").Coordinate>} source\n * @property {Array<import("../coordinate.js").Coordinate>} target\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\n\nvar MAX_SUBDIVISION = 10;\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\n\nvar MAX_TRIANGLE_WIDTH = 0.25;\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\n\nvar Triangulation_Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {\n  /**\n   * @type {import("../proj/Projection.js").default}\n   * @private\n   */\n  this.sourceProj_ = sourceProj;\n  /**\n   * @type {import("../proj/Projection.js").default}\n   * @private\n   */\n\n  this.targetProj_ = targetProj;\n  /** @type {!Object<string, import("../coordinate.js").Coordinate>} */\n\n  var transformInvCache = {};\n  var transformInv = Object(ol_proj["getTransform"])(this.targetProj_, this.sourceProj_);\n  /**\n   * @param {import("../coordinate.js").Coordinate} c A coordinate.\n   * @return {import("../coordinate.js").Coordinate} Transformed coordinate.\n   * @private\n   */\n\n  this.transformInv_ = function (c) {\n    var key = c[0] + \'/\' + c[1];\n\n    if (!transformInvCache[key]) {\n      transformInvCache[key] = transformInv(c);\n    }\n\n    return transformInvCache[key];\n  };\n  /**\n   * @type {import("../extent.js").Extent}\n   * @private\n   */\n\n\n  this.maxSourceExtent_ = maxSourceExtent;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n  /**\n   * @type {Array<Triangle>}\n   * @private\n   */\n\n  this.triangles_ = [];\n  /**\n   * Indicates that the triangulation crosses edge of the source projection.\n   * @type {boolean}\n   * @private\n   */\n\n  this.wrapsXInSource_ = false;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && Object(ol_extent["getWidth"])(maxSourceExtent) == Object(ol_extent["getWidth"])(this.sourceProj_.getExtent());\n  /**\n   * @type {?number}\n   * @private\n   */\n\n  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? Object(ol_extent["getWidth"])(this.sourceProj_.getExtent()) : null;\n  /**\n   * @type {?number}\n   * @private\n   */\n\n  this.targetWorldWidth_ = this.targetProj_.getExtent() ? Object(ol_extent["getWidth"])(this.targetProj_.getExtent()) : null;\n  var destinationTopLeft = Object(ol_extent["getTopLeft"])(targetExtent);\n  var destinationTopRight = Object(ol_extent["getTopRight"])(targetExtent);\n  var destinationBottomRight = Object(ol_extent["getBottomRight"])(targetExtent);\n  var destinationBottomLeft = Object(ol_extent["getBottomLeft"])(targetExtent);\n  var sourceTopLeft = this.transformInv_(destinationTopLeft);\n  var sourceTopRight = this.transformInv_(destinationTopRight);\n  var sourceBottomRight = this.transformInv_(destinationBottomRight);\n  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, MAX_SUBDIVISION);\n\n  if (this.wrapsXInSource_) {\n    var leftBound = Infinity;\n    this.triangles_.forEach(function (triangle, i, arr) {\n      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n    }); // Shift triangles to be as close to `leftBound` as possible\n    // (if the distance is more than `worldWidth / 2` it can be closer.\n\n    this.triangles_.forEach(function (triangle) {\n      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];\n\n        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[0][0] -= this.sourceWorldWidth_;\n        }\n\n        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[1][0] -= this.sourceWorldWidth_;\n        }\n\n        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n          newTriangle[2][0] -= this.sourceWorldWidth_;\n        } // Rarely (if the extent contains both the dateline and prime meridian)\n        // the shift can in turn break some triangles.\n        // Detect this here and don\'t shift in such cases.\n\n\n        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n\n        if (maxX - minX < this.sourceWorldWidth_ / 2) {\n          triangle.source = newTriangle;\n        }\n      }\n    }.bind(this));\n  }\n\n  transformInvCache = {};\n};\n/**\n * Adds triangle to the triangulation.\n * @param {import("../coordinate.js").Coordinate} a The target a coordinate.\n * @param {import("../coordinate.js").Coordinate} b The target b coordinate.\n * @param {import("../coordinate.js").Coordinate} c The target c coordinate.\n * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.\n * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.\n * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.\n * @private\n */\n\n\nTriangulation_Triangulation.prototype.addTriangle_ = function addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n  this.triangles_.push({\n    source: [aSrc, bSrc, cSrc],\n    target: [a, b, c]\n  });\n};\n/**\n * Adds quad (points in clock-wise order) to the triangulation\n * (and reprojects the vertices) if valid.\n * Performs quad subdivision if needed to increase precision.\n *\n * @param {import("../coordinate.js").Coordinate} a The target a coordinate.\n * @param {import("../coordinate.js").Coordinate} b The target b coordinate.\n * @param {import("../coordinate.js").Coordinate} c The target c coordinate.\n * @param {import("../coordinate.js").Coordinate} d The target d coordinate.\n * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.\n * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.\n * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.\n * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.\n * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n * @private\n */\n\n\nTriangulation_Triangulation.prototype.addQuad_ = function addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n  var sourceQuadExtent = Object(ol_extent["boundingExtent"])([aSrc, bSrc, cSrc, dSrc]);\n  var sourceCoverageX = this.sourceWorldWidth_ ? Object(ol_extent["getWidth"])(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n  var sourceWorldWidth =\n  /** @type {number} */\n  this.sourceWorldWidth_; // when the quad is wrapped in the source projection\n  // it covers most of the projection extent, but not fully\n\n  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;\n  var needsSubdivision = false;\n\n  if (maxSubdivision > 0) {\n    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n      var targetQuadExtent = Object(ol_extent["boundingExtent"])([a, b, c, d]);\n      var targetCoverageX = Object(ol_extent["getWidth"])(targetQuadExtent) / this.targetWorldWidth_;\n      needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n    }\n\n    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n      needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n    }\n  }\n\n  if (!needsSubdivision && this.maxSourceExtent_) {\n    if (!Object(ol_extent["intersects"])(sourceQuadExtent, this.maxSourceExtent_)) {\n      // whole quad outside source projection extent -> ignore\n      return;\n    }\n  }\n\n  if (!needsSubdivision) {\n    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n      if (maxSubdivision > 0) {\n        needsSubdivision = true;\n      } else {\n        return;\n      }\n    }\n  }\n\n  if (maxSubdivision > 0) {\n    if (!needsSubdivision) {\n      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n      var centerSrc = this.transformInv_(center);\n      var dx;\n\n      if (wrapsX) {\n        var centerSrcEstimX = (Object(math["d" /* modulo */])(aSrc[0], sourceWorldWidth) + Object(math["d" /* modulo */])(cSrc[0], sourceWorldWidth)) / 2;\n        dx = centerSrcEstimX - Object(math["d" /* modulo */])(centerSrc[0], sourceWorldWidth);\n      } else {\n        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n      }\n\n      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n      var centerSrcErrorSquared = dx * dx + dy * dy;\n      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n    }\n\n    if (needsSubdivision) {\n      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n        // split horizontally (top & bottom)\n        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n        var bcSrc = this.transformInv_(bc);\n        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n        var daSrc = this.transformInv_(da);\n        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n      } else {\n        // split vertically (left & right)\n        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n        var abSrc = this.transformInv_(ab);\n        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n        var cdSrc = this.transformInv_(cd);\n        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n      }\n\n      return;\n    }\n  }\n\n  if (wrapsX) {\n    if (!this.canWrapXInSource_) {\n      return;\n    }\n\n    this.wrapsXInSource_ = true;\n  }\n\n  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n};\n/**\n * Calculates extent of the \'source\' coordinates from all the triangles.\n *\n * @return {import("../extent.js").Extent} Calculated extent.\n */\n\n\nTriangulation_Triangulation.prototype.calculateSourceExtent = function calculateSourceExtent() {\n  var extent = Object(ol_extent["createEmpty"])();\n  this.triangles_.forEach(function (triangle, i, arr) {\n    var src = triangle.source;\n    Object(ol_extent["extendCoordinate"])(extent, src[0]);\n    Object(ol_extent["extendCoordinate"])(extent, src[1]);\n    Object(ol_extent["extendCoordinate"])(extent, src[2]);\n  });\n  return extent;\n};\n/**\n * @return {Array<Triangle>} Array of the calculated triangles.\n */\n\n\nTriangulation_Triangulation.prototype.getTriangles = function getTriangles() {\n  return this.triangles_;\n};\n\n/* harmony default export */ var reproj_Triangulation = (Triangulation_Triangulation);\n// CONCATENATED MODULE: ./node_modules/ol/reproj/Tile.js\n/**\n * @module ol/reproj/Tile\n */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\n\nvar Tile_ReprojTile =\n/*@__PURE__*/\nfunction (Tile) {\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {\n    Tile.call(this, tileCoord, TileState["a" /* default */].IDLE);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = pixelRatio;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.gutter_ = gutter;\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.canvas_ = null;\n    /**\n     * @private\n     * @type {import("../tilegrid/TileGrid.js").default}\n     */\n\n    this.sourceTileGrid_ = sourceTileGrid;\n    /**\n     * @private\n     * @type {import("../tilegrid/TileGrid.js").default}\n     */\n\n    this.targetTileGrid_ = targetTileGrid;\n    /**\n     * @private\n     * @type {import("../tilecoord.js").TileCoord}\n     */\n\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n    /**\n     * @private\n     * @type {!Array<import("../Tile.js").default>}\n     */\n\n    this.sourceTiles_ = [];\n    /**\n     * @private\n     * @type {Array<import("../events.js").EventsKey>}\n     */\n\n    this.sourcesListenerKeys_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    var maxTargetExtent = this.targetTileGrid_.getExtent();\n    var maxSourceExtent = this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? Object(ol_extent["getIntersection"])(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (Object(ol_extent["getArea"])(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState["a" /* default */].EMPTY;\n      return;\n    }\n\n    var sourceProjExtent = sourceProj.getExtent();\n\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = Object(ol_extent["getIntersection"])(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n    var targetCenter = Object(ol_extent["getCenter"])(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState["a" /* default */].EMPTY;\n      return;\n    }\n\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n    /**\n     * @private\n     * @type {!import("./Triangulation.js").default}\n     */\n\n    this.triangulation_ = new reproj_Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState["a" /* default */].EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = Object(math["a" /* clamp */])(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = Object(math["a" /* clamp */])(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = Object(ol_extent["getIntersection"])(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!Object(ol_extent["getArea"])(sourceExtent)) {\n      this.state = TileState["a" /* default */].EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);\n\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState["a" /* default */].EMPTY;\n      }\n    }\n  }\n\n  if (Tile) ReprojTile.__proto__ = Tile;\n  ReprojTile.prototype = Object.create(Tile && Tile.prototype);\n  ReprojTile.prototype.constructor = ReprojTile;\n  /**\n   * @inheritDoc\n   */\n\n  ReprojTile.prototype.disposeInternal = function disposeInternal() {\n    if (this.state == TileState["a" /* default */].LOADING) {\n      this.unlistenSources_();\n    }\n\n    Tile.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n\n\n  ReprojTile.prototype.getImage = function getImage() {\n    return this.canvas_;\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.reproject_ = function reproject_() {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState["a" /* default */].LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState["a" /* default */].ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === \'number\' ? size : size[0];\n      var height = typeof size === \'number\' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = reproj_render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);\n      this.state = TileState["a" /* default */].LOADED;\n    }\n\n    this.changed();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  ReprojTile.prototype.load = function load() {\n    if (this.state == TileState["a" /* default */].IDLE) {\n      this.state = TileState["a" /* default */].LOADING;\n      this.changed();\n      var leftToLoad = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n\n        if (state == TileState["a" /* default */].IDLE || state == TileState["a" /* default */].LOADING) {\n          leftToLoad++;\n          var sourceListenKey = Object(events["a" /* listen */])(tile, EventType["a" /* default */].CHANGE, function (e) {\n            var state = tile.getState();\n\n            if (state == TileState["a" /* default */].LOADED || state == TileState["a" /* default */].ERROR || state == TileState["a" /* default */].EMPTY) {\n              Object(events["e" /* unlistenByKey */])(sourceListenKey);\n              leftToLoad--;\n\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      }.bind(this));\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n\n        if (state == TileState["a" /* default */].IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  ReprojTile.prototype.unlistenSources_ = function unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(events["e" /* unlistenByKey */]);\n    this.sourcesListenerKeys_ = null;\n  };\n\n  return ReprojTile;\n}(ol_Tile);\n\n/* harmony default export */ var reproj_Tile = (Tile_ReprojTile);\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(11);\n\n// CONCATENATED MODULE: ./node_modules/ol/tileurlfunction.js\n/**\n * @module ol/tileurlfunction\n */\n\n\n\n/**\n * @param {string} template Template.\n * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.\n * @return {import("./Tile.js").UrlFunction} Tile URL function.\n */\n\nfunction createFromTemplate(template, tileGrid) {\n  var zRegEx = /\\{z\\}/g;\n  var xRegEx = /\\{x\\}/g;\n  var yRegEx = /\\{y\\}/g;\n  var dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import("./proj/Projection.js").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, function () {\n          var y = -tileCoord[2] - 1;\n          return y.toString();\n        }).replace(dashYRegEx, function () {\n          var z = tileCoord[0];\n          var range = tileGrid.getFullTileRange(z);\n          Object(asserts["a" /* assert */])(range, 55); // The {-y} placeholder requires a tile grid with extent\n\n          var y = range.getHeight() + tileCoord[2];\n          return y.toString();\n        });\n      }\n    }\n  );\n}\n/**\n * @param {Array<string>} templates Templates.\n * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.\n * @return {import("./Tile.js").UrlFunction} Tile URL function.\n */\n\nfunction createFromTemplates(templates, tileGrid) {\n  var len = templates.length;\n  var tileUrlFunctions = new Array(len);\n\n  for (var i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n/**\n * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import("./Tile.js").UrlFunction} Tile URL function.\n */\n\nfunction createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n\n  return (\n    /**\n     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import("./proj/Projection.js").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function (tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        var h = Object(tilecoord["e" /* hash */])(tileCoord);\n        var index = Object(math["d" /* modulo */])(h, tileUrlFunctions.length);\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n      }\n    }\n  );\n}\n/**\n * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import("./proj/Projection.js").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\n\nfunction nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\n\nfunction expandUrl(url) {\n  var urls = [];\n  var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n\n  if (match) {\n    // char range\n    var startCharCode = match[1].charCodeAt(0);\n    var stopCharCode = match[2].charCodeAt(0);\n    var charCode;\n\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n\n    return urls;\n  }\n\n  match = match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n\n  if (match) {\n    // number range\n    var stop = parseInt(match[2], 10);\n\n    for (var i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n\n    return urls;\n  }\n\n  urls.push(url);\n  return urls;\n}\n// EXTERNAL MODULE: ./node_modules/ol/events/Event.js\nvar Event = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./node_modules/ol/size.js\nvar ol_size = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./node_modules/ol/source/Source.js\nvar source_Source = __webpack_require__(94);\n\n// EXTERNAL MODULE: ./node_modules/ol/tilegrid.js + 1 modules\nvar ol_tilegrid = __webpack_require__(56);\n\n// CONCATENATED MODULE: ./node_modules/ol/source/Tile.js\n/**\n * @module ol/source/Tile\n */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {import("./Source.js").AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {boolean} [opaque]\n * @property {number} [tilePixelRatio]\n * @property {import("../proj.js").ProjectionLike} [projection]\n * @property {import("./State.js").default} [state]\n * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n * @property {string} [key]\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for sources providing images divided into a tile grid.\n * @abstract\n * @api\n */\n\nvar Tile_TileSource =\n/*@__PURE__*/\nfunction (Source) {\n  function TileSource(options) {\n    Source.call(this, {\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: options.projection,\n      state: options.state,\n      wrapX: options.wrapX\n    });\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.opaque_ = options.opaque !== undefined ? options.opaque : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;\n    /**\n     * @protected\n     * @type {import("../tilegrid/TileGrid.js").default}\n     */\n\n    this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;\n    /**\n     * @protected\n     * @type {import("../TileCache.js").default}\n     */\n\n    this.tileCache = new ol_TileCache(options.cacheSize);\n    /**\n     * @protected\n     * @type {import("../size.js").Size}\n     */\n\n    this.tmpSize = [0, 0];\n    /**\n     * @private\n     * @type {string}\n     */\n\n    this.key_ = options.key || \'\';\n    /**\n     * @protected\n     * @type {import("../Tile.js").Options}\n     */\n\n    this.tileOptions = {\n      transition: options.transition\n    };\n  }\n\n  if (Source) TileSource.__proto__ = Source;\n  TileSource.prototype = Object.create(Source && Source.prototype);\n  TileSource.prototype.constructor = TileSource;\n  /**\n   * @return {boolean} Can expire cache.\n   */\n\n  TileSource.prototype.canExpireCache = function canExpireCache() {\n    return this.tileCache.canExpireCache();\n  };\n  /**\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @param {!Object<string, import("../TileRange.js").default>} usedTiles Used tiles.\n   */\n\n\n  TileSource.prototype.expireCache = function expireCache(projection, usedTiles) {\n    var tileCache = this.getTileCacheForProjection(projection);\n\n    if (tileCache) {\n      tileCache.expireCache(usedTiles);\n    }\n  };\n  /**\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @param {number} z Zoom level.\n   * @param {import("../TileRange.js").default} tileRange Tile range.\n   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each\n   *     loaded tile.  If the callback returns `false`, the tile will not be\n   *     considered loaded.\n   * @return {boolean} The tile range is fully covered with loaded tiles.\n   */\n\n\n  TileSource.prototype.forEachLoadedTile = function forEachLoadedTile(projection, z, tileRange, callback) {\n    var tileCache = this.getTileCacheForProjection(projection);\n\n    if (!tileCache) {\n      return false;\n    }\n\n    var covered = true;\n    var tile, tileCoordKey, loaded;\n\n    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        tileCoordKey = Object(tilecoord["d" /* getKeyZXY */])(z, x, y);\n        loaded = false;\n\n        if (tileCache.containsKey(tileCoordKey)) {\n          tile =\n          /** @type {!import("../Tile.js").default} */\n          tileCache.get(tileCoordKey);\n          loaded = tile.getState() === TileState["a" /* default */].LOADED;\n\n          if (loaded) {\n            loaded = callback(tile) !== false;\n          }\n        }\n\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n\n    return covered;\n  };\n  /**\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @return {number} Gutter.\n   */\n\n\n  TileSource.prototype.getGutterForProjection = function getGutterForProjection(projection) {\n    return 0;\n  };\n  /**\n   * Return the key to be used for all tiles in the source.\n   * @return {string} The key for all tiles.\n   * @protected\n   */\n\n\n  TileSource.prototype.getKey = function getKey() {\n    return this.key_;\n  };\n  /**\n   * Set the value to be used as the key for all tiles in the source.\n   * @param {string} key The key for tiles.\n   * @protected\n   */\n\n\n  TileSource.prototype.setKey = function setKey(key) {\n    if (this.key_ !== key) {\n      this.key_ = key;\n      this.changed();\n    }\n  };\n  /**\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @return {boolean} Opaque.\n   */\n\n\n  TileSource.prototype.getOpaque = function getOpaque(projection) {\n    return this.opaque_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TileSource.prototype.getResolutions = function getResolutions() {\n    return this.tileGrid.getResolutions();\n  };\n  /**\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @return {!import("../Tile.js").default} Tile.\n   */\n\n\n  TileSource.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * Return the tile grid of the tile source.\n   * @return {import("../tilegrid/TileGrid.js").default} Tile grid.\n   * @api\n   */\n\n\n  TileSource.prototype.getTileGrid = function getTileGrid() {\n    return this.tileGrid;\n  };\n  /**\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.\n   */\n\n\n  TileSource.prototype.getTileGridForProjection = function getTileGridForProjection$1(projection) {\n    if (!this.tileGrid) {\n      return Object(ol_tilegrid["getForProjection"])(projection);\n    } else {\n      return this.tileGrid;\n    }\n  };\n  /**\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @return {import("../TileCache.js").default} Tile cache.\n   * @protected\n   */\n\n\n  TileSource.prototype.getTileCacheForProjection = function getTileCacheForProjection(projection) {\n    var thisProj = this.getProjection();\n\n    if (thisProj && !Object(ol_proj["equivalent"])(thisProj, projection)) {\n      return null;\n    } else {\n      return this.tileCache;\n    }\n  };\n  /**\n   * Get the tile pixel ratio for this source. Subclasses may override this\n   * method, which is meant to return a supported pixel ratio that matches the\n   * provided `pixelRatio` as close as possible.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n\n\n  TileSource.prototype.getTilePixelRatio = function getTilePixelRatio(pixelRatio) {\n    return this.tilePixelRatio_;\n  };\n  /**\n   * @param {number} z Z.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @return {import("../size.js").Size} Tile size.\n   */\n\n\n  TileSource.prototype.getTilePixelSize = function getTilePixelSize(z, pixelRatio, projection) {\n    var tileGrid = this.getTileGridForProjection(projection);\n    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);\n    var tileSize = Object(ol_size["c" /* toSize */])(tileGrid.getTileSize(z), this.tmpSize);\n\n    if (tilePixelRatio == 1) {\n      return tileSize;\n    } else {\n      return Object(ol_size["b" /* scale */])(tileSize, tilePixelRatio, this.tmpSize);\n    }\n  };\n  /**\n   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate\n   * is outside the resolution and extent range of the tile grid, `null` will be\n   * returned.\n   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.\n   * @param {import("../proj/Projection.js").default=} opt_projection Projection.\n   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or\n   *     null if no tile URL should be created for the passed `tileCoord`.\n   */\n\n\n  TileSource.prototype.getTileCoordForTileUrlFunction = function getTileCoordForTileUrlFunction(tileCoord, opt_projection) {\n    var projection = opt_projection !== undefined ? opt_projection : this.getProjection();\n    var tileGrid = this.getTileGridForProjection(projection);\n\n    if (this.getWrapX() && projection.isGlobal()) {\n      tileCoord = Object(ol_tilegrid["wrapX"])(tileGrid, tileCoord, projection);\n    }\n\n    return Object(tilecoord["f" /* withinExtentAndZ */])(tileCoord, tileGrid) ? tileCoord : null;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TileSource.prototype.refresh = function refresh() {\n    this.tileCache.clear();\n    this.changed();\n  };\n  /**\n   * Marks a tile coord as being used, without triggering a load.\n   * @abstract\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   */\n\n\n  TileSource.prototype.useTile = function useTile(z, x, y, projection) {};\n\n  return TileSource;\n}(source_Source["a" /* default */]);\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this\n * type.\n */\n\n\nvar TileSourceEvent =\n/*@__PURE__*/\nfunction (Event) {\n  function TileSourceEvent(type, tile) {\n    Event.call(this, type);\n    /**\n     * The tile related to the event.\n     * @type {import("../Tile.js").default}\n     * @api\n     */\n\n    this.tile = tile;\n  }\n\n  if (Event) TileSourceEvent.__proto__ = Event;\n  TileSourceEvent.prototype = Object.create(Event && Event.prototype);\n  TileSourceEvent.prototype.constructor = TileSourceEvent;\n  return TileSourceEvent;\n}(Event["a" /* default */]);\n/* harmony default export */ var source_Tile = (Tile_TileSource);\n// CONCATENATED MODULE: ./node_modules/ol/source/TileEventType.js\n/**\n * @module ol/source/TileEventType\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ var TileEventType = ({\n  /**\n   * Triggered when a tile starts loading.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart\n   * @api\n   */\n  TILELOADSTART: \'tileloadstart\',\n\n  /**\n   * Triggered when a tile finishes loading, either when its data is loaded,\n   * or when loading was aborted because the tile is no longer needed.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloadend\n   * @api\n   */\n  TILELOADEND: \'tileloadend\',\n\n  /**\n   * Triggered if tile loading results in an error.\n   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror\n   * @api\n   */\n  TILELOADERROR: \'tileloaderror\'\n});\n// CONCATENATED MODULE: ./node_modules/ol/source/UrlTile.js\n/**\n * @module ol/source/UrlTile\n */\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {import("./Source.js").AttributionLike} [attributions]\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize]\n * @property {boolean} [opaque]\n * @property {import("../proj.js").ProjectionLike} [projection]\n * @property {import("./State.js").default} [state]\n * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]\n * @property {import("../Tile.js").LoadFunction} tileLoadFunction\n * @property {number} [tilePixelRatio]\n * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]\n * @property {string} [url]\n * @property {Array<string>} [urls]\n * @property {boolean} [wrapX=true]\n * @property {number} [transition]\n * @property {string} [key]\n */\n\n/**\n * @classdesc\n * Base class for sources providing tiles divided into a tile grid over http.\n *\n * @fires import("./Tile.js").TileSourceEvent\n */\n\nvar UrlTile_UrlTile =\n/*@__PURE__*/\nfunction (TileSource) {\n  function UrlTile(options) {\n    TileSource.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tilePixelRatio: options.tilePixelRatio,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible\n    });\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.generateTileUrlFunction_ = !options.tileUrlFunction;\n    /**\n     * @protected\n     * @type {import("../Tile.js").LoadFunction}\n     */\n\n    this.tileLoadFunction = options.tileLoadFunction;\n    /**\n     * @protected\n     * @type {import("../Tile.js").UrlFunction}\n     */\n\n    this.tileUrlFunction = options.tileUrlFunction ? options.tileUrlFunction.bind(this) : nullTileUrlFunction;\n    /**\n     * @protected\n     * @type {!Array<string>|null}\n     */\n\n    this.urls = null;\n\n    if (options.urls) {\n      this.setUrls(options.urls);\n    } else if (options.url) {\n      this.setUrl(options.url);\n    }\n\n    if (options.tileUrlFunction) {\n      this.setTileUrlFunction(options.tileUrlFunction, this.key_);\n    }\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n\n\n    this.tileLoadingKeys_ = {};\n  }\n\n  if (TileSource) UrlTile.__proto__ = TileSource;\n  UrlTile.prototype = Object.create(TileSource && TileSource.prototype);\n  UrlTile.prototype.constructor = UrlTile;\n  /**\n   * Return the tile load function of the source.\n   * @return {import("../Tile.js").LoadFunction} TileLoadFunction\n   * @api\n   */\n\n  UrlTile.prototype.getTileLoadFunction = function getTileLoadFunction() {\n    return this.tileLoadFunction;\n  };\n  /**\n   * Return the tile URL function of the source.\n   * @return {import("../Tile.js").UrlFunction} TileUrlFunction\n   * @api\n   */\n\n\n  UrlTile.prototype.getTileUrlFunction = function getTileUrlFunction() {\n    return this.tileUrlFunction;\n  };\n  /**\n   * Return the URLs used for this source.\n   * When a tileUrlFunction is used instead of url or urls,\n   * null will be returned.\n   * @return {!Array<string>|null} URLs.\n   * @api\n   */\n\n\n  UrlTile.prototype.getUrls = function getUrls() {\n    return this.urls;\n  };\n  /**\n   * Handle tile change events.\n   * @param {import("../events/Event.js").default} event Event.\n   * @protected\n   */\n\n\n  UrlTile.prototype.handleTileChange = function handleTileChange(event) {\n    var tile =\n    /** @type {import("../Tile.js").default} */\n    event.target;\n    var uid = Object(util["c" /* getUid */])(tile);\n    var tileState = tile.getState();\n    var type;\n\n    if (tileState == TileState["a" /* default */].LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type = tileState == TileState["a" /* default */].ERROR ? TileEventType.TILELOADERROR : tileState == TileState["a" /* default */].LOADED || tileState == TileState["a" /* default */].ABORT ? TileEventType.TILELOADEND : undefined;\n    }\n\n    if (type != undefined) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  };\n  /**\n   * Set the tile load function of the source.\n   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.\n   * @api\n   */\n\n\n  UrlTile.prototype.setTileLoadFunction = function setTileLoadFunction(tileLoadFunction) {\n    this.tileCache.clear();\n    this.tileLoadFunction = tileLoadFunction;\n    this.changed();\n  };\n  /**\n   * Set the tile URL function of the source.\n   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.\n   * @param {string=} key Optional new tile key for the source.\n   * @api\n   */\n\n\n  UrlTile.prototype.setTileUrlFunction = function setTileUrlFunction(tileUrlFunction, key) {\n    this.tileUrlFunction = tileUrlFunction;\n    this.tileCache.pruneExceptNewestZ();\n\n    if (typeof key !== \'undefined\') {\n      this.setKey(key);\n    } else {\n      this.changed();\n    }\n  };\n  /**\n   * Set the URL to use for requests.\n   * @param {string} url URL.\n   * @api\n   */\n\n\n  UrlTile.prototype.setUrl = function setUrl(url) {\n    var urls = this.urls = expandUrl(url);\n    this.setUrls(urls);\n  };\n  /**\n   * Set the URLs to use for requests.\n   * @param {Array<string>} urls URLs.\n   * @api\n   */\n\n\n  UrlTile.prototype.setUrls = function setUrls(urls) {\n    this.urls = urls;\n    var key = urls.join(\'\\n\');\n\n    if (this.generateTileUrlFunction_) {\n      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);\n    } else {\n      this.setKey(key);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  UrlTile.prototype.useTile = function useTile(z, x, y) {\n    var tileCoordKey = Object(tilecoord["d" /* getKeyZXY */])(z, x, y);\n\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      this.tileCache.get(tileCoordKey);\n    }\n  };\n\n  return UrlTile;\n}(source_Tile);\n\n/* harmony default export */ var source_UrlTile = (UrlTile_UrlTile);\n// CONCATENATED MODULE: ./node_modules/ol/source/TileImage.js\n/**\n * @module ol/source/TileImage\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {import("./Source.js").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize=2048] Cache size.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n * access pixel data with the Canvas renderer.  See\n * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {import("../proj.js").ProjectionLike} projection Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import("./State.js").default} [state] Source state.\n * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.\n * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile\n * service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be\n * used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to\n * request out-of-bounds tiles from the server. When set to `false`, only one\n * world will be rendered. When set to `true`, tiles will be requested for one\n * world only, but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [key] Optional tile key for proper cache fetching\n */\n\n/**\n * @classdesc\n * Base class for sources providing images divided into a tile grid.\n *\n * @fires import("./Tile.js").TileSourceEvent\n * @api\n */\n\nvar TileImage_TileImage =\n/*@__PURE__*/\nfunction (UrlTile) {\n  function TileImage(options) {\n    UrlTile.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      opaque: options.opaque,\n      projection: options.projection,\n      state: options.state,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      key: options.key,\n      attributionsCollapsible: options.attributionsCollapsible\n    });\n    /**\n     * @protected\n     * @type {?string}\n     */\n\n    this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;\n    /**\n     * @protected\n     * @type {typeof ImageTile}\n     */\n\n    this.tileClass = options.tileClass !== undefined ? options.tileClass : ol_ImageTile;\n    /**\n     * @protected\n     * @type {!Object<string, TileCache>}\n     */\n\n    this.tileCacheForProjection = {};\n    /**\n     * @protected\n     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}\n     */\n\n    this.tileGridForProjection = {};\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.renderReprojectionEdges_ = false;\n  }\n\n  if (UrlTile) TileImage.__proto__ = UrlTile;\n  TileImage.prototype = Object.create(UrlTile && UrlTile.prototype);\n  TileImage.prototype.constructor = TileImage;\n  /**\n   * @inheritDoc\n   */\n\n  TileImage.prototype.canExpireCache = function canExpireCache() {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return UrlTile.prototype.canExpireCache.call(this);\n    }\n\n    if (this.tileCache.canExpireCache()) {\n      return true;\n    } else {\n      for (var key in this.tileCacheForProjection) {\n        if (this.tileCacheForProjection[key].canExpireCache()) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TileImage.prototype.expireCache = function expireCache(projection, usedTiles) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      UrlTile.prototype.expireCache.call(this, projection, usedTiles);\n      return;\n    }\n\n    var usedTileCache = this.getTileCacheForProjection(projection);\n    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n\n    for (var id in this.tileCacheForProjection) {\n      var tileCache = this.tileCacheForProjection[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TileImage.prototype.getGutterForProjection = function getGutterForProjection(projection) {\n    if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !Object(ol_proj["equivalent"])(this.getProjection(), projection)) {\n      return 0;\n    } else {\n      return this.getGutter();\n    }\n  };\n  /**\n   * @return {number} Gutter.\n   */\n\n\n  TileImage.prototype.getGutter = function getGutter() {\n    return 0;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TileImage.prototype.getOpaque = function getOpaque(projection) {\n    if (ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !Object(ol_proj["equivalent"])(this.getProjection(), projection)) {\n      return false;\n    } else {\n      return UrlTile.prototype.getOpaque.call(this, projection);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TileImage.prototype.getTileGridForProjection = function getTileGridForProjection$1(projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return UrlTile.prototype.getTileGridForProjection.call(this, projection);\n    }\n\n    var thisProj = this.getProjection();\n\n    if (this.tileGrid && (!thisProj || Object(ol_proj["equivalent"])(thisProj, projection))) {\n      return this.tileGrid;\n    } else {\n      var projKey = Object(util["c" /* getUid */])(projection);\n\n      if (!(projKey in this.tileGridForProjection)) {\n        this.tileGridForProjection[projKey] = Object(ol_tilegrid["getForProjection"])(projection);\n      }\n\n      return (\n        /** @type {!import("../tilegrid/TileGrid.js").default} */\n        this.tileGridForProjection[projKey]\n      );\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TileImage.prototype.getTileCacheForProjection = function getTileCacheForProjection(projection) {\n    if (!ENABLE_RASTER_REPROJECTION) {\n      return UrlTile.prototype.getTileCacheForProjection.call(this, projection);\n    }\n\n    var thisProj = this.getProjection();\n\n    if (!thisProj || Object(ol_proj["equivalent"])(thisProj, projection)) {\n      return this.tileCache;\n    } else {\n      var projKey = Object(util["c" /* getUid */])(projection);\n\n      if (!(projKey in this.tileCacheForProjection)) {\n        this.tileCacheForProjection[projKey] = new ol_TileCache(this.tileCache.highWaterMark);\n      }\n\n      return this.tileCacheForProjection[projKey];\n    }\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import("../proj/Projection.js").default} projection Projection.\n   * @param {string} key The key set on the tile.\n   * @return {!import("../Tile.js").default} Tile.\n   * @private\n   */\n\n\n  TileImage.prototype.createTile_ = function createTile_(z, x, y, pixelRatio, projection, key) {\n    var tileCoord = [z, x, y];\n    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n    var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;\n    var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState["a" /* default */].IDLE : TileState["a" /* default */].EMPTY, tileUrl !== undefined ? tileUrl : \'\', this.crossOrigin, this.tileLoadFunction, this.tileOptions);\n    tile.key = key;\n    Object(events["a" /* listen */])(tile, EventType["a" /* default */].CHANGE, this.handleTileChange, this);\n    return tile;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  TileImage.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var sourceProjection =\n    /** @type {!import("../proj/Projection.js").default} */\n    this.getProjection();\n\n    if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || Object(ol_proj["equivalent"])(sourceProjection, projection)) {\n      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);\n    } else {\n      var cache = this.getTileCacheForProjection(projection);\n      var tileCoord = [z, x, y];\n      var tile;\n      var tileCoordKey = Object(tilecoord["c" /* getKey */])(tileCoord);\n\n      if (cache.containsKey(tileCoordKey)) {\n        tile =\n        /** @type {!import("../Tile.js").default} */\n        cache.get(tileCoordKey);\n      }\n\n      var key = this.getKey();\n\n      if (tile && tile.key == key) {\n        return tile;\n      } else {\n        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);\n        var targetTileGrid = this.getTileGridForProjection(projection);\n        var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);\n        var newTile = new reproj_Tile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {\n          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);\n        }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);\n        newTile.key = key;\n\n        if (tile) {\n          newTile.interimTile = tile;\n          newTile.refreshInterimChain();\n          cache.replace(tileCoordKey, newTile);\n        } else {\n          cache.set(tileCoordKey, newTile);\n        }\n\n        return newTile;\n      }\n    }\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {!import("../proj/Projection.js").default} projection Projection.\n   * @return {!import("../Tile.js").default} Tile.\n   * @protected\n   */\n\n\n  TileImage.prototype.getTileInternal = function getTileInternal(z, x, y, pixelRatio, projection) {\n    var tile = null;\n    var tileCoordKey = Object(tilecoord["d" /* getKeyZXY */])(z, x, y);\n    var key = this.getKey();\n\n    if (!this.tileCache.containsKey(tileCoordKey)) {\n      tile = this.createTile_(z, x, y, pixelRatio, projection, key);\n      this.tileCache.set(tileCoordKey, tile);\n    } else {\n      tile = this.tileCache.get(tileCoordKey);\n\n      if (tile.key != key) {\n        // The source\'s params changed. If the tile has an interim tile and if we\n        // can use it then we use it. Otherwise we create a new tile.  In both\n        // cases we attempt to assign an interim tile to the new tile.\n        var interimTile = tile;\n        tile = this.createTile_(z, x, y, pixelRatio, projection, key); //make the new tile the head of the list,\n\n        if (interimTile.getState() == TileState["a" /* default */].IDLE) {\n          //the old tile hasn\'t begun loading yet, and is now outdated, so we can simply discard it\n          tile.interimTile = interimTile.interimTile;\n        } else {\n          tile.interimTile = interimTile;\n        }\n\n        tile.refreshInterimChain();\n        this.tileCache.replace(tileCoordKey, tile);\n      }\n    }\n\n    return tile;\n  };\n  /**\n   * Sets whether to render reprojection edges or not (usually for debugging).\n   * @param {boolean} render Render the edges.\n   * @api\n   */\n\n\n  TileImage.prototype.setRenderReprojectionEdges = function setRenderReprojectionEdges(render) {\n    if (!ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {\n      return;\n    }\n\n    this.renderReprojectionEdges_ = render;\n\n    for (var id in this.tileCacheForProjection) {\n      this.tileCacheForProjection[id].clear();\n    }\n\n    this.changed();\n  };\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import("../proj.js").ProjectionLike} projection Projection.\n   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n\n\n  TileImage.prototype.setTileGridForProjection = function setTileGridForProjection(projection, tilegrid) {\n    if (ENABLE_RASTER_REPROJECTION) {\n      var proj = Object(ol_proj["get"])(projection);\n\n      if (proj) {\n        var projKey = Object(util["c" /* getUid */])(proj);\n\n        if (!(projKey in this.tileGridForProjection)) {\n          this.tileGridForProjection[projKey] = tilegrid;\n        }\n      }\n    }\n  };\n\n  return TileImage;\n}(source_UrlTile);\n/**\n * @param {ImageTile} imageTile Image tile.\n * @param {string} src Source.\n */\n\n\nfunction defaultTileLoadFunction(imageTile, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */\n  imageTile.getImage().src = src;\n}\n\n/* harmony default export */ var source_TileImage = (TileImage_TileImage);\n// CONCATENATED MODULE: ./node_modules/ol/source/XYZ.js\n/**\n * @module ol/source/XYZ\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {import("./Source.js").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize=2048] Cache size.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n * access pixel data with the Canvas renderer.  See\n * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {import("../proj.js").ProjectionLike} [projection=\'EPSG:3857\'] Projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {number} [maxZoom=18] Optional max zoom level.\n * @property {number} [minZoom=0] Optional min zoom level.\n * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.\n * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.\n * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px\n * by 512px images (for retina/hidpi devices) then `tilePixelRatio`\n * should be set to `2`.\n * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.\n * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get\n * tile URL given a tile coordinate and the projection.\n * Required if url or urls are not provided.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,\n * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,\n * may be used instead of defining each one separately in the `urls` option.\n * @property {Array<string>} [urls] An array of URL templates.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n */\n\n/**\n * @classdesc\n * Layer source for tile data with URLs in a set XYZ format that are\n * defined in a URL template. By default, this follows the widely-used\n * Google grid where `x` 0 and `y` 0 are in the top left. Grids like\n * TMS where `x` 0 and `y` 0 are in the bottom left can be used by\n * using the `{-y}` placeholder in the URL template, so long as the\n * source does not have a custom tile grid. In this case,\n * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`\n * such as:\n *\n *  tileUrlFunction: function(coordinate) {\n *    return \'http://mapserver.com/\' + coordinate[0] + \'/\' +\n *        coordinate[1] + \'/\' + coordinate[2] + \'.png\';\n *    }\n *\n * @api\n */\n\nvar XYZ_XYZ =\n/*@__PURE__*/\nfunction (TileImage) {\n  function XYZ(opt_options) {\n    var options = opt_options || {};\n    var projection = options.projection !== undefined ? options.projection : \'EPSG:3857\';\n    var tileGrid = options.tileGrid !== undefined ? options.tileGrid : Object(ol_tilegrid["createXYZ"])({\n      extent: Object(ol_tilegrid["extentFromProjection"])(projection),\n      maxZoom: options.maxZoom,\n      minZoom: options.minZoom,\n      tileSize: options.tileSize\n    });\n    TileImage.call(this, {\n      attributions: options.attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      opaque: options.opaque,\n      projection: projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileGrid: tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      tilePixelRatio: options.tilePixelRatio,\n      tileUrlFunction: options.tileUrlFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      attributionsCollapsible: options.attributionsCollapsible\n    });\n  }\n\n  if (TileImage) XYZ.__proto__ = TileImage;\n  XYZ.prototype = Object.create(TileImage && TileImage.prototype);\n  XYZ.prototype.constructor = XYZ;\n  return XYZ;\n}(source_TileImage);\n\n/* harmony default export */ var source_XYZ = __webpack_exports__["default"] = (XYZ_XYZ);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9yZXByb2ovY29tbW9uLmpzP2NjYTkiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9UaWxlLmpzPzllZGEiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9JbWFnZVRpbGUuanM/MWY3ZSIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL1RpbGVDYWNoZS5qcz8xYmRlIiwid2VicGFjazovLy8uLi8uLi9zcmMvb2wvcmVwcm9qLmpzPzQ5NzAiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9yZXByb2ovVHJpYW5ndWxhdGlvbi5qcz80NjFkIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvcmVwcm9qL1RpbGUuanM/ZjYzZiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL3RpbGV1cmxmdW5jdGlvbi5qcz84OTVlIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc291cmNlL1RpbGUuanM/YzQwZiIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3NvdXJjZS9UaWxlRXZlbnRUeXBlLmpzPzUyMmYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9zb3VyY2UvVXJsVGlsZS5qcz81OGJjIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc291cmNlL1RpbGVJbWFnZS5qcz9lZjBhIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc291cmNlL1hZWi5qcz8xYzkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2ovY29tbW9uXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG1heGltdW0gYWxsb3dlZCB0aHJlc2hvbGQgIChpbiBwaXhlbHMpIGZvciByZXByb2plY3Rpb25cbiAqIHRyaWFuZ3VsYXRpb24uXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgRVJST1JfVEhSRVNIT0xEID0gMC41O1xuXG4vKipcbiAqIEVuYWJsZSBhdXRvbWF0aWMgcmVwcm9qZWN0aW9uIG9mIHJhc3RlciBzb3VyY2VzLiBEZWZhdWx0IGlzIGB0cnVlYC5cbiAqIFRPRE86IGRlY2lkZSBpZiB3ZSB3YW50IHRvIGV4cG9zZSB0aGlzIGFzIGEgYnVpbGQgZmxhZyBvciByZW1vdmUgaXRcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gPSB0cnVlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1RpbGVcbiAqL1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2Vhc2VJbn0gZnJvbSAnLi9lYXNpbmcuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9UaWxlfSBmb3IgdGhlIHRpbGUgYW5kIGFcbiAqIGB7c3RyaW5nfWAgZm9yIHRoZSB1cmwgYXMgYXJndW1lbnRzLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIHNvdXJjZS5zZXRUaWxlTG9hZEZ1bmN0aW9uKGZ1bmN0aW9uKHRpbGUsIHNyYykge1xuICogICB0aWxlLmdldEltYWdlKCkuc3JjID0gc3JjO1xuICogfSk7XG4gKiBgYGBcbiAqIEZvciBtb3JlIGZpbmUgZ3JhaW5lZCBjb250cm9sLCB0aGUgbG9hZCBmdW5jdGlvbiBjYW4gdXNlIGZldGNoIG9yIFhNTEh0dHBSZXF1ZXN0IGFuZCBpbnZvbHZlXG4gKiBlcnJvciBoYW5kbGluZzpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICdvbC9UaWxlU3RhdGUnO1xuICpcbiAqIHNvdXJjZS5zZXRUaWxlTG9hZEZ1bmN0aW9uKGZ1bmN0aW9uKHRpbGUsIHNyYykge1xuICogICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gKiAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gKiAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgZnVuY3Rpb24gKGV2dCkge1xuICogICAgIHZhciBkYXRhID0gdGhpcy5yZXNwb25zZTtcbiAqICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gKiAgICAgICB0aWxlLmdldEltYWdlKCkuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChkYXRhKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgdGlsZS5zZXRTdGF0ZShUaWxlU3RhdGUuRVJST1IpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAqICAgICB0aWxlLnNldFN0YXRlKFRpbGVTdGF0ZS5FUlJPUik7XG4gKiAgIH0pO1xuICogICB4aHIub3BlbignR0VUJywgc3JjKTtcbiAqICAgeGhyLnNlbmQoKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKFRpbGUsIHN0cmluZyl9IExvYWRGdW5jdGlvblxuICogQGFwaVxuICovXG5cbi8qKlxuICoge0BsaW5rIG1vZHVsZTpvbC9zb3VyY2UvVGlsZX5UaWxlfSBzb3VyY2VzIHVzZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSB0byBnZXRcbiAqIHRoZSB1cmwgdGhhdCBwcm92aWRlcyBhIHRpbGUgZm9yIGEgZ2l2ZW4gdGlsZSBjb29yZGluYXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC90aWxlY29vcmR+VGlsZUNvb3JkfSBmb3IgdGhlIHRpbGVcbiAqIGNvb3JkaW5hdGUsIGEgYHtudW1iZXJ9YCByZXByZXNlbnRpbmcgdGhlIHBpeGVsIHJhdGlvIGFuZCBhXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3Byb2ovUHJvamVjdGlvbn0gZm9yIHRoZSBwcm9qZWN0aW9uICBhcyBhcmd1bWVudHNcbiAqIGFuZCByZXR1cm5zIGEgYHtzdHJpbmd9YCByZXByZXNlbnRpbmcgdGhlIHRpbGUgVVJMLCBvciB1bmRlZmluZWQgaWYgbm8gdGlsZVxuICogc2hvdWxkIGJlIHJlcXVlc3RlZCBmb3IgdGhlIHBhc3NlZCB0aWxlIGNvb3JkaW5hdGUuXG4gKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKGltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZCwgbnVtYmVyLFxuICogICAgICAgICAgIGltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHQpOiAoc3RyaW5nfHVuZGVmaW5lZCl9IFVybEZ1bmN0aW9uXG4gKiBAYXBpXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbj0yNTBdIEEgZHVyYXRpb24gZm9yIHRpbGUgb3BhY2l0eVxuICogdHJhbnNpdGlvbnMgaW4gbWlsbGlzZWNvbmRzLiBBIGR1cmF0aW9uIG9mIDAgZGlzYWJsZXMgdGhlIG9wYWNpdHkgdHJhbnNpdGlvbi5cbiAqIEBhcGlcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3IgdGlsZXMuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFRpbGUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge1RpbGVTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIFRpbGUgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpbGVDb29yZCwgc3RhdGUsIG9wdF9vcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNvb3JkID0gdGlsZUNvb3JkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtUaWxlU3RhdGV9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQW4gXCJpbnRlcmltXCIgdGlsZSBmb3IgdGhpcyB0aWxlLiBUaGUgaW50ZXJpbSB0aWxlIG1heSBiZSB1c2VkIHdoaWxlIHRoaXNcbiAgICAgKiBvbmUgaXMgbG9hZGluZywgZm9yIFwic21vb3RoXCIgdHJhbnNpdGlvbnMgd2hlbiBjaGFuZ2luZyBwYXJhbXMvZGltZW5zaW9uc1xuICAgICAqIG9uIHRoZSBzb3VyY2UuXG4gICAgICogQHR5cGUge1RpbGV9XG4gICAgICovXG4gICAgdGhpcy5pbnRlcmltVGlsZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBIGtleSBhc3NpZ25lZCB0byB0aGUgdGlsZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSB0aWxlIHNvdXJjZSB0byBkZXRlcm1pbmVcbiAgICAgKiBpZiB0aGlzIHRpbGUgY2FuIGVmZmVjdGl2ZWx5IGJlIHVzZWQsIG9yIGlmIGEgbmV3IHRpbGUgc2hvdWxkIGJlIGNyZWF0ZWRcbiAgICAgKiBhbmQgdGhpcyBvbmUgYmUgdXNlZCBhcyBhbiBpbnRlcmltIHRpbGUgZm9yIHRoaXMgbmV3IHRpbGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIGZvciB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50cmFuc2l0aW9uXyA9IG9wdGlvbnMudHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkID8gMjUwIDogb3B0aW9ucy50cmFuc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogTG9va3VwIG9mIHN0YXJ0IHRpbWVzIGZvciByZW5kZXJpbmcgdHJhbnNpdGlvbnMuICBJZiB0aGUgc3RhcnQgdGltZSBpc1xuICAgICAqIGVxdWFsIHRvIC0xLCB0aGUgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zaXRpb25TdGFydHNfID0ge307XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjaGFuZ2VkKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudFR5cGUuQ0hBTkdFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEtleS5cbiAgICovXG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXkgKyAnLycgKyB0aGlzLnRpbGVDb29yZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGludGVyaW0gdGlsZSBtb3N0IHN1aXRhYmxlIGZvciByZW5kZXJpbmcgdXNpbmcgdGhlIGNoYWluIG9mIGludGVyaW1cbiAgICogdGlsZXMuIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlICBtb3N0IHJlY2VudCB0aWxlIHRoYXQgaGFzIGJlZW4gbG9hZGVkLCBpZiBub1xuICAgKiBzdWNoIHRpbGUgZXhpc3RzLCB0aGUgb3JpZ2luYWwgdGlsZSBpcyByZXR1cm5lZC5cbiAgICogQHJldHVybiB7IVRpbGV9IEJlc3QgdGlsZSBmb3IgcmVuZGVyaW5nLlxuICAgKi9cbiAgZ2V0SW50ZXJpbVRpbGUoKSB7XG4gICAgaWYgKCF0aGlzLmludGVyaW1UaWxlKSB7XG4gICAgICAvL2VtcHR5IGNoYWluXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGV0IHRpbGUgPSB0aGlzLmludGVyaW1UaWxlO1xuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgbG9hZGVkIHRpbGUgYW5kIHJldHVybiBpdC4gU2luY2UgdGhlIGNoYWluIGlzIHNvcnRlZCBpblxuICAgIC8vIGRlY3JlYXNpbmcgb3JkZXIgb2YgY3JlYXRpb24gdGltZSwgdGhlcmUgaXMgbm8gbmVlZCB0byBzZWFyY2ggdGhlIHJlbWFpbmRlclxuICAgIC8vIG9mIHRoZSBsaXN0IChhbGwgdGhvc2UgdGlsZXMgY29ycmVzcG9uZCB0byBvbGRlciByZXF1ZXN0cyBhbmQgd2lsbCBiZVxuICAgIC8vIGNsZWFuZWQgdXAgYnkgcmVmcmVzaEludGVyaW1DaGFpbilcbiAgICBkbyB7XG4gICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICB9XG4gICAgICB0aWxlID0gdGlsZS5pbnRlcmltVGlsZTtcbiAgICB9IHdoaWxlICh0aWxlKTtcblxuICAgIC8vIHdlIGNhbiBub3QgZmluZCBhIGJldHRlciB0aWxlXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR29lcyB0aHJvdWdoIHRoZSBjaGFpbiBvZiBpbnRlcmltIHRpbGVzIGFuZCBkaXNjYXJkcyBzZWN0aW9ucyBvZiB0aGUgY2hhaW5cbiAgICogdGhhdCBhcmUgbm8gbG9uZ2VyIHJlbGV2YW50LlxuICAgKi9cbiAgcmVmcmVzaEludGVyaW1DaGFpbigpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJpbVRpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdGlsZSA9IHRoaXMuaW50ZXJpbVRpbGU7XG4gICAgbGV0IHByZXYgPSAvKiogQHR5cGUge1RpbGV9ICovICh0aGlzKTtcblxuICAgIGRvIHtcbiAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAvL3dlIGhhdmUgYSBsb2FkZWQgdGlsZSwgd2UgY2FuIGRpc2NhcmQgdGhlIHJlc3Qgb2YgdGhlIGxpc3RcbiAgICAgICAgLy93ZSB3b3VsZCBjb3VsZCBhYm9ydCBhbnkgTE9BRElORyB0aWxlIHJlcXVlc3RcbiAgICAgICAgLy9vbGRlciB0aGFuIHRoaXMgdGlsZSAoaS5lLiBhbnkgTE9BRElORyB0aWxlIGZvbGxvd2luZyB0aGlzIGVudHJ5IGluIHRoZSBjaGFpbilcbiAgICAgICAgdGlsZS5pbnRlcmltVGlsZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgLy9rZWVwIHRoaXMgTE9BRElORyB0aWxlIGFueSBsb2FkZWQgdGlsZXMgbGF0ZXIgaW4gdGhlIGNoYWluIGFyZVxuICAgICAgICAvL29sZGVyIHRoYW4gdGhpcyB0aWxlLCBzbyB3ZSdyZSBzdGlsbCBpbnRlcmVzdGVkIGluIHRoZSByZXF1ZXN0XG4gICAgICAgIHByZXYgPSB0aWxlO1xuICAgICAgfSBlbHNlIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgLy90aGUgaGVhZCBvZiB0aGUgbGlzdCBpcyB0aGUgbW9zdCBjdXJyZW50IHRpbGUsIHdlIGRvbid0IG5lZWRcbiAgICAgICAgLy90byBzdGFydCBhbnkgb3RoZXIgcmVxdWVzdHMgZm9yIHRoaXMgY2hhaW5cbiAgICAgICAgcHJldi5pbnRlcmltVGlsZSA9IHRpbGUuaW50ZXJpbVRpbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2ID0gdGlsZTtcbiAgICAgIH1cbiAgICAgIHRpbGUgPSBwcmV2LmludGVyaW1UaWxlO1xuICAgIH0gd2hpbGUgKHRpbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGlsZSBjb29yZGluYXRlIGZvciB0aGlzIHRpbGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gVGhlIHRpbGUgY29vcmRpbmF0ZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUNvb3JkKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVDb29yZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtUaWxlU3RhdGV9IFN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhpcyB0aWxlLiBJZiB5b3Ugd3JpdGUgeW91ciBvd24ge0BsaW5rIG1vZHVsZTpvbC9UaWxlfkxvYWRGdW5jdGlvbiB0aWxlTG9hZEZ1bmN0aW9ufSAsXG4gICAqIGl0IGlzIGltcG9ydGFudCB0byBzZXQgdGhlIHN0YXRlIGNvcnJlY3RseSB0byB7QGxpbmsgbW9kdWxlOm9sL1RpbGVTdGF0ZX5FUlJPUn1cbiAgICogd2hlbiB0aGUgdGlsZSBjYW5ub3QgYmUgbG9hZGVkLiBPdGhlcndpc2UgdGhlIHRpbGUgY2Fubm90IGJlIHJlbW92ZWQgZnJvbVxuICAgKiB0aGUgdGlsZSBxdWV1ZSBhbmQgd2lsbCBibG9jayBvdGhlciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtUaWxlU3RhdGV9IHN0YXRlIFN0YXRlLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoZSBpbWFnZSBvciByZXRyeSBpZiBsb2FkaW5nIHByZXZpb3VzbHkgZmFpbGVkLlxuICAgKiBMb2FkaW5nIGlzIHRha2VuIGNhcmUgb2YgYnkgdGhlIHRpbGUgcXVldWUsIGFuZCBjYWxsaW5nIHRoaXMgbWV0aG9kIGlzXG4gICAqIG9ubHkgbmVlZGVkIGZvciBwcmVsb2FkaW5nIG9yIGZvciByZWxvYWRpbmcgaW4gY2FzZSBvZiBhbiBlcnJvci5cbiAgICogQGFic3RyYWN0XG4gICAqIEBhcGlcbiAgICovXG4gIGxvYWQoKSB7fVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFscGhhIHZhbHVlIGZvciByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBbiBpZCBmb3IgdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgcmVuZGVyIGZyYW1lIHRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLlxuICAgKi9cbiAgZ2V0QWxwaGEoaWQsIHRpbWUpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGxldCBzdGFydCA9IHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdO1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gdGltZTtcbiAgICAgIHRoaXMudHJhbnNpdGlvblN0YXJ0c19baWRdID0gc3RhcnQ7XG4gICAgfSBlbHNlIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gdGltZSAtIHN0YXJ0ICsgKDEwMDAgLyA2MCk7IC8vIGF2b2lkIHJlbmRlcmluZyBhdCAwXG4gICAgaWYgKGRlbHRhID49IHRoaXMudHJhbnNpdGlvbl8pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gZWFzZUluKGRlbHRhIC8gdGhpcy50cmFuc2l0aW9uXyk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgdGlsZSBpcyBpbiBhbiBhbHBoYSB0cmFuc2l0aW9uLiAgQSB0aWxlIGlzIGNvbnNpZGVyZWQgaW5cbiAgICogdHJhbnNpdGlvbiBpZiB0aWxlLmdldEFscGhhKCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQgb3IgaGFzIGJlZW4gY2FsbGVkXG4gICAqIGFuZCByZXR1cm5lZCAxLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgaXMgaW4gdHJhbnNpdGlvbi5cbiAgICovXG4gIGluVHJhbnNpdGlvbihpZCkge1xuICAgIGlmICghdGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gIT09IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgYSB0cmFuc2l0aW9uIGFzIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgQW4gaWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICovXG4gIGVuZFRyYW5zaXRpb24oaWQpIHtcbiAgICBpZiAodGhpcy50cmFuc2l0aW9uXykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uU3RhcnRzX1tpZF0gPSAtMTtcbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBUaWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL0ltYWdlVGlsZVxuICovXG5pbXBvcnQgVGlsZSBmcm9tICcuL1RpbGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW5PbmNlLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5cblxuY2xhc3MgSW1hZ2VUaWxlIGV4dGVuZHMgVGlsZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfSB0aWxlQ29vcmQgVGlsZSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge1RpbGVTdGF0ZX0gc3RhdGUgU3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgSW1hZ2Ugc291cmNlIFVSSS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjcm9zc09yaWdpbiBDcm9zcyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvbiBUaWxlIGxvYWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLk9wdGlvbnM9fSBvcHRfb3B0aW9ucyBUaWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0aWxlQ29vcmQsIHN0YXRlLCBzcmMsIGNyb3NzT3JpZ2luLCB0aWxlTG9hZEZ1bmN0aW9uLCBvcHRfb3B0aW9ucykge1xuXG4gICAgc3VwZXIodGlsZUNvb3JkLCBzdGF0ZSwgb3B0X29wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9IGNyb3NzT3JpZ2luO1xuXG4gICAgLyoqXG4gICAgICogSW1hZ2UgVVJJXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zcmNfID0gc3JjO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmltYWdlXyA9IG5ldyBJbWFnZSgpO1xuICAgIGlmIChjcm9zc09yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5pbWFnZV8uY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyA9IHRpbGVMb2FkRnVuY3Rpb247XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICB0aGlzLnVubGlzdGVuSW1hZ2VfKCk7XG4gICAgICB0aGlzLmltYWdlXyA9IGdldEJsYW5rSW1hZ2UoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW50ZXJpbVRpbGUpIHtcbiAgICAgIHRoaXMuaW50ZXJpbVRpbGUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkFCT1JUO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSFRNTCBpbWFnZSBlbGVtZW50IGZvciB0aGlzIHRpbGUgKG1heSBiZSBhIENhbnZhcywgSW1hZ2UsIG9yIFZpZGVvKS5cbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBJbWFnZS5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3JjXztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja3MgbG9hZGluZyBvciByZWFkIGVycm9ycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlRXJyb3JfKCkge1xuICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gICAgdGhpcy51bmxpc3RlbkltYWdlXygpO1xuICAgIHRoaXMuaW1hZ2VfID0gZ2V0QmxhbmtJbWFnZSgpO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrcyBzdWNjZXNzZnVsIGltYWdlIGxvYWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVJbWFnZUxvYWRfKCkge1xuICAgIGNvbnN0IGltYWdlID0gLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAodGhpcy5pbWFnZV8pO1xuICAgIGlmIChpbWFnZS5uYXR1cmFsV2lkdGggJiYgaW1hZ2UubmF0dXJhbEhlaWdodCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRU1QVFk7XG4gICAgfVxuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKiBAYXBpXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUikge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5pbWFnZV8gPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGlmICh0aGlzLmNyb3NzT3JpZ2luXyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmltYWdlXy5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW5fO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBUaWxlU3RhdGUuSURMRSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5MT0FESU5HO1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXyA9IFtcbiAgICAgICAgbGlzdGVuT25jZSh0aGlzLmltYWdlXywgRXZlbnRUeXBlLkVSUk9SLFxuICAgICAgICAgIHRoaXMuaGFuZGxlSW1hZ2VFcnJvcl8sIHRoaXMpLFxuICAgICAgICBsaXN0ZW5PbmNlKHRoaXMuaW1hZ2VfLCBFdmVudFR5cGUuTE9BRCxcbiAgICAgICAgICB0aGlzLmhhbmRsZUltYWdlTG9hZF8sIHRoaXMpXG4gICAgICBdO1xuICAgICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uXyh0aGlzLCB0aGlzLnNyY18pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkcyBldmVudCBoYW5kbGVycyB3aGljaCBsaXN0ZW4gZm9yIGxvYWQgY29tcGxldGlvbiBvciBlcnJvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlbkltYWdlXygpIHtcbiAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfVxufVxuXG5cbi8qKlxuICogR2V0IGEgMS1waXhlbCBibGFuayBpbWFnZS5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBCbGFuayBpbWFnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmxhbmtJbWFnZSgpIHtcbiAgY29uc3QgY3R4ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gIHJldHVybiBjdHguY2FudmFzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvVGlsZUNhY2hlXG4gKi9cbmltcG9ydCBMUlVDYWNoZSBmcm9tICcuL3N0cnVjdHMvTFJVQ2FjaGUuanMnO1xuaW1wb3J0IHtmcm9tS2V5LCBnZXRLZXl9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxuY2xhc3MgVGlsZUNhY2hlIGV4dGVuZHMgTFJVQ2FjaGUge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9oaWdoV2F0ZXJNYXJrIEhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9oaWdoV2F0ZXJNYXJrKSB7XG5cbiAgICBzdXBlcihvcHRfaGlnaFdhdGVyTWFyayk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0Pn0gdXNlZFRpbGVzIFVzZWQgdGlsZXMuXG4gICAqL1xuICBleHBpcmVDYWNoZSh1c2VkVGlsZXMpIHtcbiAgICB3aGlsZSAodGhpcy5jYW5FeHBpcmVDYWNoZSgpKSB7XG4gICAgICBjb25zdCB0aWxlID0gdGhpcy5wZWVrTGFzdCgpO1xuICAgICAgY29uc3QgektleSA9IHRpbGUudGlsZUNvb3JkWzBdLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoektleSBpbiB1c2VkVGlsZXMgJiYgdXNlZFRpbGVzW3pLZXldLmNvbnRhaW5zKHRpbGUudGlsZUNvb3JkKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9wKCkuZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcnVuZSBhbGwgdGlsZXMgZnJvbSB0aGUgY2FjaGUgdGhhdCBkb24ndCBoYXZlIHRoZSBzYW1lIHogYXMgdGhlIG5ld2VzdCB0aWxlLlxuICAgKi9cbiAgcHJ1bmVFeGNlcHROZXdlc3RaKCkge1xuICAgIGlmICh0aGlzLmdldENvdW50KCkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdGhpcy5wZWVrRmlyc3RLZXkoKTtcbiAgICBjb25zdCB0aWxlQ29vcmQgPSBmcm9tS2V5KGtleSk7XG4gICAgY29uc3QgeiA9IHRpbGVDb29yZFswXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odGlsZSkge1xuICAgICAgaWYgKHRpbGUudGlsZUNvb3JkWzBdICE9PSB6KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGdldEtleSh0aWxlLnRpbGVDb29yZCkpO1xuICAgICAgICB0aWxlLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFRpbGVDYWNoZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXByb2pcbiAqL1xuaW1wb3J0IHtjcmVhdGVDYW52YXNDb250ZXh0MkR9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7Y29udGFpbnNDb29yZGluYXRlLCBjcmVhdGVFbXB0eSwgZXh0ZW5kLCBnZXRIZWlnaHQsIGdldFRvcExlZnQsIGdldFdpZHRofSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge3NvbHZlTGluZWFyU3lzdGVtfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtnZXRQb2ludFJlc29sdXRpb24sIHRyYW5zZm9ybX0gZnJvbSAnLi9wcm9qLmpzJztcblxuXG4vKipcbiAqIENhbGN1bGF0ZXMgaWRlYWwgcmVzb2x1dGlvbiB0byB1c2UgZnJvbSB0aGUgc291cmNlIGluIG9yZGVyIHRvIGFjaGlldmVcbiAqIHBpeGVsIG1hcHBpbmcgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gMToxIGR1cmluZyByZXByb2plY3Rpb24uXG4gKiBUaGUgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkIHJlZ2FyZGxlc3Mgb2Ygd2hhdCByZXNvbHV0aW9uc1xuICogYXJlIGFjdHVhbGx5IGF2YWlsYWJsZSBpbiB0aGUgZGF0YXNldCAoVGlsZUdyaWQsIEltYWdlLCAuLi4pLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gdGFyZ2V0UHJvaiBUYXJnZXQgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRhcmdldENlbnRlciBUYXJnZXQgY2VudGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFJlc29sdXRpb24gVGFyZ2V0IHJlc29sdXRpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiZXN0IHJlc29sdXRpb24gdG8gdXNlLiBDYW4gYmUgKy1JbmZpbml0eSwgTmFOIG9yIDAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uKHNvdXJjZVByb2osIHRhcmdldFByb2osXG4gIHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbikge1xuXG4gIGNvbnN0IHNvdXJjZUNlbnRlciA9IHRyYW5zZm9ybSh0YXJnZXRDZW50ZXIsIHRhcmdldFByb2osIHNvdXJjZVByb2opO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgaWRlYWwgcmVzb2x1dGlvbiBvZiB0aGUgc291cmNlIGRhdGFcbiAgbGV0IHNvdXJjZVJlc29sdXRpb24gPSBnZXRQb2ludFJlc29sdXRpb24odGFyZ2V0UHJvaiwgdGFyZ2V0UmVzb2x1dGlvbiwgdGFyZ2V0Q2VudGVyKTtcblxuICBjb25zdCB0YXJnZXRNZXRlcnNQZXJVbml0ID0gdGFyZ2V0UHJvai5nZXRNZXRlcnNQZXJVbml0KCk7XG4gIGlmICh0YXJnZXRNZXRlcnNQZXJVbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VSZXNvbHV0aW9uICo9IHRhcmdldE1ldGVyc1BlclVuaXQ7XG4gIH1cbiAgY29uc3Qgc291cmNlTWV0ZXJzUGVyVW5pdCA9IHNvdXJjZVByb2ouZ2V0TWV0ZXJzUGVyVW5pdCgpO1xuICBpZiAoc291cmNlTWV0ZXJzUGVyVW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlUmVzb2x1dGlvbiAvPSBzb3VyY2VNZXRlcnNQZXJVbml0O1xuICB9XG5cbiAgLy8gQmFzZWQgb24gdGhlIHByb2plY3Rpb24gcHJvcGVydGllcywgdGhlIHBvaW50IHJlc29sdXRpb24gYXQgdGhlIHNwZWNpZmllZFxuICAvLyBjb29yZGluYXRlcyBtYXkgYmUgc2xpZ2h0bHkgZGlmZmVyZW50LiBXZSBuZWVkIHRvIHJldmVyc2UtY29tcGVuc2F0ZSB0aGlzXG4gIC8vIGluIG9yZGVyIHRvIGFjaGlldmUgb3B0aW1hbCByZXN1bHRzLlxuXG4gIGNvbnN0IHNvdXJjZUV4dGVudCA9IHNvdXJjZVByb2ouZ2V0RXh0ZW50KCk7XG4gIGlmICghc291cmNlRXh0ZW50IHx8IGNvbnRhaW5zQ29vcmRpbmF0ZShzb3VyY2VFeHRlbnQsIHNvdXJjZUNlbnRlcikpIHtcbiAgICBjb25zdCBjb21wZW5zYXRpb25GYWN0b3IgPSBnZXRQb2ludFJlc29sdXRpb24oc291cmNlUHJvaiwgc291cmNlUmVzb2x1dGlvbiwgc291cmNlQ2VudGVyKSAvXG4gICAgICAgIHNvdXJjZVJlc29sdXRpb247XG4gICAgaWYgKGlzRmluaXRlKGNvbXBlbnNhdGlvbkZhY3RvcikgJiYgY29tcGVuc2F0aW9uRmFjdG9yID4gMCkge1xuICAgICAgc291cmNlUmVzb2x1dGlvbiAvPSBjb21wZW5zYXRpb25GYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZVJlc29sdXRpb247XG59XG5cblxuLyoqXG4gKiBFbmxhcmdlIHRoZSBjbGlwcGluZyB0cmlhbmdsZSBwb2ludCBieSAxIHBpeGVsIHRvIGVuc3VyZSB0aGUgZWRnZXMgb3ZlcmxhcFxuICogaW4gb3JkZXIgdG8gbWFzayBnYXBzIGNhdXNlZCBieSBhbnRpYWxpYXNpbmcuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyb2lkWCBDZW50cm9pZCBvZiB0aGUgdHJpYW5nbGUgKHggY29vcmRpbmF0ZSBpbiBwaXhlbHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IGNlbnRyb2lkWSBDZW50cm9pZCBvZiB0aGUgdHJpYW5nbGUgKHkgY29vcmRpbmF0ZSBpbiBwaXhlbHMpLlxuICogQHBhcmFtIHtudW1iZXJ9IHggWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCAoaW4gcGl4ZWxzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgKGluIHBpeGVscykuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gTmV3IHBvaW50IDEgcHggZmFydGhlciBmcm9tIHRoZSBjZW50cm9pZC5cbiAqL1xuZnVuY3Rpb24gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgeCwgeSkge1xuICBjb25zdCBkWCA9IHggLSBjZW50cm9pZFg7XG4gIGNvbnN0IGRZID0geSAtIGNlbnRyb2lkWTtcbiAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpO1xuICByZXR1cm4gW01hdGgucm91bmQoeCArIGRYIC8gZGlzdGFuY2UpLCBNYXRoLnJvdW5kKHkgKyBkWSAvIGRpc3RhbmNlKV07XG59XG5cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBzb3VyY2UgZGF0YSBpbnRvIG5ldyBjYW52YXMgYmFzZWQgb24gdGhlIHRyaWFuZ3VsYXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFdpZHRoIG9mIHRoZSBjYW52YXMuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgY2FudmFzLlxuICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gKiBAcGFyYW0ge251bWJlcn0gc291cmNlUmVzb2x1dGlvbiBTb3VyY2UgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBzb3VyY2VFeHRlbnQgRXh0ZW50IG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRSZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50LlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3JlcHJvai9Ucmlhbmd1bGF0aW9uLmpzXCIpLmRlZmF1bHR9IHRyaWFuZ3VsYXRpb25cbiAqIENhbGN1bGF0ZWQgdHJpYW5ndWxhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8e2V4dGVudDogaW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50LFxuICogICAgICAgICAgICAgICAgIGltYWdlOiAoSFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50KX0+fSBzb3VyY2VzXG4gKiBBcnJheSBvZiBzb3VyY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGd1dHRlciBHdXR0ZXIgb2YgdGhlIHNvdXJjZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmVuZGVyRWRnZXMgUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgd2l0aCByZXByb2plY3RlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8sXG4gIHNvdXJjZVJlc29sdXRpb24sIHNvdXJjZUV4dGVudCwgdGFyZ2V0UmVzb2x1dGlvbiwgdGFyZ2V0RXh0ZW50LFxuICB0cmlhbmd1bGF0aW9uLCBzb3VyY2VzLCBndXR0ZXIsIG9wdF9yZW5kZXJFZGdlcykge1xuXG4gIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoTWF0aC5yb3VuZChwaXhlbFJhdGlvICogd2lkdGgpLFxuICAgIE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIGhlaWdodCkpO1xuXG4gIGlmIChzb3VyY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb250ZXh0LmNhbnZhcztcbiAgfVxuXG4gIGNvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cbiAgY29uc3Qgc291cmNlRGF0YUV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzcmMsIGksIGFycikge1xuICAgIGV4dGVuZChzb3VyY2VEYXRhRXh0ZW50LCBzcmMuZXh0ZW50KTtcbiAgfSk7XG5cbiAgY29uc3QgY2FudmFzV2lkdGhJblVuaXRzID0gZ2V0V2lkdGgoc291cmNlRGF0YUV4dGVudCk7XG4gIGNvbnN0IGNhbnZhc0hlaWdodEluVW5pdHMgPSBnZXRIZWlnaHQoc291cmNlRGF0YUV4dGVudCk7XG4gIGNvbnN0IHN0aXRjaENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogY2FudmFzV2lkdGhJblVuaXRzIC8gc291cmNlUmVzb2x1dGlvbiksXG4gICAgTWF0aC5yb3VuZChwaXhlbFJhdGlvICogY2FudmFzSGVpZ2h0SW5Vbml0cyAvIHNvdXJjZVJlc29sdXRpb24pKTtcblxuICBjb25zdCBzdGl0Y2hTY2FsZSA9IHBpeGVsUmF0aW8gLyBzb3VyY2VSZXNvbHV0aW9uO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzcmMsIGksIGFycikge1xuICAgIGNvbnN0IHhQb3MgPSBzcmMuZXh0ZW50WzBdIC0gc291cmNlRGF0YUV4dGVudFswXTtcbiAgICBjb25zdCB5UG9zID0gLShzcmMuZXh0ZW50WzNdIC0gc291cmNlRGF0YUV4dGVudFszXSk7XG4gICAgY29uc3Qgc3JjV2lkdGggPSBnZXRXaWR0aChzcmMuZXh0ZW50KTtcbiAgICBjb25zdCBzcmNIZWlnaHQgPSBnZXRIZWlnaHQoc3JjLmV4dGVudCk7XG5cbiAgICBzdGl0Y2hDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgIHNyYy5pbWFnZSxcbiAgICAgIGd1dHRlciwgZ3V0dGVyLFxuICAgICAgc3JjLmltYWdlLndpZHRoIC0gMiAqIGd1dHRlciwgc3JjLmltYWdlLmhlaWdodCAtIDIgKiBndXR0ZXIsXG4gICAgICB4UG9zICogc3RpdGNoU2NhbGUsIHlQb3MgKiBzdGl0Y2hTY2FsZSxcbiAgICAgIHNyY1dpZHRoICogc3RpdGNoU2NhbGUsIHNyY0hlaWdodCAqIHN0aXRjaFNjYWxlKTtcbiAgfSk7XG5cbiAgY29uc3QgdGFyZ2V0VG9wTGVmdCA9IGdldFRvcExlZnQodGFyZ2V0RXh0ZW50KTtcblxuICB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLmZvckVhY2goZnVuY3Rpb24odHJpYW5nbGUsIGksIGFycikge1xuICAgIC8qIENhbGN1bGF0ZSBhZmZpbmUgdHJhbnNmb3JtIChzcmMgLT4gZHN0KVxuICAgICAqIFJlc3VsdGluZyBtYXRyaXggY2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkaW5hdGVcbiAgICAgKiBmcm9tIGBzb3VyY2VQcm9qZWN0aW9uYCB0byBkZXN0aW5hdGlvbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBUbyBvcHRpbWl6ZSBudW1iZXIgb2YgY29udGV4dCBjYWxscyBhbmQgaW5jcmVhc2UgbnVtZXJpY2FsIHN0YWJpbGl0eSxcbiAgICAgKiB3ZSBhbHNvIGRvIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9uczpcbiAgICAgKiB0cmFucygtdG9wTGVmdEV4dGVudENvcm5lciksIHNjYWxlKDEgLyB0YXJnZXRSZXNvbHV0aW9uKSwgc2NhbGUoMSwgLTEpXG4gICAgICogaGVyZSBiZWZvcmUgc29sdmluZyB0aGUgbGluZWFyIHN5c3RlbSBzbyBbdWksIHZpXSBhcmUgcGl4ZWwgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBTcmMgcG9pbnRzOiB4aSwgeWlcbiAgICAgKiBEc3QgcG9pbnRzOiB1aSwgdmlcbiAgICAgKiBBZmZpbmUgY29lZmZpY2llbnRzOiBhaWpcbiAgICAgKlxuICAgICAqIHwgeDAgeTAgMSAgMCAgMCAwIHwgICB8YTAwfCAgIHx1MHxcbiAgICAgKiB8IHgxIHkxIDEgIDAgIDAgMCB8ICAgfGEwMXwgICB8dTF8XG4gICAgICogfCB4MiB5MiAxICAwICAwIDAgfCB4IHxhMDJ8ID0gfHUyfFxuICAgICAqIHwgIDAgIDAgMCB4MCB5MCAxIHwgICB8YTEwfCAgIHx2MHxcbiAgICAgKiB8ICAwICAwIDAgeDEgeTEgMSB8ICAgfGExMXwgICB8djF8XG4gICAgICogfCAgMCAgMCAwIHgyIHkyIDEgfCAgIHxhMTJ8ICAgfHYyfFxuICAgICAqL1xuICAgIGNvbnN0IHNvdXJjZSA9IHRyaWFuZ2xlLnNvdXJjZTtcbiAgICBjb25zdCB0YXJnZXQgPSB0cmlhbmdsZS50YXJnZXQ7XG4gICAgbGV0IHgwID0gc291cmNlWzBdWzBdLCB5MCA9IHNvdXJjZVswXVsxXTtcbiAgICBsZXQgeDEgPSBzb3VyY2VbMV1bMF0sIHkxID0gc291cmNlWzFdWzFdO1xuICAgIGxldCB4MiA9IHNvdXJjZVsyXVswXSwgeTIgPSBzb3VyY2VbMl1bMV07XG4gICAgY29uc3QgdTAgPSAodGFyZ2V0WzBdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIGNvbnN0IHYwID0gLSh0YXJnZXRbMF1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgY29uc3QgdTEgPSAodGFyZ2V0WzFdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIGNvbnN0IHYxID0gLSh0YXJnZXRbMV1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgY29uc3QgdTIgPSAodGFyZ2V0WzJdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgIGNvbnN0IHYyID0gLSh0YXJnZXRbMl1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG5cbiAgICAvLyBTaGlmdCBhbGwgdGhlIHNvdXJjZSBwb2ludHMgdG8gaW1wcm92ZSBudW1lcmljYWwgc3RhYmlsaXR5XG4gICAgLy8gb2YgYWxsIHRoZSBzdWJzZXF1ZW50IGNhbGN1bGF0aW9ucy4gVGhlIFt4MCwgeTBdIGlzIHVzZWQgaGVyZS5cbiAgICAvLyBUaGlzIGlzIGFsc28gdXNlZCB0byBzaW1wbGlmeSB0aGUgbGluZWFyIHN5c3RlbS5cbiAgICBjb25zdCBzb3VyY2VOdW1lcmljYWxTaGlmdFggPSB4MDtcbiAgICBjb25zdCBzb3VyY2VOdW1lcmljYWxTaGlmdFkgPSB5MDtcbiAgICB4MCA9IDA7XG4gICAgeTAgPSAwO1xuICAgIHgxIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WDtcbiAgICB5MSAtPSBzb3VyY2VOdW1lcmljYWxTaGlmdFk7XG4gICAgeDIgLT0gc291cmNlTnVtZXJpY2FsU2hpZnRYO1xuICAgIHkyIC09IHNvdXJjZU51bWVyaWNhbFNoaWZ0WTtcblxuICAgIGNvbnN0IGF1Z21lbnRlZE1hdHJpeCA9IFtcbiAgICAgIFt4MSwgeTEsIDAsIDAsIHUxIC0gdTBdLFxuICAgICAgW3gyLCB5MiwgMCwgMCwgdTIgLSB1MF0sXG4gICAgICBbMCwgMCwgeDEsIHkxLCB2MSAtIHYwXSxcbiAgICAgIFswLCAwLCB4MiwgeTIsIHYyIC0gdjBdXG4gICAgXTtcbiAgICBjb25zdCBhZmZpbmVDb2VmcyA9IHNvbHZlTGluZWFyU3lzdGVtKGF1Z21lbnRlZE1hdHJpeCk7XG4gICAgaWYgKCFhZmZpbmVDb2Vmcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgY2VudHJvaWRYID0gKHUwICsgdTEgKyB1MikgLyAzO1xuICAgIGNvbnN0IGNlbnRyb2lkWSA9ICh2MCArIHYxICsgdjIpIC8gMztcbiAgICBjb25zdCBwMCA9IGVubGFyZ2VDbGlwUG9pbnQoY2VudHJvaWRYLCBjZW50cm9pZFksIHUwLCB2MCk7XG4gICAgY29uc3QgcDEgPSBlbmxhcmdlQ2xpcFBvaW50KGNlbnRyb2lkWCwgY2VudHJvaWRZLCB1MSwgdjEpO1xuICAgIGNvbnN0IHAyID0gZW5sYXJnZUNsaXBQb2ludChjZW50cm9pZFgsIGNlbnRyb2lkWSwgdTIsIHYyKTtcblxuICAgIGNvbnRleHQubW92ZVRvKHAxWzBdLCBwMVsxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocDBbMF0sIHAwWzFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhwMlswXSwgcDJbMV0pO1xuICAgIGNvbnRleHQuY2xpcCgpO1xuXG4gICAgY29udGV4dC50cmFuc2Zvcm0oXG4gICAgICBhZmZpbmVDb2Vmc1swXSwgYWZmaW5lQ29lZnNbMl0sIGFmZmluZUNvZWZzWzFdLCBhZmZpbmVDb2Vmc1szXSwgdTAsIHYwKTtcblxuICAgIGNvbnRleHQudHJhbnNsYXRlKHNvdXJjZURhdGFFeHRlbnRbMF0gLSBzb3VyY2VOdW1lcmljYWxTaGlmdFgsXG4gICAgICBzb3VyY2VEYXRhRXh0ZW50WzNdIC0gc291cmNlTnVtZXJpY2FsU2hpZnRZKTtcblxuICAgIGNvbnRleHQuc2NhbGUoc291cmNlUmVzb2x1dGlvbiAvIHBpeGVsUmF0aW8sXG4gICAgICAtc291cmNlUmVzb2x1dGlvbiAvIHBpeGVsUmF0aW8pO1xuXG4gICAgY29udGV4dC5kcmF3SW1hZ2Uoc3RpdGNoQ29udGV4dC5jYW52YXMsIDAsIDApO1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9KTtcblxuICBpZiAob3B0X3JlbmRlckVkZ2VzKSB7XG4gICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG5cbiAgICB0cmlhbmd1bGF0aW9uLmdldFRyaWFuZ2xlcygpLmZvckVhY2goZnVuY3Rpb24odHJpYW5nbGUsIGksIGFycikge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdHJpYW5nbGUudGFyZ2V0O1xuICAgICAgY29uc3QgdTAgPSAodGFyZ2V0WzBdWzBdIC0gdGFyZ2V0VG9wTGVmdFswXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgY29uc3QgdjAgPSAtKHRhcmdldFswXVsxXSAtIHRhcmdldFRvcExlZnRbMV0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHUxID0gKHRhcmdldFsxXVswXSAtIHRhcmdldFRvcExlZnRbMF0pIC8gdGFyZ2V0UmVzb2x1dGlvbjtcbiAgICAgIGNvbnN0IHYxID0gLSh0YXJnZXRbMV1bMV0gLSB0YXJnZXRUb3BMZWZ0WzFdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB1MiA9ICh0YXJnZXRbMl1bMF0gLSB0YXJnZXRUb3BMZWZ0WzBdKSAvIHRhcmdldFJlc29sdXRpb247XG4gICAgICBjb25zdCB2MiA9IC0odGFyZ2V0WzJdWzFdIC0gdGFyZ2V0VG9wTGVmdFsxXSkgLyB0YXJnZXRSZXNvbHV0aW9uO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8odTEsIHYxKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHUwLCB2MCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh1MiwgdjIpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSk7XG5cbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5jYW52YXM7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcmVwcm9qL1RyaWFuZ3VsYXRpb25cbiAqL1xuaW1wb3J0IHtib3VuZGluZ0V4dGVudCwgY3JlYXRlRW1wdHksIGV4dGVuZENvb3JkaW5hdGUsIGdldEJvdHRvbUxlZnQsIGdldEJvdHRvbVJpZ2h0LFxuICBnZXRUb3BMZWZ0LCBnZXRUb3BSaWdodCwgZ2V0V2lkdGgsIGludGVyc2VjdHN9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge21vZHVsb30gZnJvbSAnLi4vbWF0aC5qcyc7XG5pbXBvcnQge2dldFRyYW5zZm9ybX0gZnJvbSAnLi4vcHJvai5qcyc7XG5cblxuLyoqXG4gKiBTaW5nbGUgdHJpYW5nbGU7IGNvbnNpc3RzIG9mIDMgc291cmNlIHBvaW50cyBhbmQgMyB0YXJnZXQgcG9pbnRzLlxuICogQHR5cGVkZWYge09iamVjdH0gVHJpYW5nbGVcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPn0gc291cmNlXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZT59IHRhcmdldFxuICovXG5cblxuLyoqXG4gKiBNYXhpbXVtIG51bWJlciBvZiBzdWJkaXZpc2lvbiBzdGVwcyBkdXJpbmcgcmFzdGVyIHJlcHJvamVjdGlvbiB0cmlhbmd1bGF0aW9uLlxuICogUHJldmVudHMgaGlnaCBtZW1vcnkgdXNhZ2UgYW5kIGxhcmdlIG51bWJlciBvZiBwcm9qNCBjYWxscyAoZm9yIGNlcnRhaW5cbiAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgYXJlYXMpLiBBdCBtb3N0IGAyKigyXnRoaXMpYCB0cmlhbmdsZXMgYXJlIGNyZWF0ZWQgZm9yXG4gKiBlYWNoIHRyaWFuZ3VsYXRlZCBleHRlbnQgKHRpbGUvaW1hZ2UpLlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuY29uc3QgTUFYX1NVQkRJVklTSU9OID0gMTA7XG5cblxuLyoqXG4gKiBNYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiB0cmlhbmdsZSByZWxhdGl2ZSB0byB3b3JsZCB3aWR0aC4gV2hlbiB0cmFuc2Zvcm1pbmdcbiAqIGNvcm5lcnMgb2Ygd29ybGQgZXh0ZW50IGJldHdlZW4gY2VydGFpbiBwcm9qZWN0aW9ucywgdGhlIHJlc3VsdGluZ1xuICogdHJpYW5ndWxhdGlvbiBzZWVtcyB0byBoYXZlIHplcm8gZXJyb3IgYW5kIG5vIHN1YmRpdmlzaW9uIGlzIHBlcmZvcm1lZC4gSWZcbiAqIHRoZSB0cmlhbmdsZSB3aWR0aCBpcyBtb3JlIHRoYW4gdGhpcyAocmVsYXRpdmUgdG8gd29ybGQgd2lkdGg7IDAtMSksXG4gKiBzdWJkaXZpc29uIGlzIGZvcmNlZCAodXAgdG8gYE1BWF9TVUJESVZJU0lPTmApLiBEZWZhdWx0IGlzIGAwLjI1YC5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IE1BWF9UUklBTkdMRV9XSURUSCA9IDAuMjU7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBjb250YWluaW5nIHRyaWFuZ3VsYXRpb24gb2YgdGhlIGdpdmVuIHRhcmdldCBleHRlbnQuXG4gKiBVc2VkIGZvciBkZXRlcm1pbmluZyBzb3VyY2UgZGF0YSBhbmQgdGhlIHJlcHJvamVjdGlvbiBpdHNlbGYuXG4gKi9cbmNsYXNzIFRyaWFuZ3VsYXRpb24ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBzb3VyY2VQcm9qIFNvdXJjZSBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IHRhcmdldEV4dGVudCBUYXJnZXQgZXh0ZW50IHRvIHRyaWFuZ3VsYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IG1heFNvdXJjZUV4dGVudCBNYXhpbWFsIHNvdXJjZSBleHRlbnQgdGhhdCBjYW4gYmUgdXNlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGVycm9yVGhyZXNob2xkIEFjY2VwdGFibGUgZXJyb3IgKGluIHNvdXJjZSB1bml0cykuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VQcm9qLCB0YXJnZXRQcm9qLCB0YXJnZXRFeHRlbnQsIG1heFNvdXJjZUV4dGVudCwgZXJyb3JUaHJlc2hvbGQpIHtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlUHJval8gPSBzb3VyY2VQcm9qO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50YXJnZXRQcm9qXyA9IHRhcmdldFByb2o7XG5cbiAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGU+fSAqL1xuICAgIGxldCB0cmFuc2Zvcm1JbnZDYWNoZSA9IHt9O1xuICAgIGNvbnN0IHRyYW5zZm9ybUludiA9IGdldFRyYW5zZm9ybSh0aGlzLnRhcmdldFByb2pfLCB0aGlzLnNvdXJjZVByb2pfKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjIEEgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFRyYW5zZm9ybWVkIGNvb3JkaW5hdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybUludl8gPSBmdW5jdGlvbihjKSB7XG4gICAgICBjb25zdCBrZXkgPSBjWzBdICsgJy8nICsgY1sxXTtcbiAgICAgIGlmICghdHJhbnNmb3JtSW52Q2FjaGVba2V5XSkge1xuICAgICAgICB0cmFuc2Zvcm1JbnZDYWNoZVtrZXldID0gdHJhbnNmb3JtSW52KGMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybUludkNhY2hlW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhTb3VyY2VFeHRlbnRfID0gbWF4U291cmNlRXh0ZW50O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JUaHJlc2hvbGRTcXVhcmVkXyA9IGVycm9yVGhyZXNob2xkICogZXJyb3JUaHJlc2hvbGQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHJpYW5nbGU+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy50cmlhbmdsZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgdHJpYW5ndWxhdGlvbiBjcm9zc2VzIGVkZ2Ugb2YgdGhlIHNvdXJjZSBwcm9qZWN0aW9uLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy53cmFwc1hJblNvdXJjZV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jYW5XcmFwWEluU291cmNlXyA9IHRoaXMuc291cmNlUHJval8uY2FuV3JhcFgoKSAmJlxuICAgICAgICAhIW1heFNvdXJjZUV4dGVudCAmJlxuICAgICAgICAhIXRoaXMuc291cmNlUHJval8uZ2V0RXh0ZW50KCkgJiZcbiAgICAgICAgKGdldFdpZHRoKG1heFNvdXJjZUV4dGVudCkgPT0gZ2V0V2lkdGgodGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSkpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9udW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfID0gdGhpcy5zb3VyY2VQcm9qXy5nZXRFeHRlbnQoKSA/XG4gICAgICBnZXRXaWR0aCh0aGlzLnNvdXJjZVByb2pfLmdldEV4dGVudCgpKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0V29ybGRXaWR0aF8gPSB0aGlzLnRhcmdldFByb2pfLmdldEV4dGVudCgpID9cbiAgICAgIGdldFdpZHRoKHRoaXMudGFyZ2V0UHJval8uZ2V0RXh0ZW50KCkpIDogbnVsbDtcblxuICAgIGNvbnN0IGRlc3RpbmF0aW9uVG9wTGVmdCA9IGdldFRvcExlZnQodGFyZ2V0RXh0ZW50KTtcbiAgICBjb25zdCBkZXN0aW5hdGlvblRvcFJpZ2h0ID0gZ2V0VG9wUmlnaHQodGFyZ2V0RXh0ZW50KTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0ID0gZ2V0Qm90dG9tUmlnaHQodGFyZ2V0RXh0ZW50KTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkJvdHRvbUxlZnQgPSBnZXRCb3R0b21MZWZ0KHRhcmdldEV4dGVudCk7XG4gICAgY29uc3Qgc291cmNlVG9wTGVmdCA9IHRoaXMudHJhbnNmb3JtSW52XyhkZXN0aW5hdGlvblRvcExlZnQpO1xuICAgIGNvbnN0IHNvdXJjZVRvcFJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uVG9wUmlnaHQpO1xuICAgIGNvbnN0IHNvdXJjZUJvdHRvbVJpZ2h0ID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRlc3RpbmF0aW9uQm90dG9tUmlnaHQpO1xuICAgIGNvbnN0IHNvdXJjZUJvdHRvbUxlZnQgPSB0aGlzLnRyYW5zZm9ybUludl8oZGVzdGluYXRpb25Cb3R0b21MZWZ0KTtcblxuICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICBkZXN0aW5hdGlvblRvcExlZnQsIGRlc3RpbmF0aW9uVG9wUmlnaHQsXG4gICAgICBkZXN0aW5hdGlvbkJvdHRvbVJpZ2h0LCBkZXN0aW5hdGlvbkJvdHRvbUxlZnQsXG4gICAgICBzb3VyY2VUb3BMZWZ0LCBzb3VyY2VUb3BSaWdodCwgc291cmNlQm90dG9tUmlnaHQsIHNvdXJjZUJvdHRvbUxlZnQsXG4gICAgICBNQVhfU1VCRElWSVNJT04pO1xuXG4gICAgaWYgKHRoaXMud3JhcHNYSW5Tb3VyY2VfKSB7XG4gICAgICBsZXQgbGVmdEJvdW5kID0gSW5maW5pdHk7XG4gICAgICB0aGlzLnRyaWFuZ2xlc18uZm9yRWFjaChmdW5jdGlvbih0cmlhbmdsZSwgaSwgYXJyKSB7XG4gICAgICAgIGxlZnRCb3VuZCA9IE1hdGgubWluKGxlZnRCb3VuZCxcbiAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMF1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVswXSwgdHJpYW5nbGUuc291cmNlWzJdWzBdKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaGlmdCB0cmlhbmdsZXMgdG8gYmUgYXMgY2xvc2UgdG8gYGxlZnRCb3VuZGAgYXMgcG9zc2libGVcbiAgICAgIC8vIChpZiB0aGUgZGlzdGFuY2UgaXMgbW9yZSB0aGFuIGB3b3JsZFdpZHRoIC8gMmAgaXQgY2FuIGJlIGNsb3Nlci5cbiAgICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlKSB7XG4gICAgICAgIGlmIChNYXRoLm1heCh0cmlhbmdsZS5zb3VyY2VbMF1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsxXVswXSxcbiAgICAgICAgICB0cmlhbmdsZS5zb3VyY2VbMl1bMF0pIC0gbGVmdEJvdW5kID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICBjb25zdCBuZXdUcmlhbmdsZSA9IFtbdHJpYW5nbGUuc291cmNlWzBdWzBdLCB0cmlhbmdsZS5zb3VyY2VbMF1bMV1dLFxuICAgICAgICAgICAgW3RyaWFuZ2xlLnNvdXJjZVsxXVswXSwgdHJpYW5nbGUuc291cmNlWzFdWzFdXSxcbiAgICAgICAgICAgIFt0cmlhbmdsZS5zb3VyY2VbMl1bMF0sIHRyaWFuZ2xlLnNvdXJjZVsyXVsxXV1dO1xuICAgICAgICAgIGlmICgobmV3VHJpYW5nbGVbMF1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzBdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgobmV3VHJpYW5nbGVbMV1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzFdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgobmV3VHJpYW5nbGVbMl1bMF0gLSBsZWZ0Qm91bmQpID4gdGhpcy5zb3VyY2VXb3JsZFdpZHRoXyAvIDIpIHtcbiAgICAgICAgICAgIG5ld1RyaWFuZ2xlWzJdWzBdIC09IHRoaXMuc291cmNlV29ybGRXaWR0aF87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmFyZWx5IChpZiB0aGUgZXh0ZW50IGNvbnRhaW5zIGJvdGggdGhlIGRhdGVsaW5lIGFuZCBwcmltZSBtZXJpZGlhbilcbiAgICAgICAgICAvLyB0aGUgc2hpZnQgY2FuIGluIHR1cm4gYnJlYWsgc29tZSB0cmlhbmdsZXMuXG4gICAgICAgICAgLy8gRGV0ZWN0IHRoaXMgaGVyZSBhbmQgZG9uJ3Qgc2hpZnQgaW4gc3VjaCBjYXNlcy5cbiAgICAgICAgICBjb25zdCBtaW5YID0gTWF0aC5taW4oXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSwgbmV3VHJpYW5nbGVbMV1bMF0sIG5ld1RyaWFuZ2xlWzJdWzBdKTtcbiAgICAgICAgICBjb25zdCBtYXhYID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBuZXdUcmlhbmdsZVswXVswXSwgbmV3VHJpYW5nbGVbMV1bMF0sIG5ld1RyaWFuZ2xlWzJdWzBdKTtcbiAgICAgICAgICBpZiAoKG1heFggLSBtaW5YKSA8IHRoaXMuc291cmNlV29ybGRXaWR0aF8gLyAyKSB7XG4gICAgICAgICAgICB0cmlhbmdsZS5zb3VyY2UgPSBuZXdUcmlhbmdsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtSW52Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRyaWFuZ2xlIHRvIHRoZSB0cmlhbmd1bGF0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYSBUaGUgdGFyZ2V0IGEgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGIgVGhlIHRhcmdldCBiIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjIFRoZSB0YXJnZXQgYyBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYVNyYyBUaGUgc291cmNlIGEgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGJTcmMgVGhlIHNvdXJjZSBiIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjU3JjIFRoZSBzb3VyY2UgYyBjb29yZGluYXRlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkVHJpYW5nbGVfKGEsIGIsIGMsIGFTcmMsIGJTcmMsIGNTcmMpIHtcbiAgICB0aGlzLnRyaWFuZ2xlc18ucHVzaCh7XG4gICAgICBzb3VyY2U6IFthU3JjLCBiU3JjLCBjU3JjXSxcbiAgICAgIHRhcmdldDogW2EsIGIsIGNdXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBxdWFkIChwb2ludHMgaW4gY2xvY2std2lzZSBvcmRlcikgdG8gdGhlIHRyaWFuZ3VsYXRpb25cbiAgICogKGFuZCByZXByb2plY3RzIHRoZSB2ZXJ0aWNlcykgaWYgdmFsaWQuXG4gICAqIFBlcmZvcm1zIHF1YWQgc3ViZGl2aXNpb24gaWYgbmVlZGVkIHRvIGluY3JlYXNlIHByZWNpc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGEgVGhlIHRhcmdldCBhIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBiIFRoZSB0YXJnZXQgYiBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYyBUaGUgdGFyZ2V0IGMgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGQgVGhlIHRhcmdldCBkIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhU3JjIFRoZSBzb3VyY2UgYSBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYlNyYyBUaGUgc291cmNlIGIgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNTcmMgVGhlIHNvdXJjZSBjIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBkU3JjIFRoZSBzb3VyY2UgZCBjb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4U3ViZGl2aXNpb24gTWF4aW1hbCBhbGxvd2VkIHN1YmRpdmlzaW9uIG9mIHRoZSBxdWFkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRkUXVhZF8oYSwgYiwgYywgZCwgYVNyYywgYlNyYywgY1NyYywgZFNyYywgbWF4U3ViZGl2aXNpb24pIHtcblxuICAgIGNvbnN0IHNvdXJjZVF1YWRFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbYVNyYywgYlNyYywgY1NyYywgZFNyY10pO1xuICAgIGNvbnN0IHNvdXJjZUNvdmVyYWdlWCA9IHRoaXMuc291cmNlV29ybGRXaWR0aF8gP1xuICAgICAgZ2V0V2lkdGgoc291cmNlUXVhZEV4dGVudCkgLyB0aGlzLnNvdXJjZVdvcmxkV2lkdGhfIDogbnVsbDtcbiAgICBjb25zdCBzb3VyY2VXb3JsZFdpZHRoID0gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnNvdXJjZVdvcmxkV2lkdGhfKTtcblxuICAgIC8vIHdoZW4gdGhlIHF1YWQgaXMgd3JhcHBlZCBpbiB0aGUgc291cmNlIHByb2plY3Rpb25cbiAgICAvLyBpdCBjb3ZlcnMgbW9zdCBvZiB0aGUgcHJvamVjdGlvbiBleHRlbnQsIGJ1dCBub3QgZnVsbHlcbiAgICBjb25zdCB3cmFwc1ggPSB0aGlzLnNvdXJjZVByb2pfLmNhbldyYXBYKCkgJiZcbiAgICAgICAgICAgICAgICAgc291cmNlQ292ZXJhZ2VYID4gMC41ICYmIHNvdXJjZUNvdmVyYWdlWCA8IDE7XG5cbiAgICBsZXQgbmVlZHNTdWJkaXZpc2lvbiA9IGZhbHNlO1xuXG4gICAgaWYgKG1heFN1YmRpdmlzaW9uID4gMCkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0UHJval8uaXNHbG9iYWwoKSAmJiB0aGlzLnRhcmdldFdvcmxkV2lkdGhfKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFF1YWRFeHRlbnQgPSBib3VuZGluZ0V4dGVudChbYSwgYiwgYywgZF0pO1xuICAgICAgICBjb25zdCB0YXJnZXRDb3ZlcmFnZVggPSBnZXRXaWR0aCh0YXJnZXRRdWFkRXh0ZW50KSAvIHRoaXMudGFyZ2V0V29ybGRXaWR0aF87XG4gICAgICAgIG5lZWRzU3ViZGl2aXNpb24gPSB0YXJnZXRDb3ZlcmFnZVggPiBNQVhfVFJJQU5HTEVfV0lEVEggfHxcbiAgICAgICAgICBuZWVkc1N1YmRpdmlzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKCF3cmFwc1ggJiYgdGhpcy5zb3VyY2VQcm9qXy5pc0dsb2JhbCgpICYmIHNvdXJjZUNvdmVyYWdlWCkge1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gc291cmNlQ292ZXJhZ2VYID4gTUFYX1RSSUFOR0xFX1dJRFRIIHx8XG4gICAgICAgICAgICBuZWVkc1N1YmRpdmlzaW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbmVlZHNTdWJkaXZpc2lvbiAmJiB0aGlzLm1heFNvdXJjZUV4dGVudF8pIHtcbiAgICAgIGlmICghaW50ZXJzZWN0cyhzb3VyY2VRdWFkRXh0ZW50LCB0aGlzLm1heFNvdXJjZUV4dGVudF8pKSB7XG4gICAgICAgIC8vIHdob2xlIHF1YWQgb3V0c2lkZSBzb3VyY2UgcHJvamVjdGlvbiBleHRlbnQgLT4gaWdub3JlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgIGlmICghaXNGaW5pdGUoYVNyY1swXSkgfHwgIWlzRmluaXRlKGFTcmNbMV0pIHx8XG4gICAgICAgICAgIWlzRmluaXRlKGJTcmNbMF0pIHx8ICFpc0Zpbml0ZShiU3JjWzFdKSB8fFxuICAgICAgICAgICFpc0Zpbml0ZShjU3JjWzBdKSB8fCAhaXNGaW5pdGUoY1NyY1sxXSkgfHxcbiAgICAgICAgICAhaXNGaW5pdGUoZFNyY1swXSkgfHwgIWlzRmluaXRlKGRTcmNbMV0pKSB7XG4gICAgICAgIGlmIChtYXhTdWJkaXZpc2lvbiA+IDApIHtcbiAgICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF4U3ViZGl2aXNpb24gPiAwKSB7XG4gICAgICBpZiAoIW5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gWyhhWzBdICsgY1swXSkgLyAyLCAoYVsxXSArIGNbMV0pIC8gMl07XG4gICAgICAgIGNvbnN0IGNlbnRlclNyYyA9IHRoaXMudHJhbnNmb3JtSW52XyhjZW50ZXIpO1xuXG4gICAgICAgIGxldCBkeDtcbiAgICAgICAgaWYgKHdyYXBzWCkge1xuICAgICAgICAgIGNvbnN0IGNlbnRlclNyY0VzdGltWCA9XG4gICAgICAgICAgICAgIChtb2R1bG8oYVNyY1swXSwgc291cmNlV29ybGRXaWR0aCkgK1xuICAgICAgICAgICAgICAgbW9kdWxvKGNTcmNbMF0sIHNvdXJjZVdvcmxkV2lkdGgpKSAvIDI7XG4gICAgICAgICAgZHggPSBjZW50ZXJTcmNFc3RpbVggLVxuICAgICAgICAgICAgICBtb2R1bG8oY2VudGVyU3JjWzBdLCBzb3VyY2VXb3JsZFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkeCA9IChhU3JjWzBdICsgY1NyY1swXSkgLyAyIC0gY2VudGVyU3JjWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR5ID0gKGFTcmNbMV0gKyBjU3JjWzFdKSAvIDIgLSBjZW50ZXJTcmNbMV07XG4gICAgICAgIGNvbnN0IGNlbnRlclNyY0Vycm9yU3F1YXJlZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBuZWVkc1N1YmRpdmlzaW9uID0gY2VudGVyU3JjRXJyb3JTcXVhcmVkID4gdGhpcy5lcnJvclRocmVzaG9sZFNxdWFyZWRfO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzU3ViZGl2aXNpb24pIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGFbMF0gLSBjWzBdKSA8PSBNYXRoLmFicyhhWzFdIC0gY1sxXSkpIHtcbiAgICAgICAgICAvLyBzcGxpdCBob3Jpem9udGFsbHkgKHRvcCAmIGJvdHRvbSlcbiAgICAgICAgICBjb25zdCBiYyA9IFsoYlswXSArIGNbMF0pIC8gMiwgKGJbMV0gKyBjWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGJjU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGJjKTtcbiAgICAgICAgICBjb25zdCBkYSA9IFsoZFswXSArIGFbMF0pIC8gMiwgKGRbMV0gKyBhWzFdKSAvIDJdO1xuICAgICAgICAgIGNvbnN0IGRhU3JjID0gdGhpcy50cmFuc2Zvcm1JbnZfKGRhKTtcblxuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBhLCBiLCBiYywgZGEsIGFTcmMsIGJTcmMsIGJjU3JjLCBkYVNyYywgbWF4U3ViZGl2aXNpb24gLSAxKTtcbiAgICAgICAgICB0aGlzLmFkZFF1YWRfKFxuICAgICAgICAgICAgZGEsIGJjLCBjLCBkLCBkYVNyYywgYmNTcmMsIGNTcmMsIGRTcmMsIG1heFN1YmRpdmlzaW9uIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3BsaXQgdmVydGljYWxseSAobGVmdCAmIHJpZ2h0KVxuICAgICAgICAgIGNvbnN0IGFiID0gWyhhWzBdICsgYlswXSkgLyAyLCAoYVsxXSArIGJbMV0pIC8gMl07XG4gICAgICAgICAgY29uc3QgYWJTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oYWIpO1xuICAgICAgICAgIGNvbnN0IGNkID0gWyhjWzBdICsgZFswXSkgLyAyLCAoY1sxXSArIGRbMV0pIC8gMl07XG4gICAgICAgICAgY29uc3QgY2RTcmMgPSB0aGlzLnRyYW5zZm9ybUludl8oY2QpO1xuXG4gICAgICAgICAgdGhpcy5hZGRRdWFkXyhcbiAgICAgICAgICAgIGEsIGFiLCBjZCwgZCwgYVNyYywgYWJTcmMsIGNkU3JjLCBkU3JjLCBtYXhTdWJkaXZpc2lvbiAtIDEpO1xuICAgICAgICAgIHRoaXMuYWRkUXVhZF8oXG4gICAgICAgICAgICBhYiwgYiwgYywgY2QsIGFiU3JjLCBiU3JjLCBjU3JjLCBjZFNyYywgbWF4U3ViZGl2aXNpb24gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdyYXBzWCkge1xuICAgICAgaWYgKCF0aGlzLmNhbldyYXBYSW5Tb3VyY2VfKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3JhcHNYSW5Tb3VyY2VfID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBjLCBkLCBhU3JjLCBjU3JjLCBkU3JjKTtcbiAgICB0aGlzLmFkZFRyaWFuZ2xlXyhhLCBiLCBjLCBhU3JjLCBiU3JjLCBjU3JjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGV4dGVudCBvZiB0aGUgJ3NvdXJjZScgY29vcmRpbmF0ZXMgZnJvbSBhbGwgdGhlIHRyaWFuZ2xlcy5cbiAgICpcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gQ2FsY3VsYXRlZCBleHRlbnQuXG4gICAqL1xuICBjYWxjdWxhdGVTb3VyY2VFeHRlbnQoKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gY3JlYXRlRW1wdHkoKTtcblxuICAgIHRoaXMudHJpYW5nbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRyaWFuZ2xlLCBpLCBhcnIpIHtcbiAgICAgIGNvbnN0IHNyYyA9IHRyaWFuZ2xlLnNvdXJjZTtcbiAgICAgIGV4dGVuZENvb3JkaW5hdGUoZXh0ZW50LCBzcmNbMF0pO1xuICAgICAgZXh0ZW5kQ29vcmRpbmF0ZShleHRlbnQsIHNyY1sxXSk7XG4gICAgICBleHRlbmRDb29yZGluYXRlKGV4dGVudCwgc3JjWzJdKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8VHJpYW5nbGU+fSBBcnJheSBvZiB0aGUgY2FsY3VsYXRlZCB0cmlhbmdsZXMuXG4gICAqL1xuICBnZXRUcmlhbmdsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJpYW5nbGVzXztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmlhbmd1bGF0aW9uO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlcHJvai9UaWxlXG4gKi9cbmltcG9ydCB7RVJST1JfVEhSRVNIT0xEfSBmcm9tICcuL2NvbW1vbi5qcyc7XG5cbmltcG9ydCBUaWxlIGZyb20gJy4uL1RpbGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVuQnlLZXl9IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4uL2V2ZW50cy9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtnZXRBcmVhLCBnZXRDZW50ZXIsIGdldEludGVyc2VjdGlvbn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4uL21hdGguanMnO1xuaW1wb3J0IHtjYWxjdWxhdGVTb3VyY2VSZXNvbHV0aW9uLCByZW5kZXIgYXMgcmVuZGVyUmVwcm9qZWN0ZWR9IGZyb20gJy4uL3JlcHJvai5qcyc7XG5pbXBvcnQgVHJpYW5ndWxhdGlvbiBmcm9tICcuL1RyaWFuZ3VsYXRpb24uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcikgOiBpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9IEZ1bmN0aW9uVHlwZVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDbGFzcyBlbmNhcHN1bGF0aW5nIHNpbmdsZSByZXByb2plY3RlZCB0aWxlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGVJbWFnZX5UaWxlSW1hZ2V9LlxuICpcbiAqL1xuY2xhc3MgUmVwcm9qVGlsZSBleHRlbmRzIFRpbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gc291cmNlUHJvaiBTb3VyY2UgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBzb3VyY2VUaWxlR3JpZCBTb3VyY2UgdGlsZSBncmlkLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSB0YXJnZXRQcm9qIFRhcmdldCBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRhcmdldFRpbGVHcmlkIFRhcmdldCB0aWxlIGdyaWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIENvb3JkaW5hdGUgb2YgdGhlIHRpbGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gd3JhcHBlZFRpbGVDb29yZCBDb29yZGluYXRlIG9mIHRoZSB0aWxlIHdyYXBwZWQgaW4gWC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBndXR0ZXIgR3V0dGVyIG9mIHRoZSBzb3VyY2UgdGlsZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb25UeXBlfSBnZXRUaWxlRnVuY3Rpb25cbiAgICogICAgIEZ1bmN0aW9uIHJldHVybmluZyBzb3VyY2UgdGlsZXMgKHosIHgsIHksIHBpeGVsUmF0aW8pLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9lcnJvclRocmVzaG9sZCBBY2NlcHRhYmxlIHJlcHJvamVjdGlvbiBlcnJvciAoaW4gcHgpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfcmVuZGVyRWRnZXMgUmVuZGVyIHJlcHJvamVjdGlvbiBlZGdlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNvdXJjZVByb2osXG4gICAgc291cmNlVGlsZUdyaWQsXG4gICAgdGFyZ2V0UHJvaixcbiAgICB0YXJnZXRUaWxlR3JpZCxcbiAgICB0aWxlQ29vcmQsXG4gICAgd3JhcHBlZFRpbGVDb29yZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIGd1dHRlcixcbiAgICBnZXRUaWxlRnVuY3Rpb24sXG4gICAgb3B0X2Vycm9yVGhyZXNob2xkLFxuICAgIG9wdF9yZW5kZXJFZGdlc1xuICApIHtcbiAgICBzdXBlcih0aWxlQ29vcmQsIFRpbGVTdGF0ZS5JRExFKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJFZGdlc18gPSBvcHRfcmVuZGVyRWRnZXMgIT09IHVuZGVmaW5lZCA/IG9wdF9yZW5kZXJFZGdlcyA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucGl4ZWxSYXRpb18gPSBwaXhlbFJhdGlvO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ3V0dGVyXyA9IGd1dHRlcjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlVGlsZUdyaWRfID0gc291cmNlVGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0VGlsZUdyaWRfID0gdGFyZ2V0VGlsZUdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi90aWxlY29vcmQuanNcIikuVGlsZUNvb3JkfVxuICAgICAqL1xuICAgIHRoaXMud3JhcHBlZFRpbGVDb29yZF8gPSB3cmFwcGVkVGlsZUNvb3JkID8gd3JhcHBlZFRpbGVDb29yZCA6IHRpbGVDb29yZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHQ+fVxuICAgICAqL1xuICAgIHRoaXMuc291cmNlVGlsZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9ldmVudHMuanNcIikuRXZlbnRzS2V5Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNvdXJjZVpfID0gMDtcblxuICAgIGNvbnN0IHRhcmdldEV4dGVudCA9IHRhcmdldFRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudCh0aGlzLndyYXBwZWRUaWxlQ29vcmRfKTtcbiAgICBjb25zdCBtYXhUYXJnZXRFeHRlbnQgPSB0aGlzLnRhcmdldFRpbGVHcmlkXy5nZXRFeHRlbnQoKTtcbiAgICBsZXQgbWF4U291cmNlRXh0ZW50ID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0RXh0ZW50KCk7XG5cbiAgICBjb25zdCBsaW1pdGVkVGFyZ2V0RXh0ZW50ID0gbWF4VGFyZ2V0RXh0ZW50ID9cbiAgICAgIGdldEludGVyc2VjdGlvbih0YXJnZXRFeHRlbnQsIG1heFRhcmdldEV4dGVudCkgOiB0YXJnZXRFeHRlbnQ7XG5cbiAgICBpZiAoZ2V0QXJlYShsaW1pdGVkVGFyZ2V0RXh0ZW50KSA9PT0gMCkge1xuICAgICAgLy8gVGlsZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgcmFuZ2UgLT4gRU1QVFlcbiAgICAgIC8vIFRPRE86IGlzIGl0IGFjdHVhbGx5IGNvcnJlY3QgdGhhdCB0aGUgc291cmNlIGV2ZW4gY3JlYXRlcyB0aGUgdGlsZSA/XG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZVByb2pFeHRlbnQgPSBzb3VyY2VQcm9qLmdldEV4dGVudCgpO1xuICAgIGlmIChzb3VyY2VQcm9qRXh0ZW50KSB7XG4gICAgICBpZiAoIW1heFNvdXJjZUV4dGVudCkge1xuICAgICAgICBtYXhTb3VyY2VFeHRlbnQgPSBzb3VyY2VQcm9qRXh0ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4U291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKG1heFNvdXJjZUV4dGVudCwgc291cmNlUHJvakV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRhcmdldFRpbGVHcmlkLmdldFJlc29sdXRpb24oXG4gICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdKTtcblxuICAgIGNvbnN0IHRhcmdldENlbnRlciA9IGdldENlbnRlcihsaW1pdGVkVGFyZ2V0RXh0ZW50KTtcbiAgICBjb25zdCBzb3VyY2VSZXNvbHV0aW9uID0gY2FsY3VsYXRlU291cmNlUmVzb2x1dGlvbihcbiAgICAgIHNvdXJjZVByb2osIHRhcmdldFByb2osIHRhcmdldENlbnRlciwgdGFyZ2V0UmVzb2x1dGlvbik7XG5cbiAgICBpZiAoIWlzRmluaXRlKHNvdXJjZVJlc29sdXRpb24pIHx8IHNvdXJjZVJlc29sdXRpb24gPD0gMCkge1xuICAgICAgLy8gaW52YWxpZCBzb3VyY2VSZXNvbHV0aW9uIC0+IEVNUFRZXG4gICAgICAvLyBwcm9iYWJseSBlZGdlcyBvZiB0aGUgcHJvamVjdGlvbnMgd2hlbiBubyBleHRlbnQgaXMgZGVmaW5lZFxuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvclRocmVzaG9sZEluUGl4ZWxzID0gb3B0X2Vycm9yVGhyZXNob2xkICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0X2Vycm9yVGhyZXNob2xkIDogRVJST1JfVEhSRVNIT0xEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IWltcG9ydChcIi4vVHJpYW5ndWxhdGlvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMudHJpYW5ndWxhdGlvbl8gPSBuZXcgVHJpYW5ndWxhdGlvbihcbiAgICAgIHNvdXJjZVByb2osIHRhcmdldFByb2osIGxpbWl0ZWRUYXJnZXRFeHRlbnQsIG1heFNvdXJjZUV4dGVudCxcbiAgICAgIHNvdXJjZVJlc29sdXRpb24gKiBlcnJvclRocmVzaG9sZEluUGl4ZWxzKTtcblxuICAgIGlmICh0aGlzLnRyaWFuZ3VsYXRpb25fLmdldFRyaWFuZ2xlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gbm8gdmFsaWQgdHJpYW5nbGVzIC0+IEVNUFRZXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc291cmNlWl8gPSBzb3VyY2VUaWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbihzb3VyY2VSZXNvbHV0aW9uKTtcbiAgICBsZXQgc291cmNlRXh0ZW50ID0gdGhpcy50cmlhbmd1bGF0aW9uXy5jYWxjdWxhdGVTb3VyY2VFeHRlbnQoKTtcblxuICAgIGlmIChtYXhTb3VyY2VFeHRlbnQpIHtcbiAgICAgIGlmIChzb3VyY2VQcm9qLmNhbldyYXBYKCkpIHtcbiAgICAgICAgc291cmNlRXh0ZW50WzFdID0gY2xhbXAoXG4gICAgICAgICAgc291cmNlRXh0ZW50WzFdLCBtYXhTb3VyY2VFeHRlbnRbMV0sIG1heFNvdXJjZUV4dGVudFszXSk7XG4gICAgICAgIHNvdXJjZUV4dGVudFszXSA9IGNsYW1wKFxuICAgICAgICAgIHNvdXJjZUV4dGVudFszXSwgbWF4U291cmNlRXh0ZW50WzFdLCBtYXhTb3VyY2VFeHRlbnRbM10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlRXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKHNvdXJjZUV4dGVudCwgbWF4U291cmNlRXh0ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdldEFyZWEoc291cmNlRXh0ZW50KSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFRpbGVTdGF0ZS5FTVBUWTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc291cmNlUmFuZ2UgPSBzb3VyY2VUaWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKFxuICAgICAgICBzb3VyY2VFeHRlbnQsIHRoaXMuc291cmNlWl8pO1xuXG4gICAgICBmb3IgKGxldCBzcmNYID0gc291cmNlUmFuZ2UubWluWDsgc3JjWCA8PSBzb3VyY2VSYW5nZS5tYXhYOyBzcmNYKyspIHtcbiAgICAgICAgZm9yIChsZXQgc3JjWSA9IHNvdXJjZVJhbmdlLm1pblk7IHNyY1kgPD0gc291cmNlUmFuZ2UubWF4WTsgc3JjWSsrKSB7XG4gICAgICAgICAgY29uc3QgdGlsZSA9IGdldFRpbGVGdW5jdGlvbih0aGlzLnNvdXJjZVpfLCBzcmNYLCBzcmNZLCBwaXhlbFJhdGlvKTtcbiAgICAgICAgICBpZiAodGlsZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VUaWxlc18ucHVzaCh0aWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkVNUFRZO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFRpbGVTdGF0ZS5MT0FESU5HKSB7XG4gICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICB9XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBIVE1MIENhbnZhcyBlbGVtZW50IGZvciB0aGlzIHRpbGUuXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMuXG4gICAqL1xuICBnZXRJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXByb2plY3RfKCkge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICB0aGlzLnNvdXJjZVRpbGVzXy5mb3JFYWNoKGZ1bmN0aW9uKHRpbGUsIGksIGFycikge1xuICAgICAgaWYgKHRpbGUgJiYgdGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHtcbiAgICAgICAgICBleHRlbnQ6IHRoaXMuc291cmNlVGlsZUdyaWRfLmdldFRpbGVDb29yZEV4dGVudCh0aWxlLnRpbGVDb29yZCksXG4gICAgICAgICAgaW1hZ2U6IHRpbGUuZ2V0SW1hZ2UoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHRoaXMuc291cmNlVGlsZXNfLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoc291cmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuRVJST1I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHogPSB0aGlzLndyYXBwZWRUaWxlQ29vcmRfWzBdO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFRpbGVTaXplKHopO1xuICAgICAgY29uc3Qgd2lkdGggPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogc2l6ZVswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiBzaXplWzFdO1xuICAgICAgY29uc3QgdGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMudGFyZ2V0VGlsZUdyaWRfLmdldFJlc29sdXRpb24oeik7XG4gICAgICBjb25zdCBzb3VyY2VSZXNvbHV0aW9uID0gdGhpcy5zb3VyY2VUaWxlR3JpZF8uZ2V0UmVzb2x1dGlvbih0aGlzLnNvdXJjZVpfKTtcblxuICAgICAgY29uc3QgdGFyZ2V0RXh0ZW50ID0gdGhpcy50YXJnZXRUaWxlR3JpZF8uZ2V0VGlsZUNvb3JkRXh0ZW50KFxuICAgICAgICB0aGlzLndyYXBwZWRUaWxlQ29vcmRfKTtcbiAgICAgIHRoaXMuY2FudmFzXyA9IHJlbmRlclJlcHJvamVjdGVkKHdpZHRoLCBoZWlnaHQsIHRoaXMucGl4ZWxSYXRpb18sXG4gICAgICAgIHNvdXJjZVJlc29sdXRpb24sIHRoaXMuc291cmNlVGlsZUdyaWRfLmdldEV4dGVudCgpLFxuICAgICAgICB0YXJnZXRSZXNvbHV0aW9uLCB0YXJnZXRFeHRlbnQsIHRoaXMudHJpYW5ndWxhdGlvbl8sIHNvdXJjZXMsXG4gICAgICAgIHRoaXMuZ3V0dGVyXywgdGhpcy5yZW5kZXJFZGdlc18pO1xuXG4gICAgICB0aGlzLnN0YXRlID0gVGlsZVN0YXRlLkxPQURFRDtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGxvYWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBUaWxlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuY2hhbmdlZCgpO1xuXG4gICAgICBsZXQgbGVmdFRvTG9hZCA9IDA7XG5cbiAgICAgIHRoaXMuc291cmNlc0xpc3RlbmVyS2V5c18gPSBbXTtcbiAgICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goZnVuY3Rpb24odGlsZSwgaSwgYXJyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUgfHwgc3RhdGUgPT0gVGlsZVN0YXRlLkxPQURJTkcpIHtcbiAgICAgICAgICBsZWZ0VG9Mb2FkKys7XG5cbiAgICAgICAgICBjb25zdCBzb3VyY2VMaXN0ZW5LZXkgPSBsaXN0ZW4odGlsZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID09IFRpbGVTdGF0ZS5FUlJPUiB8fFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9PSBUaWxlU3RhdGUuRU1QVFkpIHtcbiAgICAgICAgICAgICAgICB1bmxpc3RlbkJ5S2V5KHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgICAgICAgICAgbGVmdFRvTG9hZC0tO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnVubGlzdGVuU291cmNlc18oKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucmVwcm9qZWN0XygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXy5wdXNoKHNvdXJjZUxpc3RlbktleSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMuc291cmNlVGlsZXNfLmZvckVhY2goZnVuY3Rpb24odGlsZSwgaSwgYXJyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoc3RhdGUgPT0gVGlsZVN0YXRlLklETEUpIHtcbiAgICAgICAgICB0aWxlLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChsZWZ0VG9Mb2FkID09PSAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5yZXByb2plY3RfLmJpbmQodGhpcyksIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5saXN0ZW5Tb3VyY2VzXygpIHtcbiAgICB0aGlzLnNvdXJjZXNMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgdGhpcy5zb3VyY2VzTGlzdGVuZXJLZXlzXyA9IG51bGw7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBSZXByb2pUaWxlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3RpbGV1cmxmdW5jdGlvblxuICovXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bW9kdWxvfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHtoYXNoIGFzIHRpbGVDb29yZEhhc2h9IGZyb20gJy4vdGlsZWNvb3JkLmpzJztcblxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBUZW1wbGF0ZS5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB0aWxlR3JpZCkge1xuICBjb25zdCB6UmVnRXggPSAvXFx7elxcfS9nO1xuICBjb25zdCB4UmVnRXggPSAvXFx7eFxcfS9nO1xuICBjb25zdCB5UmVnRXggPSAvXFx7eVxcfS9nO1xuICBjb25zdCBkYXNoWVJlZ0V4ID0gL1xcey15XFx9L2c7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAoIXRpbGVDb29yZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoelJlZ0V4LCB0aWxlQ29vcmRbMF0udG9TdHJpbmcoKSlcbiAgICAgICAgICAucmVwbGFjZSh4UmVnRXgsIHRpbGVDb29yZFsxXS50b1N0cmluZygpKVxuICAgICAgICAgIC5yZXBsYWNlKHlSZWdFeCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCB5ID0gLXRpbGVDb29yZFsyXSAtIDE7XG4gICAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLnJlcGxhY2UoZGFzaFlSZWdFeCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aWxlR3JpZC5nZXRGdWxsVGlsZVJhbmdlKHopO1xuICAgICAgICAgICAgYXNzZXJ0KHJhbmdlLCA1NSk7IC8vIFRoZSB7LXl9IHBsYWNlaG9sZGVyIHJlcXVpcmVzIGEgdGlsZSBncmlkIHdpdGggZXh0ZW50XG4gICAgICAgICAgICBjb25zdCB5ID0gcmFuZ2UuZ2V0SGVpZ2h0KCkgKyB0aWxlQ29vcmRbMl07XG4gICAgICAgICAgICByZXR1cm4geS50b1N0cmluZygpO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdGVtcGxhdGVzIFRlbXBsYXRlcy5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSB0aWxlR3JpZCBUaWxlIGdyaWQuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb259IFRpbGUgVVJMIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJvbVRlbXBsYXRlcyh0ZW1wbGF0ZXMsIHRpbGVHcmlkKSB7XG4gIGNvbnN0IGxlbiA9IHRlbXBsYXRlcy5sZW5ndGg7XG4gIGNvbnN0IHRpbGVVcmxGdW5jdGlvbnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHRpbGVVcmxGdW5jdGlvbnNbaV0gPSBjcmVhdGVGcm9tVGVtcGxhdGUodGVtcGxhdGVzW2ldLCB0aWxlR3JpZCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUZyb21UaWxlVXJsRnVuY3Rpb25zKHRpbGVVcmxGdW5jdGlvbnMpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoXCIuL1RpbGUuanNcIikuVXJsRnVuY3Rpb24+fSB0aWxlVXJsRnVuY3Rpb25zIFRpbGUgVVJMIEZ1bmN0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZSBVUkwgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tVGlsZVVybEZ1bmN0aW9ucyh0aWxlVXJsRnVuY3Rpb25zKSB7XG4gIGlmICh0aWxlVXJsRnVuY3Rpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aWxlVXJsRnVuY3Rpb25zWzBdO1xuICB9XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IHRpbGVDb29yZCBUaWxlIENvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGlsZSBVUkwuXG4gICAgICovXG4gICAgZnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgICBpZiAoIXRpbGVDb29yZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaCA9IHRpbGVDb29yZEhhc2godGlsZUNvb3JkKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBtb2R1bG8oaCwgdGlsZVVybEZ1bmN0aW9ucy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGlsZVVybEZ1bmN0aW9uc1tpbmRleF0odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaWxlIFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxUaWxlVXJsRnVuY3Rpb24odGlsZUNvb3JkLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTC5cbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEFycmF5IG9mIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRVcmwodXJsKSB7XG4gIGNvbnN0IHVybHMgPSBbXTtcbiAgbGV0IG1hdGNoID0gL1xceyhbYS16XSktKFthLXpdKVxcfS8uZXhlYyh1cmwpO1xuICBpZiAobWF0Y2gpIHtcbiAgICAvLyBjaGFyIHJhbmdlXG4gICAgY29uc3Qgc3RhcnRDaGFyQ29kZSA9IG1hdGNoWzFdLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3Qgc3RvcENoYXJDb2RlID0gbWF0Y2hbMl0uY2hhckNvZGVBdCgwKTtcbiAgICBsZXQgY2hhckNvZGU7XG4gICAgZm9yIChjaGFyQ29kZSA9IHN0YXJ0Q2hhckNvZGU7IGNoYXJDb2RlIDw9IHN0b3BDaGFyQ29kZTsgKytjaGFyQ29kZSkge1xuICAgICAgdXJscy5wdXNoKHVybC5yZXBsYWNlKG1hdGNoWzBdLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfVxuICBtYXRjaCA9IG1hdGNoID0gL1xceyhcXGQrKS0oXFxkKylcXH0vLmV4ZWModXJsKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgLy8gbnVtYmVyIHJhbmdlXG4gICAgY29uc3Qgc3RvcCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgZm9yIChsZXQgaSA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7IGkgPD0gc3RvcDsgaSsrKSB7XG4gICAgICB1cmxzLnB1c2godXJsLnJlcGxhY2UobWF0Y2hbMF0sIGkudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJscztcbiAgfVxuICB1cmxzLnB1c2godXJsKTtcbiAgcmV0dXJuIHVybHM7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1RpbGVcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgVGlsZUNhY2hlIGZyb20gJy4uL1RpbGVDYWNoZS5qcyc7XG5pbXBvcnQgVGlsZVN0YXRlIGZyb20gJy4uL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQgRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCB7ZXF1aXZhbGVudH0gZnJvbSAnLi4vcHJvai5qcyc7XG5pbXBvcnQge3RvU2l6ZSwgc2NhbGUgYXMgc2NhbGVTaXplfSBmcm9tICcuLi9zaXplLmpzJztcbmltcG9ydCBTb3VyY2UgZnJvbSAnLi9Tb3VyY2UuanMnO1xuaW1wb3J0IHtnZXRLZXlaWFksIHdpdGhpbkV4dGVudEFuZFp9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge3dyYXBYLCBnZXRGb3JQcm9qZWN0aW9uIGFzIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbn0gZnJvbSAnLi4vdGlsZWdyaWQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9Tb3VyY2UuanNcIikuQXR0cmlidXRpb25MaWtlfSBbYXR0cmlidXRpb25zXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXR0cmlidXRpb25zQ29sbGFwc2libGU9dHJ1ZV0gQXR0cmlidXRpb25zIGFyZSBjb2xsYXBzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2FjaGVTaXplXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aWxlUGl4ZWxSYXRpb11cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3RhdGUuanNcIikuZGVmYXVsdH0gW3N0YXRlXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3M7IG5vcm1hbGx5IG9ubHkgdXNlZCBmb3IgY3JlYXRpbmcgc3ViY2xhc3NlcyBhbmQgbm90XG4gKiBpbnN0YW50aWF0ZWQgaW4gYXBwcy5cbiAqIEJhc2UgY2xhc3MgZm9yIHNvdXJjZXMgcHJvdmlkaW5nIGltYWdlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQuXG4gKiBAYWJzdHJhY3RcbiAqIEBhcGlcbiAqL1xuY2xhc3MgVGlsZVNvdXJjZSBleHRlbmRzIFNvdXJjZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgU291cmNlVGlsZSBzb3VyY2Ugb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogb3B0aW9ucy5hdHRyaWJ1dGlvbnMsXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZSxcbiAgICAgIHByb2plY3Rpb246IG9wdGlvbnMucHJvamVjdGlvbixcbiAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFhcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vcGFxdWVfID0gb3B0aW9ucy5vcGFxdWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3BhcXVlIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWxlUGl4ZWxSYXRpb18gPSBvcHRpb25zLnRpbGVQaXhlbFJhdGlvICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50aWxlR3JpZCA9IG9wdGlvbnMudGlsZUdyaWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGlsZUdyaWQgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlQ2FjaGUuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDYWNoZSA9IG5ldyBUaWxlQ2FjaGUob3B0aW9ucy5jYWNoZVNpemUpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy50bXBTaXplID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5XyA9IG9wdGlvbnMua2V5IHx8ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLk9wdGlvbnN9XG4gICAgICovXG4gICAgdGhpcy50aWxlT3B0aW9ucyA9IHt0cmFuc2l0aW9uOiBvcHRpb25zLnRyYW5zaXRpb259O1xuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIGV4cGlyZSBjYWNoZS5cbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZS5jYW5FeHBpcmVDYWNoZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHQ+fSB1c2VkVGlsZXMgVXNlZCB0aWxlcy5cbiAgICovXG4gIGV4cGlyZUNhY2hlKHByb2plY3Rpb24sIHVzZWRUaWxlcykge1xuICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZUNhY2hlKSB7XG4gICAgICB0aWxlQ2FjaGUuZXhwaXJlQ2FjaGUodXNlZFRpbGVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBab29tIGxldmVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0fSB0aWxlUmFuZ2UgVGlsZSByYW5nZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHQpOihib29sZWFufHZvaWQpfSBjYWxsYmFjayBDYWxsZWQgd2l0aCBlYWNoXG4gICAqICAgICBsb2FkZWQgdGlsZS4gIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRoZSB0aWxlIHdpbGwgbm90IGJlXG4gICAqICAgICBjb25zaWRlcmVkIGxvYWRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHRpbGUgcmFuZ2UgaXMgZnVsbHkgY292ZXJlZCB3aXRoIGxvYWRlZCB0aWxlcy5cbiAgICovXG4gIGZvckVhY2hMb2FkZWRUaWxlKHByb2plY3Rpb24sIHosIHRpbGVSYW5nZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0aWxlQ2FjaGUgPSB0aGlzLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgaWYgKCF0aWxlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY292ZXJlZCA9IHRydWU7XG4gICAgbGV0IHRpbGUsIHRpbGVDb29yZEtleSwgbG9hZGVkO1xuICAgIGZvciAobGV0IHggPSB0aWxlUmFuZ2UubWluWDsgeCA8PSB0aWxlUmFuZ2UubWF4WDsgKyt4KSB7XG4gICAgICBmb3IgKGxldCB5ID0gdGlsZVJhbmdlLm1pblk7IHkgPD0gdGlsZVJhbmdlLm1heFk7ICsreSkge1xuICAgICAgICB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgICAgICB0aWxlID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpKTtcbiAgICAgICAgICBsb2FkZWQgPSB0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5MT0FERUQ7XG4gICAgICAgICAgaWYgKGxvYWRlZCkge1xuICAgICAgICAgICAgbG9hZGVkID0gKGNhbGxiYWNrKHRpbGUpICE9PSBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgY292ZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3ZlcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gICAqL1xuICBnZXRHdXR0ZXJGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGtleSB0byBiZSB1c2VkIGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUga2V5IGZvciBhbGwgdGlsZXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlfO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdmFsdWUgdG8gYmUgdXNlZCBhcyB0aGUga2V5IGZvciBhbGwgdGlsZXMgaW4gdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aWxlcy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0S2V5KGtleSkge1xuICAgIGlmICh0aGlzLmtleV8gIT09IGtleSkge1xuICAgICAgdGhpcy5rZXlfID0ga2V5O1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gT3BhcXVlLlxuICAgKi9cbiAgZ2V0T3BhcXVlKHByb2plY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5vcGFxdWVfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRSZXNvbHV0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlR3JpZC5nZXRSZXNvbHV0aW9ucygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSBUaWxlLlxuICAgKi9cbiAgZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0aWxlIGdyaWQgb2YgdGhlIHRpbGUgc291cmNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBUaWxlIGdyaWQuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFRpbGUgZ3JpZC5cbiAgICovXG4gIGdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLnRpbGVHcmlkKSB7XG4gICAgICByZXR1cm4gZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50aWxlR3JpZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9UaWxlQ2FjaGUuanNcIikuZGVmYXVsdH0gVGlsZSBjYWNoZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgY29uc3QgdGhpc1Byb2ogPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICBpZiAodGhpc1Byb2ogJiYgIWVxdWl2YWxlbnQodGhpc1Byb2osIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRpbGUgcGl4ZWwgcmF0aW8gZm9yIHRoaXMgc291cmNlLiBTdWJjbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzXG4gICAqIG1ldGhvZCwgd2hpY2ggaXMgbWVhbnQgdG8gcmV0dXJuIGEgc3VwcG9ydGVkIHBpeGVsIHJhdGlvIHRoYXQgbWF0Y2hlcyB0aGVcbiAgICogcHJvdmlkZWQgYHBpeGVsUmF0aW9gIGFzIGNsb3NlIGFzIHBvc3NpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaWxlIHBpeGVsIHJhdGlvLlxuICAgKi9cbiAgZ2V0VGlsZVBpeGVsUmF0aW8ocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiB0aGlzLnRpbGVQaXhlbFJhdGlvXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geiBaLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFRpbGUgc2l6ZS5cbiAgICovXG4gIGdldFRpbGVQaXhlbFNpemUoeiwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgY29uc3QgdGlsZVBpeGVsUmF0aW8gPSB0aGlzLmdldFRpbGVQaXhlbFJhdGlvKHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IHRpbGVTaXplID0gdG9TaXplKHRpbGVHcmlkLmdldFRpbGVTaXplKHopLCB0aGlzLnRtcFNpemUpO1xuICAgIGlmICh0aWxlUGl4ZWxSYXRpbyA9PSAxKSB7XG4gICAgICByZXR1cm4gdGlsZVNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzY2FsZVNpemUodGlsZVNpemUsIHRpbGVQaXhlbFJhdGlvLCB0aGlzLnRtcFNpemUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGlsZSBjb29yZGluYXRlIHdyYXBwZWQgYXJvdW5kIHRoZSB4LWF4aXMuIFdoZW4gdGhlIHRpbGUgY29vcmRpbmF0ZVxuICAgKiBpcyBvdXRzaWRlIHRoZSByZXNvbHV0aW9uIGFuZCBleHRlbnQgcmFuZ2Ugb2YgdGhlIHRpbGUgZ3JpZCwgYG51bGxgIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vdGlsZWNvb3JkLmpzXCIpLlRpbGVDb29yZH0gdGlsZUNvb3JkIFRpbGUgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdD19IG9wdF9wcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3RpbGVjb29yZC5qc1wiKS5UaWxlQ29vcmR9IFRpbGUgY29vcmRpbmF0ZSB0byBiZSBwYXNzZWQgdG8gdGhlIHRpbGVVcmxGdW5jdGlvbiBvclxuICAgKiAgICAgbnVsbCBpZiBubyB0aWxlIFVSTCBzaG91bGQgYmUgY3JlYXRlZCBmb3IgdGhlIHBhc3NlZCBgdGlsZUNvb3JkYC5cbiAgICovXG4gIGdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbih0aWxlQ29vcmQsIG9wdF9wcm9qZWN0aW9uKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IG9wdF9wcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0X3Byb2plY3Rpb24gOiB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHRoaXMuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGlmICh0aGlzLmdldFdyYXBYKCkgJiYgcHJvamVjdGlvbi5pc0dsb2JhbCgpKSB7XG4gICAgICB0aWxlQ29vcmQgPSB3cmFwWCh0aWxlR3JpZCwgdGlsZUNvb3JkLCBwcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHdpdGhpbkV4dGVudEFuZFoodGlsZUNvb3JkLCB0aWxlR3JpZCkgPyB0aWxlQ29vcmQgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMudGlsZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgYSB0aWxlIGNvb3JkIGFzIGJlaW5nIHVzZWQsIHdpdGhvdXQgdHJpZ2dlcmluZyBhIGxvYWQuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0geiBUaWxlIGNvb3JkaW5hdGUgei5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggVGlsZSBjb29yZGluYXRlIHguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRpbGUgY29vcmRpbmF0ZSB5LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBwcm9qZWN0aW9uIFByb2plY3Rpb24uXG4gICAqL1xuICB1c2VUaWxlKHosIHgsIHksIHByb2plY3Rpb24pIHt9XG5cbn1cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvc291cmNlL1RpbGV+VGlsZVNvdXJjZX0gaW5zdGFuY2VzIGFyZSBpbnN0YW5jZXMgb2YgdGhpc1xuICogdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRpbGVTb3VyY2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlIFRoZSB0aWxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgdGlsZSkge1xuXG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGlsZSByZWxhdGVkIHRvIHRoZSBldmVudC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLnRpbGUgPSB0aWxlO1xuXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlU291cmNlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3NvdXJjZS9UaWxlRXZlbnRUeXBlXG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgdGlsZSBzdGFydHMgbG9hZGluZy5cbiAgICogQGV2ZW50IG1vZHVsZTpvbC9zb3VyY2UvVGlsZS5UaWxlU291cmNlRXZlbnQjdGlsZWxvYWRzdGFydFxuICAgKiBAYXBpXG4gICAqL1xuICBUSUxFTE9BRFNUQVJUOiAndGlsZWxvYWRzdGFydCcsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB3aGVuIGEgdGlsZSBmaW5pc2hlcyBsb2FkaW5nLCBlaXRoZXIgd2hlbiBpdHMgZGF0YSBpcyBsb2FkZWQsXG4gICAqIG9yIHdoZW4gbG9hZGluZyB3YXMgYWJvcnRlZCBiZWNhdXNlIHRoZSB0aWxlIGlzIG5vIGxvbmdlciBuZWVkZWQuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGUuVGlsZVNvdXJjZUV2ZW50I3RpbGVsb2FkZW5kXG4gICAqIEBhcGlcbiAgICovXG4gIFRJTEVMT0FERU5EOiAndGlsZWxvYWRlbmQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgaWYgdGlsZSBsb2FkaW5nIHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4gICAqIEBldmVudCBtb2R1bGU6b2wvc291cmNlL1RpbGUuVGlsZVNvdXJjZUV2ZW50I3RpbGVsb2FkZXJyb3JcbiAgICogQGFwaVxuICAgKi9cbiAgVElMRUxPQURFUlJPUjogJ3RpbGVsb2FkZXJyb3InXG5cbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1VybFRpbGVcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IHtleHBhbmRVcmwsIGNyZWF0ZUZyb21UZW1wbGF0ZXMsIG51bGxUaWxlVXJsRnVuY3Rpb259IGZyb20gJy4uL3RpbGV1cmxmdW5jdGlvbi5qcyc7XG5pbXBvcnQgVGlsZVNvdXJjZSwge1RpbGVTb3VyY2VFdmVudH0gZnJvbSAnLi9UaWxlLmpzJztcbmltcG9ydCBUaWxlRXZlbnRUeXBlIGZyb20gJy4vVGlsZUV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldEtleVpYWX0gZnJvbSAnLi4vdGlsZWNvb3JkLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZV1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gW3Byb2plY3Rpb25dXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3RhdGUuanNcIikuZGVmYXVsdH0gW3N0YXRlXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL1RpbGUuanNcIikuTG9hZEZ1bmN0aW9ufSB0aWxlTG9hZEZ1bmN0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvXVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufSBbdGlsZVVybEZ1bmN0aW9uXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFt1cmxzXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbd3JhcFg9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdHJhbnNpdGlvbl1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2V5XVxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBCYXNlIGNsYXNzIGZvciBzb3VyY2VzIHByb3ZpZGluZyB0aWxlcyBkaXZpZGVkIGludG8gYSB0aWxlIGdyaWQgb3ZlciBodHRwLlxuICpcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL1RpbGUuanNcIikuVGlsZVNvdXJjZUV2ZW50XG4gKi9cbmNsYXNzIFVybFRpbGUgZXh0ZW5kcyBUaWxlU291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBJbWFnZSB0aWxlIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICBzdXBlcih7XG4gICAgICBhdHRyaWJ1dGlvbnM6IG9wdGlvbnMuYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgICBwcm9qZWN0aW9uOiBvcHRpb25zLnByb2plY3Rpb24sXG4gICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgIHRpbGVHcmlkOiBvcHRpb25zLnRpbGVHcmlkLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB3cmFwWDogb3B0aW9ucy53cmFwWCxcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbixcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogb3B0aW9ucy5hdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmdlbmVyYXRlVGlsZVVybEZ1bmN0aW9uXyA9ICFvcHRpb25zLnRpbGVVcmxGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uID0gb3B0aW9ucy50aWxlTG9hZEZ1bmN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLlVybEZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24gPyBvcHRpb25zLnRpbGVVcmxGdW5jdGlvbi5iaW5kKHRoaXMpIDogbnVsbFRpbGVVcmxGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IUFycmF5PHN0cmluZz58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnVybHMgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMudXJscykge1xuICAgICAgdGhpcy5zZXRVcmxzKG9wdGlvbnMudXJscyk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgdGhpcy5zZXRVcmwob3B0aW9ucy51cmwpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRpbGVVcmxGdW5jdGlvbikge1xuICAgICAgdGhpcy5zZXRUaWxlVXJsRnVuY3Rpb24ob3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sIHRoaXMua2V5Xyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZUxvYWRpbmdLZXlzXyA9IHt9O1xuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSB0aWxlIGxvYWQgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFRpbGVMb2FkRnVuY3Rpb25cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VGlsZUxvYWRGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlTG9hZEZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGlsZSBVUkwgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gVGlsZVVybEZ1bmN0aW9uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRpbGVVcmxGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlVXJsRnVuY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBVUkxzIHVzZWQgZm9yIHRoaXMgc291cmNlLlxuICAgKiBXaGVuIGEgdGlsZVVybEZ1bmN0aW9uIGlzIHVzZWQgaW5zdGVhZCBvZiB1cmwgb3IgdXJscyxcbiAgICogbnVsbCB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPnxudWxsfSBVUkxzLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnVybHM7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIHRpbGUgY2hhbmdlIGV2ZW50cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVRpbGVDaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovIChldmVudC50YXJnZXQpO1xuICAgIGNvbnN0IHVpZCA9IGdldFVpZCh0aWxlKTtcbiAgICBjb25zdCB0aWxlU3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgbGV0IHR5cGU7XG4gICAgaWYgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BRElORykge1xuICAgICAgdGhpcy50aWxlTG9hZGluZ0tleXNfW3VpZF0gPSB0cnVlO1xuICAgICAgdHlwZSA9IFRpbGVFdmVudFR5cGUuVElMRUxPQURTVEFSVDtcbiAgICB9IGVsc2UgaWYgKHVpZCBpbiB0aGlzLnRpbGVMb2FkaW5nS2V5c18pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnRpbGVMb2FkaW5nS2V5c19bdWlkXTtcbiAgICAgIHR5cGUgPSB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkVSUk9SID8gVGlsZUV2ZW50VHlwZS5USUxFTE9BREVSUk9SIDpcbiAgICAgICAgKHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuTE9BREVEIHx8IHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuQUJPUlQpID9cbiAgICAgICAgICBUaWxlRXZlbnRUeXBlLlRJTEVMT0FERU5EIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVGlsZVNvdXJjZUV2ZW50KHR5cGUsIHRpbGUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0aWxlIGxvYWQgZnVuY3Rpb24gb2YgdGhlIHNvdXJjZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gdGlsZUxvYWRGdW5jdGlvbiBUaWxlIGxvYWQgZnVuY3Rpb24uXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVMb2FkRnVuY3Rpb24odGlsZUxvYWRGdW5jdGlvbikge1xuICAgIHRoaXMudGlsZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy50aWxlTG9hZEZ1bmN0aW9uID0gdGlsZUxvYWRGdW5jdGlvbjtcbiAgICB0aGlzLmNoYW5nZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRpbGUgVVJMIGZ1bmN0aW9uIG9mIHRoZSBzb3VyY2UuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gdGlsZVVybEZ1bmN0aW9uIFRpbGUgVVJMIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGtleSBPcHRpb25hbCBuZXcgdGlsZSBrZXkgZm9yIHRoZSBzb3VyY2UuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRpbGVVcmxGdW5jdGlvbih0aWxlVXJsRnVuY3Rpb24sIGtleSkge1xuICAgIHRoaXMudGlsZVVybEZ1bmN0aW9uID0gdGlsZVVybEZ1bmN0aW9uO1xuICAgIHRoaXMudGlsZUNhY2hlLnBydW5lRXhjZXB0TmV3ZXN0WigpO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zZXRLZXkoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgVVJMIHRvIHVzZSBmb3IgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRVcmwodXJsKSB7XG4gICAgY29uc3QgdXJscyA9IHRoaXMudXJscyA9IGV4cGFuZFVybCh1cmwpO1xuICAgIHRoaXMuc2V0VXJscyh1cmxzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIFVSTHMgdG8gdXNlIGZvciByZXF1ZXN0cy5cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB1cmxzIFVSTHMuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFVybHModXJscykge1xuICAgIHRoaXMudXJscyA9IHVybHM7XG4gICAgY29uc3Qga2V5ID0gdXJscy5qb2luKCdcXG4nKTtcbiAgICBpZiAodGhpcy5nZW5lcmF0ZVRpbGVVcmxGdW5jdGlvbl8pIHtcbiAgICAgIHRoaXMuc2V0VGlsZVVybEZ1bmN0aW9uKGNyZWF0ZUZyb21UZW1wbGF0ZXModXJscywgdGhpcy50aWxlR3JpZCksIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0S2V5KGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICB1c2VUaWxlKHosIHgsIHkpIHtcbiAgICBjb25zdCB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gICAgaWYgKHRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgIHRoaXMudGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IFVybFRpbGU7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1RpbGVJbWFnZVxuICovXG5pbXBvcnQge0VOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OfSBmcm9tICcuLi9yZXByb2ovY29tbW9uLmpzJztcbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBJbWFnZVRpbGUgZnJvbSAnLi4vSW1hZ2VUaWxlLmpzJztcbmltcG9ydCBUaWxlQ2FjaGUgZnJvbSAnLi4vVGlsZUNhY2hlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCB7bGlzdGVufSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7ZXF1aXZhbGVudCwgZ2V0IGFzIGdldFByb2plY3Rpb259IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IFJlcHJvalRpbGUgZnJvbSAnLi4vcmVwcm9qL1RpbGUuanMnO1xuaW1wb3J0IFVybFRpbGUgZnJvbSAnLi9VcmxUaWxlLmpzJztcbmltcG9ydCB7Z2V0S2V5LCBnZXRLZXlaWFl9IGZyb20gJy4uL3RpbGVjb29yZC5qcyc7XG5pbXBvcnQge2dldEZvclByb2plY3Rpb24gYXMgZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZT0yMDQ4XSBDYWNoZSBzaXplLlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuICBOb3RlIHRoYXRcbiAqIHlvdSBtdXN0IHByb3ZpZGUgYSBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSBhcmUgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyIG9yIGlmIHlvdSB3YW50IHRvXG4gKiBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuICBTZWVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZT10cnVlXSBXaGV0aGVyIHRoZSBsYXllciBpcyBvcGFxdWUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MC41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0YXRlLmpzXCIpLmRlZmF1bHR9IFtzdGF0ZV0gU291cmNlIHN0YXRlLlxuICogQHByb3BlcnR5IHt0eXBlb2YgaW1wb3J0KFwiLi4vSW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9IFt0aWxlQ2xhc3NdIENsYXNzIHVzZWQgdG8gaW5zdGFudGlhdGUgaW1hZ2UgdGlsZXMuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvSW1hZ2VUaWxlfkltYWdlVGlsZX0uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IFt0aWxlR3JpZF0gVGlsZSBncmlkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGlsZVBpeGVsUmF0aW89MV0gVGhlIHBpeGVsIHJhdGlvIHVzZWQgYnkgdGhlIHRpbGUgc2VydmljZS4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0aWxlXG4gKiBzZXJ2aWNlIGFkdmVydGl6ZXMgMjU2cHggYnkgMjU2cHggdGlsZXMgYnV0IGFjdHVhbGx5IHNlbmRzIDUxMnB4XG4gKiBieSA1MTJweCBpbWFnZXMgKGZvciByZXRpbmEvaGlkcGkgZGV2aWNlcykgdGhlbiBgdGlsZVBpeGVsUmF0aW9gXG4gKiBzaG91bGQgYmUgc2V0IHRvIGAyYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZ2V0IHRpbGUgVVJMIGdpdmVuIGEgdGlsZSBjb29yZGluYXRlIGFuZCB0aGUgcHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSBVUkwgdGVtcGxhdGUuIE11c3QgaW5jbHVkZSBge3h9YCwgYHt5fWAgb3IgYHsteX1gLCBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLlxuICogQSBgez8tP31gIHRlbXBsYXRlIHBhdHRlcm4sIGZvciBleGFtcGxlIGBzdWJkb21haW57YS1mfS5kb21haW4uY29tYCwgbWF5IGJlXG4gKiB1c2VkIGluc3RlYWQgb2YgZGVmaW5pbmcgZWFjaCBvbmUgc2VwYXJhdGVseSBpbiB0aGUgYHVybHNgIG9wdGlvbi5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3VybHNdIEFuIGFycmF5IG9mIFVSTCB0ZW1wbGF0ZXMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWF0gV2hldGhlciB0byB3cmFwIHRoZSB3b3JsZCBob3Jpem9udGFsbHkuIFRoZSBkZWZhdWx0LCBpcyB0b1xuICogcmVxdWVzdCBvdXQtb2YtYm91bmRzIHRpbGVzIGZyb20gdGhlIHNlcnZlci4gV2hlbiBzZXQgdG8gYGZhbHNlYCwgb25seSBvbmVcbiAqIHdvcmxkIHdpbGwgYmUgcmVuZGVyZWQuIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGlsZXMgd2lsbCBiZSByZXF1ZXN0ZWQgZm9yIG9uZVxuICogd29ybGQgb25seSwgYnV0IHRoZXkgd2lsbCBiZSB3cmFwcGVkIGhvcml6b250YWxseSB0byByZW5kZXIgbXVsdGlwbGUgd29ybGRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXSBEdXJhdGlvbiBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uIGZvciByZW5kZXJpbmcuXG4gKiBUbyBkaXNhYmxlIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24sIHBhc3MgYHRyYW5zaXRpb246IDBgLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXldIE9wdGlvbmFsIHRpbGUga2V5IGZvciBwcm9wZXIgY2FjaGUgZmV0Y2hpbmdcbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQmFzZSBjbGFzcyBmb3Igc291cmNlcyBwcm92aWRpbmcgaW1hZ2VzIGRpdmlkZWQgaW50byBhIHRpbGUgZ3JpZC5cbiAqXG4gKiBAZmlyZXMgaW1wb3J0KFwiLi9UaWxlLmpzXCIpLlRpbGVTb3VyY2VFdmVudFxuICogQGFwaVxuICovXG5jbGFzcyBUaWxlSW1hZ2UgZXh0ZW5kcyBVcmxUaWxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IU9wdGlvbnN9IG9wdGlvbnMgSW1hZ2UgdGlsZSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBvcGFxdWU6IG9wdGlvbnMub3BhcXVlLFxuICAgICAgcHJvamVjdGlvbjogb3B0aW9ucy5wcm9qZWN0aW9uLFxuICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICB0aWxlR3JpZDogb3B0aW9ucy50aWxlR3JpZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbiA/XG4gICAgICAgIG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbiA6IGRlZmF1bHRUaWxlTG9hZEZ1bmN0aW9uLFxuICAgICAgdGlsZVBpeGVsUmF0aW86IG9wdGlvbnMudGlsZVBpeGVsUmF0aW8sXG4gICAgICB0aWxlVXJsRnVuY3Rpb246IG9wdGlvbnMudGlsZVVybEZ1bmN0aW9uLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIHVybHM6IG9wdGlvbnMudXJscyxcbiAgICAgIHdyYXBYOiBvcHRpb25zLndyYXBYLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgIGF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlOiBvcHRpb25zLmF0dHJpYnV0aW9uc0NvbGxhcHNpYmxlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9XG4gICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NPcmlnaW4gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHt0eXBlb2YgSW1hZ2VUaWxlfVxuICAgICAqL1xuICAgIHRoaXMudGlsZUNsYXNzID0gb3B0aW9ucy50aWxlQ2xhc3MgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnRpbGVDbGFzcyA6IEltYWdlVGlsZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIFRpbGVDYWNoZT59XG4gICAgICovXG4gICAgdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbiA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcHJvamVjdGlvbkVycm9yVGhyZXNob2xkXyA9IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNhbkV4cGlyZUNhY2hlKCkge1xuICAgIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICAgIHJldHVybiBzdXBlci5jYW5FeHBpcmVDYWNoZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy50aWxlQ2FjaGUuY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uW2tleV0uY2FuRXhwaXJlQ2FjaGUoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZXhwaXJlQ2FjaGUocHJvamVjdGlvbiwgdXNlZFRpbGVzKSB7XG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgc3VwZXIuZXhwaXJlQ2FjaGUocHJvamVjdGlvbiwgdXNlZFRpbGVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXNlZFRpbGVDYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcblxuICAgIHRoaXMudGlsZUNhY2hlLmV4cGlyZUNhY2hlKHRoaXMudGlsZUNhY2hlID09IHVzZWRUaWxlQ2FjaGUgPyB1c2VkVGlsZXMgOiB7fSk7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICAgIGNvbnN0IHRpbGVDYWNoZSA9IHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltpZF07XG4gICAgICB0aWxlQ2FjaGUuZXhwaXJlQ2FjaGUodGlsZUNhY2hlID09IHVzZWRUaWxlQ2FjaGUgPyB1c2VkVGlsZXMgOiB7fSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRHdXR0ZXJGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04gJiZcbiAgICAgICAgdGhpcy5nZXRQcm9qZWN0aW9uKCkgJiYgcHJvamVjdGlvbiAmJiAhZXF1aXZhbGVudCh0aGlzLmdldFByb2plY3Rpb24oKSwgcHJvamVjdGlvbikpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRHdXR0ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBHdXR0ZXIuXG4gICAqL1xuICBnZXRHdXR0ZXIoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldE9wYXF1ZShwcm9qZWN0aW9uKSB7XG4gICAgaWYgKEVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OICYmXG4gICAgICAgIHRoaXMuZ2V0UHJvamVjdGlvbigpICYmIHByb2plY3Rpb24gJiYgIWVxdWl2YWxlbnQodGhpcy5nZXRQcm9qZWN0aW9uKCksIHByb2plY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5nZXRPcGFxdWUocHJvamVjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIGlmICghRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICAgIHJldHVybiBzdXBlci5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgaWYgKHRoaXMudGlsZUdyaWQgJiYgKCF0aGlzUHJvaiB8fCBlcXVpdmFsZW50KHRoaXNQcm9qLCBwcm9qZWN0aW9uKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVHcmlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm9qS2V5ID0gZ2V0VWlkKHByb2plY3Rpb24pO1xuICAgICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbikpIHtcbiAgICAgICAgdGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0gPSBnZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy50aWxlR3JpZEZvclByb2plY3Rpb25bcHJvaktleV0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTikge1xuICAgICAgcmV0dXJuIHN1cGVyLmdldFRpbGVDYWNoZUZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHRoaXNQcm9qID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7IGlmICghdGhpc1Byb2ogfHwgZXF1aXZhbGVudCh0aGlzUHJvaiwgcHJvamVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbGVDYWNoZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJvaktleSA9IGdldFVpZChwcm9qZWN0aW9uKTtcbiAgICAgIGlmICghKHByb2pLZXkgaW4gdGhpcy50aWxlQ2FjaGVGb3JQcm9qZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb25bcHJvaktleV0gPSBuZXcgVGlsZUNhY2hlKHRoaXMudGlsZUNhY2hlLmhpZ2hXYXRlck1hcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltwcm9qS2V5XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHNldCBvbiB0aGUgdGlsZS5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZVRpbGVfKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSkge1xuICAgIGNvbnN0IHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgICBjb25zdCB1cmxUaWxlQ29vcmQgPSB0aGlzLmdldFRpbGVDb29yZEZvclRpbGVVcmxGdW5jdGlvbihcbiAgICAgIHRpbGVDb29yZCwgcHJvamVjdGlvbik7XG4gICAgY29uc3QgdGlsZVVybCA9IHVybFRpbGVDb29yZCA/XG4gICAgICB0aGlzLnRpbGVVcmxGdW5jdGlvbih1cmxUaWxlQ29vcmQsIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRpbGUgPSBuZXcgdGhpcy50aWxlQ2xhc3MoXG4gICAgICB0aWxlQ29vcmQsXG4gICAgICB0aWxlVXJsICE9PSB1bmRlZmluZWQgPyBUaWxlU3RhdGUuSURMRSA6IFRpbGVTdGF0ZS5FTVBUWSxcbiAgICAgIHRpbGVVcmwgIT09IHVuZGVmaW5lZCA/IHRpbGVVcmwgOiAnJyxcbiAgICAgIHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICB0aGlzLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aGlzLnRpbGVPcHRpb25zKTtcbiAgICB0aWxlLmtleSA9IGtleTtcbiAgICBsaXN0ZW4odGlsZSwgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgIHRoaXMuaGFuZGxlVGlsZUNoYW5nZSwgdGhpcyk7XG4gICAgcmV0dXJuIHRpbGU7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IHNvdXJjZVByb2plY3Rpb24gPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0UHJvamVjdGlvbigpKTtcbiAgICBpZiAoIUVOQUJMRV9SQVNURVJfUkVQUk9KRUNUSU9OIHx8XG4gICAgICAgICFzb3VyY2VQcm9qZWN0aW9uIHx8ICFwcm9qZWN0aW9uIHx8IGVxdWl2YWxlbnQoc291cmNlUHJvamVjdGlvbiwgcHJvamVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uIHx8IHByb2plY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjYWNoZSA9IHRoaXMuZ2V0VGlsZUNhY2hlRm9yUHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIGNvbnN0IHRpbGVDb29yZCA9IFt6LCB4LCB5XTtcbiAgICAgIGxldCB0aWxlO1xuICAgICAgY29uc3QgdGlsZUNvb3JkS2V5ID0gZ2V0S2V5KHRpbGVDb29yZCk7XG4gICAgICBpZiAoY2FjaGUuY29udGFpbnNLZXkodGlsZUNvb3JkS2V5KSkge1xuICAgICAgICB0aWxlID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAoY2FjaGUuZ2V0KHRpbGVDb29yZEtleSkpO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICAgIGlmICh0aWxlICYmIHRpbGUua2V5ID09IGtleSkge1xuICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24oc291cmNlUHJvamVjdGlvbik7XG4gICAgICAgIGNvbnN0IHRhcmdldFRpbGVHcmlkID0gdGhpcy5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICAgIGNvbnN0IHdyYXBwZWRUaWxlQ29vcmQgPVxuICAgICAgICAgICAgdGhpcy5nZXRUaWxlQ29vcmRGb3JUaWxlVXJsRnVuY3Rpb24odGlsZUNvb3JkLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgY29uc3QgbmV3VGlsZSA9IG5ldyBSZXByb2pUaWxlKFxuICAgICAgICAgIHNvdXJjZVByb2plY3Rpb24sIHNvdXJjZVRpbGVHcmlkLFxuICAgICAgICAgIHByb2plY3Rpb24sIHRhcmdldFRpbGVHcmlkLFxuICAgICAgICAgIHRpbGVDb29yZCwgd3JhcHBlZFRpbGVDb29yZCwgdGhpcy5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKSxcbiAgICAgICAgICB0aGlzLmdldEd1dHRlcigpLFxuICAgICAgICAgIGZ1bmN0aW9uKHosIHgsIHksIHBpeGVsUmF0aW8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRpbGVJbnRlcm5hbCh6LCB4LCB5LCBwaXhlbFJhdGlvLCBzb3VyY2VQcm9qZWN0aW9uKTtcbiAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGRfLFxuICAgICAgICAgIHRoaXMucmVuZGVyUmVwcm9qZWN0aW9uRWRnZXNfKTtcbiAgICAgICAgbmV3VGlsZS5rZXkgPSBrZXk7XG5cbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICBuZXdUaWxlLmludGVyaW1UaWxlID0gdGlsZTtcbiAgICAgICAgICBuZXdUaWxlLnJlZnJlc2hJbnRlcmltQ2hhaW4oKTtcbiAgICAgICAgICBjYWNoZS5yZXBsYWNlKHRpbGVDb29yZEtleSwgbmV3VGlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUuc2V0KHRpbGVDb29yZEtleSwgbmV3VGlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1RpbGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6IFRpbGUgY29vcmRpbmF0ZSB6LlxuICAgKiBAcGFyYW0ge251bWJlcn0geCBUaWxlIGNvb3JkaW5hdGUgeC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGlsZSBjb29yZGluYXRlIHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5kZWZhdWx0fSBUaWxlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRUaWxlSW50ZXJuYWwoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIGxldCB0aWxlID0gbnVsbDtcbiAgICBjb25zdCB0aWxlQ29vcmRLZXkgPSBnZXRLZXlaWFkoeiwgeCwgeSk7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcbiAgICBpZiAoIXRoaXMudGlsZUNhY2hlLmNvbnRhaW5zS2V5KHRpbGVDb29yZEtleSkpIHtcbiAgICAgIHRpbGUgPSB0aGlzLmNyZWF0ZVRpbGVfKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24sIGtleSk7XG4gICAgICB0aGlzLnRpbGVDYWNoZS5zZXQodGlsZUNvb3JkS2V5LCB0aWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGlsZSA9IHRoaXMudGlsZUNhY2hlLmdldCh0aWxlQ29vcmRLZXkpO1xuICAgICAgaWYgKHRpbGUua2V5ICE9IGtleSkge1xuICAgICAgICAvLyBUaGUgc291cmNlJ3MgcGFyYW1zIGNoYW5nZWQuIElmIHRoZSB0aWxlIGhhcyBhbiBpbnRlcmltIHRpbGUgYW5kIGlmIHdlXG4gICAgICAgIC8vIGNhbiB1c2UgaXQgdGhlbiB3ZSB1c2UgaXQuIE90aGVyd2lzZSB3ZSBjcmVhdGUgYSBuZXcgdGlsZS4gIEluIGJvdGhcbiAgICAgICAgLy8gY2FzZXMgd2UgYXR0ZW1wdCB0byBhc3NpZ24gYW4gaW50ZXJpbSB0aWxlIHRvIHRoZSBuZXcgdGlsZS5cbiAgICAgICAgY29uc3QgaW50ZXJpbVRpbGUgPSB0aWxlO1xuICAgICAgICB0aWxlID0gdGhpcy5jcmVhdGVUaWxlXyh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uLCBrZXkpO1xuXG4gICAgICAgIC8vbWFrZSB0aGUgbmV3IHRpbGUgdGhlIGhlYWQgb2YgdGhlIGxpc3QsXG4gICAgICAgIGlmIChpbnRlcmltVGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgLy90aGUgb2xkIHRpbGUgaGFzbid0IGJlZ3VuIGxvYWRpbmcgeWV0LCBhbmQgaXMgbm93IG91dGRhdGVkLCBzbyB3ZSBjYW4gc2ltcGx5IGRpc2NhcmQgaXRcbiAgICAgICAgICB0aWxlLmludGVyaW1UaWxlID0gaW50ZXJpbVRpbGUuaW50ZXJpbVRpbGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlsZS5pbnRlcmltVGlsZSA9IGludGVyaW1UaWxlO1xuICAgICAgICB9XG4gICAgICAgIHRpbGUucmVmcmVzaEludGVyaW1DaGFpbigpO1xuICAgICAgICB0aGlzLnRpbGVDYWNoZS5yZXBsYWNlKHRpbGVDb29yZEtleSwgdGlsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0byByZW5kZXIgcmVwcm9qZWN0aW9uIGVkZ2VzIG9yIG5vdCAodXN1YWxseSBmb3IgZGVidWdnaW5nKS5cbiAgICogQHBhcmFtIHtib29sZWFufSByZW5kZXIgUmVuZGVyIHRoZSBlZGdlcy5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0UmVuZGVyUmVwcm9qZWN0aW9uRWRnZXMocmVuZGVyKSB7XG4gICAgaWYgKCFFTkFCTEVfUkFTVEVSX1JFUFJPSkVDVElPTiB8fFxuICAgICAgICB0aGlzLnJlbmRlclJlcHJvamVjdGlvbkVkZ2VzXyA9PSByZW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJSZXByb2plY3Rpb25FZGdlc18gPSByZW5kZXI7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLnRpbGVDYWNoZUZvclByb2plY3Rpb24pIHtcbiAgICAgIHRoaXMudGlsZUNhY2hlRm9yUHJvamVjdGlvbltpZF0uY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGlsZSBncmlkIHRvIHVzZSB3aGVuIHJlcHJvamVjdGluZyB0aGUgdGlsZXMgdG8gdGhlIGdpdmVuXG4gICAqIHByb2plY3Rpb24gaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCB0aWxlIGdyaWQgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGUgZGVmYXVsdCB0aWxlIGdyaWQgY2Fubm90IGJlIGNyZWF0ZWRcbiAgICogKGUuZy4gcHJvamVjdGlvbiBoYXMgbm8gZXh0ZW50IGRlZmluZWQpIG9yXG4gICAqIGZvciBvcHRpbWl6YXRpb24gcmVhc29ucyAoY3VzdG9tIHRpbGUgc2l6ZSwgcmVzb2x1dGlvbnMsIC4uLikuXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBQcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3RpbGVncmlkL1RpbGVHcmlkLmpzXCIpLmRlZmF1bHR9IHRpbGVncmlkIFRpbGUgZ3JpZCB0byB1c2UgZm9yIHRoZSBwcm9qZWN0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbiwgdGlsZWdyaWQpIHtcbiAgICBpZiAoRU5BQkxFX1JBU1RFUl9SRVBST0pFQ1RJT04pIHtcbiAgICAgIGNvbnN0IHByb2ogPSBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgaWYgKHByb2opIHtcbiAgICAgICAgY29uc3QgcHJvaktleSA9IGdldFVpZChwcm9qKTtcbiAgICAgICAgaWYgKCEocHJvaktleSBpbiB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbikpIHtcbiAgICAgICAgICB0aGlzLnRpbGVHcmlkRm9yUHJvamVjdGlvbltwcm9qS2V5XSA9IHRpbGVncmlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0ltYWdlVGlsZX0gaW1hZ2VUaWxlIEltYWdlIHRpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFRpbGVMb2FkRnVuY3Rpb24oaW1hZ2VUaWxlLCBzcmMpIHtcbiAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9ICovIChpbWFnZVRpbGUuZ2V0SW1hZ2UoKSkuc3JjID0gc3JjO1xufVxuXG5leHBvcnQgZGVmYXVsdCBUaWxlSW1hZ2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL1hZWlxuICovXG5cbmltcG9ydCBUaWxlSW1hZ2UgZnJvbSAnLi9UaWxlSW1hZ2UuanMnO1xuaW1wb3J0IHtjcmVhdGVYWVosIGV4dGVudEZyb21Qcm9qZWN0aW9ufSBmcm9tICcuLi90aWxlZ3JpZC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1NvdXJjZS5qc1wiKS5BdHRyaWJ1dGlvbkxpa2V9IFthdHRyaWJ1dGlvbnNdIEF0dHJpYnV0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2F0dHJpYnV0aW9uc0NvbGxhcHNpYmxlPXRydWVdIEF0dHJpYnV0aW9ucyBhcmUgY29sbGFwc2libGUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2NhY2hlU2l6ZT0yMDQ4XSBDYWNoZSBzaXplLlxuICogQHByb3BlcnR5IHtudWxsfHN0cmluZ30gW2Nyb3NzT3JpZ2luXSBUaGUgYGNyb3NzT3JpZ2luYCBhdHRyaWJ1dGUgZm9yIGxvYWRlZCBpbWFnZXMuICBOb3RlIHRoYXRcbiAqIHlvdSBtdXN0IHByb3ZpZGUgYSBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSBhcmUgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyIG9yIGlmIHlvdSB3YW50IHRvXG4gKiBhY2Nlc3MgcGl4ZWwgZGF0YSB3aXRoIHRoZSBDYW52YXMgcmVuZGVyZXIuICBTZWVcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQ09SU19lbmFibGVkX2ltYWdlIGZvciBtb3JlIGRldGFpbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wYXF1ZT10cnVlXSBXaGV0aGVyIHRoZSBsYXllciBpcyBvcGFxdWUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3Byb2ouanNcIikuUHJvamVjdGlvbkxpa2V9IFtwcm9qZWN0aW9uPSdFUFNHOjM4NTcnXSBQcm9qZWN0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXByb2plY3Rpb25FcnJvclRocmVzaG9sZD0wLjVdIE1heGltdW0gYWxsb3dlZCByZXByb2plY3Rpb24gZXJyb3IgKGluIHBpeGVscykuXG4gKiBIaWdoZXIgdmFsdWVzIGNhbiBpbmNyZWFzZSByZXByb2plY3Rpb24gcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZSBwcmVjaXNpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209MThdIE9wdGlvbmFsIG1heCB6b29tIGxldmVsLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5ab29tPTBdIE9wdGlvbmFsIG1pbiB6b29tIGxldmVsLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi90aWxlZ3JpZC9UaWxlR3JpZC5qc1wiKS5kZWZhdWx0fSBbdGlsZUdyaWRdIFRpbGUgZ3JpZC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5Mb2FkRnVuY3Rpb259IFt0aWxlTG9hZEZ1bmN0aW9uXSBPcHRpb25hbCBmdW5jdGlvbiB0byBsb2FkIGEgdGlsZSBnaXZlbiBhIFVSTC4gVGhlIGRlZmF1bHQgaXNcbiAqIGBgYGpzXG4gKiBmdW5jdGlvbihpbWFnZVRpbGUsIHNyYykge1xuICogICBpbWFnZVRpbGUuZ2V0SW1hZ2UoKS5zcmMgPSBzcmM7XG4gKiB9O1xuICogYGBgXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RpbGVQaXhlbFJhdGlvPTFdIFRoZSBwaXhlbCByYXRpbyB1c2VkIGJ5IHRoZSB0aWxlIHNlcnZpY2UuXG4gKiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRpbGUgc2VydmljZSBhZHZlcnRpemVzIDI1NnB4IGJ5IDI1NnB4IHRpbGVzIGJ1dCBhY3R1YWxseSBzZW5kcyA1MTJweFxuICogYnkgNTEycHggaW1hZ2VzIChmb3IgcmV0aW5hL2hpZHBpIGRldmljZXMpIHRoZW4gYHRpbGVQaXhlbFJhdGlvYFxuICogc2hvdWxkIGJlIHNldCB0byBgMmAuXG4gKiBAcHJvcGVydHkge251bWJlcnxpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFt0aWxlU2l6ZT1bMjU2LCAyNTZdXSBUaGUgdGlsZSBzaXplIHVzZWQgYnkgdGhlIHRpbGUgc2VydmljZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vVGlsZS5qc1wiKS5VcmxGdW5jdGlvbn0gW3RpbGVVcmxGdW5jdGlvbl0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZ2V0XG4gKiB0aWxlIFVSTCBnaXZlbiBhIHRpbGUgY29vcmRpbmF0ZSBhbmQgdGhlIHByb2plY3Rpb24uXG4gKiBSZXF1aXJlZCBpZiB1cmwgb3IgdXJscyBhcmUgbm90IHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cmxdIFVSTCB0ZW1wbGF0ZS4gTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsXG4gKiBhbmQgYHt6fWAgcGxhY2Vob2xkZXJzLiBBIGB7Py0/fWAgdGVtcGxhdGUgcGF0dGVybiwgZm9yIGV4YW1wbGUgYHN1YmRvbWFpbnthLWZ9LmRvbWFpbi5jb21gLFxuICogbWF5IGJlIHVzZWQgaW5zdGVhZCBvZiBkZWZpbmluZyBlYWNoIG9uZSBzZXBhcmF0ZWx5IGluIHRoZSBgdXJsc2Agb3B0aW9uLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbdXJsc10gQW4gYXJyYXkgb2YgVVJMIHRlbXBsYXRlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3dyYXBYPXRydWVdIFdoZXRoZXIgdG8gd3JhcCB0aGUgd29ybGQgaG9yaXpvbnRhbGx5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uXSBEdXJhdGlvbiBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uIGZvciByZW5kZXJpbmcuXG4gKiBUbyBkaXNhYmxlIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24sIHBhc3MgYHRyYW5zaXRpb246IDBgLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBMYXllciBzb3VyY2UgZm9yIHRpbGUgZGF0YSB3aXRoIFVSTHMgaW4gYSBzZXQgWFlaIGZvcm1hdCB0aGF0IGFyZVxuICogZGVmaW5lZCBpbiBhIFVSTCB0ZW1wbGF0ZS4gQnkgZGVmYXVsdCwgdGhpcyBmb2xsb3dzIHRoZSB3aWRlbHktdXNlZFxuICogR29vZ2xlIGdyaWQgd2hlcmUgYHhgIDAgYW5kIGB5YCAwIGFyZSBpbiB0aGUgdG9wIGxlZnQuIEdyaWRzIGxpa2VcbiAqIFRNUyB3aGVyZSBgeGAgMCBhbmQgYHlgIDAgYXJlIGluIHRoZSBib3R0b20gbGVmdCBjYW4gYmUgdXNlZCBieVxuICogdXNpbmcgdGhlIGB7LXl9YCBwbGFjZWhvbGRlciBpbiB0aGUgVVJMIHRlbXBsYXRlLCBzbyBsb25nIGFzIHRoZVxuICogc291cmNlIGRvZXMgbm90IGhhdmUgYSBjdXN0b20gdGlsZSBncmlkLiBJbiB0aGlzIGNhc2UsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlSW1hZ2V9IGNhbiBiZSB1c2VkIHdpdGggYSBgdGlsZVVybEZ1bmN0aW9uYFxuICogc3VjaCBhczpcbiAqXG4gKiAgdGlsZVVybEZ1bmN0aW9uOiBmdW5jdGlvbihjb29yZGluYXRlKSB7XG4gKiAgICByZXR1cm4gJ2h0dHA6Ly9tYXBzZXJ2ZXIuY29tLycgKyBjb29yZGluYXRlWzBdICsgJy8nICtcbiAqICAgICAgICBjb29yZGluYXRlWzFdICsgJy8nICsgY29vcmRpbmF0ZVsyXSArICcucG5nJztcbiAqICAgIH1cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFhZWiBleHRlbmRzIFRpbGVJbWFnZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBYWVogb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9vcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb24gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnByb2plY3Rpb24gOiAnRVBTRzozODU3JztcblxuICAgIGNvbnN0IHRpbGVHcmlkID0gb3B0aW9ucy50aWxlR3JpZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aWxlR3JpZCA6XG4gICAgICBjcmVhdGVYWVooe1xuICAgICAgICBleHRlbnQ6IGV4dGVudEZyb21Qcm9qZWN0aW9uKHByb2plY3Rpb24pLFxuICAgICAgICBtYXhab29tOiBvcHRpb25zLm1heFpvb20sXG4gICAgICAgIG1pblpvb206IG9wdGlvbnMubWluWm9vbSxcbiAgICAgICAgdGlsZVNpemU6IG9wdGlvbnMudGlsZVNpemVcbiAgICAgIH0pO1xuXG4gICAgc3VwZXIoe1xuICAgICAgYXR0cmlidXRpb25zOiBvcHRpb25zLmF0dHJpYnV0aW9ucyxcbiAgICAgIGNhY2hlU2l6ZTogb3B0aW9ucy5jYWNoZVNpemUsXG4gICAgICBjcm9zc09yaWdpbjogb3B0aW9ucy5jcm9zc09yaWdpbixcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUsXG4gICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uLFxuICAgICAgcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ6IG9wdGlvbnMucmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQsXG4gICAgICB0aWxlR3JpZDogdGlsZUdyaWQsXG4gICAgICB0aWxlTG9hZEZ1bmN0aW9uOiBvcHRpb25zLnRpbGVMb2FkRnVuY3Rpb24sXG4gICAgICB0aWxlUGl4ZWxSYXRpbzogb3B0aW9ucy50aWxlUGl4ZWxSYXRpbyxcbiAgICAgIHRpbGVVcmxGdW5jdGlvbjogb3B0aW9ucy50aWxlVXJsRnVuY3Rpb24sXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgdXJsczogb3B0aW9ucy51cmxzLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFggIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFggOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbjogb3B0aW9ucy50cmFuc2l0aW9uLFxuICAgICAgYXR0cmlidXRpb25zQ29sbGFwc2libGU6IG9wdGlvbnMuYXR0cmlidXRpb25zQ29sbGFwc2libGVcbiAgICB9KTtcblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgWFlaO1xuIl0sIm1hcHBpbmdzIjoiOzs7QUFBQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0VBO0FBQUE7QUFBQTtBQU9BO0FBQ0E7QUFFQTs7Ozs7QUFLQTs7Ozs7O0FBTUE7Ozs7Ozs7O0FBUUE7Ozs7Ozs7O0FBUUE7Ozs7OztBQU1BOzs7Ozs7O0FBT0E7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXpOQTtBQUNBO0FBMk5BOzs7Ozs7OztBQ3hTQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBVUE7QUFFQTs7Ozs7O0FBTUE7Ozs7Ozs7O0FBUUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFqSkE7Ozs7Ozs7QUF3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6S0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBRUE7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEzQ0E7QUFDQTtBQTZDQTs7Ozs7Ozs7Ozs7QUNwREE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWVBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FDbFBBOzs7QUFHQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7QUFXQTs7Ozs7OztBQVFBO0FBV0E7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7Ozs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7Ozs7QUFLQTtBQUVBOzs7OztBQUlBO0FBS0E7Ozs7O0FBSUE7QUFHQTs7Ozs7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUNoV0E7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBY0E7QUFBQTtBQUFBO0FBZUE7QUFhQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhTQTtBQUNBO0FBa1NBOzs7OztBQzdUQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpCQTtBQTJCQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbElBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7Ozs7O0FBWUE7Ozs7OztBQU1BOzs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFBQTtBQUFBOzs7OztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBOztBQTdRQTs7Ozs7Ozs7QUFzUkE7QUFBQTtBQUFBO0FBS0E7QUFFQTs7Ozs7OztBQU9BOzs7OztBQUVBOztBQWhCQTtBQW9CQTs7QUMvVUE7Ozs7Ozs7QUFPQTs7Ozs7O0FBT0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7OztBQU1BO0FBdEJBOztBQ1BBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRCQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBOzs7Ozs7QUFrQkE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BOzs7OztBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWhMQTtBQUNBO0FBa0xBOztBQ3ZOQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1EQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBOzs7Ozs7QUF1QkE7Ozs7OztBQU9BOzs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQU9BO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBclVBOzs7Ozs7O0FBNFVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2paQTs7O0FBSUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0REE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTs7Ozs7QUFrQkE7O0FBbkNBO0FBQ0E7QUFzQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///106\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/tilegrid/common.js\nvar common = __webpack_require__(65);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/functions.js\nvar functions = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/ol/math.js\nvar math = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./node_modules/ol/centerconstraint.js\n/**\n * @module ol/centerconstraint\n */\n\n/**\n * @typedef {function((import("./coordinate.js").Coordinate|undefined)): (import("./coordinate.js").Coordinate|undefined)} Type\n */\n\n/**\n * @param {import("./extent.js").Extent} extent Extent.\n * @return {Type} The constraint.\n */\n\nfunction createExtent(extent) {\n  return (\n    /**\n     * @param {import("./coordinate.js").Coordinate=} center Center.\n     * @return {import("./coordinate.js").Coordinate|undefined} Center.\n     */\n    function (center) {\n      if (center) {\n        return [Object(math["a" /* clamp */])(center[0], extent[0], extent[2]), Object(math["a" /* clamp */])(center[1], extent[1], extent[3])];\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {import("./coordinate.js").Coordinate=} center Center.\n * @return {import("./coordinate.js").Coordinate|undefined} Center.\n */\n\nfunction none(center) {\n  return center;\n}\n// EXTERNAL MODULE: ./node_modules/ol/Object.js\nvar ol_Object = __webpack_require__(15);\n\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(13);\n\n// CONCATENATED MODULE: ./node_modules/ol/resolutionconstraint.js\n/**\n * @module ol/resolutionconstraint\n */\n\n\n/**\n * @typedef {function((number|undefined), number, number): (number|undefined)} Type\n */\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @return {Type} Zoom function.\n */\n\nfunction createSnapToResolutions(resolutions) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} delta Delta.\n     * @param {number} direction Direction.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, delta, direction) {\n      if (resolution !== undefined) {\n        var z = Object(array["f" /* linearFindNearest */])(resolutions, resolution, direction);\n        z = Object(math["a" /* clamp */])(z + delta, 0, resolutions.length - 1);\n        var index = Math.floor(z);\n\n        if (z != index && index < resolutions.length - 1) {\n          var power = resolutions[index] / resolutions[index + 1];\n          return resolutions[index] / Math.pow(power, z - index);\n        } else {\n          return resolutions[index];\n        }\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number=} opt_maxLevel Maximum level.\n * @return {Type} Zoom function.\n */\n\nfunction createSnapToPower(power, maxResolution, opt_maxLevel) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} delta Delta.\n     * @param {number} direction Direction.\n     * @return {number|undefined} Resolution.\n     */\n    function (resolution, delta, direction) {\n      if (resolution !== undefined) {\n        var offset = -direction / 2 + 0.5;\n        var oldLevel = Math.floor(Math.log(maxResolution / resolution) / Math.log(power) + offset);\n        var newLevel = Math.max(oldLevel + delta, 0);\n\n        if (opt_maxLevel !== undefined) {\n          newLevel = Math.min(newLevel, opt_maxLevel);\n        }\n\n        return maxResolution / Math.pow(power, newLevel);\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n// CONCATENATED MODULE: ./node_modules/ol/rotationconstraint.js\n/**\n * @module ol/rotationconstraint\n */\n\n/**\n * @typedef {function((number|undefined), number): (number|undefined)} Type\n */\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @param {number} delta Delta.\n * @return {number|undefined} Rotation.\n */\n\nfunction disable(rotation, delta) {\n  if (rotation !== undefined) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n/**\n * @param {number|undefined} rotation Rotation.\n * @param {number} delta Delta.\n * @return {number|undefined} Rotation.\n */\n\nfunction rotationconstraint_none(rotation, delta) {\n  if (rotation !== undefined) {\n    return rotation + delta;\n  } else {\n    return undefined;\n  }\n}\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\n\nfunction createSnapToN(n) {\n  var theta = 2 * Math.PI / n;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {number} delta Delta.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, delta) {\n      if (rotation !== undefined) {\n        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;\n        return rotation;\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n/**\n * @param {number=} opt_tolerance Tolerance.\n * @return {Type} Rotation constraint.\n */\n\nfunction createSnapToZero(opt_tolerance) {\n  var tolerance = opt_tolerance || Object(math["i" /* toRadians */])(5);\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {number} delta Delta.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, delta) {\n      if (rotation !== undefined) {\n        if (Math.abs(rotation + delta) <= tolerance) {\n          return 0;\n        } else {\n          return rotation + delta;\n        }\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n// EXTERNAL MODULE: ./node_modules/ol/ViewHint.js\nvar ViewHint = __webpack_require__(18);\n\n// CONCATENATED MODULE: ./node_modules/ol/ViewProperty.js\n/**\n * @module ol/ViewProperty\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ var ViewProperty = ({\n  CENTER: \'center\',\n  RESOLUTION: \'resolution\',\n  ROTATION: \'rotation\'\n});\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(11);\n\n// EXTERNAL MODULE: ./node_modules/ol/coordinate.js + 1 modules\nvar coordinate = __webpack_require__(41);\n\n// EXTERNAL MODULE: ./node_modules/ol/easing.js\nvar easing = __webpack_require__(28);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/GeometryType.js\nvar GeometryType = __webpack_require__(3);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/Polygon.js + 1 modules\nvar Polygon = __webpack_require__(47);\n\n// EXTERNAL MODULE: ./node_modules/ol/obj.js\nvar obj = __webpack_require__(12);\n\n// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules\nvar proj = __webpack_require__(10);\n\n// EXTERNAL MODULE: ./node_modules/ol/proj/Units.js\nvar Units = __webpack_require__(26);\n\n// CONCATENATED MODULE: ./node_modules/ol/View.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCenterConstraint", function() { return createCenterConstraint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createResolutionConstraint", function() { return createResolutionConstraint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRotationConstraint", function() { return createRotationConstraint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNoopAnimation", function() { return isNoopAnimation; });\n/**\n * @module ol/View\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * An animation configuration\n *\n * @typedef {Object} Animation\n * @property {import("./coordinate.js").Coordinate} [sourceCenter]\n * @property {import("./coordinate.js").Coordinate} [targetCenter]\n * @property {number} [sourceResolution]\n * @property {number} [targetResolution]\n * @property {number} [sourceRotation]\n * @property {number} [targetRotation]\n * @property {import("./coordinate.js").Coordinate} [anchor]\n * @property {number} start\n * @property {number} duration\n * @property {boolean} complete\n * @property {function(number):number} easing\n * @property {function(boolean)} callback\n */\n\n/**\n * @typedef {Object} Constraints\n * @property {import("./centerconstraint.js").Type} center\n * @property {import("./resolutionconstraint.js").Type} resolution\n * @property {import("./rotationconstraint.js").Type} rotation\n */\n\n/**\n * @typedef {Object} FitOptions\n * @property {import("./size.js").Size} [size] The size in pixels of the box to fit\n * the extent into. Default is the current size of the first map in the DOM that\n * uses this view, or `[100, 100]` if no such map is found.\n * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be\n * cleared inside the view. Values in the array are top, right, bottom and left\n * padding.\n * @property {boolean} [constrainResolution=true] Constrain the resolution.\n * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get\n * the nearest extent instead of the closest that actually fits the view.\n * @property {number} [minResolution=0] Minimum resolution that we zoom to.\n * @property {number} [maxZoom] Maximum zoom level that we zoom to. If\n * `minResolution` is given, this property is ignored.\n * @property {number} [duration] The duration of the animation in milliseconds.\n * By default, there is no animation to the target extent.\n * @property {function(number):number} [easing] The easing function used during\n * the animation (defaults to {@link module:ol/easing~inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation\'s duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n * @property {function(boolean)} [callback] Function called when the view is in\n * its final position. The callback will be called with `true` if the animation\n * series completed on its own or `false` if it was cancelled.\n */\n\n/**\n * @typedef {Object} ViewOptions\n * @property {import("./coordinate.js").Coordinate} [center] The initial center for\n * the view. The coordinate system for the center is specified with the\n * `projection` option. Layer sources will not be fetched if this is not set,\n * but the center can be set later with {@link #setCenter}.\n * @property {boolean|number} [constrainRotation=true] Rotation constraint.\n * `false` means no constraint. `true` means no constraint, but snap to zero\n * near zero. A number constrains the rotation to that number of values. For\n * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.\n * @property {boolean} [enableRotation=true] Enable rotation.\n * If `false`, a rotation constraint that always sets the rotation to zero is\n * used. The `constrainRotation` option has no effect if `enableRotation` is\n * `false`.\n * @property {import("./extent.js").Extent} [extent] The extent that constrains the\n * center, in other words, center cannot be set outside this extent.\n * @property {number} [maxResolution] The maximum resolution used to determine\n * the resolution constraint. It is used together with `minResolution` (or\n * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way\n * that the projection\'s validity extent fits in a 256x256 px tile. If the\n * projection is Spherical Mercator (the default) then `maxResolution` defaults\n * to `40075016.68557849 / 256 = 156543.03392804097`.\n * @property {number} [minResolution] The minimum resolution used to determine\n * the resolution constraint.  It is used together with `maxResolution` (or\n * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29\n * zoom levels (with a factor of 2). If the projection is Spherical Mercator\n * (the default) then `minResolution` defaults to\n * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.\n * @property {number} [maxZoom=28] The maximum zoom level used to determine the\n * resolution constraint. It is used together with `minZoom` (or\n * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also\n * provided, it is given precedence over `maxZoom`.\n * @property {number} [minZoom=0] The minimum zoom level used to determine the\n * resolution constraint. It is used together with `maxZoom` (or\n * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also\n * provided, it is given precedence over `minZoom`.\n * @property {import("./proj.js").ProjectionLike} [projection=\'EPSG:3857\'] The\n * projection. The default is Spherical Mercator.\n * @property {number} [resolution] The initial resolution for the view. The\n * units are `projection` units per pixel (e.g. meters per pixel). An\n * alternative to setting this is to set `zoom`. Layer sources will not be\n * fetched if neither this nor `zoom` are defined, but they can be set later\n * with {@link #setZoom} or {@link #setResolution}.\n * @property {Array<number>} [resolutions] Resolutions to determine the\n * resolution constraint. If set the `maxResolution`, `minResolution`,\n * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.\n * @property {number} [rotation=0] The initial rotation for the view in radians\n * (positive rotation clockwise, 0 means North).\n * @property {number} [zoom] Only used if `resolution` is not defined. Zoom\n * level used to calculate the initial resolution for the view. The initial\n * resolution is determined using the {@link #constrainResolution} method.\n * @property {number} [zoomFactor=2] The zoom factor used to determine the\n * resolution constraint.\n */\n\n/**\n * @typedef {Object} AnimationOptions\n * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of\n * the animation.\n * @property {number} [zoom] The zoom level of the view at the end of the\n * animation. This takes precedence over `resolution`.\n * @property {number} [resolution] The resolution of the view at the end\n * of the animation.  If `zoom` is also provided, this option will be ignored.\n * @property {number} [rotation] The rotation of the view at the end of\n * the animation.\n * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remained fixed\n * during a rotation or resolution animation.\n * @property {number} [duration=1000] The duration of the animation in milliseconds.\n * @property {function(number):number} [easing] The easing function used\n * during the animation (defaults to {@link module:ol/easing~inAndOut}).\n * The function will be called for each frame with a number representing a\n * fraction of the animation\'s duration.  The function should return a number\n * between 0 and 1 representing the progress toward the destination state.\n */\n\n/**\n * @typedef {Object} State\n * @property {import("./coordinate.js").Coordinate} center\n * @property {import("./proj/Projection.js").default} projection\n * @property {number} resolution\n * @property {number} rotation\n * @property {number} zoom\n */\n\n/**\n * Default min zoom level for the map view.\n * @type {number}\n */\n\nvar DEFAULT_MIN_ZOOM = 0;\n/**\n * @classdesc\n * A View object represents a simple 2D view of the map.\n *\n * This is the object to act upon to change the center, resolution,\n * and rotation of the map.\n *\n * ### The view states\n *\n * An View is determined by three states: `center`, `resolution`,\n * and `rotation`. Each state has a corresponding getter and setter, e.g.\n * `getCenter` and `setCenter` for the `center` state.\n *\n * An View has a `projection`. The projection determines the\n * coordinate system of the center, and its units determine the units of the\n * resolution (projection units per pixel). The default projection is\n * Spherical Mercator (EPSG:3857).\n *\n * ### The constraints\n *\n * `setCenter`, `setResolution` and `setRotation` can be used to change the\n * states of the view. Any value can be passed to the setters. And the value\n * that is passed to a setter will effectively be the value set in the view,\n * and returned by the corresponding getter.\n *\n * But a View object also has a *resolution constraint*, a\n * *rotation constraint* and a *center constraint*.\n *\n * As said above, no constraints are applied when the setters are used to set\n * new states for the view. Applying constraints is done explicitly through\n * the use of the `constrain*` functions (`constrainResolution` and\n * `constrainRotation` and `constrainCenter`).\n *\n * The main users of the constraints are the interactions and the\n * controls. For example, double-clicking on the map changes the view to\n * the "next" resolution. And releasing the fingers after pinch-zooming\n * snaps to the closest resolution (with an animation).\n *\n * The *resolution constraint* snaps to specific resolutions. It is\n * determined by the following options: `resolutions`, `maxResolution`,\n * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three\n * options are ignored. See documentation for each option for more\n * information.\n *\n * The *rotation constraint* snaps to specific angles. It is determined\n * by the following options: `enableRotation` and `constrainRotation`.\n * By default the rotation value is snapped to zero when approaching the\n * horizontal.\n *\n * The *center constraint* is determined by the `extent` option. By\n * default the center is not constrained at all.\n *\n  * @api\n */\n\nvar View_View =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function View(opt_options) {\n    BaseObject.call(this);\n    var options = Object(obj["a" /* assign */])({}, opt_options);\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.hints_ = [0, 0];\n    /**\n     * @private\n     * @type {Array<Array<Animation>>}\n     */\n\n    this.animations_ = [];\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.updateAnimationKey_;\n    this.updateAnimations_ = this.updateAnimations_.bind(this);\n    /**\n     * @private\n     * @const\n     * @type {import("./proj/Projection.js").default}\n     */\n\n    this.projection_ = Object(proj["createProjection"])(options.projection, \'EPSG:3857\');\n    this.applyOptions_(options);\n  }\n\n  if (BaseObject) View.__proto__ = BaseObject;\n  View.prototype = Object.create(BaseObject && BaseObject.prototype);\n  View.prototype.constructor = View;\n  /**\n   * Set up the view with the given options.\n   * @param {ViewOptions} options View options.\n   */\n\n  View.prototype.applyOptions_ = function applyOptions_(options) {\n    /**\n     * @type {Object<string, *>}\n     */\n    var properties = {};\n    properties[ViewProperty.CENTER] = options.center !== undefined ? options.center : null;\n    var resolutionConstraintInfo = createResolutionConstraint(options);\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.maxResolution_ = resolutionConstraintInfo.maxResolution;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.minResolution_ = resolutionConstraintInfo.minResolution;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;\n    /**\n     * @private\n     * @type {Array<number>|undefined}\n     */\n\n    this.resolutions_ = options.resolutions;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.minZoom_ = resolutionConstraintInfo.minZoom;\n    var centerConstraint = createCenterConstraint(options);\n    var resolutionConstraint = resolutionConstraintInfo.constraint;\n    var rotationConstraint = createRotationConstraint(options);\n    /**\n     * @private\n     * @type {Constraints}\n     */\n\n    this.constraints_ = {\n      center: centerConstraint,\n      resolution: resolutionConstraint,\n      rotation: rotationConstraint\n    };\n\n    if (options.resolution !== undefined) {\n      properties[ViewProperty.RESOLUTION] = options.resolution;\n    } else if (options.zoom !== undefined) {\n      properties[ViewProperty.RESOLUTION] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_);\n\n      if (this.resolutions_) {\n        // in case map zoom is out of min/max zoom range\n        properties[ViewProperty.RESOLUTION] = Object(math["a" /* clamp */])(Number(this.getResolution() || properties[ViewProperty.RESOLUTION]), this.minResolution_, this.maxResolution_);\n      }\n    }\n\n    properties[ViewProperty.ROTATION] = options.rotation !== undefined ? options.rotation : 0;\n    this.setProperties(properties);\n    /**\n     * @private\n     * @type {ViewOptions}\n     */\n\n    this.options_ = options;\n  };\n  /**\n   * Get an updated version of the view options used to construct the view.  The\n   * current resolution (or zoom), center, and rotation are applied to any stored\n   * options.  The provided options can be used to apply new min/max zoom or\n   * resolution limits.\n   * @param {ViewOptions} newOptions New options to be applied.\n   * @return {ViewOptions} New options updated with the current view state.\n   */\n\n\n  View.prototype.getUpdatedOptions_ = function getUpdatedOptions_(newOptions) {\n    var options = Object(obj["a" /* assign */])({}, this.options_); // preserve resolution (or zoom)\n\n    if (options.resolution !== undefined) {\n      options.resolution = this.getResolution();\n    } else {\n      options.zoom = this.getZoom();\n    } // preserve center\n\n\n    options.center = this.getCenter(); // preserve rotation\n\n    options.rotation = this.getRotation();\n    return Object(obj["a" /* assign */])({}, options, newOptions);\n  };\n  /**\n   * Animate the view.  The view\'s center, zoom (or resolution), and rotation\n   * can be animated for smooth transitions between view states.  For example,\n   * to animate the view to a new zoom level:\n   *\n   *     view.animate({zoom: view.getZoom() + 1});\n   *\n   * By default, the animation lasts one second and uses in-and-out easing.  You\n   * can customize this behavior by including `duration` (in milliseconds) and\n   * `easing` options (see {@link module:ol/easing}).\n   *\n   * To chain together multiple animations, call the method with multiple\n   * animation objects.  For example, to first zoom and then pan:\n   *\n   *     view.animate({zoom: 10}, {center: [0, 0]});\n   *\n   * If you provide a function as the last argument to the animate method, it\n   * will get called at the end of an animation series.  The callback will be\n   * called with `true` if the animation series completed on its own or `false`\n   * if it was cancelled.\n   *\n   * Animations are cancelled by user interactions (e.g. dragging the map) or by\n   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`\n   * (or another method that calls one of these).\n   *\n   * @param {...(AnimationOptions|function(boolean))} var_args Animation\n   *     options.  Multiple animations can be run in series by passing multiple\n   *     options objects.  To run multiple animations in parallel, call the method\n   *     multiple times.  An optional callback can be provided as a final\n   *     argument.  The callback will be called with a boolean indicating whether\n   *     the animation completed without being cancelled.\n   * @api\n   */\n\n\n  View.prototype.animate = function animate(var_args) {\n    var arguments$1 = arguments;\n    var animationCount = arguments.length;\n    var callback;\n\n    if (animationCount > 1 && typeof arguments[animationCount - 1] === \'function\') {\n      callback = arguments[animationCount - 1];\n      --animationCount;\n    }\n\n    if (!this.isDef()) {\n      // if view properties are not yet set, shortcut to the final state\n      var state = arguments[animationCount - 1];\n\n      if (state.center) {\n        this.setCenter(state.center);\n      }\n\n      if (state.zoom !== undefined) {\n        this.setZoom(state.zoom);\n      }\n\n      if (state.rotation !== undefined) {\n        this.setRotation(state.rotation);\n      }\n\n      if (callback) {\n        animationCallback(callback, true);\n      }\n\n      return;\n    }\n\n    var start = Date.now();\n    var center = this.getCenter().slice();\n    var resolution = this.getResolution();\n    var rotation = this.getRotation();\n    var series = [];\n\n    for (var i = 0; i < animationCount; ++i) {\n      var options =\n      /** @type {AnimationOptions} */\n      arguments$1[i];\n      var animation =\n      /** @type {Animation} */\n      {\n        start: start,\n        complete: false,\n        anchor: options.anchor,\n        duration: options.duration !== undefined ? options.duration : 1000,\n        easing: options.easing || easing["inAndOut"]\n      };\n\n      if (options.center) {\n        animation.sourceCenter = center;\n        animation.targetCenter = options.center;\n        center = animation.targetCenter;\n      }\n\n      if (options.zoom !== undefined) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_, 0);\n        resolution = animation.targetResolution;\n      } else if (options.resolution) {\n        animation.sourceResolution = resolution;\n        animation.targetResolution = options.resolution;\n        resolution = animation.targetResolution;\n      }\n\n      if (options.rotation !== undefined) {\n        animation.sourceRotation = rotation;\n        var delta = Object(math["d" /* modulo */])(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;\n        animation.targetRotation = rotation + delta;\n        rotation = animation.targetRotation;\n      }\n\n      animation.callback = callback; // check if animation is a no-op\n\n      if (isNoopAnimation(animation)) {\n        animation.complete = true; // we still push it onto the series for callback handling\n      } else {\n        start += animation.duration;\n      }\n\n      series.push(animation);\n    }\n\n    this.animations_.push(series);\n    this.setHint(ViewHint["a" /* default */].ANIMATING, 1);\n    this.updateAnimations_();\n  };\n  /**\n   * Determine if the view is being animated.\n   * @return {boolean} The view is being animated.\n   * @api\n   */\n\n\n  View.prototype.getAnimating = function getAnimating() {\n    return this.hints_[ViewHint["a" /* default */].ANIMATING] > 0;\n  };\n  /**\n   * Determine if the user is interacting with the view, such as panning or zooming.\n   * @return {boolean} The view is being interacted with.\n   * @api\n   */\n\n\n  View.prototype.getInteracting = function getInteracting() {\n    return this.hints_[ViewHint["a" /* default */].INTERACTING] > 0;\n  };\n  /**\n   * Cancel any ongoing animations.\n   * @api\n   */\n\n\n  View.prototype.cancelAnimations = function cancelAnimations() {\n    this.setHint(ViewHint["a" /* default */].ANIMATING, -this.hints_[ViewHint["a" /* default */].ANIMATING]);\n\n    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {\n      var series = this.animations_[i];\n\n      if (series[0].callback) {\n        animationCallback(series[0].callback, false);\n      }\n    }\n\n    this.animations_.length = 0;\n  };\n  /**\n   * Update all animations.\n   */\n\n\n  View.prototype.updateAnimations_ = function updateAnimations_() {\n    if (this.updateAnimationKey_ !== undefined) {\n      cancelAnimationFrame(this.updateAnimationKey_);\n      this.updateAnimationKey_ = undefined;\n    }\n\n    if (!this.getAnimating()) {\n      return;\n    }\n\n    var now = Date.now();\n    var more = false;\n\n    for (var i = this.animations_.length - 1; i >= 0; --i) {\n      var series = this.animations_[i];\n      var seriesComplete = true;\n\n      for (var j = 0, jj = series.length; j < jj; ++j) {\n        var animation = series[j];\n\n        if (animation.complete) {\n          continue;\n        }\n\n        var elapsed = now - animation.start;\n        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;\n\n        if (fraction >= 1) {\n          animation.complete = true;\n          fraction = 1;\n        } else {\n          seriesComplete = false;\n        }\n\n        var progress = animation.easing(fraction);\n\n        if (animation.sourceCenter) {\n          var x0 = animation.sourceCenter[0];\n          var y0 = animation.sourceCenter[1];\n          var x1 = animation.targetCenter[0];\n          var y1 = animation.targetCenter[1];\n          var x = x0 + progress * (x1 - x0);\n          var y = y0 + progress * (y1 - y0);\n          this.set(ViewProperty.CENTER, [x, y]);\n        }\n\n        if (animation.sourceResolution && animation.targetResolution) {\n          var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);\n\n          if (animation.anchor) {\n            this.set(ViewProperty.CENTER, this.calculateCenterZoom(resolution, animation.anchor));\n          }\n\n          this.set(ViewProperty.RESOLUTION, resolution);\n        }\n\n        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {\n          var rotation = progress === 1 ? Object(math["d" /* modulo */])(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);\n\n          if (animation.anchor) {\n            this.set(ViewProperty.CENTER, this.calculateCenterRotate(rotation, animation.anchor));\n          }\n\n          this.set(ViewProperty.ROTATION, rotation);\n        }\n\n        more = true;\n\n        if (!animation.complete) {\n          break;\n        }\n      }\n\n      if (seriesComplete) {\n        this.animations_[i] = null;\n        this.setHint(ViewHint["a" /* default */].ANIMATING, -1);\n        var callback = series[0].callback;\n\n        if (callback) {\n          animationCallback(callback, true);\n        }\n      }\n    } // prune completed series\n\n\n    this.animations_ = this.animations_.filter(Boolean);\n\n    if (more && this.updateAnimationKey_ === undefined) {\n      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);\n    }\n  };\n  /**\n   * @param {number} rotation Target rotation.\n   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.\n   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.\n   */\n\n\n  View.prototype.calculateCenterRotate = function calculateCenterRotate(rotation, anchor) {\n    var center;\n    var currentCenter = this.getCenter();\n\n    if (currentCenter !== undefined) {\n      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];\n      Object(coordinate["rotate"])(center, rotation - this.getRotation());\n      Object(coordinate["add"])(center, anchor);\n    }\n\n    return center;\n  };\n  /**\n   * @param {number} resolution Target resolution.\n   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.\n   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.\n   */\n\n\n  View.prototype.calculateCenterZoom = function calculateCenterZoom(resolution, anchor) {\n    var center;\n    var currentCenter = this.getCenter();\n    var currentResolution = this.getResolution();\n\n    if (currentCenter !== undefined && currentResolution !== undefined) {\n      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;\n      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;\n      center = [x, y];\n    }\n\n    return center;\n  };\n  /**\n   * @private\n   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.\n   */\n\n\n  View.prototype.getSizeFromViewport_ = function getSizeFromViewport_() {\n    var size = [100, 100];\n    var selector = \'.ol-viewport[data-view="\' + Object(util["c" /* getUid */])(this) + \'"]\';\n    var element = document.querySelector(selector);\n\n    if (element) {\n      var metrics = getComputedStyle(element);\n      size[0] = parseInt(metrics.width, 10);\n      size[1] = parseInt(metrics.height, 10);\n    }\n\n    return size;\n  };\n  /**\n   * Get the constrained center of this view.\n   * @param {import("./coordinate.js").Coordinate|undefined} center Center.\n   * @return {import("./coordinate.js").Coordinate|undefined} Constrained center.\n   * @api\n   */\n\n\n  View.prototype.constrainCenter = function constrainCenter(center) {\n    return this.constraints_.center(center);\n  };\n  /**\n   * Get the constrained resolution of this view.\n   * @param {number|undefined} resolution Resolution.\n   * @param {number=} opt_delta Delta. Default is `0`.\n   * @param {number=} opt_direction Direction. Default is `0`.\n   * @return {number|undefined} Constrained resolution.\n   * @api\n   */\n\n\n  View.prototype.constrainResolution = function constrainResolution(resolution, opt_delta, opt_direction) {\n    var delta = opt_delta || 0;\n    var direction = opt_direction || 0;\n    return this.constraints_.resolution(resolution, delta, direction);\n  };\n  /**\n   * Get the constrained rotation of this view.\n   * @param {number|undefined} rotation Rotation.\n   * @param {number=} opt_delta Delta. Default is `0`.\n   * @return {number|undefined} Constrained rotation.\n   * @api\n   */\n\n\n  View.prototype.constrainRotation = function constrainRotation(rotation, opt_delta) {\n    var delta = opt_delta || 0;\n    return this.constraints_.rotation(rotation, delta);\n  };\n  /**\n   * Get the view center.\n   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.getCenter = function getCenter() {\n    return (\n      /** @type {import("./coordinate.js").Coordinate|undefined} */\n      this.get(ViewProperty.CENTER)\n    );\n  };\n  /**\n   * @return {Constraints} Constraints.\n   */\n\n\n  View.prototype.getConstraints = function getConstraints() {\n    return this.constraints_;\n  };\n  /**\n   * @param {Array<number>=} opt_hints Destination array.\n   * @return {Array<number>} Hint.\n   */\n\n\n  View.prototype.getHints = function getHints(opt_hints) {\n    if (opt_hints !== undefined) {\n      opt_hints[0] = this.hints_[0];\n      opt_hints[1] = this.hints_[1];\n      return opt_hints;\n    } else {\n      return this.hints_.slice();\n    }\n  };\n  /**\n   * Calculate the extent for the current view state and the passed size.\n   * The size is the pixel dimensions of the box into which the calculated extent\n   * should fit. In most cases you want to get the extent of the entire map,\n   * that is `map.getSize()`.\n   * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size of the\n   * first map that uses this view will be used.\n   * @return {import("./extent.js").Extent} Extent.\n   * @api\n   */\n\n\n  View.prototype.calculateExtent = function calculateExtent(opt_size) {\n    var size = opt_size || this.getSizeFromViewport_();\n    var center =\n    /** @type {!import("./coordinate.js").Coordinate} */\n    this.getCenter();\n    Object(asserts["a" /* assert */])(center, 1); // The view center is not defined\n\n    var resolution =\n    /** @type {!number} */\n    this.getResolution();\n    Object(asserts["a" /* assert */])(resolution !== undefined, 2); // The view resolution is not defined\n\n    var rotation =\n    /** @type {!number} */\n    this.getRotation();\n    Object(asserts["a" /* assert */])(rotation !== undefined, 3); // The view rotation is not defined\n\n    return Object(ol_extent["getForViewAndSize"])(center, resolution, rotation, size);\n  };\n  /**\n   * Get the maximum resolution of the view.\n   * @return {number} The maximum resolution of the view.\n   * @api\n   */\n\n\n  View.prototype.getMaxResolution = function getMaxResolution() {\n    return this.maxResolution_;\n  };\n  /**\n   * Get the minimum resolution of the view.\n   * @return {number} The minimum resolution of the view.\n   * @api\n   */\n\n\n  View.prototype.getMinResolution = function getMinResolution() {\n    return this.minResolution_;\n  };\n  /**\n   * Get the maximum zoom level for the view.\n   * @return {number} The maximum zoom level.\n   * @api\n   */\n\n\n  View.prototype.getMaxZoom = function getMaxZoom() {\n    return (\n      /** @type {number} */\n      this.getZoomForResolution(this.minResolution_)\n    );\n  };\n  /**\n   * Set a new maximum zoom level for the view.\n   * @param {number} zoom The maximum zoom level.\n   * @api\n   */\n\n\n  View.prototype.setMaxZoom = function setMaxZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({\n      maxZoom: zoom\n    }));\n  };\n  /**\n   * Get the minimum zoom level for the view.\n   * @return {number} The minimum zoom level.\n   * @api\n   */\n\n\n  View.prototype.getMinZoom = function getMinZoom() {\n    return (\n      /** @type {number} */\n      this.getZoomForResolution(this.maxResolution_)\n    );\n  };\n  /**\n   * Set a new minimum zoom level for the view.\n   * @param {number} zoom The minimum zoom level.\n   * @api\n   */\n\n\n  View.prototype.setMinZoom = function setMinZoom(zoom) {\n    this.applyOptions_(this.getUpdatedOptions_({\n      minZoom: zoom\n    }));\n  };\n  /**\n   * Get the view projection.\n   * @return {import("./proj/Projection.js").default} The projection of the view.\n   * @api\n   */\n\n\n  View.prototype.getProjection = function getProjection() {\n    return this.projection_;\n  };\n  /**\n   * Get the view resolution.\n   * @return {number|undefined} The resolution of the view.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.getResolution = function getResolution() {\n    return (\n      /** @type {number|undefined} */\n      this.get(ViewProperty.RESOLUTION)\n    );\n  };\n  /**\n   * Get the resolutions for the view. This returns the array of resolutions\n   * passed to the constructor of the View, or undefined if none were given.\n   * @return {Array<number>|undefined} The resolutions of the view.\n   * @api\n   */\n\n\n  View.prototype.getResolutions = function getResolutions() {\n    return this.resolutions_;\n  };\n  /**\n   * Get the resolution for a provided extent (in map units) and size (in pixels).\n   * @param {import("./extent.js").Extent} extent Extent.\n   * @param {import("./size.js").Size=} opt_size Box pixel size.\n   * @return {number} The resolution at which the provided extent will render at\n   *     the given size.\n   * @api\n   */\n\n\n  View.prototype.getResolutionForExtent = function getResolutionForExtent(extent, opt_size) {\n    var size = opt_size || this.getSizeFromViewport_();\n    var xResolution = Object(ol_extent["getWidth"])(extent) / size[0];\n    var yResolution = Object(ol_extent["getHeight"])(extent) / size[1];\n    return Math.max(xResolution, yResolution);\n  };\n  /**\n   * Return a function that returns a value between 0 and 1 for a\n   * resolution. Exponential scaling is assumed.\n   * @param {number=} opt_power Power.\n   * @return {function(number): number} Resolution for value function.\n   */\n\n\n  View.prototype.getResolutionForValueFunction = function getResolutionForValueFunction(opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.maxResolution_;\n    var minResolution = this.minResolution_;\n    var max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} value Value.\n       * @return {number} Resolution.\n       */\n      function (value) {\n        var resolution = maxResolution / Math.pow(power, value * max);\n        return resolution;\n      }\n    );\n  };\n  /**\n   * Get the view rotation.\n   * @return {number} The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.getRotation = function getRotation() {\n    return (\n      /** @type {number} */\n      this.get(ViewProperty.ROTATION)\n    );\n  };\n  /**\n   * Return a function that returns a resolution for a value between\n   * 0 and 1. Exponential scaling is assumed.\n   * @param {number=} opt_power Power.\n   * @return {function(number): number} Value for resolution function.\n   */\n\n\n  View.prototype.getValueForResolutionFunction = function getValueForResolutionFunction(opt_power) {\n    var power = opt_power || 2;\n    var maxResolution = this.maxResolution_;\n    var minResolution = this.minResolution_;\n    var max = Math.log(maxResolution / minResolution) / Math.log(power);\n    return (\n      /**\n       * @param {number} resolution Resolution.\n       * @return {number} Value.\n       */\n      function (resolution) {\n        var value = Math.log(maxResolution / resolution) / Math.log(power) / max;\n        return value;\n      }\n    );\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio for center rounding.\n   * @return {State} View state.\n   */\n\n\n  View.prototype.getState = function getState(pixelRatio) {\n    var center =\n    /** @type {import("./coordinate.js").Coordinate} */\n    this.getCenter();\n    var projection = this.getProjection();\n    var resolution =\n    /** @type {number} */\n    this.getResolution();\n    var pixelResolution = resolution / pixelRatio;\n    var rotation = this.getRotation();\n    return (\n      /** @type {State} */\n      {\n        center: [Math.round(center[0] / pixelResolution) * pixelResolution, Math.round(center[1] / pixelResolution) * pixelResolution],\n        projection: projection !== undefined ? projection : null,\n        resolution: resolution,\n        rotation: rotation,\n        zoom: this.getZoom()\n      }\n    );\n  };\n  /**\n   * Get the current zoom level.  If you configured your view with a resolutions\n   * array (this is rare), this method may return non-integer zoom levels (so\n   * the zoom level is not safe to use as an index into a resolutions array).\n   * @return {number|undefined} Zoom.\n   * @api\n   */\n\n\n  View.prototype.getZoom = function getZoom() {\n    var zoom;\n    var resolution = this.getResolution();\n\n    if (resolution !== undefined) {\n      zoom = this.getZoomForResolution(resolution);\n    }\n\n    return zoom;\n  };\n  /**\n   * Get the zoom level for a resolution.\n   * @param {number} resolution The resolution.\n   * @return {number|undefined} The zoom level for the provided resolution.\n   * @api\n   */\n\n\n  View.prototype.getZoomForResolution = function getZoomForResolution(resolution) {\n    var offset = this.minZoom_ || 0;\n    var max, zoomFactor;\n\n    if (this.resolutions_) {\n      var nearest = Object(array["f" /* linearFindNearest */])(this.resolutions_, resolution, 1);\n      offset = nearest;\n      max = this.resolutions_[nearest];\n\n      if (nearest == this.resolutions_.length - 1) {\n        zoomFactor = 2;\n      } else {\n        zoomFactor = max / this.resolutions_[nearest + 1];\n      }\n    } else {\n      max = this.maxResolution_;\n      zoomFactor = this.zoomFactor_;\n    }\n\n    return offset + Math.log(max / resolution) / Math.log(zoomFactor);\n  };\n  /**\n   * Get the resolution for a zoom level.\n   * @param {number} zoom Zoom level.\n   * @return {number} The view resolution for the provided zoom level.\n   * @api\n   */\n\n\n  View.prototype.getResolutionForZoom = function getResolutionForZoom(zoom) {\n    return (\n      /** @type {number} */\n      this.constrainResolution(this.maxResolution_, zoom - this.minZoom_, 0)\n    );\n  };\n  /**\n   * Fit the given geometry or extent based on the given map size and border.\n   * The size is pixel dimensions of the box to fit the extent into.\n   * In most cases you will want to use the map size, that is `map.getSize()`.\n   * Takes care of the map angle.\n   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or\n   *     extent to fit the view to.\n   * @param {FitOptions=} opt_options Options.\n   * @api\n   */\n\n\n  View.prototype.fit = function fit(geometryOrExtent, opt_options) {\n    var options = opt_options || {};\n    var size = options.size;\n\n    if (!size) {\n      size = this.getSizeFromViewport_();\n    }\n    /** @type {import("./geom/SimpleGeometry.js").default} */\n\n\n    var geometry;\n    Object(asserts["a" /* assert */])(Array.isArray(geometryOrExtent) || typeof\n    /** @type {?} */\n    geometryOrExtent.getSimplifiedGeometry === \'function\', 24); // Invalid extent or geometry provided as `geometry`\n\n    if (Array.isArray(geometryOrExtent)) {\n      Object(asserts["a" /* assert */])(!Object(ol_extent["isEmpty"])(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`\n\n      geometry = Object(Polygon["c" /* fromExtent */])(geometryOrExtent);\n    } else if (geometryOrExtent.getType() === GeometryType["a" /* default */].CIRCLE) {\n      geometryOrExtent = geometryOrExtent.getExtent();\n      geometry = Object(Polygon["c" /* fromExtent */])(geometryOrExtent);\n      geometry.rotate(this.getRotation(), Object(ol_extent["getCenter"])(geometryOrExtent));\n    } else {\n      geometry = geometryOrExtent;\n    }\n\n    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];\n    var constrainResolution = options.constrainResolution !== undefined ? options.constrainResolution : true;\n    var nearest = options.nearest !== undefined ? options.nearest : false;\n    var minResolution;\n\n    if (options.minResolution !== undefined) {\n      minResolution = options.minResolution;\n    } else if (options.maxZoom !== undefined) {\n      minResolution = this.constrainResolution(this.maxResolution_, options.maxZoom - this.minZoom_, 0);\n    } else {\n      minResolution = 0;\n    }\n\n    var coords = geometry.getFlatCoordinates(); // calculate rotated extent\n\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var minRotX = +Infinity;\n    var minRotY = +Infinity;\n    var maxRotX = -Infinity;\n    var maxRotY = -Infinity;\n    var stride = geometry.getStride();\n\n    for (var i = 0, ii = coords.length; i < ii; i += stride) {\n      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;\n      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;\n      minRotX = Math.min(minRotX, rotX);\n      minRotY = Math.min(minRotY, rotY);\n      maxRotX = Math.max(maxRotX, rotX);\n      maxRotY = Math.max(maxRotY, rotY);\n    } // calculate resolution\n\n\n    var resolution = this.getResolutionForExtent([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);\n    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);\n\n    if (constrainResolution) {\n      var constrainedResolution = this.constrainResolution(resolution, 0, 0);\n\n      if (!nearest && constrainedResolution < resolution) {\n        constrainedResolution = this.constrainResolution(constrainedResolution, -1, 0);\n      }\n\n      resolution = constrainedResolution;\n    } // calculate center\n\n\n    sinAngle = -sinAngle; // go back to original rotation\n\n    var centerRotX = (minRotX + maxRotX) / 2;\n    var centerRotY = (minRotY + maxRotY) / 2;\n    centerRotX += (padding[1] - padding[3]) / 2 * resolution;\n    centerRotY += (padding[0] - padding[2]) / 2 * resolution;\n    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;\n    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;\n    var center = [centerX, centerY];\n    var callback = options.callback ? options.callback : functions["c" /* VOID */];\n\n    if (options.duration !== undefined) {\n      this.animate({\n        resolution: resolution,\n        center: center,\n        duration: options.duration,\n        easing: options.easing\n      }, callback);\n    } else {\n      this.setResolution(resolution);\n      this.setCenter(center);\n      animationCallback(callback, true);\n    }\n  };\n  /**\n   * Center on coordinate and view position.\n   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {import("./size.js").Size} size Box pixel size.\n   * @param {import("./pixel.js").Pixel} position Position on the view to center on.\n   * @api\n   */\n\n\n  View.prototype.centerOn = function centerOn(coordinate, size, position) {\n    // calculate rotated position\n    var rotation = this.getRotation();\n    var cosAngle = Math.cos(-rotation);\n    var sinAngle = Math.sin(-rotation);\n    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n    var resolution = this.getResolution();\n    rotX += (size[0] / 2 - position[0]) * resolution;\n    rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle\n\n    sinAngle = -sinAngle; // go back to original rotation\n\n    var centerX = rotX * cosAngle - rotY * sinAngle;\n    var centerY = rotY * cosAngle + rotX * sinAngle;\n    this.setCenter([centerX, centerY]);\n  };\n  /**\n   * @return {boolean} Is defined.\n   */\n\n\n  View.prototype.isDef = function isDef() {\n    return !!this.getCenter() && this.getResolution() !== undefined;\n  };\n  /**\n   * Rotate the view around a given coordinate.\n   * @param {number} rotation New rotation value for the view.\n   * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.\n   * @api\n   */\n\n\n  View.prototype.rotate = function rotate(rotation, opt_anchor) {\n    if (opt_anchor !== undefined) {\n      var center = this.calculateCenterRotate(rotation, opt_anchor);\n      this.setCenter(center);\n    }\n\n    this.setRotation(rotation);\n  };\n  /**\n   * Set the center of the current view.\n   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.setCenter = function setCenter(center) {\n    this.set(ViewProperty.CENTER, center);\n\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  /**\n   * @param {ViewHint} hint Hint.\n   * @param {number} delta Delta.\n   * @return {number} New value.\n   */\n\n\n  View.prototype.setHint = function setHint(hint, delta) {\n    this.hints_[hint] += delta;\n    this.changed();\n    return this.hints_[hint];\n  };\n  /**\n   * Set the resolution for this view.\n   * @param {number|undefined} resolution The resolution of the view.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.setResolution = function setResolution(resolution) {\n    this.set(ViewProperty.RESOLUTION, resolution);\n\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  /**\n   * Set the rotation for this view.\n   * @param {number} rotation The rotation of the view in radians.\n   * @observable\n   * @api\n   */\n\n\n  View.prototype.setRotation = function setRotation(rotation) {\n    this.set(ViewProperty.ROTATION, rotation);\n\n    if (this.getAnimating()) {\n      this.cancelAnimations();\n    }\n  };\n  /**\n   * Zoom to a specific zoom level.\n   * @param {number} zoom Zoom level.\n   * @api\n   */\n\n\n  View.prototype.setZoom = function setZoom(zoom) {\n    this.setResolution(this.getResolutionForZoom(zoom));\n  };\n\n  return View;\n}(ol_Object["a" /* default */]);\n/**\n * @param {Function} callback Callback.\n * @param {*} returnValue Return value.\n */\n\n\nfunction animationCallback(callback, returnValue) {\n  setTimeout(function () {\n    callback(returnValue);\n  }, 0);\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {import("./centerconstraint.js").Type} The constraint.\n */\n\n\nfunction createCenterConstraint(options) {\n  if (options.extent !== undefined) {\n    return createExtent(options.extent);\n  } else {\n    return none;\n  }\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,\n *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.\n */\n\nfunction createResolutionConstraint(options) {\n  var resolutionConstraint;\n  var maxResolution;\n  var minResolution; // TODO: move these to be ol constants\n  // see https://github.com/openlayers/openlayers/issues/2076\n\n  var defaultMaxZoom = 28;\n  var defaultZoomFactor = 2;\n  var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;\n  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;\n  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;\n\n  if (options.resolutions !== undefined) {\n    var resolutions = options.resolutions;\n    maxResolution = resolutions[minZoom];\n    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];\n    resolutionConstraint = createSnapToResolutions(resolutions);\n  } else {\n    // calculate the default min and max resolution\n    var projection = Object(proj["createProjection"])(options.projection, \'EPSG:3857\');\n    var extent = projection.getExtent();\n    var size = !extent ? // use an extent that can fit the whole world if need be\n    360 * proj["METERS_PER_UNIT"][Units["b" /* default */].DEGREES] / projection.getMetersPerUnit() : Math.max(Object(ol_extent["getWidth"])(extent), Object(ol_extent["getHeight"])(extent));\n    var defaultMaxResolution = size / common["b" /* DEFAULT_TILE_SIZE */] / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);\n    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence\n\n    maxResolution = options.maxResolution;\n\n    if (maxResolution !== undefined) {\n      minZoom = 0;\n    } else {\n      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);\n    } // user provided minResolution takes precedence\n\n\n    minResolution = options.minResolution;\n\n    if (minResolution === undefined) {\n      if (options.maxZoom !== undefined) {\n        if (options.maxResolution !== undefined) {\n          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);\n        } else {\n          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);\n        }\n      } else {\n        minResolution = defaultMinResolution;\n      }\n    } // given discrete zoom levels, minResolution may be different than provided\n\n\n    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));\n    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);\n    resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, maxZoom - minZoom);\n  }\n\n  return {\n    constraint: resolutionConstraint,\n    maxResolution: maxResolution,\n    minResolution: minResolution,\n    minZoom: minZoom,\n    zoomFactor: zoomFactor\n  };\n}\n/**\n * @param {ViewOptions} options View options.\n * @return {import("./rotationconstraint.js").Type} Rotation constraint.\n */\n\nfunction createRotationConstraint(options) {\n  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;\n\n  if (enableRotation) {\n    var constrainRotation = options.constrainRotation;\n\n    if (constrainRotation === undefined || constrainRotation === true) {\n      return createSnapToZero();\n    } else if (constrainRotation === false) {\n      return rotationconstraint_none;\n    } else if (typeof constrainRotation === \'number\') {\n      return createSnapToN(constrainRotation);\n    } else {\n      return rotationconstraint_none;\n    }\n  } else {\n    return disable;\n  }\n}\n/**\n * Determine if an animation involves no view change.\n * @param {Animation} animation The animation.\n * @return {boolean} The animation involves no view change.\n */\n\nfunction isNoopAnimation(animation) {\n  if (animation.sourceCenter && animation.targetCenter) {\n    if (!Object(coordinate["equals"])(animation.sourceCenter, animation.targetCenter)) {\n      return false;\n    }\n  }\n\n  if (animation.sourceResolution !== animation.targetResolution) {\n    return false;\n  }\n\n  if (animation.sourceRotation !== animation.targetRotation) {\n    return false;\n  }\n\n  return true;\n}\n/* harmony default export */ var ol_View = __webpack_exports__["default"] = (View_View);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9jZW50ZXJjb25zdHJhaW50LmpzP2Q1MDAiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9yZXNvbHV0aW9uY29uc3RyYWludC5qcz9jNGMyIiwid2VicGFjazovLy8uLi8uLi9zcmMvb2wvcm90YXRpb25jb25zdHJhaW50LmpzPzQxNmQiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9WaWV3UHJvcGVydHkuanM/MGRiYSIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL1ZpZXcuanM/NDNlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvY2VudGVyY29uc3RyYWludFxuICovXG5pbXBvcnQge2NsYW1wfSBmcm9tICcuL21hdGguanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWQpKTogKGltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZCl9IFR5cGVcbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGV4dGVudCBFeHRlbnQuXG4gKiBAcmV0dXJuIHtUeXBlfSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV4dGVudChleHRlbnQpIHtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gY2VudGVyIENlbnRlci5cbiAgICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IENlbnRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihjZW50ZXIpIHtcbiAgICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBjbGFtcChjZW50ZXJbMF0sIGV4dGVudFswXSwgZXh0ZW50WzJdKSxcbiAgICAgICAgICBjbGFtcChjZW50ZXJbMV0sIGV4dGVudFsxXSwgZXh0ZW50WzNdKVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gY2VudGVyIENlbnRlci5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9uZShjZW50ZXIpIHtcbiAgcmV0dXJuIGNlbnRlcjtcbn1cbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZXNvbHV0aW9uY29uc3RyYWludFxuICovXG5pbXBvcnQge2xpbmVhckZpbmROZWFyZXN0fSBmcm9tICcuL2FycmF5LmpzJztcbmltcG9ydCB7Y2xhbXB9IGZyb20gJy4vbWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKG51bWJlcnx1bmRlZmluZWQpLCBudW1iZXIsIG51bWJlcik6IChudW1iZXJ8dW5kZWZpbmVkKX0gVHlwZVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHJlc29sdXRpb25zIFJlc29sdXRpb25zLlxuICogQHJldHVybiB7VHlwZX0gWm9vbSBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zKHJlc29sdXRpb25zKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlc29sdXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24ocmVzb2x1dGlvbiwgZGVsdGEsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgeiA9IGxpbmVhckZpbmROZWFyZXN0KHJlc29sdXRpb25zLCByZXNvbHV0aW9uLCBkaXJlY3Rpb24pO1xuICAgICAgICB6ID0gY2xhbXAoeiArIGRlbHRhLCAwLCByZXNvbHV0aW9ucy5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKHopO1xuICAgICAgICBpZiAoeiAhPSBpbmRleCAmJiBpbmRleCA8IHJlc29sdXRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBwb3dlciA9IHJlc29sdXRpb25zW2luZGV4XSAvIHJlc29sdXRpb25zW2luZGV4ICsgMV07XG4gICAgICAgICAgcmV0dXJuIHJlc29sdXRpb25zW2luZGV4XSAvIE1hdGgucG93KHBvd2VyLCB6IC0gaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXNvbHV0aW9uc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvd2VyIFBvd2VyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1heFJlc29sdXRpb24gTWF4aW11bSByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfbWF4TGV2ZWwgTWF4aW11bSBsZXZlbC5cbiAqIEByZXR1cm4ge1R5cGV9IFpvb20gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbmFwVG9Qb3dlcihwb3dlciwgbWF4UmVzb2x1dGlvbiwgb3B0X21heExldmVsKSB7XG4gIHJldHVybiAoXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFJlc29sdXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gRGlyZWN0aW9uLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJlc29sdXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24ocmVzb2x1dGlvbiwgZGVsdGEsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKHJlc29sdXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAtZGlyZWN0aW9uIC8gMiArIDAuNTtcbiAgICAgICAgY29uc3Qgb2xkTGV2ZWwgPSBNYXRoLmZsb29yKFxuICAgICAgICAgIE1hdGgubG9nKG1heFJlc29sdXRpb24gLyByZXNvbHV0aW9uKSAvIE1hdGgubG9nKHBvd2VyKSArIG9mZnNldCk7XG4gICAgICAgIGxldCBuZXdMZXZlbCA9IE1hdGgubWF4KG9sZExldmVsICsgZGVsdGEsIDApO1xuICAgICAgICBpZiAob3B0X21heExldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdMZXZlbCA9IE1hdGgubWluKG5ld0xldmVsLCBvcHRfbWF4TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3cocG93ZXIsIG5ld0xldmVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG59XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcm90YXRpb25jb25zdHJhaW50XG4gKi9cbmltcG9ydCB7dG9SYWRpYW5zfSBmcm9tICcuL21hdGguanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKChudW1iZXJ8dW5kZWZpbmVkKSwgbnVtYmVyKTogKG51bWJlcnx1bmRlZmluZWQpfSBUeXBlXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGUocm90YXRpb24sIGRlbHRhKSB7XG4gIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9uZShyb3RhdGlvbiwgZGVsdGEpIHtcbiAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcm90YXRpb24gKyBkZWx0YTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbiBOLlxuICogQHJldHVybiB7VHlwZX0gUm90YXRpb24gY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNuYXBUb04obikge1xuICBjb25zdCB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gbjtcbiAgcmV0dXJuIChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJvdGF0aW9uIFJvdGF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YSBEZWx0YS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBSb3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbihyb3RhdGlvbiwgZGVsdGEpIHtcbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvdGF0aW9uID0gTWF0aC5mbG9vcigocm90YXRpb24gKyBkZWx0YSkgLyB0aGV0YSArIDAuNSkgKiB0aGV0YTtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X3RvbGVyYW5jZSBUb2xlcmFuY2UuXG4gKiBAcmV0dXJuIHtUeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU25hcFRvWmVybyhvcHRfdG9sZXJhbmNlKSB7XG4gIGNvbnN0IHRvbGVyYW5jZSA9IG9wdF90b2xlcmFuY2UgfHwgdG9SYWRpYW5zKDUpO1xuICByZXR1cm4gKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHVuZGVmaW5lZH0gcm90YXRpb24gUm90YXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhIERlbHRhLlxuICAgICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uKHJvdGF0aW9uLCBkZWx0YSkge1xuICAgICAgaWYgKHJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHJvdGF0aW9uICsgZGVsdGEpIDw9IHRvbGVyYW5jZSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByb3RhdGlvbiArIGRlbHRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xufVxuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdQcm9wZXJ0eVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBDRU5URVI6ICdjZW50ZXInLFxuICBSRVNPTFVUSU9OOiAncmVzb2x1dGlvbicsXG4gIFJPVEFUSU9OOiAncm90YXRpb24nXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1ZpZXdcbiAqL1xuaW1wb3J0IHtERUZBVUxUX1RJTEVfU0laRX0gZnJvbSAnLi90aWxlZ3JpZC9jb21tb24uanMnO1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4vdXRpbC5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7Y3JlYXRlRXh0ZW50LCBub25lIGFzIGNlbnRlck5vbmV9IGZyb20gJy4vY2VudGVyY29uc3RyYWludC5qcyc7XG5pbXBvcnQgQmFzZU9iamVjdCBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQge2NyZWF0ZVNuYXBUb1Jlc29sdXRpb25zLCBjcmVhdGVTbmFwVG9Qb3dlcn0gZnJvbSAnLi9yZXNvbHV0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQge2NyZWF0ZVNuYXBUb1plcm8sIGNyZWF0ZVNuYXBUb04sIG5vbmUgYXMgcm90YXRpb25Ob25lLCBkaXNhYmxlfSBmcm9tICcuL3JvdGF0aW9uY29uc3RyYWludC5qcyc7XG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi9WaWV3SGludC5qcyc7XG5pbXBvcnQgVmlld1Byb3BlcnR5IGZyb20gJy4vVmlld1Byb3BlcnR5LmpzJztcbmltcG9ydCB7bGluZWFyRmluZE5lYXJlc3R9IGZyb20gJy4vYXJyYXkuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2FkZCBhcyBhZGRDb29yZGluYXRlLCByb3RhdGUgYXMgcm90YXRlQ29vcmRpbmF0ZSwgZXF1YWxzIGFzIGNvb3JkaW5hdGVzRXF1YWx9IGZyb20gJy4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2luQW5kT3V0fSBmcm9tICcuL2Vhc2luZy5qcyc7XG5pbXBvcnQge2dldEZvclZpZXdBbmRTaXplLCBnZXRDZW50ZXIsIGdldEhlaWdodCwgZ2V0V2lkdGgsIGlzRW1wdHl9IGZyb20gJy4vZXh0ZW50LmpzJztcbmltcG9ydCBHZW9tZXRyeVR5cGUgZnJvbSAnLi9nZW9tL0dlb21ldHJ5VHlwZS5qcyc7XG5pbXBvcnQge2Zyb21FeHRlbnQgYXMgcG9seWdvbkZyb21FeHRlbnR9IGZyb20gJy4vZ2VvbS9Qb2x5Z29uLmpzJztcbmltcG9ydCB7Y2xhbXAsIG1vZHVsb30gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7YXNzaWdufSBmcm9tICcuL29iai5qcyc7XG5pbXBvcnQge2NyZWF0ZVByb2plY3Rpb24sIE1FVEVSU19QRVJfVU5JVH0gZnJvbSAnLi9wcm9qLmpzJztcbmltcG9ydCBVbml0cyBmcm9tICcuL3Byb2ovVW5pdHMuanMnO1xuXG5cbi8qKlxuICogQW4gYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBBbmltYXRpb25cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IFtzb3VyY2VDZW50ZXJdXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbdGFyZ2V0Q2VudGVyXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzb3VyY2VSZXNvbHV0aW9uXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0YXJnZXRSZXNvbHV0aW9uXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzb3VyY2VSb3RhdGlvbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGFyZ2V0Um90YXRpb25dXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29tcGxldGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IGVhc2luZ1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihib29sZWFuKX0gY2FsbGJhY2tcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29uc3RyYWludHNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jZW50ZXJjb25zdHJhaW50LmpzXCIpLlR5cGV9IGNlbnRlclxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGV9IHJlc29sdXRpb25cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9yb3RhdGlvbmNvbnN0cmFpbnQuanNcIikuVHlwZX0gcm90YXRpb25cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRml0T3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gW3NpemVdIFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgYm94IHRvIGZpdFxuICogdGhlIGV4dGVudCBpbnRvLiBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGZpcnN0IG1hcCBpbiB0aGUgRE9NIHRoYXRcbiAqIHVzZXMgdGhpcyB2aWV3LCBvciBgWzEwMCwgMTAwXWAgaWYgbm8gc3VjaCBtYXAgaXMgZm91bmQuXG4gKiBAcHJvcGVydHkgeyFBcnJheTxudW1iZXI+fSBbcGFkZGluZz1bMCwgMCwgMCwgMF1dIFBhZGRpbmcgKGluIHBpeGVscykgdG8gYmVcbiAqIGNsZWFyZWQgaW5zaWRlIHRoZSB2aWV3LiBWYWx1ZXMgaW4gdGhlIGFycmF5IGFyZSB0b3AsIHJpZ2h0LCBib3R0b20gYW5kIGxlZnRcbiAqIHBhZGRpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPXRydWVdIENvbnN0cmFpbiB0aGUgcmVzb2x1dGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW25lYXJlc3Q9ZmFsc2VdIElmIGBjb25zdHJhaW5SZXNvbHV0aW9uYCBpcyBgdHJ1ZWAsIGdldFxuICogdGhlIG5lYXJlc3QgZXh0ZW50IGluc3RlYWQgb2YgdGhlIGNsb3Nlc3QgdGhhdCBhY3R1YWxseSBmaXRzIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttaW5SZXNvbHV0aW9uPTBdIE1pbmltdW0gcmVzb2x1dGlvbiB0aGF0IHdlIHpvb20gdG8uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb21dIE1heGltdW0gem9vbSBsZXZlbCB0aGF0IHdlIHpvb20gdG8uIElmXG4gKiBgbWluUmVzb2x1dGlvbmAgaXMgZ2l2ZW4sIHRoaXMgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb25dIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiB0byB0aGUgdGFyZ2V0IGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdXNlZCBkdXJpbmdcbiAqIHRoZSBhbmltYXRpb24gKGRlZmF1bHRzIHRvIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfmluQW5kT3V0fSkuXG4gKiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZnJhbWUgd2l0aCBhIG51bWJlciByZXByZXNlbnRpbmcgYVxuICogZnJhY3Rpb24gb2YgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLiAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBudW1iZXJcbiAqIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHByb2dyZXNzIHRvd2FyZCB0aGUgZGVzdGluYXRpb24gc3RhdGUuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4pfSBbY2FsbGJhY2tdIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSB2aWV3IGlzIGluXG4gKiBpdHMgZmluYWwgcG9zaXRpb24uIFRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGB0cnVlYCBpZiB0aGUgYW5pbWF0aW9uXG4gKiBzZXJpZXMgY29tcGxldGVkIG9uIGl0cyBvd24gb3IgYGZhbHNlYCBpZiBpdCB3YXMgY2FuY2VsbGVkLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBWaWV3T3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gVGhlIGluaXRpYWwgY2VudGVyIGZvclxuICogdGhlIHZpZXcuIFRoZSBjb29yZGluYXRlIHN5c3RlbSBmb3IgdGhlIGNlbnRlciBpcyBzcGVjaWZpZWQgd2l0aCB0aGVcbiAqIGBwcm9qZWN0aW9uYCBvcHRpb24uIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmUgZmV0Y2hlZCBpZiB0aGlzIGlzIG5vdCBzZXQsXG4gKiBidXQgdGhlIGNlbnRlciBjYW4gYmUgc2V0IGxhdGVyIHdpdGgge0BsaW5rICNzZXRDZW50ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufG51bWJlcn0gW2NvbnN0cmFpblJvdGF0aW9uPXRydWVdIFJvdGF0aW9uIGNvbnN0cmFpbnQuXG4gKiBgZmFsc2VgIG1lYW5zIG5vIGNvbnN0cmFpbnQuIGB0cnVlYCBtZWFucyBubyBjb25zdHJhaW50LCBidXQgc25hcCB0byB6ZXJvXG4gKiBuZWFyIHplcm8uIEEgbnVtYmVyIGNvbnN0cmFpbnMgdGhlIHJvdGF0aW9uIHRvIHRoYXQgbnVtYmVyIG9mIHZhbHVlcy4gRm9yXG4gKiBleGFtcGxlLCBgNGAgd2lsbCBjb25zdHJhaW4gdGhlIHJvdGF0aW9uIHRvIDAsIDkwLCAxODAsIGFuZCAyNzAgZGVncmVlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZVJvdGF0aW9uPXRydWVdIEVuYWJsZSByb3RhdGlvbi5cbiAqIElmIGBmYWxzZWAsIGEgcm90YXRpb24gY29uc3RyYWludCB0aGF0IGFsd2F5cyBzZXRzIHRoZSByb3RhdGlvbiB0byB6ZXJvIGlzXG4gKiB1c2VkLiBUaGUgYGNvbnN0cmFpblJvdGF0aW9uYCBvcHRpb24gaGFzIG5vIGVmZmVjdCBpZiBgZW5hYmxlUm90YXRpb25gIGlzXG4gKiBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBleHRlbnQgdGhhdCBjb25zdHJhaW5zIHRoZVxuICogY2VudGVyLCBpbiBvdGhlciB3b3JkcywgY2VudGVyIGNhbm5vdCBiZSBzZXQgb3V0c2lkZSB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4UmVzb2x1dGlvbl0gVGhlIG1heGltdW0gcmVzb2x1dGlvbiB1c2VkIHRvIGRldGVybWluZVxuICogdGhlIHJlc29sdXRpb24gY29uc3RyYWludC4gSXQgaXMgdXNlZCB0b2dldGhlciB3aXRoIGBtaW5SZXNvbHV0aW9uYCAob3JcbiAqIGBtYXhab29tYCkgYW5kIGB6b29tRmFjdG9yYC4gSWYgdW5zcGVjaWZpZWQgaXQgaXMgY2FsY3VsYXRlZCBpbiBzdWNoIGEgd2F5XG4gKiB0aGF0IHRoZSBwcm9qZWN0aW9uJ3MgdmFsaWRpdHkgZXh0ZW50IGZpdHMgaW4gYSAyNTZ4MjU2IHB4IHRpbGUuIElmIHRoZVxuICogcHJvamVjdGlvbiBpcyBTcGhlcmljYWwgTWVyY2F0b3IgKHRoZSBkZWZhdWx0KSB0aGVuIGBtYXhSZXNvbHV0aW9uYCBkZWZhdWx0c1xuICogdG8gYDQwMDc1MDE2LjY4NTU3ODQ5IC8gMjU2ID0gMTU2NTQzLjAzMzkyODA0MDk3YC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluUmVzb2x1dGlvbl0gVGhlIG1pbmltdW0gcmVzb2x1dGlvbiB1c2VkIHRvIGRldGVybWluZVxuICogdGhlIHJlc29sdXRpb24gY29uc3RyYWludC4gIEl0IGlzIHVzZWQgdG9nZXRoZXIgd2l0aCBgbWF4UmVzb2x1dGlvbmAgKG9yXG4gKiBgbWluWm9vbWApIGFuZCBgem9vbUZhY3RvcmAuICBJZiB1bnNwZWNpZmllZCBpdCBpcyBjYWxjdWxhdGVkIGFzc3VtaW5nIDI5XG4gKiB6b29tIGxldmVscyAod2l0aCBhIGZhY3RvciBvZiAyKS4gSWYgdGhlIHByb2plY3Rpb24gaXMgU3BoZXJpY2FsIE1lcmNhdG9yXG4gKiAodGhlIGRlZmF1bHQpIHRoZW4gYG1pblJlc29sdXRpb25gIGRlZmF1bHRzIHRvXG4gKiBgNDAwNzUwMTYuNjg1NTc4NDkgLyAyNTYgLyBNYXRoLnBvdygyLCAyOCkgPSAwLjAwMDU4MzE2ODI0NTU4MzkyNTNgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhab29tPTI4XSBUaGUgbWF4aW11bSB6b29tIGxldmVsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZVxuICogcmVzb2x1dGlvbiBjb25zdHJhaW50LiBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1pblpvb21gIChvclxuICogYG1heFJlc29sdXRpb25gKSBhbmQgYHpvb21GYWN0b3JgLiAgTm90ZSB0aGF0IGlmIGBtaW5SZXNvbHV0aW9uYCBpcyBhbHNvXG4gKiBwcm92aWRlZCwgaXQgaXMgZ2l2ZW4gcHJlY2VkZW5jZSBvdmVyIGBtYXhab29tYC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluWm9vbT0wXSBUaGUgbWluaW11bSB6b29tIGxldmVsIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZVxuICogcmVzb2x1dGlvbiBjb25zdHJhaW50LiBJdCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggYG1heFpvb21gIChvclxuICogYG1pblJlc29sdXRpb25gKSBhbmQgYHpvb21GYWN0b3JgLiAgTm90ZSB0aGF0IGlmIGBtYXhSZXNvbHV0aW9uYCBpcyBhbHNvXG4gKiBwcm92aWRlZCwgaXQgaXMgZ2l2ZW4gcHJlY2VkZW5jZSBvdmVyIGBtaW5ab29tYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbj0nRVBTRzozODU3J10gVGhlXG4gKiBwcm9qZWN0aW9uLiBUaGUgZGVmYXVsdCBpcyBTcGhlcmljYWwgTWVyY2F0b3IuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Jlc29sdXRpb25dIFRoZSBpbml0aWFsIHJlc29sdXRpb24gZm9yIHRoZSB2aWV3LiBUaGVcbiAqIHVuaXRzIGFyZSBgcHJvamVjdGlvbmAgdW5pdHMgcGVyIHBpeGVsIChlLmcuIG1ldGVycyBwZXIgcGl4ZWwpLiBBblxuICogYWx0ZXJuYXRpdmUgdG8gc2V0dGluZyB0aGlzIGlzIHRvIHNldCBgem9vbWAuIExheWVyIHNvdXJjZXMgd2lsbCBub3QgYmVcbiAqIGZldGNoZWQgaWYgbmVpdGhlciB0aGlzIG5vciBgem9vbWAgYXJlIGRlZmluZWQsIGJ1dCB0aGV5IGNhbiBiZSBzZXQgbGF0ZXJcbiAqIHdpdGgge0BsaW5rICNzZXRab29tfSBvciB7QGxpbmsgI3NldFJlc29sdXRpb259LlxuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbcmVzb2x1dGlvbnNdIFJlc29sdXRpb25zIHRvIGRldGVybWluZSB0aGVcbiAqIHJlc29sdXRpb24gY29uc3RyYWludC4gSWYgc2V0IHRoZSBgbWF4UmVzb2x1dGlvbmAsIGBtaW5SZXNvbHV0aW9uYCxcbiAqIGBtaW5ab29tYCwgYG1heFpvb21gLCBhbmQgYHpvb21GYWN0b3JgIG9wdGlvbnMgYXJlIGlnbm9yZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSBpbml0aWFsIHJvdGF0aW9uIGZvciB0aGUgdmlldyBpbiByYWRpYW5zXG4gKiAocG9zaXRpdmUgcm90YXRpb24gY2xvY2t3aXNlLCAwIG1lYW5zIE5vcnRoKS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbV0gT25seSB1c2VkIGlmIGByZXNvbHV0aW9uYCBpcyBub3QgZGVmaW5lZC4gWm9vbVxuICogbGV2ZWwgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGluaXRpYWwgcmVzb2x1dGlvbiBmb3IgdGhlIHZpZXcuIFRoZSBpbml0aWFsXG4gKiByZXNvbHV0aW9uIGlzIGRldGVybWluZWQgdXNpbmcgdGhlIHtAbGluayAjY29uc3RyYWluUmVzb2x1dGlvbn0gbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tRmFjdG9yPTJdIFRoZSB6b29tIGZhY3RvciB1c2VkIHRvIGRldGVybWluZSB0aGVcbiAqIHJlc29sdXRpb24gY29uc3RyYWludC5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQW5pbWF0aW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gW2NlbnRlcl0gVGhlIGNlbnRlciBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mXG4gKiB0aGUgYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6b29tXSBUaGUgem9vbSBsZXZlbCBvZiB0aGUgdmlldyBhdCB0aGUgZW5kIG9mIHRoZVxuICogYW5pbWF0aW9uLiBUaGlzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgcmVzb2x1dGlvbmAuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3Jlc29sdXRpb25dIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3IGF0IHRoZSBlbmRcbiAqIG9mIHRoZSBhbmltYXRpb24uICBJZiBgem9vbWAgaXMgYWxzbyBwcm92aWRlZCwgdGhpcyBvcHRpb24gd2lsbCBiZSBpZ25vcmVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbl0gVGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3IGF0IHRoZSBlbmQgb2ZcbiAqIHRoZSBhbmltYXRpb24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbYW5jaG9yXSBPcHRpb25hbCBhbmNob3IgdG8gcmVtYWluZWQgZml4ZWRcbiAqIGR1cmluZyBhIHJvdGF0aW9uIG9yIHJlc29sdXRpb24gYW5pbWF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0xMDAwXSBUaGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKG51bWJlcik6bnVtYmVyfSBbZWFzaW5nXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHVzZWRcbiAqIGR1cmluZyB0aGUgYW5pbWF0aW9uIChkZWZhdWx0cyB0byB7QGxpbmsgbW9kdWxlOm9sL2Vhc2luZ35pbkFuZE91dH0pLlxuICogVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGZyYW1lIHdpdGggYSBudW1iZXIgcmVwcmVzZW50aW5nIGFcbiAqIGZyYWN0aW9uIG9mIHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbi4gIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyXG4gKiBiZXR3ZWVuIDAgYW5kIDEgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmVzcyB0b3dhcmQgdGhlIGRlc3RpbmF0aW9uIHN0YXRlLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY2VudGVyXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNvbHV0aW9uXG4gKiBAcHJvcGVydHkge251bWJlcn0gcm90YXRpb25cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB6b29tXG4gKi9cblxuXG4vKipcbiAqIERlZmF1bHQgbWluIHpvb20gbGV2ZWwgZm9yIHRoZSBtYXAgdmlldy5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmNvbnN0IERFRkFVTFRfTUlOX1pPT00gPSAwO1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSBWaWV3IG9iamVjdCByZXByZXNlbnRzIGEgc2ltcGxlIDJEIHZpZXcgb2YgdGhlIG1hcC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBvYmplY3QgdG8gYWN0IHVwb24gdG8gY2hhbmdlIHRoZSBjZW50ZXIsIHJlc29sdXRpb24sXG4gKiBhbmQgcm90YXRpb24gb2YgdGhlIG1hcC5cbiAqXG4gKiAjIyMgVGhlIHZpZXcgc3RhdGVzXG4gKlxuICogQW4gVmlldyBpcyBkZXRlcm1pbmVkIGJ5IHRocmVlIHN0YXRlczogYGNlbnRlcmAsIGByZXNvbHV0aW9uYCxcbiAqIGFuZCBgcm90YXRpb25gLiBFYWNoIHN0YXRlIGhhcyBhIGNvcnJlc3BvbmRpbmcgZ2V0dGVyIGFuZCBzZXR0ZXIsIGUuZy5cbiAqIGBnZXRDZW50ZXJgIGFuZCBgc2V0Q2VudGVyYCBmb3IgdGhlIGBjZW50ZXJgIHN0YXRlLlxuICpcbiAqIEFuIFZpZXcgaGFzIGEgYHByb2plY3Rpb25gLiBUaGUgcHJvamVjdGlvbiBkZXRlcm1pbmVzIHRoZVxuICogY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGNlbnRlciwgYW5kIGl0cyB1bml0cyBkZXRlcm1pbmUgdGhlIHVuaXRzIG9mIHRoZVxuICogcmVzb2x1dGlvbiAocHJvamVjdGlvbiB1bml0cyBwZXIgcGl4ZWwpLiBUaGUgZGVmYXVsdCBwcm9qZWN0aW9uIGlzXG4gKiBTcGhlcmljYWwgTWVyY2F0b3IgKEVQU0c6Mzg1NykuXG4gKlxuICogIyMjIFRoZSBjb25zdHJhaW50c1xuICpcbiAqIGBzZXRDZW50ZXJgLCBgc2V0UmVzb2x1dGlvbmAgYW5kIGBzZXRSb3RhdGlvbmAgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIHRoZVxuICogc3RhdGVzIG9mIHRoZSB2aWV3LiBBbnkgdmFsdWUgY2FuIGJlIHBhc3NlZCB0byB0aGUgc2V0dGVycy4gQW5kIHRoZSB2YWx1ZVxuICogdGhhdCBpcyBwYXNzZWQgdG8gYSBzZXR0ZXIgd2lsbCBlZmZlY3RpdmVseSBiZSB0aGUgdmFsdWUgc2V0IGluIHRoZSB2aWV3LFxuICogYW5kIHJldHVybmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGdldHRlci5cbiAqXG4gKiBCdXQgYSBWaWV3IG9iamVjdCBhbHNvIGhhcyBhICpyZXNvbHV0aW9uIGNvbnN0cmFpbnQqLCBhXG4gKiAqcm90YXRpb24gY29uc3RyYWludCogYW5kIGEgKmNlbnRlciBjb25zdHJhaW50Ki5cbiAqXG4gKiBBcyBzYWlkIGFib3ZlLCBubyBjb25zdHJhaW50cyBhcmUgYXBwbGllZCB3aGVuIHRoZSBzZXR0ZXJzIGFyZSB1c2VkIHRvIHNldFxuICogbmV3IHN0YXRlcyBmb3IgdGhlIHZpZXcuIEFwcGx5aW5nIGNvbnN0cmFpbnRzIGlzIGRvbmUgZXhwbGljaXRseSB0aHJvdWdoXG4gKiB0aGUgdXNlIG9mIHRoZSBgY29uc3RyYWluKmAgZnVuY3Rpb25zIChgY29uc3RyYWluUmVzb2x1dGlvbmAgYW5kXG4gKiBgY29uc3RyYWluUm90YXRpb25gIGFuZCBgY29uc3RyYWluQ2VudGVyYCkuXG4gKlxuICogVGhlIG1haW4gdXNlcnMgb2YgdGhlIGNvbnN0cmFpbnRzIGFyZSB0aGUgaW50ZXJhY3Rpb25zIGFuZCB0aGVcbiAqIGNvbnRyb2xzLiBGb3IgZXhhbXBsZSwgZG91YmxlLWNsaWNraW5nIG9uIHRoZSBtYXAgY2hhbmdlcyB0aGUgdmlldyB0b1xuICogdGhlIFwibmV4dFwiIHJlc29sdXRpb24uIEFuZCByZWxlYXNpbmcgdGhlIGZpbmdlcnMgYWZ0ZXIgcGluY2gtem9vbWluZ1xuICogc25hcHMgdG8gdGhlIGNsb3Nlc3QgcmVzb2x1dGlvbiAod2l0aCBhbiBhbmltYXRpb24pLlxuICpcbiAqIFRoZSAqcmVzb2x1dGlvbiBjb25zdHJhaW50KiBzbmFwcyB0byBzcGVjaWZpYyByZXNvbHV0aW9ucy4gSXQgaXNcbiAqIGRldGVybWluZWQgYnkgdGhlIGZvbGxvd2luZyBvcHRpb25zOiBgcmVzb2x1dGlvbnNgLCBgbWF4UmVzb2x1dGlvbmAsXG4gKiBgbWF4Wm9vbWAsIGFuZCBgem9vbUZhY3RvcmAuIElmIGByZXNvbHV0aW9uc2AgaXMgc2V0LCB0aGUgb3RoZXIgdGhyZWVcbiAqIG9wdGlvbnMgYXJlIGlnbm9yZWQuIFNlZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG9wdGlvbiBmb3IgbW9yZVxuICogaW5mb3JtYXRpb24uXG4gKlxuICogVGhlICpyb3RhdGlvbiBjb25zdHJhaW50KiBzbmFwcyB0byBzcGVjaWZpYyBhbmdsZXMuIEl0IGlzIGRldGVybWluZWRcbiAqIGJ5IHRoZSBmb2xsb3dpbmcgb3B0aW9uczogYGVuYWJsZVJvdGF0aW9uYCBhbmQgYGNvbnN0cmFpblJvdGF0aW9uYC5cbiAqIEJ5IGRlZmF1bHQgdGhlIHJvdGF0aW9uIHZhbHVlIGlzIHNuYXBwZWQgdG8gemVybyB3aGVuIGFwcHJvYWNoaW5nIHRoZVxuICogaG9yaXpvbnRhbC5cbiAqXG4gKiBUaGUgKmNlbnRlciBjb25zdHJhaW50KiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgZXh0ZW50YCBvcHRpb24uIEJ5XG4gKiBkZWZhdWx0IHRoZSBjZW50ZXIgaXMgbm90IGNvbnN0cmFpbmVkIGF0IGFsbC5cbiAqXG4gICogQGFwaVxuICovXG5jbGFzcyBWaWV3IGV4dGVuZHMgQmFzZU9iamVjdCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Vmlld09wdGlvbnM9fSBvcHRfb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCBvcHRpb25zID0gYXNzaWduKHt9LCBvcHRfb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuaGludHNfID0gWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXk8QW5pbWF0aW9uPj59XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV87XG5cbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfID0gdGhpcy51cGRhdGVBbmltYXRpb25zXy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9wcm9qL1Byb2plY3Rpb24uanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2plY3Rpb25fID0gY3JlYXRlUHJvamVjdGlvbihvcHRpb25zLnByb2plY3Rpb24sICdFUFNHOjM4NTcnKTtcblxuICAgIHRoaXMuYXBwbHlPcHRpb25zXyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHZpZXcgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICogQHBhcmFtIHtWaWV3T3B0aW9uc30gb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gICAqL1xuICBhcHBseU9wdGlvbnNfKG9wdGlvbnMpIHtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgcHJvcGVydGllc1tWaWV3UHJvcGVydHkuQ0VOVEVSXSA9IG9wdGlvbnMuY2VudGVyICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5jZW50ZXIgOiBudWxsO1xuXG4gICAgY29uc3QgcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvID0gY3JlYXRlUmVzb2x1dGlvbkNvbnN0cmFpbnQob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5tYXhSZXNvbHV0aW9uXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5tYXhSZXNvbHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWluUmVzb2x1dGlvbl8gPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8ubWluUmVzb2x1dGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnpvb21GYWN0b3JfID0gcmVzb2x1dGlvbkNvbnN0cmFpbnRJbmZvLnpvb21GYWN0b3I7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdXRpb25zXyA9IG9wdGlvbnMucmVzb2x1dGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5taW5ab29tXyA9IHJlc29sdXRpb25Db25zdHJhaW50SW5mby5taW5ab29tO1xuXG4gICAgY29uc3QgY2VudGVyQ29uc3RyYWludCA9IGNyZWF0ZUNlbnRlckNvbnN0cmFpbnQob3B0aW9ucyk7XG4gICAgY29uc3QgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSByZXNvbHV0aW9uQ29uc3RyYWludEluZm8uY29uc3RyYWludDtcbiAgICBjb25zdCByb3RhdGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVSb3RhdGlvbkNvbnN0cmFpbnQob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtDb25zdHJhaW50c31cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpbnRzXyA9IHtcbiAgICAgIGNlbnRlcjogY2VudGVyQ29uc3RyYWludCxcbiAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb25Db25zdHJhaW50LFxuICAgICAgcm90YXRpb246IHJvdGF0aW9uQ29uc3RyYWludFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5yZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJFU09MVVRJT05dID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJFU09MVVRJT05dID0gdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uKFxuICAgICAgICB0aGlzLm1heFJlc29sdXRpb25fLCBvcHRpb25zLnpvb20gLSB0aGlzLm1pblpvb21fKTtcblxuICAgICAgaWYgKHRoaXMucmVzb2x1dGlvbnNfKSB7IC8vIGluIGNhc2UgbWFwIHpvb20gaXMgb3V0IG9mIG1pbi9tYXggem9vbSByYW5nZVxuICAgICAgICBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OXSA9IGNsYW1wKFxuICAgICAgICAgIE51bWJlcih0aGlzLmdldFJlc29sdXRpb24oKSB8fCBwcm9wZXJ0aWVzW1ZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OXSksXG4gICAgICAgICAgdGhpcy5taW5SZXNvbHV0aW9uXywgdGhpcy5tYXhSZXNvbHV0aW9uXyk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BlcnRpZXNbVmlld1Byb3BlcnR5LlJPVEFUSU9OXSA9IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwO1xuICAgIHRoaXMuc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1ZpZXdPcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9uc18gPSBvcHRpb25zO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIHVwZGF0ZWQgdmVyc2lvbiBvZiB0aGUgdmlldyBvcHRpb25zIHVzZWQgdG8gY29uc3RydWN0IHRoZSB2aWV3LiAgVGhlXG4gICAqIGN1cnJlbnQgcmVzb2x1dGlvbiAob3Igem9vbSksIGNlbnRlciwgYW5kIHJvdGF0aW9uIGFyZSBhcHBsaWVkIHRvIGFueSBzdG9yZWRcbiAgICogb3B0aW9ucy4gIFRoZSBwcm92aWRlZCBvcHRpb25zIGNhbiBiZSB1c2VkIHRvIGFwcGx5IG5ldyBtaW4vbWF4IHpvb20gb3JcbiAgICogcmVzb2x1dGlvbiBsaW1pdHMuXG4gICAqIEBwYXJhbSB7Vmlld09wdGlvbnN9IG5ld09wdGlvbnMgTmV3IG9wdGlvbnMgdG8gYmUgYXBwbGllZC5cbiAgICogQHJldHVybiB7Vmlld09wdGlvbnN9IE5ldyBvcHRpb25zIHVwZGF0ZWQgd2l0aCB0aGUgY3VycmVudCB2aWV3IHN0YXRlLlxuICAgKi9cbiAgZ2V0VXBkYXRlZE9wdGlvbnNfKG5ld09wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gYXNzaWduKHt9LCB0aGlzLm9wdGlvbnNfKTtcblxuICAgIC8vIHByZXNlcnZlIHJlc29sdXRpb24gKG9yIHpvb20pXG4gICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy56b29tID0gdGhpcy5nZXRab29tKCk7XG4gICAgfVxuXG4gICAgLy8gcHJlc2VydmUgY2VudGVyXG4gICAgb3B0aW9ucy5jZW50ZXIgPSB0aGlzLmdldENlbnRlcigpO1xuXG4gICAgLy8gcHJlc2VydmUgcm90YXRpb25cbiAgICBvcHRpb25zLnJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXG4gICAgcmV0dXJuIGFzc2lnbih7fSwgb3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0ZSB0aGUgdmlldy4gIFRoZSB2aWV3J3MgY2VudGVyLCB6b29tIChvciByZXNvbHV0aW9uKSwgYW5kIHJvdGF0aW9uXG4gICAqIGNhbiBiZSBhbmltYXRlZCBmb3Igc21vb3RoIHRyYW5zaXRpb25zIGJldHdlZW4gdmlldyBzdGF0ZXMuICBGb3IgZXhhbXBsZSxcbiAgICogdG8gYW5pbWF0ZSB0aGUgdmlldyB0byBhIG5ldyB6b29tIGxldmVsOlxuICAgKlxuICAgKiAgICAgdmlldy5hbmltYXRlKHt6b29tOiB2aWV3LmdldFpvb20oKSArIDF9KTtcbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIGFuaW1hdGlvbiBsYXN0cyBvbmUgc2Vjb25kIGFuZCB1c2VzIGluLWFuZC1vdXQgZWFzaW5nLiAgWW91XG4gICAqIGNhbiBjdXN0b21pemUgdGhpcyBiZWhhdmlvciBieSBpbmNsdWRpbmcgYGR1cmF0aW9uYCAoaW4gbWlsbGlzZWNvbmRzKSBhbmRcbiAgICogYGVhc2luZ2Agb3B0aW9ucyAoc2VlIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfSkuXG4gICAqXG4gICAqIFRvIGNoYWluIHRvZ2V0aGVyIG11bHRpcGxlIGFuaW1hdGlvbnMsIGNhbGwgdGhlIG1ldGhvZCB3aXRoIG11bHRpcGxlXG4gICAqIGFuaW1hdGlvbiBvYmplY3RzLiAgRm9yIGV4YW1wbGUsIHRvIGZpcnN0IHpvb20gYW5kIHRoZW4gcGFuOlxuICAgKlxuICAgKiAgICAgdmlldy5hbmltYXRlKHt6b29tOiAxMH0sIHtjZW50ZXI6IFswLCAwXX0pO1xuICAgKlxuICAgKiBJZiB5b3UgcHJvdmlkZSBhIGZ1bmN0aW9uIGFzIHRoZSBsYXN0IGFyZ3VtZW50IHRvIHRoZSBhbmltYXRlIG1ldGhvZCwgaXRcbiAgICogd2lsbCBnZXQgY2FsbGVkIGF0IHRoZSBlbmQgb2YgYW4gYW5pbWF0aW9uIHNlcmllcy4gIFRoZSBjYWxsYmFjayB3aWxsIGJlXG4gICAqIGNhbGxlZCB3aXRoIGB0cnVlYCBpZiB0aGUgYW5pbWF0aW9uIHNlcmllcyBjb21wbGV0ZWQgb24gaXRzIG93biBvciBgZmFsc2VgXG4gICAqIGlmIGl0IHdhcyBjYW5jZWxsZWQuXG4gICAqXG4gICAqIEFuaW1hdGlvbnMgYXJlIGNhbmNlbGxlZCBieSB1c2VyIGludGVyYWN0aW9ucyAoZS5nLiBkcmFnZ2luZyB0aGUgbWFwKSBvciBieVxuICAgKiBjYWxsaW5nIGB2aWV3LnNldENlbnRlcigpYCwgYHZpZXcuc2V0UmVzb2x1dGlvbigpYCwgb3IgYHZpZXcuc2V0Um90YXRpb24oKWBcbiAgICogKG9yIGFub3RoZXIgbWV0aG9kIHRoYXQgY2FsbHMgb25lIG9mIHRoZXNlKS5cbiAgICpcbiAgICogQHBhcmFtIHsuLi4oQW5pbWF0aW9uT3B0aW9uc3xmdW5jdGlvbihib29sZWFuKSl9IHZhcl9hcmdzIEFuaW1hdGlvblxuICAgKiAgICAgb3B0aW9ucy4gIE11bHRpcGxlIGFuaW1hdGlvbnMgY2FuIGJlIHJ1biBpbiBzZXJpZXMgYnkgcGFzc2luZyBtdWx0aXBsZVxuICAgKiAgICAgb3B0aW9ucyBvYmplY3RzLiAgVG8gcnVuIG11bHRpcGxlIGFuaW1hdGlvbnMgaW4gcGFyYWxsZWwsIGNhbGwgdGhlIG1ldGhvZFxuICAgKiAgICAgbXVsdGlwbGUgdGltZXMuICBBbiBvcHRpb25hbCBjYWxsYmFjayBjYW4gYmUgcHJvdmlkZWQgYXMgYSBmaW5hbFxuICAgKiAgICAgYXJndW1lbnQuICBUaGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyXG4gICAqICAgICB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlZCB3aXRob3V0IGJlaW5nIGNhbmNlbGxlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgYW5pbWF0ZSh2YXJfYXJncykge1xuICAgIGxldCBhbmltYXRpb25Db3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIGlmIChhbmltYXRpb25Db3VudCA+IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1thbmltYXRpb25Db3VudCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3VtZW50c1thbmltYXRpb25Db3VudCAtIDFdO1xuICAgICAgLS1hbmltYXRpb25Db3VudDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRGVmKCkpIHtcbiAgICAgIC8vIGlmIHZpZXcgcHJvcGVydGllcyBhcmUgbm90IHlldCBzZXQsIHNob3J0Y3V0IHRvIHRoZSBmaW5hbCBzdGF0ZVxuICAgICAgY29uc3Qgc3RhdGUgPSBhcmd1bWVudHNbYW5pbWF0aW9uQ291bnQgLSAxXTtcbiAgICAgIGlmIChzdGF0ZS5jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXIoc3RhdGUuY2VudGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS56b29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRab29tKHN0YXRlLnpvb20pO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLnJvdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihzdGF0ZS5yb3RhdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLnNsaWNlKCk7XG4gICAgbGV0IHJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBsZXQgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3Qgc2VyaWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmltYXRpb25Db3VudDsgKytpKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gLyoqIEB0eXBlIHtBbmltYXRpb25PcHRpb25zfSAqLyAoYXJndW1lbnRzW2ldKTtcblxuICAgICAgY29uc3QgYW5pbWF0aW9uID0gLyoqIEB0eXBlIHtBbmltYXRpb259ICovICh7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICBhbmNob3I6IG9wdGlvbnMuYW5jaG9yLFxuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kdXJhdGlvbiA6IDEwMDAsXG4gICAgICAgIGVhc2luZzogb3B0aW9ucy5lYXNpbmcgfHwgaW5BbmRPdXRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob3B0aW9ucy5jZW50ZXIpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZUNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgYW5pbWF0aW9uLnRhcmdldENlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuICAgICAgICBjZW50ZXIgPSBhbmltYXRpb24udGFyZ2V0Q2VudGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbiA9IHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICAgICAgICB0aGlzLm1heFJlc29sdXRpb25fLCBvcHRpb25zLnpvb20gLSB0aGlzLm1pblpvb21fLCAwKTtcbiAgICAgICAgcmVzb2x1dGlvbiA9IGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnJlc29sdXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgICAgcmVzb2x1dGlvbiA9IGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFuaW1hdGlvbi5zb3VyY2VSb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgICBjb25zdCBkZWx0YSA9IG1vZHVsbyhvcHRpb25zLnJvdGF0aW9uIC0gcm90YXRpb24gKyBNYXRoLlBJLCAyICogTWF0aC5QSSkgLSBNYXRoLlBJO1xuICAgICAgICBhbmltYXRpb24udGFyZ2V0Um90YXRpb24gPSByb3RhdGlvbiArIGRlbHRhO1xuICAgICAgICByb3RhdGlvbiA9IGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGFuaW1hdGlvbiBpcyBhIG5vLW9wXG4gICAgICBpZiAoaXNOb29wQW5pbWF0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgYW5pbWF0aW9uLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gd2Ugc3RpbGwgcHVzaCBpdCBvbnRvIHRoZSBzZXJpZXMgZm9yIGNhbGxiYWNrIGhhbmRsaW5nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCArPSBhbmltYXRpb24uZHVyYXRpb247XG4gICAgICB9XG4gICAgICBzZXJpZXMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbnNfLnB1c2goc2VyaWVzKTtcbiAgICB0aGlzLnNldEhpbnQoVmlld0hpbnQuQU5JTUFUSU5HLCAxKTtcbiAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB2aWV3IGlzIGJlaW5nIGFuaW1hdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgdmlldyBpcyBiZWluZyBhbmltYXRlZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1tWaWV3SGludC5BTklNQVRJTkddID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdmlldywgc3VjaCBhcyBwYW5uaW5nIG9yIHpvb21pbmcuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2aWV3IGlzIGJlaW5nIGludGVyYWN0ZWQgd2l0aC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW50ZXJhY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGludHNfW1ZpZXdIaW50LklOVEVSQUNUSU5HXSA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIGFueSBvbmdvaW5nIGFuaW1hdGlvbnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGNhbmNlbEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LkFOSU1BVElORywgLXRoaXMuaGludHNfW1ZpZXdIaW50LkFOSU1BVElOR10pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuYW5pbWF0aW9uc18ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5hbmltYXRpb25zX1tpXTtcbiAgICAgIGlmIChzZXJpZXNbMF0uY2FsbGJhY2spIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soc2VyaWVzWzBdLmNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uc18ubGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYWxsIGFuaW1hdGlvbnMuXG4gICAqL1xuICB1cGRhdGVBbmltYXRpb25zXygpIHtcbiAgICBpZiAodGhpcy51cGRhdGVBbmltYXRpb25LZXlfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5Xyk7XG4gICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbktleV8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghdGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGxldCBtb3JlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuYW5pbWF0aW9uc18ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuYW5pbWF0aW9uc19baV07XG4gICAgICBsZXQgc2VyaWVzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gc2VyaWVzLmxlbmd0aDsgaiA8IGpqOyArK2opIHtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gc2VyaWVzW2pdO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIGFuaW1hdGlvbi5zdGFydDtcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uID4gMCA/IGVsYXBzZWQgLyBhbmltYXRpb24uZHVyYXRpb24gOiAxO1xuICAgICAgICBpZiAoZnJhY3Rpb24gPj0gMSkge1xuICAgICAgICAgIGFuaW1hdGlvbi5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgZnJhY3Rpb24gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcmllc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBhbmltYXRpb24uZWFzaW5nKGZyYWN0aW9uKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIpIHtcbiAgICAgICAgICBjb25zdCB4MCA9IGFuaW1hdGlvbi5zb3VyY2VDZW50ZXJbMF07XG4gICAgICAgICAgY29uc3QgeTAgPSBhbmltYXRpb24uc291cmNlQ2VudGVyWzFdO1xuICAgICAgICAgIGNvbnN0IHgxID0gYW5pbWF0aW9uLnRhcmdldENlbnRlclswXTtcbiAgICAgICAgICBjb25zdCB5MSA9IGFuaW1hdGlvbi50YXJnZXRDZW50ZXJbMV07XG4gICAgICAgICAgY29uc3QgeCA9IHgwICsgcHJvZ3Jlc3MgKiAoeDEgLSB4MCk7XG4gICAgICAgICAgY29uc3QgeSA9IHkwICsgcHJvZ3Jlc3MgKiAoeTEgLSB5MCk7XG4gICAgICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUiwgW3gsIHldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gJiYgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24pIHtcbiAgICAgICAgICBjb25zdCByZXNvbHV0aW9uID0gcHJvZ3Jlc3MgPT09IDEgP1xuICAgICAgICAgICAgYW5pbWF0aW9uLnRhcmdldFJlc29sdXRpb24gOlxuICAgICAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gKyBwcm9ncmVzcyAqIChhbmltYXRpb24udGFyZ2V0UmVzb2x1dGlvbiAtIGFuaW1hdGlvbi5zb3VyY2VSZXNvbHV0aW9uKTtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uLmFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUixcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIGFuaW1hdGlvbi5hbmNob3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJFU09MVVRJT04sIHJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb24uc291cmNlUm90YXRpb24gIT09IHVuZGVmaW5lZCAmJiBhbmltYXRpb24udGFyZ2V0Um90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IHJvdGF0aW9uID0gcHJvZ3Jlc3MgPT09IDEgP1xuICAgICAgICAgICAgbW9kdWxvKGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbiArIE1hdGguUEksIDIgKiBNYXRoLlBJKSAtIE1hdGguUEkgOlxuICAgICAgICAgICAgYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uICsgcHJvZ3Jlc3MgKiAoYW5pbWF0aW9uLnRhcmdldFJvdGF0aW9uIC0gYW5pbWF0aW9uLnNvdXJjZVJvdGF0aW9uKTtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uLmFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LkNFTlRFUixcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVDZW50ZXJSb3RhdGUocm90YXRpb24sIGFuaW1hdGlvbi5hbmNob3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OLCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgbW9yZSA9IHRydWU7XG4gICAgICAgIGlmICghYW5pbWF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpZXNDb21wbGV0ZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnNfW2ldID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRIaW50KFZpZXdIaW50LkFOSU1BVElORywgLTEpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHNlcmllc1swXS5jYWxsYmFjaztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2soY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBydW5lIGNvbXBsZXRlZCBzZXJpZXNcbiAgICB0aGlzLmFuaW1hdGlvbnNfID0gdGhpcy5hbmltYXRpb25zXy5maWx0ZXIoQm9vbGVhbik7XG4gICAgaWYgKG1vcmUgJiYgdGhpcy51cGRhdGVBbmltYXRpb25LZXlfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uS2V5XyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZUFuaW1hdGlvbnNfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIFRhcmdldCByb3RhdGlvbi5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gYW5jaG9yIFJvdGF0aW9uIGFuY2hvci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBDZW50ZXIgZm9yIHJvdGF0aW9uIGFuZCBhbmNob3IuXG4gICAqL1xuICBjYWxjdWxhdGVDZW50ZXJSb3RhdGUocm90YXRpb24sIGFuY2hvcikge1xuICAgIGxldCBjZW50ZXI7XG4gICAgY29uc3QgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgaWYgKGN1cnJlbnRDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2VudGVyID0gW2N1cnJlbnRDZW50ZXJbMF0gLSBhbmNob3JbMF0sIGN1cnJlbnRDZW50ZXJbMV0gLSBhbmNob3JbMV1dO1xuICAgICAgcm90YXRlQ29vcmRpbmF0ZShjZW50ZXIsIHJvdGF0aW9uIC0gdGhpcy5nZXRSb3RhdGlvbigpKTtcbiAgICAgIGFkZENvb3JkaW5hdGUoY2VudGVyLCBhbmNob3IpO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIFRhcmdldCByZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBhbmNob3IgWm9vbSBhbmNob3IuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gQ2VudGVyIGZvciByZXNvbHV0aW9uIGFuZCBhbmNob3IuXG4gICAqL1xuICBjYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIGFuY2hvcikge1xuICAgIGxldCBjZW50ZXI7XG4gICAgY29uc3QgY3VycmVudENlbnRlciA9IHRoaXMuZ2V0Q2VudGVyKCk7XG4gICAgY29uc3QgY3VycmVudFJlc29sdXRpb24gPSB0aGlzLmdldFJlc29sdXRpb24oKTtcbiAgICBpZiAoY3VycmVudENlbnRlciAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHggPSBhbmNob3JbMF0gLSByZXNvbHV0aW9uICogKGFuY2hvclswXSAtIGN1cnJlbnRDZW50ZXJbMF0pIC8gY3VycmVudFJlc29sdXRpb247XG4gICAgICBjb25zdCB5ID0gYW5jaG9yWzFdIC0gcmVzb2x1dGlvbiAqIChhbmNob3JbMV0gLSBjdXJyZW50Q2VudGVyWzFdKSAvIGN1cnJlbnRSZXNvbHV0aW9uO1xuICAgICAgY2VudGVyID0gW3gsIHldO1xuICAgIH1cbiAgICByZXR1cm4gY2VudGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfSBWaWV3cG9ydCBzaXplIG9yIGBbMTAwLCAxMDBdYCB3aGVuIG5vIHZpZXdwb3J0IGlzIGZvdW5kLlxuICAgKi9cbiAgZ2V0U2l6ZUZyb21WaWV3cG9ydF8oKSB7XG4gICAgY29uc3Qgc2l6ZSA9IFsxMDAsIDEwMF07XG4gICAgY29uc3Qgc2VsZWN0b3IgPSAnLm9sLXZpZXdwb3J0W2RhdGEtdmlldz1cIicgKyBnZXRVaWQodGhpcykgKyAnXCJdJztcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgc2l6ZVswXSA9IHBhcnNlSW50KG1ldHJpY3Mud2lkdGgsIDEwKTtcbiAgICAgIHNpemVbMV0gPSBwYXJzZUludChtZXRyaWNzLmhlaWdodCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbnN0cmFpbmVkIGNlbnRlciBvZiB0aGlzIHZpZXcuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBjZW50ZXIgQ2VudGVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IENvbnN0cmFpbmVkIGNlbnRlci5cbiAgICogQGFwaVxuICAgKi9cbiAgY29uc3RyYWluQ2VudGVyKGNlbnRlcikge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnRzXy5jZW50ZXIoY2VudGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbnN0cmFpbmVkIHJlc29sdXRpb24gb2YgdGhpcyB2aWV3LlxuICAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHJlc29sdXRpb24gUmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGVsdGEgRGVsdGEuIERlZmF1bHQgaXMgYDBgLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9kaXJlY3Rpb24gRGlyZWN0aW9uLiBEZWZhdWx0IGlzIGAwYC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gQ29uc3RyYWluZWQgcmVzb2x1dGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgY29uc3RyYWluUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBvcHRfZGVsdGEsIG9wdF9kaXJlY3Rpb24pIHtcbiAgICBjb25zdCBkZWx0YSA9IG9wdF9kZWx0YSB8fCAwO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IG9wdF9kaXJlY3Rpb24gfHwgMDtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c18ucmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZWx0YSwgZGlyZWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbnN0cmFpbmVkIHJvdGF0aW9uIG9mIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZGVsdGEgRGVsdGEuIERlZmF1bHQgaXMgYDBgLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBDb25zdHJhaW5lZCByb3RhdGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgY29uc3RyYWluUm90YXRpb24ocm90YXRpb24sIG9wdF9kZWx0YSkge1xuICAgIGNvbnN0IGRlbHRhID0gb3B0X2RlbHRhIHx8IDA7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludHNfLnJvdGF0aW9uKHJvdGF0aW9uLCBkZWx0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2aWV3IGNlbnRlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBUaGUgY2VudGVyIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDZW50ZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LkNFTlRFUikpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb25zdHJhaW50c30gQ29uc3RyYWludHMuXG4gICAqL1xuICBnZXRDb25zdHJhaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJhaW50c187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+PX0gb3B0X2hpbnRzIERlc3RpbmF0aW9uIGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSBIaW50LlxuICAgKi9cbiAgZ2V0SGludHMob3B0X2hpbnRzKSB7XG4gICAgaWYgKG9wdF9oaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRfaGludHNbMF0gPSB0aGlzLmhpbnRzX1swXTtcbiAgICAgIG9wdF9oaW50c1sxXSA9IHRoaXMuaGludHNfWzFdO1xuICAgICAgcmV0dXJuIG9wdF9oaW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGludHNfLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXh0ZW50IGZvciB0aGUgY3VycmVudCB2aWV3IHN0YXRlIGFuZCB0aGUgcGFzc2VkIHNpemUuXG4gICAqIFRoZSBzaXplIGlzIHRoZSBwaXhlbCBkaW1lbnNpb25zIG9mIHRoZSBib3ggaW50byB3aGljaCB0aGUgY2FsY3VsYXRlZCBleHRlbnRcbiAgICogc2hvdWxkIGZpdC4gSW4gbW9zdCBjYXNlcyB5b3Ugd2FudCB0byBnZXQgdGhlIGV4dGVudCBvZiB0aGUgZW50aXJlIG1hcCxcbiAgICogdGhhdCBpcyBgbWFwLmdldFNpemUoKWAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemU9fSBvcHRfc2l6ZSBCb3ggcGl4ZWwgc2l6ZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgc2l6ZSBvZiB0aGVcbiAgICogZmlyc3QgbWFwIHRoYXQgdXNlcyB0aGlzIHZpZXcgd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IEV4dGVudC5cbiAgICogQGFwaVxuICAgKi9cbiAgY2FsY3VsYXRlRXh0ZW50KG9wdF9zaXplKSB7XG4gICAgY29uc3Qgc2l6ZSA9IG9wdF9zaXplIHx8IHRoaXMuZ2V0U2l6ZUZyb21WaWV3cG9ydF8oKTtcbiAgICBjb25zdCBjZW50ZXIgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gKi8gKHRoaXMuZ2V0Q2VudGVyKCkpO1xuICAgIGFzc2VydChjZW50ZXIsIDEpOyAvLyBUaGUgdmlldyBjZW50ZXIgaXMgbm90IGRlZmluZWRcbiAgICBjb25zdCByZXNvbHV0aW9uID0gLyoqIEB0eXBlIHshbnVtYmVyfSAqLyAodGhpcy5nZXRSZXNvbHV0aW9uKCkpO1xuICAgIGFzc2VydChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQsIDIpOyAvLyBUaGUgdmlldyByZXNvbHV0aW9uIGlzIG5vdCBkZWZpbmVkXG4gICAgY29uc3Qgcm90YXRpb24gPSAvKiogQHR5cGUgeyFudW1iZXJ9ICovICh0aGlzLmdldFJvdGF0aW9uKCkpO1xuICAgIGFzc2VydChyb3RhdGlvbiAhPT0gdW5kZWZpbmVkLCAzKTsgLy8gVGhlIHZpZXcgcm90YXRpb24gaXMgbm90IGRlZmluZWRcblxuICAgIHJldHVybiBnZXRGb3JWaWV3QW5kU2l6ZShjZW50ZXIsIHJlc29sdXRpb24sIHJvdGF0aW9uLCBzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1heGltdW0gcmVzb2x1dGlvbiBvZiB0aGUgdmlldy5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRNYXhSZXNvbHV0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1heFJlc29sdXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtaW5pbXVtIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1pblJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWluUmVzb2x1dGlvbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSB2aWV3LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1heFpvb20oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXRab29tRm9yUmVzb2x1dGlvbih0aGlzLm1pblJlc29sdXRpb25fKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbmV3IG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB6b29tIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE1heFpvb20oem9vbSkge1xuICAgIHRoaXMuYXBwbHlPcHRpb25zXyh0aGlzLmdldFVwZGF0ZWRPcHRpb25zXyh7bWF4Wm9vbTogem9vbX0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbmltdW0gem9vbSBsZXZlbCBmb3IgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1pbmltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TWluWm9vbSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHRoaXMubWF4UmVzb2x1dGlvbl8pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gVGhlIG1pbmltdW0gem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWluWm9vbSh6b29tKSB7XG4gICAgdGhpcy5hcHBseU9wdGlvbnNfKHRoaXMuZ2V0VXBkYXRlZE9wdGlvbnNfKHttaW5ab29tOiB6b29tfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBwcm9qZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fSBUaGUgcHJvamVjdGlvbiBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0aW9uXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZXcgcmVzb2x1dGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFZpZXdQcm9wZXJ0eS5SRVNPTFVUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByZXNvbHV0aW9ucyBmb3IgdGhlIHZpZXcuIFRoaXMgcmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzb2x1dGlvbnNcbiAgICogcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgVmlldywgb3IgdW5kZWZpbmVkIGlmIG5vbmUgd2VyZSBnaXZlbi5cbiAgICogQHJldHVybiB7QXJyYXk8bnVtYmVyPnx1bmRlZmluZWR9IFRoZSByZXNvbHV0aW9ucyBvZiB0aGUgdmlldy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbnNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcmVzb2x1dGlvbiBmb3IgYSBwcm92aWRlZCBleHRlbnQgKGluIG1hcCB1bml0cykgYW5kIHNpemUgKGluIHBpeGVscykuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnQgRXh0ZW50LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplPX0gb3B0X3NpemUgQm94IHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHJlc29sdXRpb24gYXQgd2hpY2ggdGhlIHByb3ZpZGVkIGV4dGVudCB3aWxsIHJlbmRlciBhdFxuICAgKiAgICAgdGhlIGdpdmVuIHNpemUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3JFeHRlbnQoZXh0ZW50LCBvcHRfc2l6ZSkge1xuICAgIGNvbnN0IHNpemUgPSBvcHRfc2l6ZSB8fCB0aGlzLmdldFNpemVGcm9tVmlld3BvcnRfKCk7XG4gICAgY29uc3QgeFJlc29sdXRpb24gPSBnZXRXaWR0aChleHRlbnQpIC8gc2l6ZVswXTtcbiAgICBjb25zdCB5UmVzb2x1dGlvbiA9IGdldEhlaWdodChleHRlbnQpIC8gc2l6ZVsxXTtcbiAgICByZXR1cm4gTWF0aC5tYXgoeFJlc29sdXRpb24sIHlSZXNvbHV0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgZm9yIGFcbiAgICogcmVzb2x1dGlvbi4gRXhwb25lbnRpYWwgc2NhbGluZyBpcyBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9wb3dlciBQb3dlci5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24obnVtYmVyKTogbnVtYmVyfSBSZXNvbHV0aW9uIGZvciB2YWx1ZSBmdW5jdGlvbi5cbiAgICovXG4gIGdldFJlc29sdXRpb25Gb3JWYWx1ZUZ1bmN0aW9uKG9wdF9wb3dlcikge1xuICAgIGNvbnN0IHBvd2VyID0gb3B0X3Bvd2VyIHx8IDI7XG4gICAgY29uc3QgbWF4UmVzb2x1dGlvbiA9IHRoaXMubWF4UmVzb2x1dGlvbl87XG4gICAgY29uc3QgbWluUmVzb2x1dGlvbiA9IHRoaXMubWluUmVzb2x1dGlvbl87XG4gICAgY29uc3QgbWF4ID0gTWF0aC5sb2cobWF4UmVzb2x1dGlvbiAvIG1pblJlc29sdXRpb24pIC8gTWF0aC5sb2cocG93ZXIpO1xuICAgIHJldHVybiAoXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZS5cbiAgICAgICAqIEByZXR1cm4ge251bWJlcn0gUmVzb2x1dGlvbi5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IG1heFJlc29sdXRpb24gLyBNYXRoLnBvdyhwb3dlciwgdmFsdWUgKiBtYXgpO1xuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyByb3RhdGlvbi5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVmlld1Byb3BlcnR5LlJPVEFUSU9OKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcmVzb2x1dGlvbiBmb3IgYSB2YWx1ZSBiZXR3ZWVuXG4gICAqIDAgYW5kIDEuIEV4cG9uZW50aWFsIHNjYWxpbmcgaXMgYXNzdW1lZC5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcG93ZXIgUG93ZXIuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG51bWJlcik6IG51bWJlcn0gVmFsdWUgZm9yIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAqL1xuICBnZXRWYWx1ZUZvclJlc29sdXRpb25GdW5jdGlvbihvcHRfcG93ZXIpIHtcbiAgICBjb25zdCBwb3dlciA9IG9wdF9wb3dlciB8fCAyO1xuICAgIGNvbnN0IG1heFJlc29sdXRpb24gPSB0aGlzLm1heFJlc29sdXRpb25fO1xuICAgIGNvbnN0IG1pblJlc29sdXRpb24gPSB0aGlzLm1pblJlc29sdXRpb25fO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubG9nKG1heFJlc29sdXRpb24gLyBtaW5SZXNvbHV0aW9uKSAvIE1hdGgubG9nKHBvd2VyKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfSBWYWx1ZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24ocmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChNYXRoLmxvZyhtYXhSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyhwb3dlcikpIC8gbWF4O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpbyBmb3IgY2VudGVyIHJvdW5kaW5nLlxuICAgKiBAcmV0dXJuIHtTdGF0ZX0gVmlldyBzdGF0ZS5cbiAgICovXG4gIGdldFN0YXRlKHBpeGVsUmF0aW8pIHtcbiAgICBjb25zdCBjZW50ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqLyAodGhpcy5nZXRDZW50ZXIoKSk7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICBjb25zdCBwaXhlbFJlc29sdXRpb24gPSByZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbztcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi8gKHtcbiAgICAgICAgY2VudGVyOiBbXG4gICAgICAgICAgTWF0aC5yb3VuZChjZW50ZXJbMF0gLyBwaXhlbFJlc29sdXRpb24pICogcGl4ZWxSZXNvbHV0aW9uLFxuICAgICAgICAgIE1hdGgucm91bmQoY2VudGVyWzFdIC8gcGl4ZWxSZXNvbHV0aW9uKSAqIHBpeGVsUmVzb2x1dGlvblxuICAgICAgICBdLFxuICAgICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uICE9PSB1bmRlZmluZWQgPyBwcm9qZWN0aW9uIDogbnVsbCxcbiAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICB6b29tOiB0aGlzLmdldFpvb20oKVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB6b29tIGxldmVsLiAgSWYgeW91IGNvbmZpZ3VyZWQgeW91ciB2aWV3IHdpdGggYSByZXNvbHV0aW9uc1xuICAgKiBhcnJheSAodGhpcyBpcyByYXJlKSwgdGhpcyBtZXRob2QgbWF5IHJldHVybiBub24taW50ZWdlciB6b29tIGxldmVscyAoc29cbiAgICogdGhlIHpvb20gbGV2ZWwgaXMgbm90IHNhZmUgdG8gdXNlIGFzIGFuIGluZGV4IGludG8gYSByZXNvbHV0aW9ucyBhcnJheSkuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFpvb20uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFpvb20oKSB7XG4gICAgbGV0IHpvb207XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIGlmIChyZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHpvb20gPSB0aGlzLmdldFpvb21Gb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gem9vbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHpvb20gbGV2ZWwgZm9yIGEgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gVGhlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSB6b29tIGxldmVsIGZvciB0aGUgcHJvdmlkZWQgcmVzb2x1dGlvbi5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Wm9vbUZvclJlc29sdXRpb24ocmVzb2x1dGlvbikge1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLm1pblpvb21fIHx8IDA7XG4gICAgbGV0IG1heCwgem9vbUZhY3RvcjtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uc18pIHtcbiAgICAgIGNvbnN0IG5lYXJlc3QgPSBsaW5lYXJGaW5kTmVhcmVzdCh0aGlzLnJlc29sdXRpb25zXywgcmVzb2x1dGlvbiwgMSk7XG4gICAgICBvZmZzZXQgPSBuZWFyZXN0O1xuICAgICAgbWF4ID0gdGhpcy5yZXNvbHV0aW9uc19bbmVhcmVzdF07XG4gICAgICBpZiAobmVhcmVzdCA9PSB0aGlzLnJlc29sdXRpb25zXy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHpvb21GYWN0b3IgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9vbUZhY3RvciA9IG1heCAvIHRoaXMucmVzb2x1dGlvbnNfW25lYXJlc3QgKyAxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4ID0gdGhpcy5tYXhSZXNvbHV0aW9uXztcbiAgICAgIHpvb21GYWN0b3IgPSB0aGlzLnpvb21GYWN0b3JfO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgTWF0aC5sb2cobWF4IC8gcmVzb2x1dGlvbikgLyBNYXRoLmxvZyh6b29tRmFjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJlc29sdXRpb24gZm9yIGEgem9vbSBsZXZlbC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHpvb20gWm9vbSBsZXZlbC5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmlldyByZXNvbHV0aW9uIGZvciB0aGUgcHJvdmlkZWQgem9vbSBsZXZlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UmVzb2x1dGlvbkZvclpvb20oem9vbSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICAgIHRoaXMubWF4UmVzb2x1dGlvbl8sIHpvb20gLSB0aGlzLm1pblpvb21fLCAwKSk7XG4gIH1cblxuICAvKipcbiAgICogRml0IHRoZSBnaXZlbiBnZW9tZXRyeSBvciBleHRlbnQgYmFzZWQgb24gdGhlIGdpdmVuIG1hcCBzaXplIGFuZCBib3JkZXIuXG4gICAqIFRoZSBzaXplIGlzIHBpeGVsIGRpbWVuc2lvbnMgb2YgdGhlIGJveCB0byBmaXQgdGhlIGV4dGVudCBpbnRvLlxuICAgKiBJbiBtb3N0IGNhc2VzIHlvdSB3aWxsIHdhbnQgdG8gdXNlIHRoZSBtYXAgc2l6ZSwgdGhhdCBpcyBgbWFwLmdldFNpemUoKWAuXG4gICAqIFRha2VzIGNhcmUgb2YgdGhlIG1hcCBhbmdsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb20vU2ltcGxlR2VvbWV0cnkuanNcIikuZGVmYXVsdHxpbXBvcnQoXCIuL2V4dGVudC5qc1wiKS5FeHRlbnR9IGdlb21ldHJ5T3JFeHRlbnQgVGhlIGdlb21ldHJ5IG9yXG4gICAqICAgICBleHRlbnQgdG8gZml0IHRoZSB2aWV3IHRvLlxuICAgKiBAcGFyYW0ge0ZpdE9wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zLlxuICAgKiBAYXBpXG4gICAqL1xuICBmaXQoZ2VvbWV0cnlPckV4dGVudCwgb3B0X29wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gb3B0X29wdGlvbnMgfHwge307XG4gICAgbGV0IHNpemUgPSBvcHRpb25zLnNpemU7XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICBzaXplID0gdGhpcy5nZXRTaXplRnJvbVZpZXdwb3J0XygpO1xuICAgIH1cbiAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vZ2VvbS9TaW1wbGVHZW9tZXRyeS5qc1wiKS5kZWZhdWx0fSAqL1xuICAgIGxldCBnZW9tZXRyeTtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShnZW9tZXRyeU9yRXh0ZW50KSB8fCB0eXBlb2YgLyoqIEB0eXBlIHs/fSAqLyAoZ2VvbWV0cnlPckV4dGVudCkuZ2V0U2ltcGxpZmllZEdlb21ldHJ5ID09PSAnZnVuY3Rpb24nLFxuICAgICAgMjQpOyAvLyBJbnZhbGlkIGV4dGVudCBvciBnZW9tZXRyeSBwcm92aWRlZCBhcyBgZ2VvbWV0cnlgXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VvbWV0cnlPckV4dGVudCkpIHtcbiAgICAgIGFzc2VydCghaXNFbXB0eShnZW9tZXRyeU9yRXh0ZW50KSxcbiAgICAgICAgMjUpOyAvLyBDYW5ub3QgZml0IGVtcHR5IGV4dGVudCBwcm92aWRlZCBhcyBgZ2VvbWV0cnlgXG4gICAgICBnZW9tZXRyeSA9IHBvbHlnb25Gcm9tRXh0ZW50KGdlb21ldHJ5T3JFeHRlbnQpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnlPckV4dGVudC5nZXRUeXBlKCkgPT09IEdlb21ldHJ5VHlwZS5DSVJDTEUpIHtcbiAgICAgIGdlb21ldHJ5T3JFeHRlbnQgPSBnZW9tZXRyeU9yRXh0ZW50LmdldEV4dGVudCgpO1xuICAgICAgZ2VvbWV0cnkgPSBwb2x5Z29uRnJvbUV4dGVudChnZW9tZXRyeU9yRXh0ZW50KTtcbiAgICAgIGdlb21ldHJ5LnJvdGF0ZSh0aGlzLmdldFJvdGF0aW9uKCksIGdldENlbnRlcihnZW9tZXRyeU9yRXh0ZW50KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cnlPckV4dGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBhZGRpbmcgOiBbMCwgMCwgMCwgMF07XG4gICAgY29uc3QgY29uc3RyYWluUmVzb2x1dGlvbiA9IG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuY29uc3RyYWluUmVzb2x1dGlvbiA6IHRydWU7XG4gICAgY29uc3QgbmVhcmVzdCA9IG9wdGlvbnMubmVhcmVzdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uZWFyZXN0IDogZmFsc2U7XG4gICAgbGV0IG1pblJlc29sdXRpb247XG4gICAgaWYgKG9wdGlvbnMubWluUmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5SZXNvbHV0aW9uID0gb3B0aW9ucy5taW5SZXNvbHV0aW9uO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1pblJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpblJlc29sdXRpb24oXG4gICAgICAgIHRoaXMubWF4UmVzb2x1dGlvbl8sIG9wdGlvbnMubWF4Wm9vbSAtIHRoaXMubWluWm9vbV8sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5SZXNvbHV0aW9uID0gMDtcbiAgICB9XG4gICAgY29uc3QgY29vcmRzID0gZ2VvbWV0cnkuZ2V0RmxhdENvb3JkaW5hdGVzKCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcm90YXRlZCBleHRlbnRcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBjb25zdCBjb3NBbmdsZSA9IE1hdGguY29zKC1yb3RhdGlvbik7XG4gICAgbGV0IHNpbkFuZ2xlID0gTWF0aC5zaW4oLXJvdGF0aW9uKTtcbiAgICBsZXQgbWluUm90WCA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWluUm90WSA9ICtJbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4Um90WSA9IC1JbmZpbml0eTtcbiAgICBjb25zdCBzdHJpZGUgPSBnZW9tZXRyeS5nZXRTdHJpZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjb29yZHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gc3RyaWRlKSB7XG4gICAgICBjb25zdCByb3RYID0gY29vcmRzW2ldICogY29zQW5nbGUgLSBjb29yZHNbaSArIDFdICogc2luQW5nbGU7XG4gICAgICBjb25zdCByb3RZID0gY29vcmRzW2ldICogc2luQW5nbGUgKyBjb29yZHNbaSArIDFdICogY29zQW5nbGU7XG4gICAgICBtaW5Sb3RYID0gTWF0aC5taW4obWluUm90WCwgcm90WCk7XG4gICAgICBtaW5Sb3RZID0gTWF0aC5taW4obWluUm90WSwgcm90WSk7XG4gICAgICBtYXhSb3RYID0gTWF0aC5tYXgobWF4Um90WCwgcm90WCk7XG4gICAgICBtYXhSb3RZID0gTWF0aC5tYXgobWF4Um90WSwgcm90WSk7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHJlc29sdXRpb25cbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbkZvckV4dGVudChcbiAgICAgIFttaW5Sb3RYLCBtaW5Sb3RZLCBtYXhSb3RYLCBtYXhSb3RZXSxcbiAgICAgIFtzaXplWzBdIC0gcGFkZGluZ1sxXSAtIHBhZGRpbmdbM10sIHNpemVbMV0gLSBwYWRkaW5nWzBdIC0gcGFkZGluZ1syXV0pO1xuICAgIHJlc29sdXRpb24gPSBpc05hTihyZXNvbHV0aW9uKSA/IG1pblJlc29sdXRpb24gOlxuICAgICAgTWF0aC5tYXgocmVzb2x1dGlvbiwgbWluUmVzb2x1dGlvbik7XG4gICAgaWYgKGNvbnN0cmFpblJlc29sdXRpb24pIHtcbiAgICAgIGxldCBjb25zdHJhaW5lZFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpblJlc29sdXRpb24ocmVzb2x1dGlvbiwgMCwgMCk7XG4gICAgICBpZiAoIW5lYXJlc3QgJiYgY29uc3RyYWluZWRSZXNvbHV0aW9uIDwgcmVzb2x1dGlvbikge1xuICAgICAgICBjb25zdHJhaW5lZFJlc29sdXRpb24gPSB0aGlzLmNvbnN0cmFpblJlc29sdXRpb24oXG4gICAgICAgICAgY29uc3RyYWluZWRSZXNvbHV0aW9uLCAtMSwgMCk7XG4gICAgICB9XG4gICAgICByZXNvbHV0aW9uID0gY29uc3RyYWluZWRSZXNvbHV0aW9uO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBjZW50ZXJcbiAgICBzaW5BbmdsZSA9IC1zaW5BbmdsZTsgLy8gZ28gYmFjayB0byBvcmlnaW5hbCByb3RhdGlvblxuICAgIGxldCBjZW50ZXJSb3RYID0gKG1pblJvdFggKyBtYXhSb3RYKSAvIDI7XG4gICAgbGV0IGNlbnRlclJvdFkgPSAobWluUm90WSArIG1heFJvdFkpIC8gMjtcbiAgICBjZW50ZXJSb3RYICs9IChwYWRkaW5nWzFdIC0gcGFkZGluZ1szXSkgLyAyICogcmVzb2x1dGlvbjtcbiAgICBjZW50ZXJSb3RZICs9IChwYWRkaW5nWzBdIC0gcGFkZGluZ1syXSkgLyAyICogcmVzb2x1dGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gY2VudGVyUm90WCAqIGNvc0FuZ2xlIC0gY2VudGVyUm90WSAqIHNpbkFuZ2xlO1xuICAgIGNvbnN0IGNlbnRlclkgPSBjZW50ZXJSb3RZICogY29zQW5nbGUgKyBjZW50ZXJSb3RYICogc2luQW5nbGU7XG4gICAgY29uc3QgY2VudGVyID0gW2NlbnRlclgsIGNlbnRlclldO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayA/IG9wdGlvbnMuY2FsbGJhY2sgOiBWT0lEO1xuXG4gICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IG9wdGlvbnMuZWFzaW5nXG4gICAgICB9LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICAgIHRoaXMuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgICBhbmltYXRpb25DYWxsYmFjayhjYWxsYmFjaywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENlbnRlciBvbiBjb29yZGluYXRlIGFuZCB2aWV3IHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIENvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV9IHNpemUgQm94IHBpeGVsIHNpemUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcG9zaXRpb24gUG9zaXRpb24gb24gdGhlIHZpZXcgdG8gY2VudGVyIG9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBjZW50ZXJPbihjb29yZGluYXRlLCBzaXplLCBwb3NpdGlvbikge1xuICAgIC8vIGNhbGN1bGF0ZSByb3RhdGVkIHBvc2l0aW9uXG4gICAgY29uc3Qgcm90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcygtcm90YXRpb24pO1xuICAgIGxldCBzaW5BbmdsZSA9IE1hdGguc2luKC1yb3RhdGlvbik7XG4gICAgbGV0IHJvdFggPSBjb29yZGluYXRlWzBdICogY29zQW5nbGUgLSBjb29yZGluYXRlWzFdICogc2luQW5nbGU7XG4gICAgbGV0IHJvdFkgPSBjb29yZGluYXRlWzFdICogY29zQW5nbGUgKyBjb29yZGluYXRlWzBdICogc2luQW5nbGU7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRoaXMuZ2V0UmVzb2x1dGlvbigpO1xuICAgIHJvdFggKz0gKHNpemVbMF0gLyAyIC0gcG9zaXRpb25bMF0pICogcmVzb2x1dGlvbjtcbiAgICByb3RZICs9IChwb3NpdGlvblsxXSAtIHNpemVbMV0gLyAyKSAqIHJlc29sdXRpb247XG5cbiAgICAvLyBnbyBiYWNrIHRvIG9yaWdpbmFsIGFuZ2xlXG4gICAgc2luQW5nbGUgPSAtc2luQW5nbGU7IC8vIGdvIGJhY2sgdG8gb3JpZ2luYWwgcm90YXRpb25cbiAgICBjb25zdCBjZW50ZXJYID0gcm90WCAqIGNvc0FuZ2xlIC0gcm90WSAqIHNpbkFuZ2xlO1xuICAgIGNvbnN0IGNlbnRlclkgPSByb3RZICogY29zQW5nbGUgKyByb3RYICogc2luQW5nbGU7XG5cbiAgICB0aGlzLnNldENlbnRlcihbY2VudGVyWCwgY2VudGVyWV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIGRlZmluZWQuXG4gICAqL1xuICBpc0RlZigpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldENlbnRlcigpICYmIHRoaXMuZ2V0UmVzb2x1dGlvbigpICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUm90YXRlIHRoZSB2aWV3IGFyb3VuZCBhIGdpdmVuIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBOZXcgcm90YXRpb24gdmFsdWUgZm9yIHRoZSB2aWV3LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlPX0gb3B0X2FuY2hvciBUaGUgcm90YXRpb24gY2VudGVyLlxuICAgKiBAYXBpXG4gICAqL1xuICByb3RhdGUocm90YXRpb24sIG9wdF9hbmNob3IpIHtcbiAgICBpZiAob3B0X2FuY2hvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLmNhbGN1bGF0ZUNlbnRlclJvdGF0ZShyb3RhdGlvbiwgb3B0X2FuY2hvcik7XG4gICAgICB0aGlzLnNldENlbnRlcihjZW50ZXIpO1xuICAgIH1cbiAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNlbnRlciBvZiB0aGUgY3VycmVudCB2aWV3LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gY2VudGVyIFRoZSBjZW50ZXIgb2YgdGhlIHZpZXcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldENlbnRlcihjZW50ZXIpIHtcbiAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuQ0VOVEVSLCBjZW50ZXIpO1xuICAgIGlmICh0aGlzLmdldEFuaW1hdGluZygpKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtWaWV3SGludH0gaGludCBIaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgRGVsdGEuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTmV3IHZhbHVlLlxuICAgKi9cbiAgc2V0SGludChoaW50LCBkZWx0YSkge1xuICAgIHRoaXMuaGludHNfW2hpbnRdICs9IGRlbHRhO1xuICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIHJldHVybiB0aGlzLmhpbnRzX1toaW50XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJlc29sdXRpb24gZm9yIHRoaXMgdmlldy5cbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByZXNvbHV0aW9uIFRoZSByZXNvbHV0aW9uIG9mIHRoZSB2aWV3LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuUkVTT0xVVElPTiwgcmVzb2x1dGlvbik7XG4gICAgaWYgKHRoaXMuZ2V0QW5pbWF0aW5nKCkpIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHJvdGF0aW9uIGZvciB0aGlzIHZpZXcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiBUaGUgcm90YXRpb24gb2YgdGhlIHZpZXcgaW4gcmFkaWFucy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0Um90YXRpb24ocm90YXRpb24pIHtcbiAgICB0aGlzLnNldChWaWV3UHJvcGVydHkuUk9UQVRJT04sIHJvdGF0aW9uKTtcbiAgICBpZiAodGhpcy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25zKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFpvb20gdG8gYSBzcGVjaWZpYyB6b29tIGxldmVsLlxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbSBab29tIGxldmVsLlxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRab29tKHpvb20pIHtcbiAgICB0aGlzLnNldFJlc29sdXRpb24odGhpcy5nZXRSZXNvbHV0aW9uRm9yWm9vbSh6b29tKSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrLlxuICogQHBhcmFtIHsqfSByZXR1cm5WYWx1ZSBSZXR1cm4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGlvbkNhbGxiYWNrKGNhbGxiYWNrLCByZXR1cm5WYWx1ZSkge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGNhbGxiYWNrKHJldHVyblZhbHVlKTtcbiAgfSwgMCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge2ltcG9ydChcIi4vY2VudGVyY29uc3RyYWludC5qc1wiKS5UeXBlfSBUaGUgY29uc3RyYWludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNlbnRlckNvbnN0cmFpbnQob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjcmVhdGVFeHRlbnQob3B0aW9ucy5leHRlbnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjZW50ZXJOb25lO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge1ZpZXdPcHRpb25zfSBvcHRpb25zIFZpZXcgb3B0aW9ucy5cbiAqIEByZXR1cm4ge3tjb25zdHJhaW50OiBpbXBvcnQoXCIuL3Jlc29sdXRpb25jb25zdHJhaW50LmpzXCIpLlR5cGUsIG1heFJlc29sdXRpb246IG51bWJlcixcbiAqICAgICBtaW5SZXNvbHV0aW9uOiBudW1iZXIsIG1pblpvb206IG51bWJlciwgem9vbUZhY3RvcjogbnVtYmVyfX0gVGhlIGNvbnN0cmFpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHV0aW9uQ29uc3RyYWludChvcHRpb25zKSB7XG4gIGxldCByZXNvbHV0aW9uQ29uc3RyYWludDtcbiAgbGV0IG1heFJlc29sdXRpb247XG4gIGxldCBtaW5SZXNvbHV0aW9uO1xuXG4gIC8vIFRPRE86IG1vdmUgdGhlc2UgdG8gYmUgb2wgY29uc3RhbnRzXG4gIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2lzc3Vlcy8yMDc2XG4gIGNvbnN0IGRlZmF1bHRNYXhab29tID0gMjg7XG4gIGNvbnN0IGRlZmF1bHRab29tRmFjdG9yID0gMjtcblxuICBsZXQgbWluWm9vbSA9IG9wdGlvbnMubWluWm9vbSAhPT0gdW5kZWZpbmVkID9cbiAgICBvcHRpb25zLm1pblpvb20gOiBERUZBVUxUX01JTl9aT09NO1xuXG4gIGxldCBtYXhab29tID0gb3B0aW9ucy5tYXhab29tICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMubWF4Wm9vbSA6IGRlZmF1bHRNYXhab29tO1xuXG4gIGNvbnN0IHpvb21GYWN0b3IgPSBvcHRpb25zLnpvb21GYWN0b3IgIT09IHVuZGVmaW5lZCA/XG4gICAgb3B0aW9ucy56b29tRmFjdG9yIDogZGVmYXVsdFpvb21GYWN0b3I7XG5cbiAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHJlc29sdXRpb25zID0gb3B0aW9ucy5yZXNvbHV0aW9ucztcbiAgICBtYXhSZXNvbHV0aW9uID0gcmVzb2x1dGlvbnNbbWluWm9vbV07XG4gICAgbWluUmVzb2x1dGlvbiA9IHJlc29sdXRpb25zW21heFpvb21dICE9PSB1bmRlZmluZWQgP1xuICAgICAgcmVzb2x1dGlvbnNbbWF4Wm9vbV0gOiByZXNvbHV0aW9uc1tyZXNvbHV0aW9ucy5sZW5ndGggLSAxXTtcbiAgICByZXNvbHV0aW9uQ29uc3RyYWludCA9IGNyZWF0ZVNuYXBUb1Jlc29sdXRpb25zKFxuICAgICAgcmVzb2x1dGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGVmYXVsdCBtaW4gYW5kIG1heCByZXNvbHV0aW9uXG4gICAgY29uc3QgcHJvamVjdGlvbiA9IGNyZWF0ZVByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uLCAnRVBTRzozODU3Jyk7XG4gICAgY29uc3QgZXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgICBjb25zdCBzaXplID0gIWV4dGVudCA/XG4gICAgICAvLyB1c2UgYW4gZXh0ZW50IHRoYXQgY2FuIGZpdCB0aGUgd2hvbGUgd29ybGQgaWYgbmVlZCBiZVxuICAgICAgMzYwICogTUVURVJTX1BFUl9VTklUW1VuaXRzLkRFR1JFRVNdIC9cbiAgICAgICAgICAgIHByb2plY3Rpb24uZ2V0TWV0ZXJzUGVyVW5pdCgpIDpcbiAgICAgIE1hdGgubWF4KGdldFdpZHRoKGV4dGVudCksIGdldEhlaWdodChleHRlbnQpKTtcblxuICAgIGNvbnN0IGRlZmF1bHRNYXhSZXNvbHV0aW9uID0gc2l6ZSAvIERFRkFVTFRfVElMRV9TSVpFIC8gTWF0aC5wb3coXG4gICAgICBkZWZhdWx0Wm9vbUZhY3RvciwgREVGQVVMVF9NSU5fWk9PTSk7XG5cbiAgICBjb25zdCBkZWZhdWx0TWluUmVzb2x1dGlvbiA9IGRlZmF1bHRNYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coXG4gICAgICBkZWZhdWx0Wm9vbUZhY3RvciwgZGVmYXVsdE1heFpvb20gLSBERUZBVUxUX01JTl9aT09NKTtcblxuICAgIC8vIHVzZXIgcHJvdmlkZWQgbWF4UmVzb2x1dGlvbiB0YWtlcyBwcmVjZWRlbmNlXG4gICAgbWF4UmVzb2x1dGlvbiA9IG9wdGlvbnMubWF4UmVzb2x1dGlvbjtcbiAgICBpZiAobWF4UmVzb2x1dGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBtaW5ab29tID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4UmVzb2x1dGlvbiA9IGRlZmF1bHRNYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWluWm9vbSk7XG4gICAgfVxuXG4gICAgLy8gdXNlciBwcm92aWRlZCBtaW5SZXNvbHV0aW9uIHRha2VzIHByZWNlZGVuY2VcbiAgICBtaW5SZXNvbHV0aW9uID0gb3B0aW9ucy5taW5SZXNvbHV0aW9uO1xuICAgIGlmIChtaW5SZXNvbHV0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLm1heFpvb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5tYXhSZXNvbHV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtaW5SZXNvbHV0aW9uID0gbWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1heFpvb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1pblJlc29sdXRpb24gPSBkZWZhdWx0TWF4UmVzb2x1dGlvbiAvIE1hdGgucG93KHpvb21GYWN0b3IsIG1heFpvb20pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5SZXNvbHV0aW9uID0gZGVmYXVsdE1pblJlc29sdXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ2l2ZW4gZGlzY3JldGUgem9vbSBsZXZlbHMsIG1pblJlc29sdXRpb24gbWF5IGJlIGRpZmZlcmVudCB0aGFuIHByb3ZpZGVkXG4gICAgbWF4Wm9vbSA9IG1pblpvb20gKyBNYXRoLmZsb29yKFxuICAgICAgTWF0aC5sb2cobWF4UmVzb2x1dGlvbiAvIG1pblJlc29sdXRpb24pIC8gTWF0aC5sb2coem9vbUZhY3RvcikpO1xuICAgIG1pblJlc29sdXRpb24gPSBtYXhSZXNvbHV0aW9uIC8gTWF0aC5wb3coem9vbUZhY3RvciwgbWF4Wm9vbSAtIG1pblpvb20pO1xuXG4gICAgcmVzb2x1dGlvbkNvbnN0cmFpbnQgPSBjcmVhdGVTbmFwVG9Qb3dlcihcbiAgICAgIHpvb21GYWN0b3IsIG1heFJlc29sdXRpb24sIG1heFpvb20gLSBtaW5ab29tKTtcbiAgfVxuICByZXR1cm4ge2NvbnN0cmFpbnQ6IHJlc29sdXRpb25Db25zdHJhaW50LCBtYXhSZXNvbHV0aW9uOiBtYXhSZXNvbHV0aW9uLFxuICAgIG1pblJlc29sdXRpb246IG1pblJlc29sdXRpb24sIG1pblpvb206IG1pblpvb20sIHpvb21GYWN0b3I6IHpvb21GYWN0b3J9O1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtWaWV3T3B0aW9uc30gb3B0aW9ucyBWaWV3IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3JvdGF0aW9uY29uc3RyYWludC5qc1wiKS5UeXBlfSBSb3RhdGlvbiBjb25zdHJhaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm90YXRpb25Db25zdHJhaW50KG9wdGlvbnMpIHtcbiAgY29uc3QgZW5hYmxlUm90YXRpb24gPSBvcHRpb25zLmVuYWJsZVJvdGF0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMuZW5hYmxlUm90YXRpb24gOiB0cnVlO1xuICBpZiAoZW5hYmxlUm90YXRpb24pIHtcbiAgICBjb25zdCBjb25zdHJhaW5Sb3RhdGlvbiA9IG9wdGlvbnMuY29uc3RyYWluUm90YXRpb247XG4gICAgaWYgKGNvbnN0cmFpblJvdGF0aW9uID09PSB1bmRlZmluZWQgfHwgY29uc3RyYWluUm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTbmFwVG9aZXJvKCk7XG4gICAgfSBlbHNlIGlmIChjb25zdHJhaW5Sb3RhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiByb3RhdGlvbk5vbmU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWluUm90YXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU25hcFRvTihjb25zdHJhaW5Sb3RhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3RhdGlvbk5vbmU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkaXNhYmxlO1xuICB9XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gYW5pbWF0aW9uIGludm9sdmVzIG5vIHZpZXcgY2hhbmdlLlxuICogQHBhcmFtIHtBbmltYXRpb259IGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGFuaW1hdGlvbiBpbnZvbHZlcyBubyB2aWV3IGNoYW5nZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9vcEFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgaWYgKGFuaW1hdGlvbi5zb3VyY2VDZW50ZXIgJiYgYW5pbWF0aW9uLnRhcmdldENlbnRlcikge1xuICAgIGlmICghY29vcmRpbmF0ZXNFcXVhbChhbmltYXRpb24uc291cmNlQ2VudGVyLCBhbmltYXRpb24udGFyZ2V0Q2VudGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoYW5pbWF0aW9uLnNvdXJjZVJlc29sdXRpb24gIT09IGFuaW1hdGlvbi50YXJnZXRSZXNvbHV0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhbmltYXRpb24uc291cmNlUm90YXRpb24gIT09IGFuaW1hdGlvbi50YXJnZXRSb3RhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlldztcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUdBOzs7Ozs7Ozs7O0FBWUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDekNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7O0FBWUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBdUJBOzs7Ozs7OztBQVNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFxQkE7O0FDdkVBOzs7QUFHQTs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWNBOzs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFpQkE7Ozs7O0FDckZBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvSkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeURBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUVBOzs7Ozs7O0FBT0E7QUFFQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7Ozs7QUFLQTtBQUNBO0FBR0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQU1BO0FBRUE7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFHQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFTQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFEQTtBQVlBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUF6N0JBOzs7Ozs7O0FBZzhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUVBO0FBR0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBRUE7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///107\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/LayerType.js\nvar LayerType = __webpack_require__(53);\n\n// EXTERNAL MODULE: ./node_modules/ol/layer/Layer.js\nvar layer_Layer = __webpack_require__(55);\n\n// CONCATENATED MODULE: ./node_modules/ol/layer/TileProperty.js\n/**\n * @module ol/layer/TileProperty\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ var TileProperty = ({\n  PRELOAD: \'preload\',\n  USE_INTERIM_TILES_ON_ERROR: \'useInterimTilesOnError\'\n});\n// EXTERNAL MODULE: ./node_modules/ol/obj.js\nvar obj = __webpack_require__(12);\n\n// CONCATENATED MODULE: ./node_modules/ol/layer/Tile.js\n/**\n * @module ol/layer/Tile\n */\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map\'s `layers` collection, or `Infinity` when the layer\'s `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`\n * means no preloading.\n * @property {import("../source/Tile.js").default} [source] Source for this layer.\n * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use {@link module:ol/Map#addLayer}.\n * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.\n */\n\n/**\n * @classdesc\n * For layer sources that provide pre-rendered, tiled images in grids that are\n * organized by zoom levels for specific resolutions.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: \'My Title\'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @api\n */\n\nvar Tile_TileLayer =\n/*@__PURE__*/\nfunction (Layer) {\n  function TileLayer(opt_options) {\n    var options = opt_options ? opt_options : {};\n    var baseOptions = Object(obj["a" /* assign */])({}, options);\n    delete baseOptions.preload;\n    delete baseOptions.useInterimTilesOnError;\n    Layer.call(this, baseOptions);\n    this.setPreload(options.preload !== undefined ? options.preload : 0);\n    this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);\n    /**\n    * The layer type.\n    * @protected\n    * @type {import("../LayerType.js").default}\n    */\n\n    this.type = LayerType["a" /* default */].TILE;\n  }\n\n  if (Layer) TileLayer.__proto__ = Layer;\n  TileLayer.prototype = Object.create(Layer && Layer.prototype);\n  TileLayer.prototype.constructor = TileLayer;\n  /**\n  * Return the level as number to which we will preload tiles up to.\n  * @return {number} The level to preload tiles up to.\n  * @observable\n  * @api\n  */\n\n  TileLayer.prototype.getPreload = function getPreload() {\n    return (\n      /** @type {number} */\n      this.get(TileProperty.PRELOAD)\n    );\n  };\n  /**\n  * Set the level as number to which we will preload tiles up to.\n  * @param {number} preload The level to preload tiles up to.\n  * @observable\n  * @api\n  */\n\n\n  TileLayer.prototype.setPreload = function setPreload(preload) {\n    this.set(TileProperty.PRELOAD, preload);\n  };\n  /**\n  * Whether we use interim tiles on error.\n  * @return {boolean} Use interim tiles on error.\n  * @observable\n  * @api\n  */\n\n\n  TileLayer.prototype.getUseInterimTilesOnError = function getUseInterimTilesOnError() {\n    return (\n      /** @type {boolean} */\n      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)\n    );\n  };\n  /**\n  * Set whether we use interim tiles on error.\n  * @param {boolean} useInterimTilesOnError Use interim tiles on error.\n  * @observable\n  * @api\n  */\n\n\n  TileLayer.prototype.setUseInterimTilesOnError = function setUseInterimTilesOnError(useInterimTilesOnError) {\n    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);\n  };\n\n  return TileLayer;\n}(layer_Layer["a" /* default */]);\n/**\n * Return the associated {@link module:ol/source/Tile tilesource} of the layer.\n * @function\n * @return {import("../source/Tile.js").default} Source.\n * @api\n */\n\n\nTile_TileLayer.prototype.getSource;\n/* harmony default export */ var Tile = __webpack_exports__["default"] = (Tile_TileLayer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9sYXllci9UaWxlUHJvcGVydHkuanM/NzQ5OSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL2xheWVyL1RpbGUuanM/YjA0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvbGF5ZXIvVGlsZVByb3BlcnR5XG4gKi9cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBSRUxPQUQ6ICdwcmVsb2FkJyxcbiAgVVNFX0lOVEVSSU1fVElMRVNfT05fRVJST1I6ICd1c2VJbnRlcmltVGlsZXNPbkVycm9yJ1xufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9UaWxlXG4gKi9cbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBMYXllciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCBUaWxlUHJvcGVydHkgZnJvbSAnLi9UaWxlUHJvcGVydHkuanMnO1xuaW1wb3J0IHthc3NpZ259IGZyb20gJy4uL29iai5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcHJlbG9hZD0wXSBQcmVsb2FkLiBMb2FkIGxvdy1yZXNvbHV0aW9uIHRpbGVzIHVwIHRvIGBwcmVsb2FkYCBsZXZlbHMuIGAwYFxuICogbWVhbnMgbm8gcHJlbG9hZGluZy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gW3NvdXJjZV0gU291cmNlIGZvciB0aGlzIGxheWVyLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gW21hcF0gU2V0cyB0aGUgbGF5ZXIgYXMgb3ZlcmxheSBvbiBhIG1hcC4gVGhlIG1hcCB3aWxsIG5vdCBtYW5hZ2VcbiAqIHRoaXMgbGF5ZXIgaW4gaXRzIGxheWVycyBjb2xsZWN0aW9uLCBhbmQgdGhlIGxheWVyIHdpbGwgYmUgcmVuZGVyZWQgb24gdG9wLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAqIHRlbXBvcmFyeSBsYXllcnMuIFRoZSBzdGFuZGFyZCB3YXkgdG8gYWRkIGEgbGF5ZXIgdG8gYSBtYXAgYW5kIGhhdmUgaXQgbWFuYWdlZCBieSB0aGUgbWFwIGlzIHRvXG4gKiB1c2Uge0BsaW5rIG1vZHVsZTpvbC9NYXAjYWRkTGF5ZXJ9LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdXNlSW50ZXJpbVRpbGVzT25FcnJvcj10cnVlXSBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAqL1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEZvciBsYXllciBzb3VyY2VzIHRoYXQgcHJvdmlkZSBwcmUtcmVuZGVyZWQsIHRpbGVkIGltYWdlcyBpbiBncmlkcyB0aGF0IGFyZVxuICogb3JnYW5pemVkIGJ5IHpvb20gbGV2ZWxzIGZvciBzcGVjaWZpYyByZXNvbHV0aW9ucy5cbiAqIE5vdGUgdGhhdCBhbnkgcHJvcGVydHkgc2V0IGluIHRoZSBvcHRpb25zIGlzIHNldCBhcyBhIHtAbGluayBtb2R1bGU6b2wvT2JqZWN0fkJhc2VPYmplY3R9XG4gKiBwcm9wZXJ0eSBvbiB0aGUgbGF5ZXIgb2JqZWN0OyBmb3IgZXhhbXBsZSwgc2V0dGluZyBgdGl0bGU6ICdNeSBUaXRsZSdgIGluIHRoZVxuICogb3B0aW9ucyBtZWFucyB0aGF0IGB0aXRsZWAgaXMgb2JzZXJ2YWJsZSwgYW5kIGhhcyBnZXQvc2V0IGFjY2Vzc29ycy5cbiAqXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFRpbGVMYXllciBleHRlbmRzIExheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIFRpbGUgbGF5ZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9vcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy5wcmVsb2FkO1xuICAgIGRlbGV0ZSBiYXNlT3B0aW9ucy51c2VJbnRlcmltVGlsZXNPbkVycm9yO1xuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcblxuICAgIHRoaXMuc2V0UHJlbG9hZChvcHRpb25zLnByZWxvYWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucHJlbG9hZCA6IDApO1xuICAgIHRoaXMuc2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcihvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3IgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnVzZUludGVyaW1UaWxlc09uRXJyb3IgOiB0cnVlKTtcblxuICAgIC8qKlxuICAgICogVGhlIGxheWVyIHR5cGUuXG4gICAgKiBAcHJvdGVjdGVkXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vTGF5ZXJUeXBlLmpzXCIpLmRlZmF1bHR9XG4gICAgKi9cbiAgICB0aGlzLnR5cGUgPSBMYXllclR5cGUuVElMRTtcblxuICB9XG5cbiAgLyoqXG4gICogUmV0dXJuIHRoZSBsZXZlbCBhcyBudW1iZXIgdG8gd2hpY2ggd2Ugd2lsbCBwcmVsb2FkIHRpbGVzIHVwIHRvLlxuICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGxldmVsIHRvIHByZWxvYWQgdGlsZXMgdXAgdG8uXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIGdldFByZWxvYWQoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5nZXQoVGlsZVByb3BlcnR5LlBSRUxPQUQpKTtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgbGV2ZWwgYXMgbnVtYmVyIHRvIHdoaWNoIHdlIHdpbGwgcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgKiBAcGFyYW0ge251bWJlcn0gcHJlbG9hZCBUaGUgbGV2ZWwgdG8gcHJlbG9hZCB0aWxlcyB1cCB0by5cbiAgKiBAb2JzZXJ2YWJsZVxuICAqIEBhcGlcbiAgKi9cbiAgc2V0UHJlbG9hZChwcmVsb2FkKSB7XG4gICAgdGhpcy5zZXQoVGlsZVByb3BlcnR5LlBSRUxPQUQsIHByZWxvYWQpO1xuICB9XG5cbiAgLyoqXG4gICogV2hldGhlciB3ZSB1c2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBVc2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgKiBAb2JzZXJ2YWJsZVxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtib29sZWFufSAqLyAodGhpcy5nZXQoVGlsZVByb3BlcnR5LlVTRV9JTlRFUklNX1RJTEVTX09OX0VSUk9SKSk7XG4gIH1cblxuICAvKipcbiAgKiBTZXQgd2hldGhlciB3ZSB1c2UgaW50ZXJpbSB0aWxlcyBvbiBlcnJvci5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUludGVyaW1UaWxlc09uRXJyb3IgVXNlIGludGVyaW0gdGlsZXMgb24gZXJyb3IuXG4gICogQG9ic2VydmFibGVcbiAgKiBAYXBpXG4gICovXG4gIHNldFVzZUludGVyaW1UaWxlc09uRXJyb3IodXNlSW50ZXJpbVRpbGVzT25FcnJvcikge1xuICAgIHRoaXMuc2V0KFRpbGVQcm9wZXJ0eS5VU0VfSU5URVJJTV9USUxFU19PTl9FUlJPUiwgdXNlSW50ZXJpbVRpbGVzT25FcnJvcik7XG4gIH1cbn1cblxuXG4vKipcbiAqIFJldHVybiB0aGUgYXNzb2NpYXRlZCB7QGxpbmsgbW9kdWxlOm9sL3NvdXJjZS9UaWxlIHRpbGVzb3VyY2V9IG9mIHRoZSBsYXllci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7aW1wb3J0KFwiLi4vc291cmNlL1RpbGUuanNcIikuZGVmYXVsdH0gU291cmNlLlxuICogQGFwaVxuICovXG5UaWxlTGF5ZXIucHJvdG90eXBlLmdldFNvdXJjZTtcblxuXG5leHBvcnQgZGVmYXVsdCBUaWxlTGF5ZXI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRkE7Ozs7O0FDUEE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7OztBQVFBOzs7OztBQUVBOzs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOztBQWpFQTs7Ozs7Ozs7O0FBMEVBO0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///108\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/LayerType.js\nvar LayerType = __webpack_require__(53);\n\n// EXTERNAL MODULE: ./node_modules/ol/TileRange.js\nvar TileRange = __webpack_require__(67);\n\n// EXTERNAL MODULE: ./node_modules/ol/TileState.js\nvar TileState = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./node_modules/ol/ViewHint.js\nvar ViewHint = __webpack_require__(18);\n\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/coordinate.js + 1 modules\nvar ol_coordinate = __webpack_require__(41);\n\n// EXTERNAL MODULE: ./node_modules/ol/renderer/canvas/Layer.js + 1 modules\nvar Layer = __webpack_require__(101);\n\n// EXTERNAL MODULE: ./node_modules/ol/transform.js\nvar ol_transform = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/IntermediateCanvas.js\n/**\n * @module ol/renderer/canvas/IntermediateCanvas\n */\n\n\n\n\n\n\n/**\n * @abstract\n */\n\nvar IntermediateCanvas_IntermediateCanvasRenderer =\n/*@__PURE__*/\nfunction (CanvasLayerRenderer) {\n  function IntermediateCanvasRenderer(layer) {\n    CanvasLayerRenderer.call(this, layer);\n    /**\n     * @protected\n     * @type {import("../../transform.js").Transform}\n     */\n\n    this.coordinateToCanvasPixelTransform = Object(ol_transform["c" /* create */])();\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.hitCanvasContext_ = null;\n  }\n\n  if (CanvasLayerRenderer) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer;\n  IntermediateCanvasRenderer.prototype = Object.create(CanvasLayerRenderer && CanvasLayerRenderer.prototype);\n  IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;\n  /**\n   * @inheritDoc\n   */\n\n  IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    this.preCompose(context, frameState);\n    var image = this.getImage();\n\n    if (image) {\n      // clipped rendering if layer extent is set\n      var extent = layerState.extent;\n      var clipped = extent !== undefined && !Object(ol_extent["containsExtent"])(extent, frameState.extent) && Object(ol_extent["intersects"])(extent, frameState.extent);\n\n      if (clipped) {\n        this.clip(context, frameState,\n        /** @type {import("../../extent.js").Extent} */\n        extent);\n      }\n\n      var imageTransform = this.getImageTransform(); // for performance reasons, context.save / context.restore is not used\n      // to save and restore the transformation matrix and the opacity.\n      // see http://jsperf.com/context-save-restore-versus-variable\n\n      var alpha = context.globalAlpha;\n      context.globalAlpha = layerState.opacity; // for performance reasons, context.setTransform is only used\n      // when the view is rotated. see http://jsperf.com/canvas-transform\n\n      var dx = imageTransform[4];\n      var dy = imageTransform[5];\n      var dw = image.width * imageTransform[0];\n      var dh = image.height * imageTransform[3];\n\n      if (dw >= 0.5 && dh >= 0.5) {\n        context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      }\n\n      context.globalAlpha = alpha;\n\n      if (clipped) {\n        context.restore();\n      }\n    }\n\n    this.postCompose(context, frameState, layerState);\n  };\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.\n   */\n\n\n  IntermediateCanvasRenderer.prototype.getImage = function getImage() {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * @abstract\n   * @return {!import("../../transform.js").Transform} Image transform.\n   */\n\n\n  IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform() {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.getImage()) {\n      return undefined;\n    }\n\n    var pixel = Object(ol_transform["a" /* apply */])(this.coordinateToCanvasPixelTransform, coordinate.slice());\n    Object(ol_coordinate["scale"])(pixel, frameState.viewState.resolution / this.renderedResolution);\n\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = Object(dom["a" /* createCanvasContext2D */])(1, 1);\n    }\n\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  };\n\n  return IntermediateCanvasRenderer;\n}(Layer["a" /* default */]);\n\n/* harmony default export */ var IntermediateCanvas = (IntermediateCanvas_IntermediateCanvasRenderer);\n// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/TileLayer.js\n/**\n * @module ol/renderer/canvas/TileLayer\n */\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\n\nvar TileLayer_CanvasTileLayerRenderer =\n/*@__PURE__*/\nfunction (IntermediateCanvasRenderer) {\n  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {\n    IntermediateCanvasRenderer.call(this, tileLayer);\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.context = opt_noContext ? null : Object(dom["a" /* createCanvasContext2D */])();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.oversampling_;\n    /**\n     * @private\n     * @type {import("../../extent.js").Extent}\n     */\n\n    this.renderedExtent_ = null;\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.renderedRevision;\n    /**\n     * @protected\n     * @type {!Array<import("../../Tile.js").default>}\n     */\n\n    this.renderedTiles = [];\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.newTiles_ = false;\n    /**\n     * @protected\n     * @type {import("../../extent.js").Extent}\n     */\n\n    this.tmpExtent = Object(ol_extent["createEmpty"])();\n    /**\n     * @private\n     * @type {import("../../TileRange.js").default}\n     */\n\n    this.tmpTileRange_ = new TileRange["b" /* default */](0, 0, 0, 0);\n    /**\n     * @private\n     * @type {import("../../transform.js").Transform}\n     */\n\n    this.imageTransform_ = Object(ol_transform["c" /* create */])();\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.zDirection = 0;\n  }\n\n  if (IntermediateCanvasRenderer) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;\n  CanvasTileLayerRenderer.prototype = Object.create(IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype);\n  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;\n  /**\n   * @private\n   * @param {import("../../Tile.js").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n\n  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_(tile) {\n    var tileLayer =\n    /** @type {import("../../layer/Tile.js").default} */\n    this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState["a" /* default */].LOADED || tileState == TileState["a" /* default */].EMPTY || tileState == TileState["a" /* default */].ERROR && !useInterimTilesOnError;\n  };\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import("../../proj/Projection.js").default} projection Projection.\n   * @return {!import("../../Tile.js").default} Tile.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tileLayer =\n    /** @type {import("../../layer/Tile.js").default} */\n    this.getLayer();\n    var tileSource =\n    /** @type {import("../../source/Tile.js").default} */\n    tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n\n    if (tile.getState() == TileState["a" /* default */].ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState["a" /* default */].LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n\n    return tile;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var pixelRatio = frameState.pixelRatio;\n    var size = frameState.size;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var tileLayer =\n    /** @type {import("../../layer/Tile.js").default} */\n    this.getLayer();\n    var tileSource =\n    /** @type {import("../../source/Tile.js").default} */\n    tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var oversampling = Math.round(viewResolution / tileResolution) || 1;\n    var extent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      extent = Object(ol_extent["getIntersection"])(extent, layerState.extent);\n    }\n\n    if (Object(ol_extent["isEmpty"])(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    /**\n     * @type {Object<number, Object<string, import("../../Tile.js").default>>}\n     */\n\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var hints = frameState.viewHints;\n    var animatingOrInteracting = hints[ViewHint["a" /* default */].ANIMATING] || hints[ViewHint["a" /* default */].INTERACTING];\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    var tile, x, y;\n\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n\n        tile = this.getTile(z, x, y, pixelRatio, projection);\n\n        if (this.isDrawableTile_(tile)) {\n          var uid = Object(util["c" /* getUid */])(this);\n\n          if (tile.getState() == TileState["a" /* default */].LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don\'t look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n\n    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (this.newTiles_ || !(this.renderedExtent_ && Object(ol_extent["containsExtent"])(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {\n      var context = this.context;\n\n      if (context) {\n        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        var canvas = context.canvas;\n\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if (this.renderedExtent_ && !Object(ol_extent["equals"])(imageExtent, this.renderedExtent_) || this.renderedRevision != sourceRevision) {\n            context.clearRect(0, 0, width, height);\n          }\n\n          oversampling = this.oversampling_;\n        }\n      }\n\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function (a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      var tileExtent, tileGutter, tilesToDraw, w, h;\n\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n\n        for (var tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this.renderedTiles.push(tile);\n        }\n      }\n\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n\n    var scale = this.renderedResolution / viewResolution;\n    var transform = Object(ol_transform["b" /* compose */])(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    Object(ol_transform["b" /* compose */])(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    return this.renderedTiles.length > 0;\n  };\n  /**\n   * @param {import("../../Tile.js").default} tile Tile.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../layer/Layer.js").State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n\n\n  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    var image = this.getTileImage(tile);\n\n    if (!image) {\n      return;\n    }\n\n    var uid = Object(util["c" /* getUid */])(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    var tileLayer =\n    /** @type {import("../../layer/Tile.js").default} */\n    this.getLayer();\n    var tileSource =\n    /** @type {import("../../source/Tile.js").default} */\n    tileLayer.getSource();\n\n    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n\n    var alphaChanged = alpha !== this.context.globalAlpha;\n\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImage = function getImage() {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform() {\n    return this.imageTransform_;\n  };\n  /**\n   * Get the image from a tile.\n   * @param {import("../../Tile.js").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n\n\n  CanvasTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n    return (\n      /** @type {import("../../ImageTile.js").default} */\n      tile.getImage()\n    );\n  };\n\n  return CanvasTileLayerRenderer;\n}(IntermediateCanvas);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import("../../layer/Layer.js").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\nTileLayer_CanvasTileLayerRenderer[\'handles\'] = function (layer) {\n  return layer.getType() === LayerType["a" /* default */].TILE;\n};\n/**\n * Create a layer renderer.\n * @param {import("../Map.js").default} mapRenderer The map renderer.\n * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.\n * @return {CanvasTileLayerRenderer} The layer renderer.\n */\n\n\nTileLayer_CanvasTileLayerRenderer[\'create\'] = function (mapRenderer, layer) {\n  return new TileLayer_CanvasTileLayerRenderer(\n  /** @type {import("../../layer/Tile.js").default} */\n  layer);\n};\n/**\n * @function\n * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}\n */\n\n\nTileLayer_CanvasTileLayerRenderer.prototype.getLayer;\n/* harmony default export */ var TileLayer = __webpack_exports__["default"] = (TileLayer_CanvasTileLayerRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXJlci9jYW52YXMvSW50ZXJtZWRpYXRlQ2FudmFzLmpzPzlmNTUiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXJlci9jYW52YXMvVGlsZUxheWVyLmpzP2E1NGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9JbnRlcm1lZGlhdGVDYW52YXNcbiAqL1xuaW1wb3J0IHthYnN0cmFjdH0gZnJvbSAnLi4vLi4vdXRpbC5qcyc7XG5pbXBvcnQge3NjYWxlIGFzIHNjYWxlQ29vcmRpbmF0ZX0gZnJvbSAnLi4vLi4vY29vcmRpbmF0ZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7Y29udGFpbnNFeHRlbnQsIGludGVyc2VjdHN9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgQ2FudmFzTGF5ZXJSZW5kZXJlciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm19IGZyb20gJy4uLy4uL3RyYW5zZm9ybS5qcyc7XG5cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyIGV4dGVuZHMgQ2FudmFzTGF5ZXJSZW5kZXJlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgTGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihsYXllcikge1xuXG4gICAgc3VwZXIobGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmhpdENhbnZhc0NvbnRleHRfID0gbnVsbDtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBjb21wb3NlRnJhbWUoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgY29udGV4dCkge1xuXG4gICAgdGhpcy5wcmVDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUpO1xuXG4gICAgY29uc3QgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCk7XG4gICAgaWYgKGltYWdlKSB7XG5cbiAgICAgIC8vIGNsaXBwZWQgcmVuZGVyaW5nIGlmIGxheWVyIGV4dGVudCBpcyBzZXRcbiAgICAgIGNvbnN0IGV4dGVudCA9IGxheWVyU3RhdGUuZXh0ZW50O1xuICAgICAgY29uc3QgY2xpcHBlZCA9IGV4dGVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgIWNvbnRhaW5zRXh0ZW50KGV4dGVudCwgZnJhbWVTdGF0ZS5leHRlbnQpICYmXG4gICAgICAgICAgaW50ZXJzZWN0cyhleHRlbnQsIGZyYW1lU3RhdGUuZXh0ZW50KTtcbiAgICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICAgIHRoaXMuY2xpcChjb250ZXh0LCBmcmFtZVN0YXRlLCAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9ICovIChleHRlbnQpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1hZ2VUcmFuc2Zvcm0gPSB0aGlzLmdldEltYWdlVHJhbnNmb3JtKCk7XG4gICAgICAvLyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgY29udGV4dC5zYXZlIC8gY29udGV4dC5yZXN0b3JlIGlzIG5vdCB1c2VkXG4gICAgICAvLyB0byBzYXZlIGFuZCByZXN0b3JlIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYW5kIHRoZSBvcGFjaXR5LlxuICAgICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnRleHQtc2F2ZS1yZXN0b3JlLXZlcnN1cy12YXJpYWJsZVxuICAgICAgY29uc3QgYWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGxheWVyU3RhdGUub3BhY2l0eTtcblxuICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGNvbnRleHQuc2V0VHJhbnNmb3JtIGlzIG9ubHkgdXNlZFxuICAgICAgLy8gd2hlbiB0aGUgdmlldyBpcyByb3RhdGVkLiBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FudmFzLXRyYW5zZm9ybVxuICAgICAgY29uc3QgZHggPSBpbWFnZVRyYW5zZm9ybVs0XTtcbiAgICAgIGNvbnN0IGR5ID0gaW1hZ2VUcmFuc2Zvcm1bNV07XG4gICAgICBjb25zdCBkdyA9IGltYWdlLndpZHRoICogaW1hZ2VUcmFuc2Zvcm1bMF07XG4gICAgICBjb25zdCBkaCA9IGltYWdlLmhlaWdodCAqIGltYWdlVHJhbnNmb3JtWzNdO1xuICAgICAgaWYgKGR3ID49IDAuNSAmJiBkaCA+PSAwLjUpIHtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsICtpbWFnZS53aWR0aCwgK2ltYWdlLmhlaWdodCxcbiAgICAgICAgICBNYXRoLnJvdW5kKGR4KSwgTWF0aC5yb3VuZChkeSksIE1hdGgucm91bmQoZHcpLCBNYXRoLnJvdW5kKGRoKSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cbiAgICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucG9zdENvbXBvc2UoY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudH0gQ2FudmFzLlxuICAgKi9cbiAgZ2V0SW1hZ2UoKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBJbWFnZSB0cmFuc2Zvcm0uXG4gICAqL1xuICBnZXRJbWFnZVRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZm9yRWFjaExheWVyQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBpZiAoIXRoaXMuZ2V0SW1hZ2UoKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbCA9IGFwcGx5VHJhbnNmb3JtKHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0sIGNvb3JkaW5hdGUuc2xpY2UoKSk7XG4gICAgc2NhbGVDb29yZGluYXRlKHBpeGVsLCBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uIC8gdGhpcy5yZW5kZXJlZFJlc29sdXRpb24pO1xuXG4gICAgaWYgKCF0aGlzLmhpdENhbnZhc0NvbnRleHRfKSB7XG4gICAgICB0aGlzLmhpdENhbnZhc0NvbnRleHRfID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICAgIH1cblxuICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8uY2xlYXJSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHRoaXMuaGl0Q2FudmFzQ29udGV4dF8uZHJhd0ltYWdlKHRoaXMuZ2V0SW1hZ2UoKSwgcGl4ZWxbMF0sIHBpeGVsWzFdLCAxLCAxLCAwLCAwLCAxLCAxKTtcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IHRoaXMuaGl0Q2FudmFzQ29udGV4dF8uZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG4gICAgaWYgKGltYWdlRGF0YVszXSA+IDApIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0TGF5ZXIoKSwgaW1hZ2VEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlcjtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXJlci9jYW52YXMvVGlsZUxheWVyXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi8uLi91dGlsLmpzJztcbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBUaWxlUmFuZ2UgZnJvbSAnLi4vLi4vVGlsZVJhbmdlLmpzJztcbmltcG9ydCBUaWxlU3RhdGUgZnJvbSAnLi4vLi4vVGlsZVN0YXRlLmpzJztcbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi8uLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7Y29udGFpbnNFeHRlbnQsIGNyZWF0ZUVtcHR5LCBlcXVhbHMsIGdldEludGVyc2VjdGlvbiwgaXNFbXB0eX0gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCBJbnRlcm1lZGlhdGVDYW52YXNSZW5kZXJlciBmcm9tICcuL0ludGVybWVkaWF0ZUNhbnZhcy5qcyc7XG5pbXBvcnQge2NyZWF0ZSBhcyBjcmVhdGVUcmFuc2Zvcm0sIGNvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybX0gZnJvbSAnLi4vLi4vdHJhbnNmb3JtLmpzJztcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgcmVuZGVyZXIgZm9yIHRpbGUgbGF5ZXJzLlxuICogQGFwaVxuICovXG5jbGFzcyBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciBleHRlbmRzIEludGVybWVkaWF0ZUNhbnZhc1JlbmRlcmVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9UaWxlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSB0aWxlTGF5ZXIgVGlsZSBsYXllci5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vQ29udGV4dCBTa2lwIHRoZSBjb250ZXh0IGNyZWF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IodGlsZUxheWVyLCBvcHRfbm9Db250ZXh0KSB7XG5cbiAgICBzdXBlcih0aWxlTGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gb3B0X25vQ29udGV4dCA/IG51bGwgOiBjcmVhdGVDYW52YXNDb250ZXh0MkQoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJzYW1wbGluZ187XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRFeHRlbnRfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbjtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7IUFycmF5PGltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFRpbGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubmV3VGlsZXNfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL2V4dGVudC5qc1wiKS5FeHRlbnR9XG4gICAgICovXG4gICAgdGhpcy50bXBFeHRlbnQgPSBjcmVhdGVFbXB0eSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vVGlsZVJhbmdlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy50bXBUaWxlUmFuZ2VfID0gbmV3IFRpbGVSYW5nZSgwLCAwLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uLy4uL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5pbWFnZVRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuekRpcmVjdGlvbiA9IDA7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaWxlIGlzIGRyYXdhYmxlLlxuICAgKi9cbiAgaXNEcmF3YWJsZVRpbGVfKHRpbGUpIHtcbiAgICBjb25zdCB0aWxlTGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgY29uc3QgdGlsZVN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHVzZUludGVyaW1UaWxlc09uRXJyb3IgPSB0aWxlTGF5ZXIuZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcigpO1xuICAgIHJldHVybiB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkxPQURFRCB8fFxuICAgICAgICB0aWxlU3RhdGUgPT0gVGlsZVN0YXRlLkVNUFRZIHx8XG4gICAgICAgIHRpbGVTdGF0ZSA9PSBUaWxlU3RhdGUuRVJST1IgJiYgIXVzZUludGVyaW1UaWxlc09uRXJyb3I7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogVGlsZSBjb29yZGluYXRlIHouXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IFRpbGUgY29vcmRpbmF0ZSB4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geSBUaWxlIGNvb3JkaW5hdGUgeS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHJldHVybiB7IWltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gVGlsZS5cbiAgICovXG4gIGdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGVMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICBjb25zdCB0aWxlU291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZUxheWVyLmdldFNvdXJjZSgpKTtcbiAgICBsZXQgdGlsZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5FUlJPUikge1xuICAgICAgaWYgKCF0aWxlTGF5ZXIuZ2V0VXNlSW50ZXJpbVRpbGVzT25FcnJvcigpKSB7XG4gICAgICAgIC8vIFdoZW4gdXNlSW50ZXJpbVRpbGVzT25FcnJvciBpcyBmYWxzZSwgd2UgY29uc2lkZXIgdGhlIGVycm9yIHRpbGUgYXMgbG9hZGVkLlxuICAgICAgICB0aWxlLnNldFN0YXRlKFRpbGVTdGF0ZS5MT0FERUQpO1xuICAgICAgfSBlbHNlIGlmICh0aWxlTGF5ZXIuZ2V0UHJlbG9hZCgpID4gMCkge1xuICAgICAgICAvLyBQcmVsb2FkZWQgdGlsZXMgZm9yIGxvd2VyIHJlc29sdXRpb25zIG1pZ2h0IGhhdmUgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgdGhpcy5uZXdUaWxlc18gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNEcmF3YWJsZVRpbGVfKHRpbGUpKSB7XG4gICAgICB0aWxlID0gdGlsZS5nZXRJbnRlcmltVGlsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgcHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcblxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3Qgc2l6ZSA9IGZyYW1lU3RhdGUuc2l6ZTtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgY29uc3Qgdmlld1Jlc29sdXRpb24gPSB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBjb25zdCB2aWV3Q2VudGVyID0gdmlld1N0YXRlLmNlbnRlcjtcblxuICAgIGNvbnN0IHRpbGVMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICBjb25zdCB0aWxlU291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZUxheWVyLmdldFNvdXJjZSgpKTtcbiAgICBjb25zdCBzb3VyY2VSZXZpc2lvbiA9IHRpbGVTb3VyY2UuZ2V0UmV2aXNpb24oKTtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHRpbGVTb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgIGNvbnN0IHogPSB0aWxlR3JpZC5nZXRaRm9yUmVzb2x1dGlvbih2aWV3UmVzb2x1dGlvbiwgdGhpcy56RGlyZWN0aW9uKTtcbiAgICBjb25zdCB0aWxlUmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oeik7XG4gICAgbGV0IG92ZXJzYW1wbGluZyA9IE1hdGgucm91bmQodmlld1Jlc29sdXRpb24gLyB0aWxlUmVzb2x1dGlvbikgfHwgMTtcbiAgICBsZXQgZXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG5cbiAgICBpZiAobGF5ZXJTdGF0ZS5leHRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXh0ZW50ID0gZ2V0SW50ZXJzZWN0aW9uKGV4dGVudCwgbGF5ZXJTdGF0ZS5leHRlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNFbXB0eShleHRlbnQpKSB7XG4gICAgICAvLyBSZXR1cm4gZmFsc2UgdG8gcHJldmVudCB0aGUgcmVuZGVyaW5nIG9mIHRoZSBsYXllci5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB0aWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VGb3JFeHRlbnRBbmRaKGV4dGVudCwgeik7XG4gICAgY29uc3QgaW1hZ2VFeHRlbnQgPSB0aWxlR3JpZC5nZXRUaWxlUmFuZ2VFeHRlbnQoeiwgdGlsZVJhbmdlKTtcblxuICAgIGNvbnN0IHRpbGVQaXhlbFJhdGlvID0gdGlsZVNvdXJjZS5nZXRUaWxlUGl4ZWxSYXRpbyhwaXhlbFJhdGlvKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHQ+Pn1cbiAgICAgKi9cbiAgICBjb25zdCB0aWxlc1RvRHJhd0J5WiA9IHt9O1xuICAgIHRpbGVzVG9EcmF3QnlaW3pdID0ge307XG5cbiAgICBjb25zdCBmaW5kTG9hZGVkVGlsZXMgPSB0aGlzLmNyZWF0ZUxvYWRlZFRpbGVGaW5kZXIoXG4gICAgICB0aWxlU291cmNlLCBwcm9qZWN0aW9uLCB0aWxlc1RvRHJhd0J5Wik7XG5cbiAgICBjb25zdCBoaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgIGNvbnN0IGFuaW1hdGluZ09ySW50ZXJhY3RpbmcgPSBoaW50c1tWaWV3SGludC5BTklNQVRJTkddIHx8IGhpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXTtcblxuICAgIGNvbnN0IHRtcEV4dGVudCA9IHRoaXMudG1wRXh0ZW50O1xuICAgIGNvbnN0IHRtcFRpbGVSYW5nZSA9IHRoaXMudG1wVGlsZVJhbmdlXztcbiAgICB0aGlzLm5ld1RpbGVzXyA9IGZhbHNlO1xuICAgIGxldCB0aWxlLCB4LCB5O1xuICAgIGZvciAoeCA9IHRpbGVSYW5nZS5taW5YOyB4IDw9IHRpbGVSYW5nZS5tYXhYOyArK3gpIHtcbiAgICAgIGZvciAoeSA9IHRpbGVSYW5nZS5taW5ZOyB5IDw9IHRpbGVSYW5nZS5tYXhZOyArK3kpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBmcmFtZVN0YXRlLnRpbWUgPiAxNiAmJiBhbmltYXRpbmdPckludGVyYWN0aW5nKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGlsZSA9IHRoaXMuZ2V0VGlsZSh6LCB4LCB5LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmF3YWJsZVRpbGVfKHRpbGUpKSB7XG4gICAgICAgICAgY29uc3QgdWlkID0gZ2V0VWlkKHRoaXMpO1xuICAgICAgICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAgICAgdGlsZXNUb0RyYXdCeVpbel1bdGlsZS50aWxlQ29vcmQudG9TdHJpbmcoKV0gPSB0aWxlO1xuICAgICAgICAgICAgY29uc3QgaW5UcmFuc2l0aW9uID0gdGlsZS5pblRyYW5zaXRpb24odWlkKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5uZXdUaWxlc18gJiYgKGluVHJhbnNpdGlvbiB8fCB0aGlzLnJlbmRlcmVkVGlsZXMuaW5kZXhPZih0aWxlKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICAgIHRoaXMubmV3VGlsZXNfID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRpbGUuZ2V0QWxwaGEodWlkLCBmcmFtZVN0YXRlLnRpbWUpID09PSAxKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBsb29rIGZvciBhbHQgdGlsZXMgaWYgYWxwaGEgaXMgMVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hpbGRUaWxlUmFuZ2UgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRDaGlsZFRpbGVSYW5nZShcbiAgICAgICAgICB0aWxlLnRpbGVDb29yZCwgdG1wVGlsZVJhbmdlLCB0bXBFeHRlbnQpO1xuICAgICAgICBsZXQgY292ZXJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoY2hpbGRUaWxlUmFuZ2UpIHtcbiAgICAgICAgICBjb3ZlcmVkID0gZmluZExvYWRlZFRpbGVzKHogKyAxLCBjaGlsZFRpbGVSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb3ZlcmVkKSB7XG4gICAgICAgICAgdGlsZUdyaWQuZm9yRWFjaFRpbGVDb29yZFBhcmVudFRpbGVSYW5nZShcbiAgICAgICAgICAgIHRpbGUudGlsZUNvb3JkLCBmaW5kTG9hZGVkVGlsZXMsIG51bGwsIHRtcFRpbGVSYW5nZSwgdG1wRXh0ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyZWRSZXNvbHV0aW9uID0gdGlsZVJlc29sdXRpb24gKiBwaXhlbFJhdGlvIC8gdGlsZVBpeGVsUmF0aW8gKiBvdmVyc2FtcGxpbmc7XG4gICAgaWYgKCEodGhpcy5yZW5kZXJlZFJlc29sdXRpb24gJiYgRGF0ZS5ub3coKSAtIGZyYW1lU3RhdGUudGltZSA+IDE2ICYmIGFuaW1hdGluZ09ySW50ZXJhY3RpbmcpICYmIChcbiAgICAgIHRoaXMubmV3VGlsZXNfIHx8XG4gICAgICAgICAgISh0aGlzLnJlbmRlcmVkRXh0ZW50XyAmJiBjb250YWluc0V4dGVudCh0aGlzLnJlbmRlcmVkRXh0ZW50XywgZXh0ZW50KSkgfHxcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb24gIT0gc291cmNlUmV2aXNpb24gfHxcbiAgICAgICAgICBvdmVyc2FtcGxpbmcgIT0gdGhpcy5vdmVyc2FtcGxpbmdfIHx8XG4gICAgICAgICAgIWFuaW1hdGluZ09ySW50ZXJhY3RpbmcgJiYgcmVuZGVyZWRSZXNvbHV0aW9uICE9IHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXG4gICAgKSkge1xuXG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdGlsZVBpeGVsU2l6ZSA9IHRpbGVTb3VyY2UuZ2V0VGlsZVBpeGVsU2l6ZSh6LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHRpbGVSYW5nZS5nZXRXaWR0aCgpICogdGlsZVBpeGVsU2l6ZVswXSAvIG92ZXJzYW1wbGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQodGlsZVJhbmdlLmdldEhlaWdodCgpICogdGlsZVBpeGVsU2l6ZVsxXSAvIG92ZXJzYW1wbGluZyk7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9IHdpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5vdmVyc2FtcGxpbmdfID0gb3ZlcnNhbXBsaW5nO1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCh0aGlzLnJlbmRlcmVkRXh0ZW50XyAmJiAhZXF1YWxzKGltYWdlRXh0ZW50LCB0aGlzLnJlbmRlcmVkRXh0ZW50XykpIHx8XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbiAhPSBzb3VyY2VSZXZpc2lvbikge1xuICAgICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG92ZXJzYW1wbGluZyA9IHRoaXMub3ZlcnNhbXBsaW5nXztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVkVGlsZXMubGVuZ3RoID0gMDtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn0gKi9cbiAgICAgIGNvbnN0IHpzID0gT2JqZWN0LmtleXModGlsZXNUb0RyYXdCeVopLm1hcChOdW1iZXIpO1xuICAgICAgenMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGlmIChhID09PSB6KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0geikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGV0IGN1cnJlbnRSZXNvbHV0aW9uLCBjdXJyZW50U2NhbGUsIGN1cnJlbnRUaWxlUGl4ZWxTaXplLCBjdXJyZW50WiwgaSwgaWk7XG4gICAgICBsZXQgdGlsZUV4dGVudCwgdGlsZUd1dHRlciwgdGlsZXNUb0RyYXcsIHcsIGg7XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHpzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgY3VycmVudFogPSB6c1tpXTtcbiAgICAgICAgY3VycmVudFRpbGVQaXhlbFNpemUgPSB0aWxlU291cmNlLmdldFRpbGVQaXhlbFNpemUoY3VycmVudFosIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgICBjdXJyZW50UmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oY3VycmVudFopO1xuICAgICAgICBjdXJyZW50U2NhbGUgPSBjdXJyZW50UmVzb2x1dGlvbiAvIHRpbGVSZXNvbHV0aW9uO1xuICAgICAgICB0aWxlR3V0dGVyID0gdGlsZVBpeGVsUmF0aW8gKiB0aWxlU291cmNlLmdldEd1dHRlckZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgICAgIHRpbGVzVG9EcmF3ID0gdGlsZXNUb0RyYXdCeVpbY3VycmVudFpdO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbGVDb29yZEtleSBpbiB0aWxlc1RvRHJhdykge1xuICAgICAgICAgIHRpbGUgPSB0aWxlc1RvRHJhd1t0aWxlQ29vcmRLZXldO1xuICAgICAgICAgIHRpbGVFeHRlbnQgPSB0aWxlR3JpZC5nZXRUaWxlQ29vcmRFeHRlbnQodGlsZS5nZXRUaWxlQ29vcmQoKSwgdG1wRXh0ZW50KTtcbiAgICAgICAgICB4ID0gKHRpbGVFeHRlbnRbMF0gLSBpbWFnZUV4dGVudFswXSkgLyB0aWxlUmVzb2x1dGlvbiAqIHRpbGVQaXhlbFJhdGlvIC8gb3ZlcnNhbXBsaW5nO1xuICAgICAgICAgIHkgPSAoaW1hZ2VFeHRlbnRbM10gLSB0aWxlRXh0ZW50WzNdKSAvIHRpbGVSZXNvbHV0aW9uICogdGlsZVBpeGVsUmF0aW8gLyBvdmVyc2FtcGxpbmc7XG4gICAgICAgICAgdyA9IGN1cnJlbnRUaWxlUGl4ZWxTaXplWzBdICogY3VycmVudFNjYWxlIC8gb3ZlcnNhbXBsaW5nO1xuICAgICAgICAgIGggPSBjdXJyZW50VGlsZVBpeGVsU2l6ZVsxXSAqIGN1cnJlbnRTY2FsZSAvIG92ZXJzYW1wbGluZztcbiAgICAgICAgICB0aGlzLmRyYXdUaWxlSW1hZ2UodGlsZSwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgeCwgeSwgdywgaCwgdGlsZUd1dHRlciwgeiA9PT0gY3VycmVudFopO1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRUaWxlcy5wdXNoKHRpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbiA9IHNvdXJjZVJldmlzaW9uO1xuICAgICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb24gPSB0aWxlUmVzb2x1dGlvbiAqIHBpeGVsUmF0aW8gLyB0aWxlUGl4ZWxSYXRpbyAqIG92ZXJzYW1wbGluZztcbiAgICAgIHRoaXMucmVuZGVyZWRFeHRlbnRfID0gaW1hZ2VFeHRlbnQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnJlbmRlcmVkUmVzb2x1dGlvbiAvIHZpZXdSZXNvbHV0aW9uO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGNvbXBvc2VUcmFuc2Zvcm0odGhpcy5pbWFnZVRyYW5zZm9ybV8sXG4gICAgICBwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIsIHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMixcbiAgICAgIHNjYWxlLCBzY2FsZSxcbiAgICAgIDAsXG4gICAgICAodGhpcy5yZW5kZXJlZEV4dGVudF9bMF0gLSB2aWV3Q2VudGVyWzBdKSAvIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uICogcGl4ZWxSYXRpbyxcbiAgICAgICh2aWV3Q2VudGVyWzFdIC0gdGhpcy5yZW5kZXJlZEV4dGVudF9bM10pIC8gdGhpcy5yZW5kZXJlZFJlc29sdXRpb24gKiBwaXhlbFJhdGlvKTtcbiAgICBjb21wb3NlVHJhbnNmb3JtKHRoaXMuY29vcmRpbmF0ZVRvQ2FudmFzUGl4ZWxUcmFuc2Zvcm0sXG4gICAgICBwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIgLSB0cmFuc2Zvcm1bNF0sIHBpeGVsUmF0aW8gKiBzaXplWzFdIC8gMiAtIHRyYW5zZm9ybVs1XSxcbiAgICAgIHBpeGVsUmF0aW8gLyB2aWV3UmVzb2x1dGlvbiwgLXBpeGVsUmF0aW8gLyB2aWV3UmVzb2x1dGlvbixcbiAgICAgIDAsXG4gICAgICAtdmlld0NlbnRlclswXSwgLXZpZXdDZW50ZXJbMV0pO1xuXG5cbiAgICB0aGlzLnVwZGF0ZVVzZWRUaWxlcyhmcmFtZVN0YXRlLnVzZWRUaWxlcywgdGlsZVNvdXJjZSwgeiwgdGlsZVJhbmdlKTtcbiAgICB0aGlzLm1hbmFnZVRpbGVQeXJhbWlkKGZyYW1lU3RhdGUsIHRpbGVTb3VyY2UsIHRpbGVHcmlkLCBwaXhlbFJhdGlvLFxuICAgICAgcHJvamVjdGlvbiwgZXh0ZW50LCB6LCB0aWxlTGF5ZXIuZ2V0UHJlbG9hZCgpKTtcbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlQ2FjaGUoZnJhbWVTdGF0ZSwgdGlsZVNvdXJjZSk7XG5cbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlZFRpbGVzLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9UaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gbGF5ZXJTdGF0ZSBMYXllciBzdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggTGVmdCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgVG9wIG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gdyBXaWR0aCBvZiB0aGUgdGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSB0aWxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZ3V0dGVyIFRpbGUgZ3V0dGVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYW5zaXRpb24gQXBwbHkgYW4gYWxwaGEgdHJhbnNpdGlvbi5cbiAgICovXG4gIGRyYXdUaWxlSW1hZ2UodGlsZSwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgeCwgeSwgdywgaCwgZ3V0dGVyLCB0cmFuc2l0aW9uKSB7XG4gICAgY29uc3QgaW1hZ2UgPSB0aGlzLmdldFRpbGVJbWFnZSh0aWxlKTtcbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVpZCA9IGdldFVpZCh0aGlzKTtcbiAgICBjb25zdCBhbHBoYSA9IHRyYW5zaXRpb24gPyB0aWxlLmdldEFscGhhKHVpZCwgZnJhbWVTdGF0ZS50aW1lKSA6IDE7XG4gICAgY29uc3QgdGlsZUxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9UaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgIGNvbnN0IHRpbGVTb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9UaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlTGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgIGlmIChhbHBoYSA9PT0gMSAmJiAhdGlsZVNvdXJjZS5nZXRPcGFxdWUoZnJhbWVTdGF0ZS52aWV3U3RhdGUucHJvamVjdGlvbikpIHtcbiAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuICAgIGNvbnN0IGFscGhhQ2hhbmdlZCA9IGFscGhhICE9PSB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgaWYgKGFscGhhQ2hhbmdlZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgIH1cbiAgICB0aGlzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBndXR0ZXIsIGd1dHRlcixcbiAgICAgIGltYWdlLndpZHRoIC0gMiAqIGd1dHRlciwgaW1hZ2UuaGVpZ2h0IC0gMiAqIGd1dHRlciwgeCwgeSwgdywgaCk7XG5cbiAgICBpZiAoYWxwaGFDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoYWxwaGEgIT09IDEpIHtcbiAgICAgIGZyYW1lU3RhdGUuYW5pbWF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICB0aWxlLmVuZFRyYW5zaXRpb24odWlkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEltYWdlKCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgcmV0dXJuIGNvbnRleHQgPyBjb250ZXh0LmNhbnZhcyA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldEltYWdlVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlVHJhbnNmb3JtXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGZyb20gYSB0aWxlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IEltYWdlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRUaWxlSW1hZ2UodGlsZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL0ltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZSkuZ2V0SW1hZ2UoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoaXMgcmVuZGVyZXIgaGFuZGxlcyB0aGUgcHJvdmlkZWQgbGF5ZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIFRoZSBjYW5kaWRhdGUgbGF5ZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVuZGVyZXIgY2FuIHJlbmRlciB0aGUgbGF5ZXIuXG4gKi9cbkNhbnZhc1RpbGVMYXllclJlbmRlcmVyWydoYW5kbGVzJ10gPSBmdW5jdGlvbihsYXllcikge1xuICByZXR1cm4gbGF5ZXIuZ2V0VHlwZSgpID09PSBMYXllclR5cGUuVElMRTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciByZW5kZXJlci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcFJlbmRlcmVyIFRoZSBtYXAgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIFRoZSBsYXllciB0byBiZSByZW5kZXJlcmQuXG4gKiBAcmV0dXJuIHtDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcn0gVGhlIGxheWVyIHJlbmRlcmVyLlxuICovXG5DYW52YXNUaWxlTGF5ZXJSZW5kZXJlclsnY3JlYXRlJ10gPSBmdW5jdGlvbihtYXBSZW5kZXJlciwgbGF5ZXIpIHtcbiAgcmV0dXJuIG5ldyBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlcigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyKSk7XG59O1xuXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi8uLi9sYXllci9UaWxlLmpzXCIpLmRlZmF1bHR8aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fVxuICovXG5DYW52YXNUaWxlTGF5ZXJSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGF5ZXI7XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUFBO0FBS0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7OztBQUVBOzs7OztBQUtBO0FBRUE7QUFFQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBOUdBO0FBQ0E7QUFnSEE7O0FDOUhBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFNQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBT0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQS9WQTs7Ozs7Ozs7QUF1V0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7O0FBT0E7QUFHQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///109\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _LocationMgr = _interopRequireDefault(__webpack_require__(135));\n\nvar _Geoclient = _interopRequireDefault(__webpack_require__(78));\n\nvar _Locator = _interopRequireDefault(__webpack_require__(136));\n\nvar _MapLocator = _interopRequireDefault(__webpack_require__(138));\n\nvar _Zoom = _interopRequireDefault(__webpack_require__(141));\n\nvar _Geolocate = _interopRequireDefault(__webpack_require__(143));\n\nvar _Search = _interopRequireDefault(__webpack_require__(145));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/LocationMgr\r\n */\n\n/**\r\n * @desc A class for managing user-specified location information\r\n * @public\r\n * @class\r\n * @extends module:nyc/LocationMgr~LocationMgr\r\n * @fires module:nyc/Locator~Locator#geocoded\r\n * @fires module:nyc/Locator~Locator#geolocated\r\n */\n\n\nvar LocationMgr =\n/*#__PURE__*/\nfunction (_LocationMgr$default) {\n  _inherits(LocationMgr, _LocationMgr$default);\n\n  /**\r\n   * @desc Create an instance of LocationMgr\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/ol/LocationMgr~LocationMgr.Options} options Constructor options\r\n   */\n  function LocationMgr(options) {\n    _classCallCheck(this, LocationMgr);\n\n    var map = options.map;\n    var searchTarget;\n\n    if (options.searchTarget !== undefined) {\n      searchTarget = options.searchTarget;\n    } else {\n      searchTarget = (0, _jquery["default"])(map.getTargetElement()).find(\'.ol-overlaycontainer-stopevent\');\n    }\n\n    var geocoder = options.geocoder || new _Geoclient["default"]({\n      url: options.url\n    });\n    return _possibleConstructorReturn(this, _getPrototypeOf(LocationMgr).call(this, {\n      search: new _Search["default"](searchTarget),\n      zoom: new _Zoom["default"](map),\n      dialogTarget: options.dialogTarget,\n      geolocate: new _Geolocate["default"](map),\n      locator: new _Locator["default"]({\n        geocoder: geocoder\n      }),\n      mapLocator: new _MapLocator["default"]({\n        map: map\n      })\n    }));\n  }\n\n  return LocationMgr;\n}(_LocationMgr["default"]);\n/**\r\n * @desc Constructor options for {@link module:nyc/ol/LocationMgr~LocationMgr}\r\n * @public\r\n * @typedef {Object}\r\n * @property {ol.Map} map The map\r\n * @property {string=} url The geoclient URL if geocoder is not provided\r\n * @property {module:nyc/Geocoder~Geocoder=} geocoder The geocoder if geoclient URL is not provided\r\n * @property {jQuery|Element|string=} searchTarget The DOM target for the search box\r\n * @property {jQuery|Element|string} [dialogTarget=body] The DOM target in which to display error dialog\r\n */\n\n\nLocationMgr.Options;\nvar _default = LocationMgr;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL0xvY2F0aW9uTWdyLmpzP2M4ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfanF1ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwianF1ZXJ5XCIpKTtcblxudmFyIF9Mb2NhdGlvbk1nciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL0xvY2F0aW9uTWdyXCIpKTtcblxudmFyIF9HZW9jbGllbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9HZW9jbGllbnRcIikpO1xuXG52YXIgX0xvY2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0xvY2F0b3JcIikpO1xuXG52YXIgX01hcExvY2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL01hcExvY2F0b3JcIikpO1xuXG52YXIgX1pvb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1pvb21cIikpO1xuXG52YXIgX0dlb2xvY2F0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vR2VvbG9jYXRlXCIpKTtcblxudmFyIF9TZWFyY2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1NlYXJjaFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9vbC9Mb2NhdGlvbk1nclxyXG4gKi9cblxuLyoqXHJcbiAqIEBkZXNjIEEgY2xhc3MgZm9yIG1hbmFnaW5nIHVzZXItc3BlY2lmaWVkIGxvY2F0aW9uIGluZm9ybWF0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIG1vZHVsZTpueWMvTG9jYXRpb25NZ3J+TG9jYXRpb25NZ3JcclxuICogQGZpcmVzIG1vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yI2dlb2NvZGVkXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNnZW9sb2NhdGVkXHJcbiAqL1xuY2xhc3MgTG9jYXRpb25NZ3IgZXh0ZW5kcyBfTG9jYXRpb25NZ3IuZGVmYXVsdCB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBMb2NhdGlvbk1nclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvb2wvTG9jYXRpb25NZ3J+TG9jYXRpb25NZ3IuT3B0aW9uc30gb3B0aW9ucyBDb25zdHJ1Y3RvciBvcHRpb25zXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYXAgPSBvcHRpb25zLm1hcDtcbiAgICBsZXQgc2VhcmNoVGFyZ2V0O1xuXG4gICAgaWYgKG9wdGlvbnMuc2VhcmNoVGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlYXJjaFRhcmdldCA9IG9wdGlvbnMuc2VhcmNoVGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWFyY2hUYXJnZXQgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KShtYXAuZ2V0VGFyZ2V0RWxlbWVudCgpKS5maW5kKCcub2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBnZW9jb2RlciA9IG9wdGlvbnMuZ2VvY29kZXIgfHwgbmV3IF9HZW9jbGllbnQuZGVmYXVsdCh7XG4gICAgICB1cmw6IG9wdGlvbnMudXJsXG4gICAgfSk7XG4gICAgc3VwZXIoe1xuICAgICAgc2VhcmNoOiBuZXcgX1NlYXJjaC5kZWZhdWx0KHNlYXJjaFRhcmdldCksXG4gICAgICB6b29tOiBuZXcgX1pvb20uZGVmYXVsdChtYXApLFxuICAgICAgZGlhbG9nVGFyZ2V0OiBvcHRpb25zLmRpYWxvZ1RhcmdldCxcbiAgICAgIGdlb2xvY2F0ZTogbmV3IF9HZW9sb2NhdGUuZGVmYXVsdChtYXApLFxuICAgICAgbG9jYXRvcjogbmV3IF9Mb2NhdG9yLmRlZmF1bHQoe1xuICAgICAgICBnZW9jb2RlcjogZ2VvY29kZXJcbiAgICAgIH0pLFxuICAgICAgbWFwTG9jYXRvcjogbmV3IF9NYXBMb2NhdG9yLmRlZmF1bHQoe1xuICAgICAgICBtYXA6IG1hcFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcclxuICogQGRlc2MgQ29uc3RydWN0b3Igb3B0aW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpueWMvb2wvTG9jYXRpb25NZ3J+TG9jYXRpb25NZ3J9XHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtvbC5NYXB9IG1hcCBUaGUgbWFwXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdXJsIFRoZSBnZW9jbGllbnQgVVJMIGlmIGdlb2NvZGVyIGlzIG5vdCBwcm92aWRlZFxyXG4gKiBAcHJvcGVydHkge21vZHVsZTpueWMvR2VvY29kZXJ+R2VvY29kZXI9fSBnZW9jb2RlciBUaGUgZ2VvY29kZXIgaWYgZ2VvY2xpZW50IFVSTCBpcyBub3QgcHJvdmlkZWRcclxuICogQHByb3BlcnR5IHtqUXVlcnl8RWxlbWVudHxzdHJpbmc9fSBzZWFyY2hUYXJnZXQgVGhlIERPTSB0YXJnZXQgZm9yIHRoZSBzZWFyY2ggYm94XHJcbiAqIEBwcm9wZXJ0eSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSBbZGlhbG9nVGFyZ2V0PWJvZHldIFRoZSBET00gdGFyZ2V0IGluIHdoaWNoIHRvIGRpc3BsYXkgZXJyb3IgZGlhbG9nXHJcbiAqL1xuXG5cbkxvY2F0aW9uTWdyLk9wdGlvbnM7XG52YXIgX2RlZmF1bHQgPSBMb2NhdGlvbk1ncjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBSUE7Ozs7Ozs7Ozs7QUFRQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBVkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQVJBO0FBWUE7QUFDQTs7QUFqQ0E7QUFtQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///110\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _EventHandling = _interopRequireDefault(__webpack_require__(64));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/Geocoder\r\n */\n\n/**\r\n * @desc A class for geocoding\r\n * @public\r\n * @abstract\r\n * @class\r\n * @extends {module:nyc/EventHandling~EventHandling}\r\n */\n\n\nvar Geocoder =\n/*#__PURE__*/\nfunction (_EventHandling$defaul) {\n  _inherits(Geocoder, _EventHandling$defaul);\n\n  /**\r\n   * @desc Create an instance of Geocoder\r\n   * @public\r\n   * @constructor\r\n   */\n  function Geocoder() {\n    _classCallCheck(this, Geocoder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Geocoder).call(this));\n  }\n  /**\r\n   * @desc Search for a location\r\n   * @public\r\n   * @abstract\r\n   * @method\r\n   * @param {string} input Input\r\n   * @returns {Promise<Object>} The result of the search request\r\n   */\n\n\n  _createClass(Geocoder, [{\n    key: "search",\n    value: function search(input) {\n      throw \'Not implemented\';\n    }\n  }]);\n\n  return Geocoder;\n}(_EventHandling["default"]);\n\nvar _default = Geocoder;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0dlb2NvZGVyLmpzP2MyNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfRXZlbnRIYW5kbGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRXZlbnRIYW5kbGluZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9HZW9jb2RlclxyXG4gKi9cblxuLyoqXHJcbiAqIEBkZXNjIEEgY2xhc3MgZm9yIGdlb2NvZGluZ1xyXG4gKiBAcHVibGljXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMge21vZHVsZTpueWMvRXZlbnRIYW5kbGluZ35FdmVudEhhbmRsaW5nfVxyXG4gKi9cbmNsYXNzIEdlb2NvZGVyIGV4dGVuZHMgX0V2ZW50SGFuZGxpbmcuZGVmYXVsdCB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBHZW9jb2RlclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBTZWFyY2ggZm9yIGEgbG9jYXRpb25cclxuICAgKiBAcHVibGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBJbnB1dFxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSByZXN1bHQgb2YgdGhlIHNlYXJjaCByZXF1ZXN0XHJcbiAgICovXG5cblxuICBzZWFyY2goaW5wdXQpIHtcbiAgICB0aHJvdyAnTm90IGltcGxlbWVudGVkJztcbiAgfVxuXG59XG5cbnZhciBfZGVmYXVsdCA9IEdlb2NvZGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7O0FBT0E7Ozs7O0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7Ozs7QUFyQkE7QUFDQTtBQXdCQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///111\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "register", function() { return register; });\n/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n/* harmony import */ var _transforms_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50);\n/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60);\n/**\n * @module ol/proj/proj4\n */\n\n\n\n/**\n * Make projections defined in proj4 (with `proj4.defs()`) available in\n * OpenLayers.\n *\n * This function should be called whenever changes are made to the proj4\n * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be\n * modified by this function.\n *\n * @param {?} proj4 Proj4.\n * @api\n */\n\nfunction register(proj4) {\n  var projCodes = Object.keys(proj4.defs);\n  var len = projCodes.length;\n  var i, j;\n\n  for (i = 0; i < len; ++i) {\n    var code = projCodes[i];\n\n    if (!Object(_proj_js__WEBPACK_IMPORTED_MODULE_0__["get"])(code)) {\n      var def = proj4.defs(code);\n      Object(_proj_js__WEBPACK_IMPORTED_MODULE_0__["addProjection"])(new _Projection_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({\n        code: code,\n        axisOrientation: def.axis,\n        metersPerUnit: def.to_meter,\n        units: def.units\n      }));\n    }\n  }\n\n  for (i = 0; i < len; ++i) {\n    var code1 = projCodes[i];\n    var proj1 = Object(_proj_js__WEBPACK_IMPORTED_MODULE_0__["get"])(code1);\n\n    for (j = 0; j < len; ++j) {\n      var code2 = projCodes[j];\n      var proj2 = Object(_proj_js__WEBPACK_IMPORTED_MODULE_0__["get"])(code2);\n\n      if (!Object(_transforms_js__WEBPACK_IMPORTED_MODULE_1__[/* get */ "c"])(code1, code2)) {\n        if (proj4.defs[code1] === proj4.defs[code2]) {\n          Object(_proj_js__WEBPACK_IMPORTED_MODULE_0__["addEquivalentProjections"])([proj1, proj2]);\n        } else {\n          var transform = proj4(code1, code2);\n          Object(_proj_js__WEBPACK_IMPORTED_MODULE_0__["addCoordinateTransforms"])(proj1, proj2, transform.forward, transform.inverse);\n        }\n      }\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9wcm9qL3Byb2o0LmpzP2UyMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL3Byb2ovcHJvajRcbiAqL1xuaW1wb3J0IHthZGRDb29yZGluYXRlVHJhbnNmb3JtcywgYWRkUHJvamVjdGlvbiwgYWRkRXF1aXZhbGVudFByb2plY3Rpb25zLCBnZXR9IGZyb20gJy4uL3Byb2ouanMnO1xuaW1wb3J0IHtnZXQgYXMgZ2V0VHJhbnNmb3JtfSBmcm9tICcuL3RyYW5zZm9ybXMuanMnO1xuaW1wb3J0IFByb2plY3Rpb24gZnJvbSAnLi9Qcm9qZWN0aW9uLmpzJztcblxuLyoqXG4gKiBNYWtlIHByb2plY3Rpb25zIGRlZmluZWQgaW4gcHJvajQgKHdpdGggYHByb2o0LmRlZnMoKWApIGF2YWlsYWJsZSBpblxuICogT3BlbkxheWVycy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgY2hhbmdlcyBhcmUgbWFkZSB0byB0aGUgcHJvajRcbiAqIHJlZ2lzdHJ5LCBlLmcuIGFmdGVyIGNhbGxpbmcgYHByb2o0LmRlZnMoKWAuIEV4aXN0aW5nIHRyYW5zZm9ybXMgd2lsbCBub3QgYmVcbiAqIG1vZGlmaWVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHs/fSBwcm9qNCBQcm9qNC5cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHByb2o0KSB7XG4gIGNvbnN0IHByb2pDb2RlcyA9IE9iamVjdC5rZXlzKHByb2o0LmRlZnMpO1xuICBjb25zdCBsZW4gPSBwcm9qQ29kZXMubGVuZ3RoO1xuICBsZXQgaSwgajtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHByb2pDb2Rlc1tpXTtcbiAgICBpZiAoIWdldChjb2RlKSkge1xuICAgICAgY29uc3QgZGVmID0gcHJvajQuZGVmcyhjb2RlKTtcbiAgICAgIGFkZFByb2plY3Rpb24obmV3IFByb2plY3Rpb24oe1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBheGlzT3JpZW50YXRpb246IGRlZi5heGlzLFxuICAgICAgICBtZXRlcnNQZXJVbml0OiBkZWYudG9fbWV0ZXIsXG4gICAgICAgIHVuaXRzOiBkZWYudW5pdHNcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgY29kZTEgPSBwcm9qQ29kZXNbaV07XG4gICAgY29uc3QgcHJvajEgPSBnZXQoY29kZTEpO1xuICAgIGZvciAoaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgY29uc3QgY29kZTIgPSBwcm9qQ29kZXNbal07XG4gICAgICBjb25zdCBwcm9qMiA9IGdldChjb2RlMik7XG4gICAgICBpZiAoIWdldFRyYW5zZm9ybShjb2RlMSwgY29kZTIpKSB7XG4gICAgICAgIGlmIChwcm9qNC5kZWZzW2NvZGUxXSA9PT0gcHJvajQuZGVmc1tjb2RlMl0pIHtcbiAgICAgICAgICBhZGRFcXVpdmFsZW50UHJvamVjdGlvbnMoW3Byb2oxLCBwcm9qMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHByb2o0KGNvZGUxLCBjb2RlMik7XG4gICAgICAgICAgYWRkQ29vcmRpbmF0ZVRyYW5zZm9ybXMocHJvajEsIHByb2oyLCB0cmFuc2Zvcm0uZm9yd2FyZCwgdHJhbnNmb3JtLmludmVyc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///112\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Container = _interopRequireDefault(__webpack_require__(69));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\r\n * @module nyc/Dialog\r\n */\n\n/**\r\n * @desc Class for alert, yes/no and input dialogs\r\n * @public\r\n * @class\r\n * @extends module:nyc/Container~Container\r\n */\n\n\nvar Dialog =\n/*#__PURE__*/\nfunction (_Container$default) {\n  _inherits(Dialog, _Container$default);\n\n  /**\r\n   * @desc Create an instance of Dialog\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/Dialog~Dialog.Options} options Constructor options\r\n   */\n  function Dialog(options) {\n    var _this;\n\n    _classCallCheck(this, Dialog);\n\n    options = options || {};\n    options.target = options.target || 'body';\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Dialog).call(this, (0, _jquery[\"default\"])(Dialog.HTML)));\n    (0, _jquery[\"default\"])(options.target).append(_this.getContainer().addClass(options.css));\n    /**\r\n     * @private\r\n     * @member {boolean}\r\n     */\n\n    _this.open = false;\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.okBtn = _this.find('.btn-ok');\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.yesNoBtns = _this.find('.btn-yes, .btn-no');\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.inputBtns = _this.find('.btn-submit, .btn-cancel');\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.field = _this.find('input');\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.msg = _this.find('.dia-msg');\n    return _this;\n  }\n  /**\r\n   * @desc Show the ok dialog\r\n   * @public\r\n   * @method\r\n   * @param {module:nyc/Dialog~Dialog.ShowOptions} options Dialog options\r\n   * @return {Promise<boolean>} The async result of the user action\r\n   */\n\n\n  _createClass(Dialog, [{\n    key: \"ok\",\n    value: function ok(options) {\n      this.buttons(Dialog.Type.OK, options);\n      this.show(Dialog.Type.OK, options);\n      this.okBtn.focus();\n      var dia = this;\n      var ok = this.okBtn;\n      return new Promise(function (resolve) {\n        ok.one('click', function (event) {\n          dia.checkHref(event);\n          dia.hide();\n          resolve(true);\n        });\n      });\n    }\n    /**\r\n     * @desc Show the input dialog\r\n     * @public\r\n     * @method\r\n     * @param {module:nyc/Dialog~Dialog.ShowOptions} options Dialog options\r\n     * @return {Promise<string|boolean|undefined>} The async result of the user action\r\n     */\n\n  }, {\n    key: \"input\",\n    value: function input(options) {\n      var field = this.field;\n      this.buttons(Dialog.Type.INPUT, options);\n      field.attr('placeholder', options.placeholder || '');\n      this.show(Dialog.Type.INPUT, options);\n      field.focus();\n      var dia = this;\n      var input = this.inputBtns;\n      return new Promise(function (resolve) {\n        var keyup = function keyup(event) {\n          dia.hndlKey(resolve, dia, event);\n        };\n\n        (0, _jquery[\"default\"])(document).keyup(keyup);\n        input.one('click', function (event) {\n          var cancel = (0, _jquery[\"default\"])(event.target).hasClass('btn-cancel');\n          (0, _jquery[\"default\"])(document).off('keyup', keyup);\n          dia.hide();\n          resolve(cancel ? undefined : field.val());\n        });\n      });\n    }\n    /**\r\n     * @desc Show the yes-no dialog\r\n     * @public\r\n     * @method\r\n     * @param {module:nyc/Dialog~Dialog.ShowOptions} options Dialog options\r\n     * @return {Promise<boolean>} The async result of the user action\r\n     */\n\n  }, {\n    key: \"yesNo\",\n    value: function yesNo(options) {\n      this.buttons(Dialog.Type.YES_NO, options);\n      this.show(Dialog.Type.YES_NO, options);\n      this.find('.btn-yes').focus();\n      var dia = this;\n      var yesNo = this.yesNoBtns;\n      return new Promise(function (resolve) {\n        yesNo.one('click', function (event) {\n          dia.checkHref(event);\n          dia.hide();\n          resolve(dia.isYesBtn(event.target));\n        });\n      });\n    }\n    /**\r\n     * @desc Show the yes-no-cancel dialog\r\n     * @public\r\n     * @method\r\n     * @param {module:nyc/Dialog~Dialog.ShowOptions} options Dialog options\r\n     * @return {Promise<boolean|undefined>} The async result of the user action\r\n     */\n\n  }, {\n    key: \"yesNoCancel\",\n    value: function yesNoCancel(options) {\n      this.buttons(Dialog.Type.YES_NO_CANCEL, options);\n      this.show(Dialog.Type.YES_NO_CANCEL, options);\n      this.find('.btn-yes').focus();\n      var dia = this;\n      var yesNo = this.yesNoBtns;\n      var cancel = this.find('.btn-cancel');\n      return new Promise(function (resolve) {\n        var keyup = function keyup(event) {\n          dia.hndlKey(resolve, dia, event);\n        };\n\n        (0, _jquery[\"default\"])(document).keyup(keyup);\n        yesNo.one('click', function (event) {\n          dia.checkHref(event);\n          (0, _jquery[\"default\"])(document).off('keyup', keyup);\n          dia.hide();\n          resolve(dia.isYesBtn(event.target));\n        });\n        cancel.one('click', function (event) {\n          dia.checkHref(event);\n          (0, _jquery[\"default\"])(document).off('keyup', keyup);\n          dia.hide();\n          resolve(undefined);\n        });\n      });\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Element} target The clicked element\r\n     * @returns {boolean} The button is/isn't the yes button\r\n     */\n\n  }, {\n    key: \"isYesBtn\",\n    value: function isYesBtn(target) {\n      return (0, _jquery[\"default\"])(target).hasClass('btn-yes') || _jquery[\"default\"].contains(this.find('.btn-yes').get(0), target);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: \"checkHref\",\n    value: function checkHref(event) {\n      if ((0, _jquery[\"default\"])(event.target).attr('href') === '#') {\n        event.preventDefault();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {module:nyc/Dialog~Dialog.Type} type Type of button\r\n     * @param {Object} options Button options (texts and hyperlinks)\r\n     */\n\n  }, {\n    key: \"buttons\",\n    value: function buttons(type, options) {\n      var buttonText = options.buttonText || [];\n      var buttonHref = options.buttonHref || [];\n\n      switch (type) {\n        case Dialog.Type.OK:\n          this.find('.btn-ok').html(buttonText[0] || 'OK').attr('href', buttonHref[0] || '#');\n          break;\n\n        case Dialog.Type.INPUT:\n          this.find('.btn-submit').html(buttonText[0] || 'Submit').attr('href', buttonHref[0] || '#');\n          this.find('.btn-cancel').html(buttonText[1] || 'Cancel').attr('href', buttonHref[1] || '#');\n          break;\n\n        case Dialog.Type.YES_NO:\n          this.find('.btn-yes').html(buttonText[0] || 'Yes').attr('href', buttonHref[0] || '#');\n          this.find('.btn-no').html(buttonText[1] || 'No').attr('href', buttonHref[1] || '#');\n          break;\n\n        case Dialog.Type.YES_NO_CANCEL:\n          this.find('.btn-yes').html(buttonText[0] || 'Yes').attr('href', buttonHref[0] || '#');\n          this.find('.btn-no').html(buttonText[1] || 'No').attr('href', buttonHref[1] || '#');\n          this.find('.btn-cancel').html(buttonText[2] || 'Cancel').attr('href', buttonHref[2] || '#');\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {module:nyc/Dialog~Dialog.Type} type Type of dialog\r\n     * @param {module:nyc/Dialog~Dialog.ShowOptions} options Dialog options\r\n     */\n\n  }, {\n    key: \"show\",\n    value: function show(type, options) {\n      this.open = true;\n      (0, _jquery[\"default\"])('*').on('focus', _jquery[\"default\"].proxy(this.trapFocus, this));\n      this.currentType = type;\n      this.getContainer().removeClass('dia-3-btns');\n      this.find('.ui-link').removeClass('ui-link');\n      this.inputBtns.css('display', type === Dialog.Type.INPUT ? 'inline-block' : 'none');\n      this.field.css('display', type === Dialog.Type.INPUT ? 'block' : 'none');\n      this.okBtn.css('display', type === Dialog.Type.OK ? 'inline-block' : 'none');\n      this.yesNoBtns.css('display', type === Dialog.Type.YES_NO ? 'inline-block' : 'none');\n\n      if (type === Dialog.Type.YES_NO_CANCEL) {\n        this.getContainer().addClass('dia-3-btns');\n        this.yesNoBtns.css('display', 'inline-block');\n        this.find('.btn-cancel').css('display', 'inline-block');\n      }\n\n      var message;\n\n      try {\n        message = (0, _jquery[\"default\"])(options.message);\n      } catch (ignore) {\n        /* empty */\n      }\n\n      if (message && message.length) {\n        this.msg.html(message);\n      } else {\n        this.msg.html(options.message);\n      }\n\n      this.getContainer().fadeIn();\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: \"trapFocus\",\n    value: function trapFocus(event) {\n      var container = this.getContainer();\n\n      if (this.open && !_jquery[\"default\"].contains(container.get(0), event.target)) {\n        this.find('.btn:visible').first().focus();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var field = this.field;\n      this.open = false;\n      (0, _jquery[\"default\"])('*').off('focus', _jquery[\"default\"].proxy(this.trapFocus, this));\n      this.getContainer().fadeOut(function () {\n        field.val('');\n      });\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {function()} resolve Resolve function\r\n     * @param {module:nyc/Dialog~Dialog} dia Dialog instance\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: \"hndlKey\",\n    value: function hndlKey(resolve, dia, event) {\n      if (event.keyCode === 13 && (0, _jquery[\"default\"])(event.target).get(0) === dia.field.get(0)) {\n        dia.hide();\n        resolve(dia.field.val());\n      } else if (event.keyCode === 27) {\n        dia.hide();\n        resolve(undefined);\n      }\n    }\n  }]);\n\n  return Dialog;\n}(_Container[\"default\"]);\n/**\r\n * @desc Dialog type\r\n * @public\r\n * @enum {string}\r\n */\n\n\nDialog.Type = {\n  /**\r\n   * @desc Dialog with OK button\r\n   */\n  OK: 'ok',\n\n  /**\r\n   * @desc Dialog with Yes and No buttons\r\n   */\n  YES_NO: 'yes-no',\n\n  /**\r\n   * @desc Dialog with Yes, No and Cancel buttons\r\n   */\n  YES_NO_CANCEL: 'yes-no-cancel',\n\n  /**\r\n   * @desc Dialog to accept user input\r\n   */\n  INPUT: 'input'\n  /**\r\n   * @desc Dialog options.\r\n   * @public\r\n   * @typedef {Object}\r\n   * @property {jQuery|Element|string} [target=body] The DOM element in which the dialog is displayed\r\n   * @property {string=} css A CSS class for the dialog\r\n   */\n\n};\nDialog.Options;\n/**\r\n * @desc Dialog options.\r\n * @public\r\n * @typedef {Object}\r\n * @property {jQuery|Element|string} message Message content\r\n * @property {Array<string>=} buttonText Button text list\r\n * @property {Array<string>=} buttonHref Button href list\r\n * @property {string=} placeholder Placeholder text for input dialog\r\n */\n\nDialog.ShowOptions;\n/**\r\n * @private\r\n * @const\r\n * @type {string}\r\n */\n\nDialog.HTML = '<div class=\"dia-container\" role=\"dialog\">' + '<div class=\"dia\">' + '<div class=\"dia-msg\"></div>' + '<input class=\"rad-all\">' + '<div class=\"dia-btns\">' + '<a class=\"btn rad-all btn-ok\">OK</a>' + '<a class=\"btn rad-all btn-yes\">Yes</a>' + '<a class=\"btn rad-all btn-no\">No</a>' + '<a class=\"btn rad-all btn-submit\">OK</a>' + '<a class=\"btn rad-all btn-cancel\">Cancel</a>' + '</div>' + '</div>' + '</div>';\nvar _default = Dialog;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0RpYWxvZy5qcz9jZTBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbnZhciBfQ29udGFpbmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9Db250YWluZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogQG1vZHVsZSBueWMvRGlhbG9nXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQ2xhc3MgZm9yIGFsZXJ0LCB5ZXMvbm8gYW5kIGlucHV0IGRpYWxvZ3NcclxuICogQHB1YmxpY1xyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgbW9kdWxlOm55Yy9Db250YWluZXJ+Q29udGFpbmVyXHJcbiAqL1xuY2xhc3MgRGlhbG9nIGV4dGVuZHMgX0NvbnRhaW5lci5kZWZhdWx0IHtcbiAgLyoqXHJcbiAgICogQGRlc2MgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIERpYWxvZ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvRGlhbG9nfkRpYWxvZy5PcHRpb25zfSBvcHRpb25zIENvbnN0cnVjdG9yIG9wdGlvbnNcclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgfHwgJ2JvZHknO1xuICAgIHN1cGVyKCgwLCBfanF1ZXJ5LmRlZmF1bHQpKERpYWxvZy5IVE1MKSk7XG4gICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkob3B0aW9ucy50YXJnZXQpLmFwcGVuZCh0aGlzLmdldENvbnRhaW5lcigpLmFkZENsYXNzKG9wdGlvbnMuY3NzKSk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7alF1ZXJ5fVxyXG4gICAgICovXG5cbiAgICB0aGlzLm9rQnRuID0gdGhpcy5maW5kKCcuYnRuLW9rJyk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7alF1ZXJ5fVxyXG4gICAgICovXG5cbiAgICB0aGlzLnllc05vQnRucyA9IHRoaXMuZmluZCgnLmJ0bi15ZXMsIC5idG4tbm8nKTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtqUXVlcnl9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuaW5wdXRCdG5zID0gdGhpcy5maW5kKCcuYnRuLXN1Ym1pdCwgLmJ0bi1jYW5jZWwnKTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtqUXVlcnl9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuZmllbGQgPSB0aGlzLmZpbmQoJ2lucHV0Jyk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7alF1ZXJ5fVxyXG4gICAgICovXG5cbiAgICB0aGlzLm1zZyA9IHRoaXMuZmluZCgnLmRpYS1tc2cnKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBTaG93IHRoZSBvayBkaWFsb2dcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9EaWFsb2d+RGlhbG9nLlNob3dPcHRpb25zfSBvcHRpb25zIERpYWxvZyBvcHRpb25zXHJcbiAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn0gVGhlIGFzeW5jIHJlc3VsdCBvZiB0aGUgdXNlciBhY3Rpb25cclxuICAgKi9cblxuXG4gIG9rKG9wdGlvbnMpIHtcbiAgICB0aGlzLmJ1dHRvbnMoRGlhbG9nLlR5cGUuT0ssIG9wdGlvbnMpO1xuICAgIHRoaXMuc2hvdyhEaWFsb2cuVHlwZS5PSywgb3B0aW9ucyk7XG4gICAgdGhpcy5va0J0bi5mb2N1cygpO1xuICAgIGNvbnN0IGRpYSA9IHRoaXM7XG4gICAgY29uc3Qgb2sgPSB0aGlzLm9rQnRuO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIG9rLm9uZSgnY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIGRpYS5jaGVja0hyZWYoZXZlbnQpO1xuICAgICAgICBkaWEuaGlkZSgpO1xuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgU2hvdyB0aGUgaW5wdXQgZGlhbG9nXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvRGlhbG9nfkRpYWxvZy5TaG93T3B0aW9uc30gb3B0aW9ucyBEaWFsb2cgb3B0aW9uc1xyXG4gICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nfGJvb2xlYW58dW5kZWZpbmVkPn0gVGhlIGFzeW5jIHJlc3VsdCBvZiB0aGUgdXNlciBhY3Rpb25cclxuICAgKi9cblxuXG4gIGlucHV0KG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaWVsZCA9IHRoaXMuZmllbGQ7XG4gICAgdGhpcy5idXR0b25zKERpYWxvZy5UeXBlLklOUFVULCBvcHRpb25zKTtcbiAgICBmaWVsZC5hdHRyKCdwbGFjZWhvbGRlcicsIG9wdGlvbnMucGxhY2Vob2xkZXIgfHwgJycpO1xuICAgIHRoaXMuc2hvdyhEaWFsb2cuVHlwZS5JTlBVVCwgb3B0aW9ucyk7XG4gICAgZmllbGQuZm9jdXMoKTtcbiAgICBjb25zdCBkaWEgPSB0aGlzO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dEJ0bnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3Qga2V5dXAgPSBldmVudCA9PiB7XG4gICAgICAgIGRpYS5obmRsS2V5KHJlc29sdmUsIGRpYSwgZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoZG9jdW1lbnQpLmtleXVwKGtleXVwKTtcbiAgICAgIGlucHV0Lm9uZSgnY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGV2ZW50LnRhcmdldCkuaGFzQ2xhc3MoJ2J0bi1jYW5jZWwnKTtcbiAgICAgICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoZG9jdW1lbnQpLm9mZigna2V5dXAnLCBrZXl1cCk7XG4gICAgICAgIGRpYS5oaWRlKCk7XG4gICAgICAgIHJlc29sdmUoY2FuY2VsID8gdW5kZWZpbmVkIDogZmllbGQudmFsKCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgU2hvdyB0aGUgeWVzLW5vIGRpYWxvZ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0RpYWxvZ35EaWFsb2cuU2hvd09wdGlvbnN9IG9wdGlvbnMgRGlhbG9nIG9wdGlvbnNcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSBUaGUgYXN5bmMgcmVzdWx0IG9mIHRoZSB1c2VyIGFjdGlvblxyXG4gICAqL1xuXG5cbiAgeWVzTm8ob3B0aW9ucykge1xuICAgIHRoaXMuYnV0dG9ucyhEaWFsb2cuVHlwZS5ZRVNfTk8sIG9wdGlvbnMpO1xuICAgIHRoaXMuc2hvdyhEaWFsb2cuVHlwZS5ZRVNfTk8sIG9wdGlvbnMpO1xuICAgIHRoaXMuZmluZCgnLmJ0bi15ZXMnKS5mb2N1cygpO1xuICAgIGNvbnN0IGRpYSA9IHRoaXM7XG4gICAgY29uc3QgeWVzTm8gPSB0aGlzLnllc05vQnRucztcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB5ZXNOby5vbmUoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICBkaWEuY2hlY2tIcmVmKGV2ZW50KTtcbiAgICAgICAgZGlhLmhpZGUoKTtcbiAgICAgICAgcmVzb2x2ZShkaWEuaXNZZXNCdG4oZXZlbnQudGFyZ2V0KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBTaG93IHRoZSB5ZXMtbm8tY2FuY2VsIGRpYWxvZ1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0RpYWxvZ35EaWFsb2cuU2hvd09wdGlvbnN9IG9wdGlvbnMgRGlhbG9nIG9wdGlvbnNcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW58dW5kZWZpbmVkPn0gVGhlIGFzeW5jIHJlc3VsdCBvZiB0aGUgdXNlciBhY3Rpb25cclxuICAgKi9cblxuXG4gIHllc05vQ2FuY2VsKG9wdGlvbnMpIHtcbiAgICB0aGlzLmJ1dHRvbnMoRGlhbG9nLlR5cGUuWUVTX05PX0NBTkNFTCwgb3B0aW9ucyk7XG4gICAgdGhpcy5zaG93KERpYWxvZy5UeXBlLllFU19OT19DQU5DRUwsIG9wdGlvbnMpO1xuICAgIHRoaXMuZmluZCgnLmJ0bi15ZXMnKS5mb2N1cygpO1xuICAgIGNvbnN0IGRpYSA9IHRoaXM7XG4gICAgY29uc3QgeWVzTm8gPSB0aGlzLnllc05vQnRucztcbiAgICBjb25zdCBjYW5jZWwgPSB0aGlzLmZpbmQoJy5idG4tY2FuY2VsJyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3Qga2V5dXAgPSBldmVudCA9PiB7XG4gICAgICAgIGRpYS5obmRsS2V5KHJlc29sdmUsIGRpYSwgZXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoZG9jdW1lbnQpLmtleXVwKGtleXVwKTtcbiAgICAgIHllc05vLm9uZSgnY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIGRpYS5jaGVja0hyZWYoZXZlbnQpO1xuICAgICAgICAoMCwgX2pxdWVyeS5kZWZhdWx0KShkb2N1bWVudCkub2ZmKCdrZXl1cCcsIGtleXVwKTtcbiAgICAgICAgZGlhLmhpZGUoKTtcbiAgICAgICAgcmVzb2x2ZShkaWEuaXNZZXNCdG4oZXZlbnQudGFyZ2V0KSk7XG4gICAgICB9KTtcbiAgICAgIGNhbmNlbC5vbmUoJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICBkaWEuY2hlY2tIcmVmKGV2ZW50KTtcbiAgICAgICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoZG9jdW1lbnQpLm9mZigna2V5dXAnLCBrZXl1cCk7XG4gICAgICAgIGRpYS5oaWRlKCk7XG4gICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IFRoZSBjbGlja2VkIGVsZW1lbnRcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGJ1dHRvbiBpcy9pc24ndCB0aGUgeWVzIGJ1dHRvblxyXG4gICAqL1xuXG5cbiAgaXNZZXNCdG4odGFyZ2V0KSB7XG4gICAgcmV0dXJuICgwLCBfanF1ZXJ5LmRlZmF1bHQpKHRhcmdldCkuaGFzQ2xhc3MoJ2J0bi15ZXMnKSB8fCBfanF1ZXJ5LmRlZmF1bHQuY29udGFpbnModGhpcy5maW5kKCcuYnRuLXllcycpLmdldCgwKSwgdGFyZ2V0KTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XHJcbiAgICovXG5cblxuICBjaGVja0hyZWYoZXZlbnQpIHtcbiAgICBpZiAoKDAsIF9qcXVlcnkuZGVmYXVsdCkoZXZlbnQudGFyZ2V0KS5hdHRyKCdocmVmJykgPT09ICcjJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0RpYWxvZ35EaWFsb2cuVHlwZX0gdHlwZSBUeXBlIG9mIGJ1dHRvblxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEJ1dHRvbiBvcHRpb25zICh0ZXh0cyBhbmQgaHlwZXJsaW5rcylcclxuICAgKi9cblxuXG4gIGJ1dHRvbnModHlwZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1dHRvblRleHQgPSBvcHRpb25zLmJ1dHRvblRleHQgfHwgW107XG4gICAgY29uc3QgYnV0dG9uSHJlZiA9IG9wdGlvbnMuYnV0dG9uSHJlZiB8fCBbXTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBEaWFsb2cuVHlwZS5PSzpcbiAgICAgICAgdGhpcy5maW5kKCcuYnRuLW9rJykuaHRtbChidXR0b25UZXh0WzBdIHx8ICdPSycpLmF0dHIoJ2hyZWYnLCBidXR0b25IcmVmWzBdIHx8ICcjJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERpYWxvZy5UeXBlLklOUFVUOlxuICAgICAgICB0aGlzLmZpbmQoJy5idG4tc3VibWl0JykuaHRtbChidXR0b25UZXh0WzBdIHx8ICdTdWJtaXQnKS5hdHRyKCdocmVmJywgYnV0dG9uSHJlZlswXSB8fCAnIycpO1xuICAgICAgICB0aGlzLmZpbmQoJy5idG4tY2FuY2VsJykuaHRtbChidXR0b25UZXh0WzFdIHx8ICdDYW5jZWwnKS5hdHRyKCdocmVmJywgYnV0dG9uSHJlZlsxXSB8fCAnIycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEaWFsb2cuVHlwZS5ZRVNfTk86XG4gICAgICAgIHRoaXMuZmluZCgnLmJ0bi15ZXMnKS5odG1sKGJ1dHRvblRleHRbMF0gfHwgJ1llcycpLmF0dHIoJ2hyZWYnLCBidXR0b25IcmVmWzBdIHx8ICcjJyk7XG4gICAgICAgIHRoaXMuZmluZCgnLmJ0bi1ubycpLmh0bWwoYnV0dG9uVGV4dFsxXSB8fCAnTm8nKS5hdHRyKCdocmVmJywgYnV0dG9uSHJlZlsxXSB8fCAnIycpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEaWFsb2cuVHlwZS5ZRVNfTk9fQ0FOQ0VMOlxuICAgICAgICB0aGlzLmZpbmQoJy5idG4teWVzJykuaHRtbChidXR0b25UZXh0WzBdIHx8ICdZZXMnKS5hdHRyKCdocmVmJywgYnV0dG9uSHJlZlswXSB8fCAnIycpO1xuICAgICAgICB0aGlzLmZpbmQoJy5idG4tbm8nKS5odG1sKGJ1dHRvblRleHRbMV0gfHwgJ05vJykuYXR0cignaHJlZicsIGJ1dHRvbkhyZWZbMV0gfHwgJyMnKTtcbiAgICAgICAgdGhpcy5maW5kKCcuYnRuLWNhbmNlbCcpLmh0bWwoYnV0dG9uVGV4dFsyXSB8fCAnQ2FuY2VsJykuYXR0cignaHJlZicsIGJ1dHRvbkhyZWZbMl0gfHwgJyMnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvRGlhbG9nfkRpYWxvZy5UeXBlfSB0eXBlIFR5cGUgb2YgZGlhbG9nXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0RpYWxvZ35EaWFsb2cuU2hvd09wdGlvbnN9IG9wdGlvbnMgRGlhbG9nIG9wdGlvbnNcclxuICAgKi9cblxuXG4gIHNob3codHlwZSwgb3B0aW9ucykge1xuICAgIHRoaXMub3BlbiA9IHRydWU7XG4gICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoJyonKS5vbignZm9jdXMnLCBfanF1ZXJ5LmRlZmF1bHQucHJveHkodGhpcy50cmFwRm9jdXMsIHRoaXMpKTtcbiAgICB0aGlzLmN1cnJlbnRUeXBlID0gdHlwZTtcbiAgICB0aGlzLmdldENvbnRhaW5lcigpLnJlbW92ZUNsYXNzKCdkaWEtMy1idG5zJyk7XG4gICAgdGhpcy5maW5kKCcudWktbGluaycpLnJlbW92ZUNsYXNzKCd1aS1saW5rJyk7XG4gICAgdGhpcy5pbnB1dEJ0bnMuY3NzKCdkaXNwbGF5JywgdHlwZSA9PT0gRGlhbG9nLlR5cGUuSU5QVVQgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJyk7XG4gICAgdGhpcy5maWVsZC5jc3MoJ2Rpc3BsYXknLCB0eXBlID09PSBEaWFsb2cuVHlwZS5JTlBVVCA/ICdibG9jaycgOiAnbm9uZScpO1xuICAgIHRoaXMub2tCdG4uY3NzKCdkaXNwbGF5JywgdHlwZSA9PT0gRGlhbG9nLlR5cGUuT0sgPyAnaW5saW5lLWJsb2NrJyA6ICdub25lJyk7XG4gICAgdGhpcy55ZXNOb0J0bnMuY3NzKCdkaXNwbGF5JywgdHlwZSA9PT0gRGlhbG9nLlR5cGUuWUVTX05PID8gJ2lubGluZS1ibG9jaycgOiAnbm9uZScpO1xuXG4gICAgaWYgKHR5cGUgPT09IERpYWxvZy5UeXBlLllFU19OT19DQU5DRUwpIHtcbiAgICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuYWRkQ2xhc3MoJ2RpYS0zLWJ0bnMnKTtcbiAgICAgIHRoaXMueWVzTm9CdG5zLmNzcygnZGlzcGxheScsICdpbmxpbmUtYmxvY2snKTtcbiAgICAgIHRoaXMuZmluZCgnLmJ0bi1jYW5jZWwnKS5jc3MoJ2Rpc3BsYXknLCAnaW5saW5lLWJsb2NrJyk7XG4gICAgfVxuXG4gICAgbGV0IG1lc3NhZ2U7XG5cbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAvKiBlbXB0eSAqL1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1zZy5odG1sKG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1zZy5odG1sKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRDb250YWluZXIoKS5mYWRlSW4oKTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XHJcbiAgICovXG5cblxuICB0cmFwRm9jdXMoZXZlbnQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuXG4gICAgaWYgKHRoaXMub3BlbiAmJiAhX2pxdWVyeS5kZWZhdWx0LmNvbnRhaW5zKGNvbnRhaW5lci5nZXQoMCksIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHRoaXMuZmluZCgnLmJ0bjp2aXNpYmxlJykuZmlyc3QoKS5mb2N1cygpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKi9cblxuXG4gIGhpZGUoKSB7XG4gICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkO1xuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKCcqJykub2ZmKCdmb2N1cycsIF9qcXVlcnkuZGVmYXVsdC5wcm94eSh0aGlzLnRyYXBGb2N1cywgdGhpcykpO1xuICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkuZmFkZU91dCgoKSA9PiB7XG4gICAgICBmaWVsZC52YWwoJycpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gcmVzb2x2ZSBSZXNvbHZlIGZ1bmN0aW9uXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0RpYWxvZ35EaWFsb2d9IGRpYSBEaWFsb2cgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XHJcbiAgICovXG5cblxuICBobmRsS2V5KHJlc29sdmUsIGRpYSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMgJiYgKDAsIF9qcXVlcnkuZGVmYXVsdCkoZXZlbnQudGFyZ2V0KS5nZXQoMCkgPT09IGRpYS5maWVsZC5nZXQoMCkpIHtcbiAgICAgIGRpYS5oaWRlKCk7XG4gICAgICByZXNvbHZlKGRpYS5maWVsZC52YWwoKSk7XG4gICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgZGlhLmhpZGUoKTtcbiAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cblxufVxuLyoqXHJcbiAqIEBkZXNjIERpYWxvZyB0eXBlXHJcbiAqIEBwdWJsaWNcclxuICogQGVudW0ge3N0cmluZ31cclxuICovXG5cblxuRGlhbG9nLlR5cGUgPSB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIERpYWxvZyB3aXRoIE9LIGJ1dHRvblxyXG4gICAqL1xuICBPSzogJ29rJyxcblxuICAvKipcclxuICAgKiBAZGVzYyBEaWFsb2cgd2l0aCBZZXMgYW5kIE5vIGJ1dHRvbnNcclxuICAgKi9cbiAgWUVTX05POiAneWVzLW5vJyxcblxuICAvKipcclxuICAgKiBAZGVzYyBEaWFsb2cgd2l0aCBZZXMsIE5vIGFuZCBDYW5jZWwgYnV0dG9uc1xyXG4gICAqL1xuICBZRVNfTk9fQ0FOQ0VMOiAneWVzLW5vLWNhbmNlbCcsXG5cbiAgLyoqXHJcbiAgICogQGRlc2MgRGlhbG9nIHRvIGFjY2VwdCB1c2VyIGlucHV0XHJcbiAgICovXG4gIElOUFVUOiAnaW5wdXQnXG4gIC8qKlxyXG4gICAqIEBkZXNjIERpYWxvZyBvcHRpb25zLlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fVxyXG4gICAqIEBwcm9wZXJ0eSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0PWJvZHldIFRoZSBET00gZWxlbWVudCBpbiB3aGljaCB0aGUgZGlhbG9nIGlzIGRpc3BsYXllZFxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gY3NzIEEgQ1NTIGNsYXNzIGZvciB0aGUgZGlhbG9nXHJcbiAgICovXG5cbn07XG5EaWFsb2cuT3B0aW9ucztcbi8qKlxyXG4gKiBAZGVzYyBEaWFsb2cgb3B0aW9ucy5cclxuICogQHB1YmxpY1xyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge2pRdWVyeXxFbGVtZW50fHN0cmluZ30gbWVzc2FnZSBNZXNzYWdlIGNvbnRlbnRcclxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+PX0gYnV0dG9uVGV4dCBCdXR0b24gdGV4dCBsaXN0XHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPj19IGJ1dHRvbkhyZWYgQnV0dG9uIGhyZWYgbGlzdFxyXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHBsYWNlaG9sZGVyIFBsYWNlaG9sZGVyIHRleHQgZm9yIGlucHV0IGRpYWxvZ1xyXG4gKi9cblxuRGlhbG9nLlNob3dPcHRpb25zO1xuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxuRGlhbG9nLkhUTUwgPSAnPGRpdiBjbGFzcz1cImRpYS1jb250YWluZXJcIiByb2xlPVwiZGlhbG9nXCI+JyArICc8ZGl2IGNsYXNzPVwiZGlhXCI+JyArICc8ZGl2IGNsYXNzPVwiZGlhLW1zZ1wiPjwvZGl2PicgKyAnPGlucHV0IGNsYXNzPVwicmFkLWFsbFwiPicgKyAnPGRpdiBjbGFzcz1cImRpYS1idG5zXCI+JyArICc8YSBjbGFzcz1cImJ0biByYWQtYWxsIGJ0bi1va1wiPk9LPC9hPicgKyAnPGEgY2xhc3M9XCJidG4gcmFkLWFsbCBidG4teWVzXCI+WWVzPC9hPicgKyAnPGEgY2xhc3M9XCJidG4gcmFkLWFsbCBidG4tbm9cIj5ObzwvYT4nICsgJzxhIGNsYXNzPVwiYnRuIHJhZC1hbGwgYnRuLXN1Ym1pdFwiPk9LPC9hPicgKyAnPGEgY2xhc3M9XCJidG4gcmFkLWFsbCBidG4tY2FuY2VsXCI+Q2FuY2VsPC9hPicgKyAnPC9kaXY+JyArICc8L2Rpdj4nICsgJzwvZGl2Pic7XG52YXIgX2RlZmF1bHQgPSBEaWFsb2c7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7QUFNQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBeENBO0FBeUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRCQTtBQXdCQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBcFRBO0FBdVRBOzs7Ozs7O0FBT0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7QUFwQkE7QUE2QkE7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///113\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/MapEventType.js\nvar MapEventType = __webpack_require__(76);\n\n// EXTERNAL MODULE: ./node_modules/ol/Object.js\nvar ol_Object = __webpack_require__(15);\n\n// CONCATENATED MODULE: ./node_modules/ol/OverlayPositioning.js\n/**\n * @module ol/OverlayPositioning\n */\n\n/**\n * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, `'top-right'`\n * @enum {string}\n */\n/* harmony default export */ var OverlayPositioning = ({\n  BOTTOM_LEFT: 'bottom-left',\n  BOTTOM_CENTER: 'bottom-center',\n  BOTTOM_RIGHT: 'bottom-right',\n  CENTER_LEFT: 'center-left',\n  CENTER_CENTER: 'center-center',\n  CENTER_RIGHT: 'center-right',\n  TOP_LEFT: 'top-left',\n  TOP_CENTER: 'top-center',\n  TOP_RIGHT: 'top-right'\n});\n// EXTERNAL MODULE: ./node_modules/ol/css.js\nvar css = __webpack_require__(73);\n\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar extent = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/ol/Overlay.js\n/**\n * @module ol/Overlay\n */\n\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\n * with the {@link module:ol/Map~Map#getOverlayById} method.\n * @property {HTMLElement} [element] The overlay element.\n * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n * the overlay. The first element in the\n * array is the horizontal offset. A positive value shifts the overlay right.\n * The second element in the array is the vertical offset. A positive value\n * shifts the overlay down.\n * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n * in map projection.\n * @property {OverlayPositioning} [positioning='top-left'] Defines how\n * the overlay is actually positioned with respect to its `position` property.\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, and `'top-right'`.\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\n * viewport should be stopped. If `true` the overlay is placed in the same\n * container as that of the controls (CSS class name\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n * with CSS class name specified by the `className` property.\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n * in the overlay container, or appended. If the overlay is placed in the same\n * container as that of the controls (see the `stopEvent` option) you will\n * probably set `insertFirst` to `true` so the overlay is displayed below the\n * controls.\n * @property {boolean} [autoPan=false] If set to `true` the map is panned when\n * calling `setPosition`, so that the overlay is entirely visible in the current\n * viewport.\n * @property {PanOptions} [autoPanAnimation] The\n * animation options used to pan the overlay into view. This animation is only\n * used when `autoPan` is enabled. A `duration` and `easing` may be provided to\n * customize the animation.\n * @property {number} [autoPanMargin=20] The margin (in pixels) between the\n * overlay and the borders of the map when autopanning.\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n * name.\n */\n\n/**\n * @typedef {Object} PanOptions\n * @property {number} [duration=1000] The duration of the animation in\n * milliseconds.\n * @property {function(number):number} [easing] The easing function to use. Can\n * be one from {@link module:ol/easing} or a custom function.\n * Default is {@link module:ol/easing~inAndOut}.\n */\n\n/**\n * @enum {string}\n * @protected\n */\n\nvar Property = {\n  ELEMENT: 'element',\n  MAP: 'map',\n  OFFSET: 'offset',\n  POSITION: 'position',\n  POSITIONING: 'positioning'\n};\n/**\n * @classdesc\n * An element to be displayed over the map and attached to a single map\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n * visible widgets. Unlike Controls, they are not in a fixed position on the\n * screen, but are tied to a geographical coordinate, so panning the map will\n * move an Overlay but not a Control.\n *\n * Example:\n *\n *     import Overlay from 'ol/Overlay';\n *\n *     var popup = new Overlay({\n *       element: document.getElementById('popup')\n *     });\n *     popup.setPosition(coordinate);\n *     map.addOverlay(popup);\n *\n * @api\n */\n\nvar Overlay_Overlay =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function Overlay(options) {\n    BaseObject.call(this);\n    /**\n     * @protected\n     * @type {Options}\n     */\n\n    this.options = options;\n    /**\n     * @protected\n     * @type {number|string|undefined}\n     */\n\n    this.id = options.id;\n    /**\n     * @protected\n     * @type {boolean}\n     */\n\n    this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;\n    /**\n     * @protected\n     * @type {boolean}\n     */\n\n    this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n\n    this.element = document.createElement('div');\n    this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + css[\"a\" /* CLASS_SELECTABLE */];\n    this.element.style.position = 'absolute';\n    /**\n     * @protected\n     * @type {boolean}\n     */\n\n    this.autoPan = options.autoPan !== undefined ? options.autoPan : false;\n    /**\n     * @protected\n     * @type {PanOptions}\n     */\n\n    this.autoPanAnimation = options.autoPanAnimation ||\n    /** @type {PanOptions} */\n    {};\n    /**\n     * @protected\n     * @type {number}\n     */\n\n    this.autoPanMargin = options.autoPanMargin !== undefined ? options.autoPanMargin : 20;\n    /**\n     * @protected\n     * @type {{bottom_: string,\n     *         left_: string,\n     *         right_: string,\n     *         top_: string,\n     *         visible: boolean}}\n     */\n\n    this.rendered = {\n      bottom_: '',\n      left_: '',\n      right_: '',\n      top_: '',\n      visible: true\n    };\n    /**\n     * @protected\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n\n    this.mapPostrenderListenerKey = null;\n    Object(events[\"a\" /* listen */])(this, Object(ol_Object[\"b\" /* getChangeEventType */])(Property.ELEMENT), this.handleElementChanged, this);\n    Object(events[\"a\" /* listen */])(this, Object(ol_Object[\"b\" /* getChangeEventType */])(Property.MAP), this.handleMapChanged, this);\n    Object(events[\"a\" /* listen */])(this, Object(ol_Object[\"b\" /* getChangeEventType */])(Property.OFFSET), this.handleOffsetChanged, this);\n    Object(events[\"a\" /* listen */])(this, Object(ol_Object[\"b\" /* getChangeEventType */])(Property.POSITION), this.handlePositionChanged, this);\n    Object(events[\"a\" /* listen */])(this, Object(ol_Object[\"b\" /* getChangeEventType */])(Property.POSITIONING), this.handlePositioningChanged, this);\n\n    if (options.element !== undefined) {\n      this.setElement(options.element);\n    }\n\n    this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n    this.setPositioning(options.positioning !== undefined ?\n    /** @type {OverlayPositioning} */\n    options.positioning : OverlayPositioning.TOP_LEFT);\n\n    if (options.position !== undefined) {\n      this.setPosition(options.position);\n    }\n  }\n\n  if (BaseObject) Overlay.__proto__ = BaseObject;\n  Overlay.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Overlay.prototype.constructor = Overlay;\n  /**\n   * Get the DOM element of this overlay.\n   * @return {HTMLElement|undefined} The Element containing the overlay.\n   * @observable\n   * @api\n   */\n\n  Overlay.prototype.getElement = function getElement() {\n    return (\n      /** @type {HTMLElement|undefined} */\n      this.get(Property.ELEMENT)\n    );\n  };\n  /**\n   * Get the overlay identifier which is set on constructor.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n\n\n  Overlay.prototype.getId = function getId() {\n    return this.id;\n  };\n  /**\n   * Get the map associated with this overlay.\n   * @return {import(\"./PluggableMap.js\").default|undefined} The map that the\n   * overlay is part of.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.getMap = function getMap() {\n    return (\n      /** @type {import(\"./PluggableMap.js\").default|undefined} */\n      this.get(Property.MAP)\n    );\n  };\n  /**\n   * Get the offset of this overlay.\n   * @return {Array<number>} The offset.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.getOffset = function getOffset() {\n    return (\n      /** @type {Array<number>} */\n      this.get(Property.OFFSET)\n    );\n  };\n  /**\n   * Get the current position of this overlay.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n   *     anchored at.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.getPosition = function getPosition() {\n    return (\n      /** @type {import(\"./coordinate.js\").Coordinate|undefined} */\n      this.get(Property.POSITION)\n    );\n  };\n  /**\n   * Get the current positioning of this overlay.\n   * @return {OverlayPositioning} How the overlay is positioned\n   *     relative to its point on the map.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.getPositioning = function getPositioning() {\n    return (\n      /** @type {OverlayPositioning} */\n      this.get(Property.POSITIONING)\n    );\n  };\n  /**\n   * @protected\n   */\n\n\n  Overlay.prototype.handleElementChanged = function handleElementChanged() {\n    Object(dom[\"d\" /* removeChildren */])(this.element);\n    var element = this.getElement();\n\n    if (element) {\n      this.element.appendChild(element);\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  Overlay.prototype.handleMapChanged = function handleMapChanged() {\n    if (this.mapPostrenderListenerKey) {\n      Object(dom[\"e\" /* removeNode */])(this.element);\n      Object(events[\"e\" /* unlistenByKey */])(this.mapPostrenderListenerKey);\n      this.mapPostrenderListenerKey = null;\n    }\n\n    var map = this.getMap();\n\n    if (map) {\n      this.mapPostrenderListenerKey = Object(events[\"a\" /* listen */])(map, MapEventType[\"a\" /* default */].POSTRENDER, this.render, this);\n      this.updatePixelPosition();\n      var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();\n\n      if (this.insertFirst) {\n        container.insertBefore(this.element, container.childNodes[0] || null);\n      } else {\n        container.appendChild(this.element);\n      }\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  Overlay.prototype.render = function render() {\n    this.updatePixelPosition();\n  };\n  /**\n   * @protected\n   */\n\n\n  Overlay.prototype.handleOffsetChanged = function handleOffsetChanged() {\n    this.updatePixelPosition();\n  };\n  /**\n   * @protected\n   */\n\n\n  Overlay.prototype.handlePositionChanged = function handlePositionChanged() {\n    this.updatePixelPosition();\n\n    if (this.get(Property.POSITION) && this.autoPan) {\n      this.panIntoView();\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  Overlay.prototype.handlePositioningChanged = function handlePositioningChanged() {\n    this.updatePixelPosition();\n  };\n  /**\n   * Set the DOM element to be associated with this overlay.\n   * @param {HTMLElement|undefined} element The Element containing the overlay.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.setElement = function setElement(element) {\n    this.set(Property.ELEMENT, element);\n  };\n  /**\n   * Set the map to be associated with this overlay.\n   * @param {import(\"./PluggableMap.js\").default|undefined} map The map that the\n   * overlay is part of.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.setMap = function setMap(map) {\n    this.set(Property.MAP, map);\n  };\n  /**\n   * Set the offset for this overlay.\n   * @param {Array<number>} offset Offset.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.setOffset = function setOffset(offset) {\n    this.set(Property.OFFSET, offset);\n  };\n  /**\n   * Set the position for this overlay. If the position is `undefined` the\n   * overlay is hidden.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n   *     is anchored at.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.setPosition = function setPosition(position) {\n    this.set(Property.POSITION, position);\n  };\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary).\n   * @protected\n   */\n\n\n  Overlay.prototype.panIntoView = function panIntoView() {\n    var map = this.getMap();\n\n    if (!map || !map.getTargetElement()) {\n      return;\n    }\n\n    var mapRect = this.getRect(map.getTargetElement(), map.getSize());\n    var element = this.getElement();\n    var overlayRect = this.getRect(element, [Object(dom[\"c\" /* outerWidth */])(element), Object(dom[\"b\" /* outerHeight */])(element)]);\n    var margin = this.autoPanMargin;\n\n    if (!Object(extent[\"containsExtent\"])(mapRect, overlayRect)) {\n      // the overlay is not completely inside the viewport, so pan the map\n      var offsetLeft = overlayRect[0] - mapRect[0];\n      var offsetRight = mapRect[2] - overlayRect[2];\n      var offsetTop = overlayRect[1] - mapRect[1];\n      var offsetBottom = mapRect[3] - overlayRect[3];\n      var delta = [0, 0];\n\n      if (offsetLeft < 0) {\n        // move map to the left\n        delta[0] = offsetLeft - margin;\n      } else if (offsetRight < 0) {\n        // move map to the right\n        delta[0] = Math.abs(offsetRight) + margin;\n      }\n\n      if (offsetTop < 0) {\n        // move map up\n        delta[1] = offsetTop - margin;\n      } else if (offsetBottom < 0) {\n        // move map down\n        delta[1] = Math.abs(offsetBottom) + margin;\n      }\n\n      if (delta[0] !== 0 || delta[1] !== 0) {\n        var center =\n        /** @type {import(\"./coordinate.js\").Coordinate} */\n        map.getView().getCenter();\n        var centerPx = map.getPixelFromCoordinate(center);\n        var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n        map.getView().animate({\n          center: map.getCoordinateFromPixel(newCenterPx),\n          duration: this.autoPanAnimation.duration,\n          easing: this.autoPanAnimation.easing\n        });\n      }\n    }\n  };\n  /**\n   * Get the extent of an element relative to the document\n   * @param {HTMLElement|undefined} element The element.\n   * @param {import(\"./size.js\").Size|undefined} size The size of the element.\n   * @return {import(\"./extent.js\").Extent} The extent.\n   * @protected\n   */\n\n\n  Overlay.prototype.getRect = function getRect(element, size) {\n    var box = element.getBoundingClientRect();\n    var offsetX = box.left + window.pageXOffset;\n    var offsetY = box.top + window.pageYOffset;\n    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n  };\n  /**\n   * Set the positioning for this overlay.\n   * @param {OverlayPositioning} positioning how the overlay is\n   *     positioned relative to its point on the map.\n   * @observable\n   * @api\n   */\n\n\n  Overlay.prototype.setPositioning = function setPositioning(positioning) {\n    this.set(Property.POSITIONING, positioning);\n  };\n  /**\n   * Modify the visibility of the element.\n   * @param {boolean} visible Element visibility.\n   * @protected\n   */\n\n\n  Overlay.prototype.setVisible = function setVisible(visible) {\n    if (this.rendered.visible !== visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.rendered.visible = visible;\n    }\n  };\n  /**\n   * Update pixel position.\n   * @protected\n   */\n\n\n  Overlay.prototype.updatePixelPosition = function updatePixelPosition() {\n    var map = this.getMap();\n    var position = this.getPosition();\n\n    if (!map || !map.isRendered() || !position) {\n      this.setVisible(false);\n      return;\n    }\n\n    var pixel = map.getPixelFromCoordinate(position);\n    var mapSize = map.getSize();\n    this.updateRenderedPosition(pixel, mapSize);\n  };\n  /**\n   * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n   * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n   * @protected\n   */\n\n\n  Overlay.prototype.updateRenderedPosition = function updateRenderedPosition(pixel, mapSize) {\n    var style = this.element.style;\n    var offset = this.getOffset();\n    var positioning = this.getPositioning();\n    this.setVisible(true);\n    var offsetX = offset[0];\n    var offsetY = offset[1];\n\n    if (positioning == OverlayPositioning.BOTTOM_RIGHT || positioning == OverlayPositioning.CENTER_RIGHT || positioning == OverlayPositioning.TOP_RIGHT) {\n      if (this.rendered.left_ !== '') {\n        this.rendered.left_ = style.left = '';\n      }\n\n      var right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';\n\n      if (this.rendered.right_ != right) {\n        this.rendered.right_ = style.right = right;\n      }\n    } else {\n      if (this.rendered.right_ !== '') {\n        this.rendered.right_ = style.right = '';\n      }\n\n      if (positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.TOP_CENTER) {\n        offsetX -= this.element.offsetWidth / 2;\n      }\n\n      var left = Math.round(pixel[0] + offsetX) + 'px';\n\n      if (this.rendered.left_ != left) {\n        this.rendered.left_ = style.left = left;\n      }\n    }\n\n    if (positioning == OverlayPositioning.BOTTOM_LEFT || positioning == OverlayPositioning.BOTTOM_CENTER || positioning == OverlayPositioning.BOTTOM_RIGHT) {\n      if (this.rendered.top_ !== '') {\n        this.rendered.top_ = style.top = '';\n      }\n\n      var bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';\n\n      if (this.rendered.bottom_ != bottom) {\n        this.rendered.bottom_ = style.bottom = bottom;\n      }\n    } else {\n      if (this.rendered.bottom_ !== '') {\n        this.rendered.bottom_ = style.bottom = '';\n      }\n\n      if (positioning == OverlayPositioning.CENTER_LEFT || positioning == OverlayPositioning.CENTER_CENTER || positioning == OverlayPositioning.CENTER_RIGHT) {\n        offsetY -= this.element.offsetHeight / 2;\n      }\n\n      var top = Math.round(pixel[1] + offsetY) + 'px';\n\n      if (this.rendered.top_ != top) {\n        this.rendered.top_ = style.top = top;\n      }\n    }\n  };\n  /**\n   * returns the options this Overlay has been created with\n   * @return {Options} overlay options\n   */\n\n\n  Overlay.prototype.getOptions = function getOptions() {\n    return this.options;\n  };\n\n  return Overlay;\n}(ol_Object[\"a\" /* default */]);\n\n/* harmony default export */ var ol_Overlay = __webpack_exports__[\"default\"] = (Overlay_Overlay);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9PdmVybGF5UG9zaXRpb25pbmcuanM/ZmMyMSIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL092ZXJsYXkuanM/NGU3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvT3ZlcmxheVBvc2l0aW9uaW5nXG4gKi9cblxuLyoqXG4gKiBPdmVybGF5IHBvc2l0aW9uOiBgJ2JvdHRvbS1sZWZ0J2AsIGAnYm90dG9tLWNlbnRlcidgLCAgYCdib3R0b20tcmlnaHQnYCxcbiAqIGAnY2VudGVyLWxlZnQnYCwgYCdjZW50ZXItY2VudGVyJ2AsIGAnY2VudGVyLXJpZ2h0J2AsIGAndG9wLWxlZnQnYCxcbiAqIGAndG9wLWNlbnRlcidgLCBgJ3RvcC1yaWdodCdgXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEJPVFRPTV9MRUZUOiAnYm90dG9tLWxlZnQnLFxuICBCT1RUT01fQ0VOVEVSOiAnYm90dG9tLWNlbnRlcicsXG4gIEJPVFRPTV9SSUdIVDogJ2JvdHRvbS1yaWdodCcsXG4gIENFTlRFUl9MRUZUOiAnY2VudGVyLWxlZnQnLFxuICBDRU5URVJfQ0VOVEVSOiAnY2VudGVyLWNlbnRlcicsXG4gIENFTlRFUl9SSUdIVDogJ2NlbnRlci1yaWdodCcsXG4gIFRPUF9MRUZUOiAndG9wLWxlZnQnLFxuICBUT1BfQ0VOVEVSOiAndG9wLWNlbnRlcicsXG4gIFRPUF9SSUdIVDogJ3RvcC1yaWdodCdcbn07XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvT3ZlcmxheVxuICovXG5pbXBvcnQgTWFwRXZlbnRUeXBlIGZyb20gJy4vTWFwRXZlbnRUeXBlLmpzJztcbmltcG9ydCBCYXNlT2JqZWN0LCB7Z2V0Q2hhbmdlRXZlbnRUeXBlfSBmcm9tICcuL09iamVjdC5qcyc7XG5pbXBvcnQgT3ZlcmxheVBvc2l0aW9uaW5nIGZyb20gJy4vT3ZlcmxheVBvc2l0aW9uaW5nLmpzJztcbmltcG9ydCB7Q0xBU1NfU0VMRUNUQUJMRX0gZnJvbSAnLi9jc3MuanMnO1xuaW1wb3J0IHtyZW1vdmVOb2RlLCByZW1vdmVDaGlsZHJlbiwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHR9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuL2V2ZW50cy5qcyc7XG5pbXBvcnQge2NvbnRhaW5zRXh0ZW50fSBmcm9tICcuL2V4dGVudC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcnxzdHJpbmd9IFtpZF0gU2V0IHRoZSBvdmVybGF5IGlkLiBUaGUgb3ZlcmxheSBpZCBjYW4gYmUgdXNlZFxuICogd2l0aCB0aGUge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwI2dldE92ZXJsYXlCeUlkfSBtZXRob2QuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBbZWxlbWVudF0gVGhlIG92ZXJsYXkgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gW29mZnNldD1bMCwgMF1dIE9mZnNldHMgaW4gcGl4ZWxzIHVzZWQgd2hlbiBwb3NpdGlvbmluZ1xuICogdGhlIG92ZXJsYXkuIFRoZSBmaXJzdCBlbGVtZW50IGluIHRoZVxuICogYXJyYXkgaXMgdGhlIGhvcml6b250YWwgb2Zmc2V0LiBBIHBvc2l0aXZlIHZhbHVlIHNoaWZ0cyB0aGUgb3ZlcmxheSByaWdodC5cbiAqIFRoZSBzZWNvbmQgZWxlbWVudCBpbiB0aGUgYXJyYXkgaXMgdGhlIHZlcnRpY2FsIG9mZnNldC4gQSBwb3NpdGl2ZSB2YWx1ZVxuICogc2hpZnRzIHRoZSBvdmVybGF5IGRvd24uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBbcG9zaXRpb25dIFRoZSBvdmVybGF5IHBvc2l0aW9uXG4gKiBpbiBtYXAgcHJvamVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7T3ZlcmxheVBvc2l0aW9uaW5nfSBbcG9zaXRpb25pbmc9J3RvcC1sZWZ0J10gRGVmaW5lcyBob3dcbiAqIHRoZSBvdmVybGF5IGlzIGFjdHVhbGx5IHBvc2l0aW9uZWQgd2l0aCByZXNwZWN0IHRvIGl0cyBgcG9zaXRpb25gIHByb3BlcnR5LlxuICogUG9zc2libGUgdmFsdWVzIGFyZSBgJ2JvdHRvbS1sZWZ0J2AsIGAnYm90dG9tLWNlbnRlcidgLCBgJ2JvdHRvbS1yaWdodCdgLFxuICogYCdjZW50ZXItbGVmdCdgLCBgJ2NlbnRlci1jZW50ZXInYCwgYCdjZW50ZXItcmlnaHQnYCwgYCd0b3AtbGVmdCdgLFxuICogYCd0b3AtY2VudGVyJ2AsIGFuZCBgJ3RvcC1yaWdodCdgLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc3RvcEV2ZW50PXRydWVdIFdoZXRoZXIgZXZlbnQgcHJvcGFnYXRpb24gdG8gdGhlIG1hcFxuICogdmlld3BvcnQgc2hvdWxkIGJlIHN0b3BwZWQuIElmIGB0cnVlYCB0aGUgb3ZlcmxheSBpcyBwbGFjZWQgaW4gdGhlIHNhbWVcbiAqIGNvbnRhaW5lciBhcyB0aGF0IG9mIHRoZSBjb250cm9scyAoQ1NTIGNsYXNzIG5hbWVcbiAqIGBvbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudGApOyBpZiBgZmFsc2VgIGl0IGlzIHBsYWNlZCBpbiB0aGUgY29udGFpbmVyXG4gKiB3aXRoIENTUyBjbGFzcyBuYW1lIHNwZWNpZmllZCBieSB0aGUgYGNsYXNzTmFtZWAgcHJvcGVydHkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbnNlcnRGaXJzdD10cnVlXSBXaGV0aGVyIHRoZSBvdmVybGF5IGlzIGluc2VydGVkIGZpcnN0XG4gKiBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIsIG9yIGFwcGVuZGVkLiBJZiB0aGUgb3ZlcmxheSBpcyBwbGFjZWQgaW4gdGhlIHNhbWVcbiAqIGNvbnRhaW5lciBhcyB0aGF0IG9mIHRoZSBjb250cm9scyAoc2VlIHRoZSBgc3RvcEV2ZW50YCBvcHRpb24pIHlvdSB3aWxsXG4gKiBwcm9iYWJseSBzZXQgYGluc2VydEZpcnN0YCB0byBgdHJ1ZWAgc28gdGhlIG92ZXJsYXkgaXMgZGlzcGxheWVkIGJlbG93IHRoZVxuICogY29udHJvbHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdXRvUGFuPWZhbHNlXSBJZiBzZXQgdG8gYHRydWVgIHRoZSBtYXAgaXMgcGFubmVkIHdoZW5cbiAqIGNhbGxpbmcgYHNldFBvc2l0aW9uYCwgc28gdGhhdCB0aGUgb3ZlcmxheSBpcyBlbnRpcmVseSB2aXNpYmxlIGluIHRoZSBjdXJyZW50XG4gKiB2aWV3cG9ydC5cbiAqIEBwcm9wZXJ0eSB7UGFuT3B0aW9uc30gW2F1dG9QYW5BbmltYXRpb25dIFRoZVxuICogYW5pbWF0aW9uIG9wdGlvbnMgdXNlZCB0byBwYW4gdGhlIG92ZXJsYXkgaW50byB2aWV3LiBUaGlzIGFuaW1hdGlvbiBpcyBvbmx5XG4gKiB1c2VkIHdoZW4gYGF1dG9QYW5gIGlzIGVuYWJsZWQuIEEgYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgbWF5IGJlIHByb3ZpZGVkIHRvXG4gKiBjdXN0b21pemUgdGhlIGFuaW1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYXV0b1Bhbk1hcmdpbj0yMF0gVGhlIG1hcmdpbiAoaW4gcGl4ZWxzKSBiZXR3ZWVuIHRoZVxuICogb3ZlcmxheSBhbmQgdGhlIGJvcmRlcnMgb2YgdGhlIG1hcCB3aGVuIGF1dG9wYW5uaW5nLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjbGFzc05hbWU9J29sLW92ZXJsYXktY29udGFpbmVyIG9sLXNlbGVjdGFibGUnXSBDU1MgY2xhc3NcbiAqIG5hbWUuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhbk9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwMF0gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaW5cbiAqIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24obnVtYmVyKTpudW1iZXJ9IFtlYXNpbmddIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlLiBDYW5cbiAqIGJlIG9uZSBmcm9tIHtAbGluayBtb2R1bGU6b2wvZWFzaW5nfSBvciBhIGN1c3RvbSBmdW5jdGlvbi5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9lYXNpbmd+aW5BbmRPdXR9LlxuICovXG5cblxuLyoqXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHByb3RlY3RlZFxuICovXG5jb25zdCBQcm9wZXJ0eSA9IHtcbiAgRUxFTUVOVDogJ2VsZW1lbnQnLFxuICBNQVA6ICdtYXAnLFxuICBPRkZTRVQ6ICdvZmZzZXQnLFxuICBQT1NJVElPTjogJ3Bvc2l0aW9uJyxcbiAgUE9TSVRJT05JTkc6ICdwb3NpdGlvbmluZydcbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbiBlbGVtZW50IHRvIGJlIGRpc3BsYXllZCBvdmVyIHRoZSBtYXAgYW5kIGF0dGFjaGVkIHRvIGEgc2luZ2xlIG1hcFxuICogbG9jYXRpb24uICBMaWtlIHtAbGluayBtb2R1bGU6b2wvY29udHJvbC9Db250cm9sfkNvbnRyb2x9LCBPdmVybGF5cyBhcmVcbiAqIHZpc2libGUgd2lkZ2V0cy4gVW5saWtlIENvbnRyb2xzLCB0aGV5IGFyZSBub3QgaW4gYSBmaXhlZCBwb3NpdGlvbiBvbiB0aGVcbiAqIHNjcmVlbiwgYnV0IGFyZSB0aWVkIHRvIGEgZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGUsIHNvIHBhbm5pbmcgdGhlIG1hcCB3aWxsXG4gKiBtb3ZlIGFuIE92ZXJsYXkgYnV0IG5vdCBhIENvbnRyb2wuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgaW1wb3J0IE92ZXJsYXkgZnJvbSAnb2wvT3ZlcmxheSc7XG4gKlxuICogICAgIHZhciBwb3B1cCA9IG5ldyBPdmVybGF5KHtcbiAqICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwb3B1cCcpXG4gKiAgICAgfSk7XG4gKiAgICAgcG9wdXAuc2V0UG9zaXRpb24oY29vcmRpbmF0ZSk7XG4gKiAgICAgbWFwLmFkZE92ZXJsYXkocG9wdXApO1xuICpcbiAqIEBhcGlcbiAqL1xuY2xhc3MgT3ZlcmxheSBleHRlbmRzIEJhc2VPYmplY3Qge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgT3ZlcmxheSBvcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7T3B0aW9uc31cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gb3B0aW9ucy5pZDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmluc2VydEZpcnN0ID0gb3B0aW9ucy5pbnNlcnRGaXJzdCAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuaW5zZXJ0Rmlyc3QgOiB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc3RvcEV2ZW50ID0gb3B0aW9ucy5zdG9wRXZlbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RvcEV2ZW50IDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IG9wdGlvbnMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5jbGFzc05hbWUgOiAnb2wtb3ZlcmxheS1jb250YWluZXIgJyArIENMQVNTX1NFTEVDVEFCTEU7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9QYW4gPSBvcHRpb25zLmF1dG9QYW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYXV0b1BhbiA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHtQYW5PcHRpb25zfVxuICAgICAqL1xuICAgIHRoaXMuYXV0b1BhbkFuaW1hdGlvbiA9IG9wdGlvbnMuYXV0b1BhbkFuaW1hdGlvbiB8fCAvKiogQHR5cGUge1Bhbk9wdGlvbnN9ICovICh7fSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9QYW5NYXJnaW4gPSBvcHRpb25zLmF1dG9QYW5NYXJnaW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLmF1dG9QYW5NYXJnaW4gOiAyMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAdHlwZSB7e2JvdHRvbV86IHN0cmluZyxcbiAgICAgKiAgICAgICAgIGxlZnRfOiBzdHJpbmcsXG4gICAgICogICAgICAgICByaWdodF86IHN0cmluZyxcbiAgICAgKiAgICAgICAgIHRvcF86IHN0cmluZyxcbiAgICAgKiAgICAgICAgIHZpc2libGU6IGJvb2xlYW59fVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWQgPSB7XG4gICAgICBib3R0b21fOiAnJyxcbiAgICAgIGxlZnRfOiAnJyxcbiAgICAgIHJpZ2h0XzogJycsXG4gICAgICB0b3BfOiAnJyxcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMubWFwUG9zdHJlbmRlckxpc3RlbmVyS2V5ID0gbnVsbDtcblxuICAgIGxpc3RlbihcbiAgICAgIHRoaXMsIGdldENoYW5nZUV2ZW50VHlwZShQcm9wZXJ0eS5FTEVNRU5UKSxcbiAgICAgIHRoaXMuaGFuZGxlRWxlbWVudENoYW5nZWQsIHRoaXMpO1xuXG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKFByb3BlcnR5Lk1BUCksXG4gICAgICB0aGlzLmhhbmRsZU1hcENoYW5nZWQsIHRoaXMpO1xuXG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKFByb3BlcnR5Lk9GRlNFVCksXG4gICAgICB0aGlzLmhhbmRsZU9mZnNldENoYW5nZWQsIHRoaXMpO1xuXG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKFByb3BlcnR5LlBPU0lUSU9OKSxcbiAgICAgIHRoaXMuaGFuZGxlUG9zaXRpb25DaGFuZ2VkLCB0aGlzKTtcblxuICAgIGxpc3RlbihcbiAgICAgIHRoaXMsIGdldENoYW5nZUV2ZW50VHlwZShQcm9wZXJ0eS5QT1NJVElPTklORyksXG4gICAgICB0aGlzLmhhbmRsZVBvc2l0aW9uaW5nQ2hhbmdlZCwgdGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy5lbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0RWxlbWVudChvcHRpb25zLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0T2Zmc2V0KG9wdGlvbnMub2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldCA6IFswLCAwXSk7XG5cbiAgICB0aGlzLnNldFBvc2l0aW9uaW5nKG9wdGlvbnMucG9zaXRpb25pbmcgIT09IHVuZGVmaW5lZCA/XG4gICAgICAvKiogQHR5cGUge092ZXJsYXlQb3NpdGlvbmluZ30gKi8gKG9wdGlvbnMucG9zaXRpb25pbmcpIDpcbiAgICAgIE92ZXJsYXlQb3NpdGlvbmluZy5UT1BfTEVGVCk7XG5cbiAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgRE9NIGVsZW1lbnQgb2YgdGhpcyBvdmVybGF5LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHx1bmRlZmluZWR9IFRoZSBFbGVtZW50IGNvbnRhaW5pbmcgdGhlIG92ZXJsYXkuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoUHJvcGVydHkuRUxFTUVOVCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3ZlcmxheSBpZGVudGlmaWVyIHdoaWNoIGlzIHNldCBvbiBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ3x1bmRlZmluZWR9IElkLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBhc3NvY2lhdGVkIHdpdGggdGhpcyBvdmVybGF5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIG1hcCB0aGF0IHRoZVxuICAgKiBvdmVybGF5IGlzIHBhcnQgb2YuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE1hcCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5Lk1BUCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG9mZnNldCBvZiB0aGlzIG92ZXJsYXkuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBvZmZzZXQuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9mZnNldCgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtBcnJheTxudW1iZXI+fSAqLyAodGhpcy5nZXQoUHJvcGVydHkuT0ZGU0VUKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoaXMgb3ZlcmxheS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSBUaGUgc3BhdGlhbCBwb2ludCB0aGF0IHRoZSBvdmVybGF5IGlzXG4gICAqICAgICBhbmNob3JlZCBhdC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoUHJvcGVydHkuUE9TSVRJT04pKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHBvc2l0aW9uaW5nIG9mIHRoaXMgb3ZlcmxheS5cbiAgICogQHJldHVybiB7T3ZlcmxheVBvc2l0aW9uaW5nfSBIb3cgdGhlIG92ZXJsYXkgaXMgcG9zaXRpb25lZFxuICAgKiAgICAgcmVsYXRpdmUgdG8gaXRzIHBvaW50IG9uIHRoZSBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvc2l0aW9uaW5nKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge092ZXJsYXlQb3NpdGlvbmluZ30gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LlBPU0lUSU9OSU5HKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZUVsZW1lbnRDaGFuZ2VkKCkge1xuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMuZWxlbWVudCk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZU1hcENoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMubWFwUG9zdHJlbmRlckxpc3RlbmVyS2V5KSB7XG4gICAgICByZW1vdmVOb2RlKHRoaXMuZWxlbWVudCk7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMubWFwUG9zdHJlbmRlckxpc3RlbmVyS2V5KTtcbiAgICAgIHRoaXMubWFwUG9zdHJlbmRlckxpc3RlbmVyS2V5ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLm1hcFBvc3RyZW5kZXJMaXN0ZW5lcktleSA9IGxpc3RlbihtYXAsXG4gICAgICAgIE1hcEV2ZW50VHlwZS5QT1NUUkVOREVSLCB0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICB0aGlzLnVwZGF0ZVBpeGVsUG9zaXRpb24oKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuc3RvcEV2ZW50ID9cbiAgICAgICAgbWFwLmdldE92ZXJsYXlDb250YWluZXJTdG9wRXZlbnQoKSA6IG1hcC5nZXRPdmVybGF5Q29udGFpbmVyKCk7XG4gICAgICBpZiAodGhpcy5pbnNlcnRGaXJzdCkge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCwgY29udGFpbmVyLmNoaWxkTm9kZXNbMF0gfHwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMudXBkYXRlUGl4ZWxQb3NpdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZU9mZnNldENoYW5nZWQoKSB7XG4gICAgdGhpcy51cGRhdGVQaXhlbFBvc2l0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaGFuZGxlUG9zaXRpb25DaGFuZ2VkKCkge1xuICAgIHRoaXMudXBkYXRlUGl4ZWxQb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLmdldChQcm9wZXJ0eS5QT1NJVElPTikgJiYgdGhpcy5hdXRvUGFuKSB7XG4gICAgICB0aGlzLnBhbkludG9WaWV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVBvc2l0aW9uaW5nQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnVwZGF0ZVBpeGVsUG9zaXRpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIERPTSBlbGVtZW50IHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8dW5kZWZpbmVkfSBlbGVtZW50IFRoZSBFbGVtZW50IGNvbnRhaW5pbmcgdGhlIG92ZXJsYXkuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LkVMRU1FTlQsIGVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWFwIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IG1hcCBUaGUgbWFwIHRoYXQgdGhlXG4gICAqIG92ZXJsYXkgaXMgcGFydCBvZi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TWFwKG1hcCkge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5Lk1BUCwgbWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIG9mZnNldCBmb3IgdGhpcyBvdmVybGF5LlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9mZnNldCBPZmZzZXQuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldE9mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5PRkZTRVQsIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwb3NpdGlvbiBmb3IgdGhpcyBvdmVybGF5LiBJZiB0aGUgcG9zaXRpb24gaXMgYHVuZGVmaW5lZGAgdGhlXG4gICAqIG92ZXJsYXkgaXMgaGlkZGVuLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gcG9zaXRpb24gVGhlIHNwYXRpYWwgcG9pbnQgdGhhdCB0aGUgb3ZlcmxheVxuICAgKiAgICAgaXMgYW5jaG9yZWQgYXQuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuUE9TSVRJT04sIHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYW4gdGhlIG1hcCBzbyB0aGF0IHRoZSBvdmVybGF5IGlzIGVudGlyZWx5IHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAgICogKGlmIG5lY2Vzc2FyeSkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHBhbkludG9WaWV3KCkge1xuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG5cbiAgICBpZiAoIW1hcCB8fCAhbWFwLmdldFRhcmdldEVsZW1lbnQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcFJlY3QgPSB0aGlzLmdldFJlY3QobWFwLmdldFRhcmdldEVsZW1lbnQoKSwgbWFwLmdldFNpemUoKSk7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnN0IG92ZXJsYXlSZWN0ID0gdGhpcy5nZXRSZWN0KGVsZW1lbnQsIFtvdXRlcldpZHRoKGVsZW1lbnQpLCBvdXRlckhlaWdodChlbGVtZW50KV0pO1xuXG4gICAgY29uc3QgbWFyZ2luID0gdGhpcy5hdXRvUGFuTWFyZ2luO1xuICAgIGlmICghY29udGFpbnNFeHRlbnQobWFwUmVjdCwgb3ZlcmxheVJlY3QpKSB7XG4gICAgICAvLyB0aGUgb3ZlcmxheSBpcyBub3QgY29tcGxldGVseSBpbnNpZGUgdGhlIHZpZXdwb3J0LCBzbyBwYW4gdGhlIG1hcFxuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IG92ZXJsYXlSZWN0WzBdIC0gbWFwUmVjdFswXTtcbiAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gbWFwUmVjdFsyXSAtIG92ZXJsYXlSZWN0WzJdO1xuICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gb3ZlcmxheVJlY3RbMV0gLSBtYXBSZWN0WzFdO1xuICAgICAgY29uc3Qgb2Zmc2V0Qm90dG9tID0gbWFwUmVjdFszXSAtIG92ZXJsYXlSZWN0WzNdO1xuXG4gICAgICBjb25zdCBkZWx0YSA9IFswLCAwXTtcbiAgICAgIGlmIChvZmZzZXRMZWZ0IDwgMCkge1xuICAgICAgICAvLyBtb3ZlIG1hcCB0byB0aGUgbGVmdFxuICAgICAgICBkZWx0YVswXSA9IG9mZnNldExlZnQgLSBtYXJnaW47XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldFJpZ2h0IDwgMCkge1xuICAgICAgICAvLyBtb3ZlIG1hcCB0byB0aGUgcmlnaHRcbiAgICAgICAgZGVsdGFbMF0gPSBNYXRoLmFicyhvZmZzZXRSaWdodCkgKyBtYXJnaW47XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0VG9wIDwgMCkge1xuICAgICAgICAvLyBtb3ZlIG1hcCB1cFxuICAgICAgICBkZWx0YVsxXSA9IG9mZnNldFRvcCAtIG1hcmdpbjtcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0Qm90dG9tIDwgMCkge1xuICAgICAgICAvLyBtb3ZlIG1hcCBkb3duXG4gICAgICAgIGRlbHRhWzFdID0gTWF0aC5hYnMob2Zmc2V0Qm90dG9tKSArIG1hcmdpbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbHRhWzBdICE9PSAwIHx8IGRlbHRhWzFdICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9ICovIChtYXAuZ2V0VmlldygpLmdldENlbnRlcigpKTtcbiAgICAgICAgY29uc3QgY2VudGVyUHggPSBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjZW50ZXIpO1xuICAgICAgICBjb25zdCBuZXdDZW50ZXJQeCA9IFtcbiAgICAgICAgICBjZW50ZXJQeFswXSArIGRlbHRhWzBdLFxuICAgICAgICAgIGNlbnRlclB4WzFdICsgZGVsdGFbMV1cbiAgICAgICAgXTtcblxuICAgICAgICBtYXAuZ2V0VmlldygpLmFuaW1hdGUoe1xuICAgICAgICAgIGNlbnRlcjogbWFwLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwobmV3Q2VudGVyUHgpLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmF1dG9QYW5BbmltYXRpb24uZHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiB0aGlzLmF1dG9QYW5BbmltYXRpb24uZWFzaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dGVudCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fHVuZGVmaW5lZH0gZWxlbWVudCBUaGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9IHNpemUgVGhlIHNpemUgb2YgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH0gVGhlIGV4dGVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0UmVjdChlbGVtZW50LCBzaXplKSB7XG4gICAgY29uc3QgYm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBvZmZzZXRYID0gYm94LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IGJveC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgcmV0dXJuIFtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgb2Zmc2V0WCArIHNpemVbMF0sXG4gICAgICBvZmZzZXRZICsgc2l6ZVsxXVxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwb3NpdGlvbmluZyBmb3IgdGhpcyBvdmVybGF5LlxuICAgKiBAcGFyYW0ge092ZXJsYXlQb3NpdGlvbmluZ30gcG9zaXRpb25pbmcgaG93IHRoZSBvdmVybGF5IGlzXG4gICAqICAgICBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIGl0cyBwb2ludCBvbiB0aGUgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRQb3NpdGlvbmluZyhwb3NpdGlvbmluZykge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LlBPU0lUSU9OSU5HLCBwb3NpdGlvbmluZyk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZ5IHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpc2libGUgRWxlbWVudCB2aXNpYmlsaXR5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXRWaXNpYmxlKHZpc2libGUpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlZC52aXNpYmxlICE9PSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgIHRoaXMucmVuZGVyZWQudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwaXhlbCBwb3NpdGlvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgdXBkYXRlUGl4ZWxQb3NpdGlvbigpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuICAgIGlmICghbWFwIHx8ICFtYXAuaXNSZW5kZXJlZCgpIHx8ICFwb3NpdGlvbikge1xuICAgICAgdGhpcy5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbCA9IG1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKHBvc2l0aW9uKTtcbiAgICBjb25zdCBtYXBTaXplID0gbWFwLmdldFNpemUoKTtcbiAgICB0aGlzLnVwZGF0ZVJlbmRlcmVkUG9zaXRpb24ocGl4ZWwsIG1hcFNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgVGhlIHBpeGVsIGxvY2F0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gbWFwU2l6ZSBUaGUgbWFwIHNpemUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHVwZGF0ZVJlbmRlcmVkUG9zaXRpb24ocGl4ZWwsIG1hcFNpemUpIHtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZTtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldE9mZnNldCgpO1xuXG4gICAgY29uc3QgcG9zaXRpb25pbmcgPSB0aGlzLmdldFBvc2l0aW9uaW5nKCk7XG5cbiAgICB0aGlzLnNldFZpc2libGUodHJ1ZSk7XG5cbiAgICBsZXQgb2Zmc2V0WCA9IG9mZnNldFswXTtcbiAgICBsZXQgb2Zmc2V0WSA9IG9mZnNldFsxXTtcbiAgICBpZiAocG9zaXRpb25pbmcgPT0gT3ZlcmxheVBvc2l0aW9uaW5nLkJPVFRPTV9SSUdIVCB8fFxuICAgICAgICBwb3NpdGlvbmluZyA9PSBPdmVybGF5UG9zaXRpb25pbmcuQ0VOVEVSX1JJR0hUIHx8XG4gICAgICAgIHBvc2l0aW9uaW5nID09IE92ZXJsYXlQb3NpdGlvbmluZy5UT1BfUklHSFQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkLmxlZnRfICE9PSAnJykge1xuICAgICAgICB0aGlzLnJlbmRlcmVkLmxlZnRfID0gc3R5bGUubGVmdCA9ICcnO1xuICAgICAgfVxuICAgICAgY29uc3QgcmlnaHQgPSBNYXRoLnJvdW5kKG1hcFNpemVbMF0gLSBwaXhlbFswXSAtIG9mZnNldFgpICsgJ3B4JztcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkLnJpZ2h0XyAhPSByaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVkLnJpZ2h0XyA9IHN0eWxlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkLnJpZ2h0XyAhPT0gJycpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZC5yaWdodF8gPSBzdHlsZS5yaWdodCA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uaW5nID09IE92ZXJsYXlQb3NpdGlvbmluZy5CT1RUT01fQ0VOVEVSIHx8XG4gICAgICAgICAgcG9zaXRpb25pbmcgPT0gT3ZlcmxheVBvc2l0aW9uaW5nLkNFTlRFUl9DRU5URVIgfHxcbiAgICAgICAgICBwb3NpdGlvbmluZyA9PSBPdmVybGF5UG9zaXRpb25pbmcuVE9QX0NFTlRFUikge1xuICAgICAgICBvZmZzZXRYIC09IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWZ0ID0gTWF0aC5yb3VuZChwaXhlbFswXSArIG9mZnNldFgpICsgJ3B4JztcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkLmxlZnRfICE9IGxlZnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZC5sZWZ0XyA9IHN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocG9zaXRpb25pbmcgPT0gT3ZlcmxheVBvc2l0aW9uaW5nLkJPVFRPTV9MRUZUIHx8XG4gICAgICAgIHBvc2l0aW9uaW5nID09IE92ZXJsYXlQb3NpdGlvbmluZy5CT1RUT01fQ0VOVEVSIHx8XG4gICAgICAgIHBvc2l0aW9uaW5nID09IE92ZXJsYXlQb3NpdGlvbmluZy5CT1RUT01fUklHSFQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkLnRvcF8gIT09ICcnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQudG9wXyA9IHN0eWxlLnRvcCA9ICcnO1xuICAgICAgfVxuICAgICAgY29uc3QgYm90dG9tID0gTWF0aC5yb3VuZChtYXBTaXplWzFdIC0gcGl4ZWxbMV0gLSBvZmZzZXRZKSArICdweCc7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZC5ib3R0b21fICE9IGJvdHRvbSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVkLmJvdHRvbV8gPSBzdHlsZS5ib3R0b20gPSBib3R0b207XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkLmJvdHRvbV8gIT09ICcnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQuYm90dG9tXyA9IHN0eWxlLmJvdHRvbSA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uaW5nID09IE92ZXJsYXlQb3NpdGlvbmluZy5DRU5URVJfTEVGVCB8fFxuICAgICAgICAgIHBvc2l0aW9uaW5nID09IE92ZXJsYXlQb3NpdGlvbmluZy5DRU5URVJfQ0VOVEVSIHx8XG4gICAgICAgICAgcG9zaXRpb25pbmcgPT0gT3ZlcmxheVBvc2l0aW9uaW5nLkNFTlRFUl9SSUdIVCkge1xuICAgICAgICBvZmZzZXRZIC09IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wID0gTWF0aC5yb3VuZChwaXhlbFsxXSArIG9mZnNldFkpICsgJ3B4JztcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkLnRvcF8gIT0gdG9wKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQudG9wXyA9IHN0eWxlLnRvcCA9IHRvcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyB0aGUgb3B0aW9ucyB0aGlzIE92ZXJsYXkgaGFzIGJlZW4gY3JlYXRlZCB3aXRoXG4gICAqIEByZXR1cm4ge09wdGlvbnN9IG92ZXJsYXkgb3B0aW9uc1xuICAgKi9cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgT3ZlcmxheTtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBOzs7Ozs7Ozs7Ozs7OztBQ1ZBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTtBQUFBO0FBQUE7QUFLQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFPQTs7Ozs7O0FBTUE7QUFDQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFBQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOzs7Ozs7QUFZQTtBQUVBO0FBSUE7QUFJQTtBQUlBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUdBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBR0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBR0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFyZUE7QUFDQTtBQXVlQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///114\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _CsvPoint = _interopRequireDefault(__webpack_require__(120));\n\nvar _Point = _interopRequireDefault(__webpack_require__(52));\n\nvar _EventHandling = _interopRequireDefault(__webpack_require__(64));\n\nvar _ReplaceTokens = _interopRequireDefault(__webpack_require__(124));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/format/CsvAddr\r\n */\n\n/**\r\n * @desc Class to create point features from CSV data\r\n * @public\r\n * @class\r\n * @extends ol.format.Feature\r\n * @mixes module:nyc/EventHandling~EventHandling\r\n * @see http://openlayers.org/en/latest/apidoc/module-ol_format_Feature-FeatureFormat.html\r\n */\n\n\nvar CsvAddr =\n/*#__PURE__*/\nfunction (_CsvPoint$default) {\n  _inherits(CsvAddr, _CsvPoint$default);\n\n  /**\r\n   * @desc Create an instance of CsvAddr\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/ol/format/CsvAddr~CsvAddr.Options} options Constructor options\r\n   */\n  function CsvAddr(options) {\n    var _this;\n\n    _classCallCheck(this, CsvAddr);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CsvAddr).call(this, options));\n    /**\r\n     * @private\r\n     * @member {boolean}\r\n     */\n\n    _this.geocoder = options.geocoder;\n    /**\r\n     * @private\r\n     * @member {string}\r\n     */\n\n    _this.locationTemplate = options.locationTemplate;\n    /**\r\n     * @private\r\n     * @member {number}\r\n     */\n\n    _this.featureCount = undefined;\n    /**\r\n     * @private\r\n     * @member {number}\r\n     */\n\n    _this.geocodedCount = 0;\n    _this.replace = new _ReplaceTokens["default"]().replace;\n    var eventHandling = new _EventHandling["default"]();\n    _this.on = _jquery["default"].proxy(eventHandling.on, eventHandling);\n    _this.one = _jquery["default"].proxy(eventHandling.one, eventHandling);\n    _this.off = _jquery["default"].proxy(eventHandling.off, eventHandling);\n    _this.trigger = _jquery["default"].proxy(eventHandling.trigger, eventHandling);\n    return _this;\n  }\n  /**\r\n   * @desc Read all features from a source\r\n   * @public\r\n   * @override\r\n   * @method\r\n   * @param {Object} source Rows from a CSV data source\r\n   * @param {olx.format.ReadOptions=} options Read options\r\n   * @return {Array.<ol.Feature>} Features\r\n   */\n\n\n  _createClass(CsvAddr, [{\n    key: "readFeatures",\n    value: function readFeatures(source, options) {\n      var features = _get(_getPrototypeOf(CsvAddr.prototype), "readFeatures", this).call(this, source, options);\n\n      this.featureCount = (this.featureCount || 0) + features.length;\n      return features;\n    }\n    /**\r\n     * @desc Set the feature geocode result and geometry\r\n     * @public\r\n     * @method\r\n     * @param {ol.Feature} feature The feature\r\n     * @param {module:nyc/Locator~Locator.Result} geocode A geocoder response\r\n     */\n\n  }, {\n    key: "setGeocode",\n    value: function setGeocode(feature, geocode) {\n      var input = feature.get(\'_input\');\n      var source = feature.get(\'_source\');\n      feature.set(\'_geocodeResp\', geocode);\n\n      if (geocode.type === \'geocoded\') {\n        console.info(\'Geocoded:\', input, source, \'Geocoder response:\', geocode);\n        feature.setGeometry(new _Point["default"](geocode.coordinate));\n      } else {\n        console.warn(\'Ambiguous location:\', input, source, \'Geocoder response:\', geocode);\n        feature.dispatchEvent(\'change\', {\n          target: feature\n        });\n      }\n    }\n    /**\r\n     * @desc Set the feature geometry\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @param {ol.Feature} feature The feature\r\n     * @param {Object<string, string>} source A row from a CSV data source\r\n     */\n\n  }, {\n    key: "setGeometry",\n    value: function setGeometry(feature, source) {\n      var _this2 = this;\n\n      var changed = false;\n      var input = this.replace(this.locationTemplate, source);\n      feature.set(\'_input\', input);\n      feature.set(\'_source\', source);\n\n      if (input.replace(/\\,/g, \'\').trim() === \'\') {\n        feature.dispatchEvent({\n          type: \'change\',\n          target: feature\n        });\n        console.error(\'Invalid location:\', input, \'Bad record:\', source);\n      } else {\n        this.geocoder.search(input).then(function (geocode) {\n          _this2.setGeocode(feature, geocode);\n\n          changed = true;\n        })["catch"](function (error) {\n          console.error(\'Geocoding error:\', input, source, \'Geocoder response:\', error);\n        })["finally"](function () {\n          if (!changed) {\n            feature.dispatchEvent({\n              type: \'change\',\n              target: feature\n            });\n          }\n\n          _this2.geocodedCount = _this2.geocodedCount + 1;\n\n          if (_this2.geocodedCount === _this2.featureCount) {\n            _this2.trigger(\'geocode-complete\', _this2);\n          }\n        });\n      }\n    }\n  }]);\n\n  return CsvAddr;\n}(_CsvPoint["default"]);\n/**\r\n* @desc Constructor options for {@link module:nyc/ol/format/CsvAddr~CsvAddr}\r\n* @public\r\n* @typedef {Object}\r\n* @property {boolean} [autoDetect=false] Attempt to determine standard column names and projection\r\n* @property {module:nyc/Geocoder~Geocoder} x The geocoder to use for geocoding feature\r\n* @property {string} locationTemplate The location template for generating a location string to pass to the geocoder\r\n*/\n\n\nCsvAddr.Options;\nvar _default = CsvAddr;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL2Zvcm1hdC9Dc3ZBZGRyLmpzPzg4MGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfanF1ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwianF1ZXJ5XCIpKTtcblxudmFyIF9Dc3ZQb2ludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vQ3N2UG9pbnRcIikpO1xuXG52YXIgX1BvaW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvZ2VvbS9Qb2ludFwiKSk7XG5cbnZhciBfRXZlbnRIYW5kbGluZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uLy4uL0V2ZW50SGFuZGxpbmdcIikpO1xuXG52YXIgX1JlcGxhY2VUb2tlbnMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9SZXBsYWNlVG9rZW5zXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL29sL2Zvcm1hdC9Dc3ZBZGRyXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQ2xhc3MgdG8gY3JlYXRlIHBvaW50IGZlYXR1cmVzIGZyb20gQ1NWIGRhdGFcclxuICogQHB1YmxpY1xyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgb2wuZm9ybWF0LkZlYXR1cmVcclxuICogQG1peGVzIG1vZHVsZTpueWMvRXZlbnRIYW5kbGluZ35FdmVudEhhbmRsaW5nXHJcbiAqIEBzZWUgaHR0cDovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX2Zvcm1hdF9GZWF0dXJlLUZlYXR1cmVGb3JtYXQuaHRtbFxyXG4gKi9cbmNsYXNzIENzdkFkZHIgZXh0ZW5kcyBfQ3N2UG9pbnQuZGVmYXVsdCB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBDc3ZBZGRyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9vbC9mb3JtYXQvQ3N2QWRkcn5Dc3ZBZGRyLk9wdGlvbnN9IG9wdGlvbnMgQ29uc3RydWN0b3Igb3B0aW9uc1xyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gICAgdGhpcy5nZW9jb2RlciA9IG9wdGlvbnMuZ2VvY29kZXI7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXG5cbiAgICB0aGlzLmxvY2F0aW9uVGVtcGxhdGUgPSBvcHRpb25zLmxvY2F0aW9uVGVtcGxhdGU7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXG5cbiAgICB0aGlzLmZlYXR1cmVDb3VudCA9IHVuZGVmaW5lZDtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuZ2VvY29kZWRDb3VudCA9IDA7XG4gICAgdGhpcy5yZXBsYWNlID0gbmV3IF9SZXBsYWNlVG9rZW5zLmRlZmF1bHQoKS5yZXBsYWNlO1xuICAgIGNvbnN0IGV2ZW50SGFuZGxpbmcgPSBuZXcgX0V2ZW50SGFuZGxpbmcuZGVmYXVsdCgpO1xuICAgIHRoaXMub24gPSBfanF1ZXJ5LmRlZmF1bHQucHJveHkoZXZlbnRIYW5kbGluZy5vbiwgZXZlbnRIYW5kbGluZyk7XG4gICAgdGhpcy5vbmUgPSBfanF1ZXJ5LmRlZmF1bHQucHJveHkoZXZlbnRIYW5kbGluZy5vbmUsIGV2ZW50SGFuZGxpbmcpO1xuICAgIHRoaXMub2ZmID0gX2pxdWVyeS5kZWZhdWx0LnByb3h5KGV2ZW50SGFuZGxpbmcub2ZmLCBldmVudEhhbmRsaW5nKTtcbiAgICB0aGlzLnRyaWdnZXIgPSBfanF1ZXJ5LmRlZmF1bHQucHJveHkoZXZlbnRIYW5kbGluZy50cmlnZ2VyLCBldmVudEhhbmRsaW5nKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBSZWFkIGFsbCBmZWF0dXJlcyBmcm9tIGEgc291cmNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFJvd3MgZnJvbSBhIENTViBkYXRhIHNvdXJjZVxyXG4gICAqIEBwYXJhbSB7b2x4LmZvcm1hdC5SZWFkT3B0aW9ucz19IG9wdGlvbnMgUmVhZCBvcHRpb25zXHJcbiAgICogQHJldHVybiB7QXJyYXkuPG9sLkZlYXR1cmU+fSBGZWF0dXJlc1xyXG4gICAqL1xuXG5cbiAgcmVhZEZlYXR1cmVzKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZlYXR1cmVzID0gc3VwZXIucmVhZEZlYXR1cmVzKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgdGhpcy5mZWF0dXJlQ291bnQgPSAodGhpcy5mZWF0dXJlQ291bnQgfHwgMCkgKyBmZWF0dXJlcy5sZW5ndGg7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFNldCB0aGUgZmVhdHVyZSBnZW9jb2RlIHJlc3VsdCBhbmQgZ2VvbWV0cnlcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7b2wuRmVhdHVyZX0gZmVhdHVyZSBUaGUgZmVhdHVyZVxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IuUmVzdWx0fSBnZW9jb2RlIEEgZ2VvY29kZXIgcmVzcG9uc2VcclxuICAgKi9cblxuXG4gIHNldEdlb2NvZGUoZmVhdHVyZSwgZ2VvY29kZSkge1xuICAgIGNvbnN0IGlucHV0ID0gZmVhdHVyZS5nZXQoJ19pbnB1dCcpO1xuICAgIGNvbnN0IHNvdXJjZSA9IGZlYXR1cmUuZ2V0KCdfc291cmNlJyk7XG4gICAgZmVhdHVyZS5zZXQoJ19nZW9jb2RlUmVzcCcsIGdlb2NvZGUpO1xuXG4gICAgaWYgKGdlb2NvZGUudHlwZSA9PT0gJ2dlb2NvZGVkJykge1xuICAgICAgY29uc29sZS5pbmZvKCdHZW9jb2RlZDonLCBpbnB1dCwgc291cmNlLCAnR2VvY29kZXIgcmVzcG9uc2U6JywgZ2VvY29kZSk7XG4gICAgICBmZWF0dXJlLnNldEdlb21ldHJ5KG5ldyBfUG9pbnQuZGVmYXVsdChnZW9jb2RlLmNvb3JkaW5hdGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdBbWJpZ3VvdXMgbG9jYXRpb246JywgaW5wdXQsIHNvdXJjZSwgJ0dlb2NvZGVyIHJlc3BvbnNlOicsIGdlb2NvZGUpO1xuICAgICAgZmVhdHVyZS5kaXNwYXRjaEV2ZW50KCdjaGFuZ2UnLCB7XG4gICAgICAgIHRhcmdldDogZmVhdHVyZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFNldCB0aGUgZmVhdHVyZSBnZW9tZXRyeVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtvbC5GZWF0dXJlfSBmZWF0dXJlIFRoZSBmZWF0dXJlXHJcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBzb3VyY2UgQSByb3cgZnJvbSBhIENTViBkYXRhIHNvdXJjZVxyXG4gICAqL1xuXG5cbiAgc2V0R2VvbWV0cnkoZmVhdHVyZSwgc291cmNlKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMucmVwbGFjZSh0aGlzLmxvY2F0aW9uVGVtcGxhdGUsIHNvdXJjZSk7XG4gICAgZmVhdHVyZS5zZXQoJ19pbnB1dCcsIGlucHV0KTtcbiAgICBmZWF0dXJlLnNldCgnX3NvdXJjZScsIHNvdXJjZSk7XG5cbiAgICBpZiAoaW5wdXQucmVwbGFjZSgvXFwsL2csICcnKS50cmltKCkgPT09ICcnKSB7XG4gICAgICBmZWF0dXJlLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiAnY2hhbmdlJyxcbiAgICAgICAgdGFyZ2V0OiBmZWF0dXJlXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgbG9jYXRpb246JywgaW5wdXQsICdCYWQgcmVjb3JkOicsIHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2VvY29kZXIuc2VhcmNoKGlucHV0KS50aGVuKGdlb2NvZGUgPT4ge1xuICAgICAgICB0aGlzLnNldEdlb2NvZGUoZmVhdHVyZSwgZ2VvY29kZSk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdHZW9jb2RpbmcgZXJyb3I6JywgaW5wdXQsIHNvdXJjZSwgJ0dlb2NvZGVyIHJlc3BvbnNlOicsIGVycm9yKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICBmZWF0dXJlLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgdHlwZTogJ2NoYW5nZScsXG4gICAgICAgICAgICB0YXJnZXQ6IGZlYXR1cmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2VvY29kZWRDb3VudCA9IHRoaXMuZ2VvY29kZWRDb3VudCArIDE7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2VvY29kZWRDb3VudCA9PT0gdGhpcy5mZWF0dXJlQ291bnQpIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2dlb2NvZGUtY29tcGxldGUnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn1cbi8qKlxyXG4qIEBkZXNjIENvbnN0cnVjdG9yIG9wdGlvbnMgZm9yIHtAbGluayBtb2R1bGU6bnljL29sL2Zvcm1hdC9Dc3ZBZGRyfkNzdkFkZHJ9XHJcbiogQHB1YmxpY1xyXG4qIEB0eXBlZGVmIHtPYmplY3R9XHJcbiogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b0RldGVjdD1mYWxzZV0gQXR0ZW1wdCB0byBkZXRlcm1pbmUgc3RhbmRhcmQgY29sdW1uIG5hbWVzIGFuZCBwcm9qZWN0aW9uXHJcbiogQHByb3BlcnR5IHttb2R1bGU6bnljL0dlb2NvZGVyfkdlb2NvZGVyfSB4IFRoZSBnZW9jb2RlciB0byB1c2UgZm9yIGdlb2NvZGluZyBmZWF0dXJlXHJcbiogQHByb3BlcnR5IHtzdHJpbmd9IGxvY2F0aW9uVGVtcGxhdGUgVGhlIGxvY2F0aW9uIHRlbXBsYXRlIGZvciBnZW5lcmF0aW5nIGEgbG9jYXRpb24gc3RyaW5nIHRvIHBhc3MgdG8gdGhlIGdlb2NvZGVyXHJcbiovXG5cblxuQ3N2QWRkci5PcHRpb25zO1xudmFyIF9kZWZhdWx0ID0gQ3N2QWRkcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7OztBQVFBOzs7OztBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQS9CQTtBQWdDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQTNIQTtBQThIQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///115\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nvar _2 = _interopRequireDefault(__webpack_require__(104));\n\nvar _BasemapHelper = _interopRequireDefault(__webpack_require__(126));\n\nvar _LocalStorage = _interopRequireDefault(__webpack_require__(127));\n\nvar _PluggableMap = _interopRequireDefault(__webpack_require__(148));\n\nvar _Map = _interopRequireDefault(__webpack_require__(154));\n\nvar _TileLayer = _interopRequireDefault(__webpack_require__(109));\n\nvar _VectorLayer = _interopRequireDefault(__webpack_require__(129));\n\nvar _VectorTileLayer = _interopRequireDefault(__webpack_require__(153));\n\nvar _DoubleClickZoom = _interopRequireDefault(__webpack_require__(130));\n\nvar _DragPan = _interopRequireDefault(__webpack_require__(131));\n\nvar _DragZoom = _interopRequireDefault(__webpack_require__(151));\n\nvar _KeyboardPan = _interopRequireDefault(__webpack_require__(152));\n\nvar _KeyboardZoom = _interopRequireDefault(__webpack_require__(132));\n\nvar _MouseWheelZoom = _interopRequireDefault(__webpack_require__(133));\n\nvar _PinchZoom = _interopRequireDefault(__webpack_require__(134));\n\nvar _View = _interopRequireDefault(__webpack_require__(107));\n\nvar _XYZ = _interopRequireDefault(__webpack_require__(106));\n\nvar _Tile = _interopRequireDefault(__webpack_require__(108));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/Basemap\r\n */\n\n\nvar proj4 = _["default"].proj4;\n/**\r\n * @desc Class that provides an ol.Map with base layers, labels, and drag-and-drop\r\n * @public\r\n * @class\r\n * @extends ol.PluggableMap\r\n * @mixes module:nyc/BasemapHelper~BasemapHelper\r\n * @see http://openlayers.org/en/latest/apidoc/module-ol_PluggableMap.html\r\n */\n\nvar Basemap =\n/*#__PURE__*/\nfunction (_PluggableMap$default) {\n  _inherits(Basemap, _PluggableMap$default);\n\n  /**\r\n   * @desc Create an instance of Basemap\r\n   * @public\r\n   * @constructor\r\n   * @param {olx.MapOptions} options Constructor options\r\n   * @param {number} [preload=0] Preload option for base layer\r\n   */\n  function Basemap(options, preload) {\n    var _this;\n\n    _classCallCheck(this, Basemap);\n\n    var viewProvided = options.view instanceof _View["default"];\n    Basemap.setupView(options);\n\n    if (!options.interactions) {\n      options.interactions = [new _DoubleClickZoom["default"](), new _DragPan["default"](), new _PinchZoom["default"](), new _KeyboardPan["default"](), new _KeyboardZoom["default"](), new _MouseWheelZoom["default"](), new _DragZoom["default"]()];\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Basemap).call(this, options));\n\n    _["default"].mixin(_assertThisInitialized(_this), [_BasemapHelper["default"]]);\n    /**\r\n     * @private\r\n     * @member {number}\r\n     */\n\n\n    _this.latestPhoto = 0;\n    /**\r\n     * @private\r\n     * @member {OlLayerTile}\r\n     */\n\n    _this.base = null;\n    /**\r\n     * @private\r\n     * @member {Object<string, OlLayerTile>}\r\n     */\n\n    _this.labels = {};\n    /**\r\n     * @private\r\n     * @member {Object<string, OlLayerTile>}\r\n     */\n\n    _this.photos = {};\n    /**\r\n     * @private\r\n     * @member {storage.Local}\r\n     */\n\n    _this.storage = new _LocalStorage["default"]();\n\n    _this.setupLayers(options, preload);\n\n    _this.defaultExtent(viewProvided);\n\n    _this.hookupEvents(_this.getTargetElement());\n\n    return _this;\n  }\n\n  _createClass(Basemap, [{\n    key: "createRenderer",\n    value: function createRenderer() {\n      var renderer = new _Map["default"](this);\n      renderer.registerLayerRenderers([_TileLayer["default"], _VectorLayer["default"], _VectorTileLayer["default"]]);\n      return renderer;\n    }\n    /**\r\n     * @desc Show photo layer\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @param {number=} year The photo year to show - shows the latest year if not provided\r\n     */\n\n  }, {\n    key: "showPhoto",\n    value: function showPhoto(year) {\n      this.hidePhoto();\n      this.photos[(year || this.latestPhoto) + \'\'].setVisible(true);\n      this.showLabels(\'photo\');\n    }\n    /**\r\n     * @desc Hide photo layer\r\n     * @public\r\n     * @override\r\n     * @method\r\n     */\n\n  }, {\n    key: "hidePhoto",\n    value: function hidePhoto() {\n      this.base.setVisible(true);\n      this.showLabels(_BasemapHelper["default"].LabelType.BASE);\n      Object.entries(this.photos).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            year = _ref2[0],\n            layer = _ref2[1];\n\n        layer.setVisible(false);\n      });\n    }\n    /**\r\n     * @desc Show the specified label layer\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @param {nyc.Basemap.BaseLayers} labelType The label type to show\r\n     */\n\n  }, {\n    key: "showLabels",\n    value: function showLabels(labelType) {\n      this.labels.base.setVisible(labelType === _BasemapHelper["default"].LabelType.BASE);\n      this.labels.photo.setVisible(labelType === _BasemapHelper["default"].LabelType.PHOTO);\n    }\n    /**\r\n     * @desc Returns the base layers\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @return {nyc.Basemap.BaseLayers} Base layers\r\n     */\n\n  }, {\n    key: "getBaseLayers",\n    value: function getBaseLayers() {\n      return {\n        base: this.base,\n        labels: this.labels,\n        photos: this.photos\n      };\n    }\n    /**\r\n     * @desc Get the storage used for loading and saving data\r\n     * @access protected\r\n     * @override\r\n     * @method\r\n     * @return {nyc.ol.storage.Local} srorage\r\n     */\n\n  }, {\n    key: "getStorage",\n    value: function getStorage() {\n      return this.storage;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {boolean} viewProvided was the view provided?\r\n     */\n\n  }, {\n    key: "defaultExtent",\n    value: function defaultExtent(viewProvided) {\n      if (!viewProvided) {\n        this.getView().fit(Basemap.EXTENT, this.getSize());\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} options Options\r\n     * @param {number} [preload=0] Preload\r\n     */\n\n  }, {\n    key: "setupLayers",\n    value: function setupLayers(options, preload) {\n      var _this2 = this;\n\n      var projection = \'EPSG:3857\';\n      this.base = new _Tile["default"]({\n        extent: this.layerExtent(Basemap.UNIVERSE_EXTENT, options.view),\n        source: new _XYZ["default"]({\n          url: Basemap.BASE_URL,\n          projection: projection\n        }),\n        preload: preload || 0\n      });\n      this.addLayer(this.base);\n      Object.entries(Basemap.LABEL_URLS).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            labelType = _ref4[0],\n            url = _ref4[1];\n\n        _this2.labels[labelType] = new _Tile["default"]({\n          extent: _this2.layerExtent(Basemap.LABEL_EXTENT, options.view),\n          source: new _XYZ["default"]({\n            url: url,\n            projection: projection\n          }),\n          zIndex: 1000,\n          visible: labelType === _BasemapHelper["default"].LabelType.BASE\n        });\n\n        _this2.addLayer(_this2.labels[labelType]);\n      });\n      Object.entries(Basemap.PHOTO_URLS).forEach(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            year = _ref6[0],\n            url = _ref6[1];\n\n        var photo = new _Tile["default"]({\n          extent: _this2.layerExtent(Basemap.PHOTO_EXTENT, options.view),\n          source: new _XYZ["default"]({\n            url: url,\n            projection: projection\n          }),\n          visible: false\n        });\n\n        if (year.split(\'-\')[0] * 1 > _this2.latestPhoto) {\n          _this2.latestPhoto = year;\n        }\n\n        photo.set(\'name\', year);\n\n        _this2.addLayer(photo);\n\n        photo.on(\'change:visible\', _jquery["default"].proxy(_this2.photoChange, _this2));\n        _this2.photos[year] = photo;\n      });\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {ol.Extent} extent Extent\r\n     * @param {ol.View|undefined} view The OpenLayers view\r\n     * @return {ol.Extent} The layer extent\r\n     */\n\n  }, {\n    key: "layerExtent",\n    value: function layerExtent(extent, view) {\n      if (view && view.getProjection().getCode() !== \'EPSG:3857\') {\n        var fr = \'EPSG:3857\';\n        var to = \'EPSG:2263\';\n        var bl = proj4(fr, to, [extent[0], extent[1]]);\n        var tr = proj4(fr, to, [extent[2], extent[3]]);\n        return [bl[0], bl[1], tr[0], tr[1]];\n      }\n\n      return extent;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "photoChange",\n    value: function photoChange() {\n      var _this3 = this;\n\n      var isPhoto = false;\n      Object.entries(this.photos).some(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            year = _ref8[0],\n            layer = _ref8[1];\n\n        isPhoto = layer.getVisible();\n\n        if (isPhoto) {\n          _this3.showLabels(_BasemapHelper["default"].LabelType.PHOTO);\n\n          return true;\n        }\n      });\n\n      if (!isPhoto) {\n        this.showLabels(_BasemapHelper["default"].LabelType.BASE);\n      }\n    }\n  }]);\n\n  return Basemap;\n}(_PluggableMap["default"]);\n/**\r\n * @private\r\n * @static\r\n * @method\r\n * @param {Object} options Options\r\n */\n\n\nBasemap.setupView = function (options) {\n  if (!(options.view instanceof _View["default"])) {\n    options.view = new _View["default"]({\n      center: Basemap.CENTER,\n      minZoom: 8,\n      maxZoom: 21,\n      zoom: 8,\n      constrainRotation: 1\n    });\n  }\n};\n/**\r\n * @desc The URL of the New York City base map tiles\r\n * @private\r\n * @const\r\n * @type {string}\r\n */\n\n\nBasemap.BASE_URL = "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/carto/basemap/{z}/{x}/{-y}.jpg");\n/**\r\n * @desc The URLs of the New York City aerial imagery map tiles\r\n * @private\r\n * @const\r\n * @type {Object<string, string>}\r\n */\n\nBasemap.PHOTO_URLS = {\n  \'1924\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/1924/{z}/{x}/{-y}.png8"),\n  \'1951\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/1951/{z}/{x}/{-y}.png8"),\n  \'1996\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/1996/{z}/{x}/{-y}.png8"),\n  \'2001-2\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2001-2/{z}/{x}/{-y}.png8"),\n  \'2004\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2004/{z}/{x}/{-y}.png8"),\n  \'2006\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2006/{z}/{x}/{-y}.png8"),\n  \'2008\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2008/{z}/{x}/{-y}.png8"),\n  \'2010\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2010/{z}/{x}/{-y}.png8"),\n  \'2012\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2012/{z}/{x}/{-y}.png8"),\n  \'2014\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2014/{z}/{x}/{-y}.png8"),\n  \'2016\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2016/{z}/{x}/{-y}.png8"),\n  \'2018\': "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/photo/2018/{z}/{x}/{-y}.png8")\n  /**\r\n   * @desc The URLs of the New York City base map label tiles\r\n   * @private\r\n   * @const\r\n   * @type {Object<string, string>}\r\n   */\n\n};\nBasemap.LABEL_URLS = {\n  base: "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/carto/label/{z}/{x}/{-y}.png8"),\n  photo: "https://".concat(_2["default"].TILE_HOSTS, "/tms/1.0.0/carto/label-lt/{z}/{x}/{-y}.png8")\n  /**\r\n   * @private\r\n   * @const\r\n   * @type {ol.Extent}\r\n   */\n\n};\nBasemap.UNIVERSE_EXTENT = [-8453323, 4774561, -7983695, 5165920];\n/**\r\n * @desc The bounds of New York City\r\n * @public\r\n * @const\r\n * @type {ol.Extent}\r\n */\n\nBasemap.EXTENT = [-8266522, 4937867, -8203781, 5000276];\n/**\r\n * @desc The center of New York City\r\n * @public\r\n * @const\r\n * @type {ol.Coordinate}\r\n */\n\nBasemap.CENTER = [-8235252, 4969073];\n/**\r\n * @private\r\n * @const\r\n * @type {ol.Extent}\r\n */\n\nBasemap.LABEL_EXTENT = [-8268000, 4870900, -8005000, 5055500];\n/**\r\n * @private\r\n * @const\r\n * @type {ol.Extent}\r\n */\n\nBasemap.PHOTO_EXTENT = [-8268357, 4937238, -8203099, 5001716];\nvar _default = Basemap;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL0Jhc2VtYXAuanM/N2UwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qcXVlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXG52YXIgXyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vLi5cIikpO1xuXG52YXIgXzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1wiKSk7XG5cbnZhciBfQmFzZW1hcEhlbHBlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL0Jhc2VtYXBIZWxwZXJcIikpO1xuXG52YXIgX0xvY2FsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vTG9jYWxTdG9yYWdlXCIpKTtcblxudmFyIF9QbHVnZ2FibGVNYXAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9QbHVnZ2FibGVNYXBcIikpO1xuXG52YXIgX01hcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL3JlbmRlcmVyL2NhbnZhcy9NYXBcIikpO1xuXG52YXIgX1RpbGVMYXllciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL3JlbmRlcmVyL2NhbnZhcy9UaWxlTGF5ZXJcIikpO1xuXG52YXIgX1ZlY3RvckxheWVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyXCIpKTtcblxudmFyIF9WZWN0b3JUaWxlTGF5ZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yVGlsZUxheWVyXCIpKTtcblxudmFyIF9Eb3VibGVDbGlja1pvb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb21cIikpO1xuXG52YXIgX0RyYWdQYW4gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9pbnRlcmFjdGlvbi9EcmFnUGFuXCIpKTtcblxudmFyIF9EcmFnWm9vbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL2ludGVyYWN0aW9uL0RyYWdab29tXCIpKTtcblxudmFyIF9LZXlib2FyZFBhbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuXCIpKTtcblxudmFyIF9LZXlib2FyZFpvb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb21cIikpO1xuXG52YXIgX01vdXNlV2hlZWxab29tID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvaW50ZXJhY3Rpb24vTW91c2VXaGVlbFpvb21cIikpO1xuXG52YXIgX1BpbmNoWm9vbSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL2ludGVyYWN0aW9uL1BpbmNoWm9vbVwiKSk7XG5cbnZhciBfVmlldyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL1ZpZXdcIikpO1xuXG52YXIgX1hZWiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL3NvdXJjZS9YWVpcIikpO1xuXG52YXIgX1RpbGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9sYXllci9UaWxlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL29sL0Jhc2VtYXBcclxuICovXG5jb25zdCBwcm9qNCA9IF8uZGVmYXVsdC5wcm9qNDtcbi8qKlxyXG4gKiBAZGVzYyBDbGFzcyB0aGF0IHByb3ZpZGVzIGFuIG9sLk1hcCB3aXRoIGJhc2UgbGF5ZXJzLCBsYWJlbHMsIGFuZCBkcmFnLWFuZC1kcm9wXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIG9sLlBsdWdnYWJsZU1hcFxyXG4gKiBAbWl4ZXMgbW9kdWxlOm55Yy9CYXNlbWFwSGVscGVyfkJhc2VtYXBIZWxwZXJcclxuICogQHNlZSBodHRwOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2FwaWRvYy9tb2R1bGUtb2xfUGx1Z2dhYmxlTWFwLmh0bWxcclxuICovXG5cbmNsYXNzIEJhc2VtYXAgZXh0ZW5kcyBfUGx1Z2dhYmxlTWFwLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQmFzZW1hcFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge29seC5NYXBPcHRpb25zfSBvcHRpb25zIENvbnN0cnVjdG9yIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWxvYWQ9MF0gUHJlbG9hZCBvcHRpb24gZm9yIGJhc2UgbGF5ZXJcclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcHJlbG9hZCkge1xuICAgIGNvbnN0IHZpZXdQcm92aWRlZCA9IG9wdGlvbnMudmlldyBpbnN0YW5jZW9mIF9WaWV3LmRlZmF1bHQ7XG4gICAgQmFzZW1hcC5zZXR1cFZpZXcob3B0aW9ucyk7XG5cbiAgICBpZiAoIW9wdGlvbnMuaW50ZXJhY3Rpb25zKSB7XG4gICAgICBvcHRpb25zLmludGVyYWN0aW9ucyA9IFtuZXcgX0RvdWJsZUNsaWNrWm9vbS5kZWZhdWx0KCksIG5ldyBfRHJhZ1Bhbi5kZWZhdWx0KCksIG5ldyBfUGluY2hab29tLmRlZmF1bHQoKSwgbmV3IF9LZXlib2FyZFBhbi5kZWZhdWx0KCksIG5ldyBfS2V5Ym9hcmRab29tLmRlZmF1bHQoKSwgbmV3IF9Nb3VzZVdoZWVsWm9vbS5kZWZhdWx0KCksIG5ldyBfRHJhZ1pvb20uZGVmYXVsdCgpXTtcbiAgICB9XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIF8uZGVmYXVsdC5taXhpbih0aGlzLCBbX0Jhc2VtYXBIZWxwZXIuZGVmYXVsdF0pO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xuXG5cbiAgICB0aGlzLmxhdGVzdFBob3RvID0gMDtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtPbExheWVyVGlsZX1cclxuICAgICAqL1xuXG4gICAgdGhpcy5iYXNlID0gbnVsbDtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtPYmplY3Q8c3RyaW5nLCBPbExheWVyVGlsZT59XHJcbiAgICAgKi9cblxuICAgIHRoaXMubGFiZWxzID0ge307XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7T2JqZWN0PHN0cmluZywgT2xMYXllclRpbGU+fVxyXG4gICAgICovXG5cbiAgICB0aGlzLnBob3RvcyA9IHt9O1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge3N0b3JhZ2UuTG9jYWx9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBfTG9jYWxTdG9yYWdlLmRlZmF1bHQoKTtcbiAgICB0aGlzLnNldHVwTGF5ZXJzKG9wdGlvbnMsIHByZWxvYWQpO1xuICAgIHRoaXMuZGVmYXVsdEV4dGVudCh2aWV3UHJvdmlkZWQpO1xuICAgIHRoaXMuaG9va3VwRXZlbnRzKHRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpKTtcbiAgfVxuXG4gIGNyZWF0ZVJlbmRlcmVyKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IF9NYXAuZGVmYXVsdCh0aGlzKTtcbiAgICByZW5kZXJlci5yZWdpc3RlckxheWVyUmVuZGVyZXJzKFtfVGlsZUxheWVyLmRlZmF1bHQsIF9WZWN0b3JMYXllci5kZWZhdWx0LCBfVmVjdG9yVGlsZUxheWVyLmRlZmF1bHRdKTtcbiAgICByZXR1cm4gcmVuZGVyZXI7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgU2hvdyBwaG90byBsYXllclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSB5ZWFyIFRoZSBwaG90byB5ZWFyIHRvIHNob3cgLSBzaG93cyB0aGUgbGF0ZXN0IHllYXIgaWYgbm90IHByb3ZpZGVkXHJcbiAgICovXG5cblxuICBzaG93UGhvdG8oeWVhcikge1xuICAgIHRoaXMuaGlkZVBob3RvKCk7XG4gICAgdGhpcy5waG90b3NbKHllYXIgfHwgdGhpcy5sYXRlc3RQaG90bykgKyAnJ10uc2V0VmlzaWJsZSh0cnVlKTtcbiAgICB0aGlzLnNob3dMYWJlbHMoJ3Bob3RvJyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgSGlkZSBwaG90byBsYXllclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICovXG5cblxuICBoaWRlUGhvdG8oKSB7XG4gICAgdGhpcy5iYXNlLnNldFZpc2libGUodHJ1ZSk7XG4gICAgdGhpcy5zaG93TGFiZWxzKF9CYXNlbWFwSGVscGVyLmRlZmF1bHQuTGFiZWxUeXBlLkJBU0UpO1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMucGhvdG9zKS5mb3JFYWNoKChbeWVhciwgbGF5ZXJdKSA9PiB7XG4gICAgICBsYXllci5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBTaG93IHRoZSBzcGVjaWZpZWQgbGFiZWwgbGF5ZXJcclxuICAgKiBAcHVibGljXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7bnljLkJhc2VtYXAuQmFzZUxheWVyc30gbGFiZWxUeXBlIFRoZSBsYWJlbCB0eXBlIHRvIHNob3dcclxuICAgKi9cblxuXG4gIHNob3dMYWJlbHMobGFiZWxUeXBlKSB7XG4gICAgdGhpcy5sYWJlbHMuYmFzZS5zZXRWaXNpYmxlKGxhYmVsVHlwZSA9PT0gX0Jhc2VtYXBIZWxwZXIuZGVmYXVsdC5MYWJlbFR5cGUuQkFTRSk7XG4gICAgdGhpcy5sYWJlbHMucGhvdG8uc2V0VmlzaWJsZShsYWJlbFR5cGUgPT09IF9CYXNlbWFwSGVscGVyLmRlZmF1bHQuTGFiZWxUeXBlLlBIT1RPKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBiYXNlIGxheWVyc1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHJldHVybiB7bnljLkJhc2VtYXAuQmFzZUxheWVyc30gQmFzZSBsYXllcnNcclxuICAgKi9cblxuXG4gIGdldEJhc2VMYXllcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IHRoaXMuYmFzZSxcbiAgICAgIGxhYmVsczogdGhpcy5sYWJlbHMsXG4gICAgICBwaG90b3M6IHRoaXMucGhvdG9zXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBHZXQgdGhlIHN0b3JhZ2UgdXNlZCBmb3IgbG9hZGluZyBhbmQgc2F2aW5nIGRhdGFcclxuICAgKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJuIHtueWMub2wuc3RvcmFnZS5Mb2NhbH0gc3JvcmFnZVxyXG4gICAqL1xuXG5cbiAgZ2V0U3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlld1Byb3ZpZGVkIHdhcyB0aGUgdmlldyBwcm92aWRlZD9cclxuICAgKi9cblxuXG4gIGRlZmF1bHRFeHRlbnQodmlld1Byb3ZpZGVkKSB7XG4gICAgaWYgKCF2aWV3UHJvdmlkZWQpIHtcbiAgICAgIHRoaXMuZ2V0VmlldygpLmZpdChCYXNlbWFwLkVYVEVOVCwgdGhpcy5nZXRTaXplKCkpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVsb2FkPTBdIFByZWxvYWRcclxuICAgKi9cblxuXG4gIHNldHVwTGF5ZXJzKG9wdGlvbnMsIHByZWxvYWQpIHtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gJ0VQU0c6Mzg1Nyc7XG4gICAgdGhpcy5iYXNlID0gbmV3IF9UaWxlLmRlZmF1bHQoe1xuICAgICAgZXh0ZW50OiB0aGlzLmxheWVyRXh0ZW50KEJhc2VtYXAuVU5JVkVSU0VfRVhURU5ULCBvcHRpb25zLnZpZXcpLFxuICAgICAgc291cmNlOiBuZXcgX1hZWi5kZWZhdWx0KHtcbiAgICAgICAgdXJsOiBCYXNlbWFwLkJBU0VfVVJMLFxuICAgICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uXG4gICAgICB9KSxcbiAgICAgIHByZWxvYWQ6IHByZWxvYWQgfHwgMFxuICAgIH0pO1xuICAgIHRoaXMuYWRkTGF5ZXIodGhpcy5iYXNlKTtcbiAgICBPYmplY3QuZW50cmllcyhCYXNlbWFwLkxBQkVMX1VSTFMpLmZvckVhY2goKFtsYWJlbFR5cGUsIHVybF0pID0+IHtcbiAgICAgIHRoaXMubGFiZWxzW2xhYmVsVHlwZV0gPSBuZXcgX1RpbGUuZGVmYXVsdCh7XG4gICAgICAgIGV4dGVudDogdGhpcy5sYXllckV4dGVudChCYXNlbWFwLkxBQkVMX0VYVEVOVCwgb3B0aW9ucy52aWV3KSxcbiAgICAgICAgc291cmNlOiBuZXcgX1hZWi5kZWZhdWx0KHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBwcm9qZWN0aW9uOiBwcm9qZWN0aW9uXG4gICAgICAgIH0pLFxuICAgICAgICB6SW5kZXg6IDEwMDAsXG4gICAgICAgIHZpc2libGU6IGxhYmVsVHlwZSA9PT0gX0Jhc2VtYXBIZWxwZXIuZGVmYXVsdC5MYWJlbFR5cGUuQkFTRVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZExheWVyKHRoaXMubGFiZWxzW2xhYmVsVHlwZV0pO1xuICAgIH0pO1xuICAgIE9iamVjdC5lbnRyaWVzKEJhc2VtYXAuUEhPVE9fVVJMUykuZm9yRWFjaCgoW3llYXIsIHVybF0pID0+IHtcbiAgICAgIGNvbnN0IHBob3RvID0gbmV3IF9UaWxlLmRlZmF1bHQoe1xuICAgICAgICBleHRlbnQ6IHRoaXMubGF5ZXJFeHRlbnQoQmFzZW1hcC5QSE9UT19FWFRFTlQsIG9wdGlvbnMudmlldyksXG4gICAgICAgIHNvdXJjZTogbmV3IF9YWVouZGVmYXVsdCh7XG4gICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgcHJvamVjdGlvbjogcHJvamVjdGlvblxuICAgICAgICB9KSxcbiAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoeWVhci5zcGxpdCgnLScpWzBdICogMSA+IHRoaXMubGF0ZXN0UGhvdG8pIHtcbiAgICAgICAgdGhpcy5sYXRlc3RQaG90byA9IHllYXI7XG4gICAgICB9XG5cbiAgICAgIHBob3RvLnNldCgnbmFtZScsIHllYXIpO1xuICAgICAgdGhpcy5hZGRMYXllcihwaG90byk7XG4gICAgICBwaG90by5vbignY2hhbmdlOnZpc2libGUnLCBfanF1ZXJ5LmRlZmF1bHQucHJveHkodGhpcy5waG90b0NoYW5nZSwgdGhpcykpO1xuICAgICAgdGhpcy5waG90b3NbeWVhcl0gPSBwaG90bztcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge29sLkV4dGVudH0gZXh0ZW50IEV4dGVudFxyXG4gICAqIEBwYXJhbSB7b2wuVmlld3x1bmRlZmluZWR9IHZpZXcgVGhlIE9wZW5MYXllcnMgdmlld1xyXG4gICAqIEByZXR1cm4ge29sLkV4dGVudH0gVGhlIGxheWVyIGV4dGVudFxyXG4gICAqL1xuXG5cbiAgbGF5ZXJFeHRlbnQoZXh0ZW50LCB2aWV3KSB7XG4gICAgaWYgKHZpZXcgJiYgdmlldy5nZXRQcm9qZWN0aW9uKCkuZ2V0Q29kZSgpICE9PSAnRVBTRzozODU3Jykge1xuICAgICAgY29uc3QgZnIgPSAnRVBTRzozODU3JztcbiAgICAgIGNvbnN0IHRvID0gJ0VQU0c6MjI2Myc7XG4gICAgICBjb25zdCBibCA9IHByb2o0KGZyLCB0bywgW2V4dGVudFswXSwgZXh0ZW50WzFdXSk7XG4gICAgICBjb25zdCB0ciA9IHByb2o0KGZyLCB0bywgW2V4dGVudFsyXSwgZXh0ZW50WzNdXSk7XG4gICAgICByZXR1cm4gW2JsWzBdLCBibFsxXSwgdHJbMF0sIHRyWzFdXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqL1xuXG5cbiAgcGhvdG9DaGFuZ2UoKSB7XG4gICAgbGV0IGlzUGhvdG8gPSBmYWxzZTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLnBob3Rvcykuc29tZSgoW3llYXIsIGxheWVyXSkgPT4ge1xuICAgICAgaXNQaG90byA9IGxheWVyLmdldFZpc2libGUoKTtcblxuICAgICAgaWYgKGlzUGhvdG8pIHtcbiAgICAgICAgdGhpcy5zaG93TGFiZWxzKF9CYXNlbWFwSGVscGVyLmRlZmF1bHQuTGFiZWxUeXBlLlBIT1RPKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWlzUGhvdG8pIHtcbiAgICAgIHRoaXMuc2hvd0xhYmVscyhfQmFzZW1hcEhlbHBlci5kZWZhdWx0LkxhYmVsVHlwZS5CQVNFKTtcbiAgICB9XG4gIH1cblxufVxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzdGF0aWNcclxuICogQG1ldGhvZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zXHJcbiAqL1xuXG5cbkJhc2VtYXAuc2V0dXBWaWV3ID0gb3B0aW9ucyA9PiB7XG4gIGlmICghKG9wdGlvbnMudmlldyBpbnN0YW5jZW9mIF9WaWV3LmRlZmF1bHQpKSB7XG4gICAgb3B0aW9ucy52aWV3ID0gbmV3IF9WaWV3LmRlZmF1bHQoe1xuICAgICAgY2VudGVyOiBCYXNlbWFwLkNFTlRFUixcbiAgICAgIG1pblpvb206IDgsXG4gICAgICBtYXhab29tOiAyMSxcbiAgICAgIHpvb206IDgsXG4gICAgICBjb25zdHJhaW5Sb3RhdGlvbjogMVxuICAgIH0pO1xuICB9XG59O1xuLyoqXHJcbiAqIEBkZXNjIFRoZSBVUkwgb2YgdGhlIE5ldyBZb3JrIENpdHkgYmFzZSBtYXAgdGlsZXNcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG5cbkJhc2VtYXAuQkFTRV9VUkwgPSBgaHR0cHM6Ly8ke18yLmRlZmF1bHQuVElMRV9IT1NUU30vdG1zLzEuMC4wL2NhcnRvL2Jhc2VtYXAve3p9L3t4fS97LXl9LmpwZ2A7XG4vKipcclxuICogQGRlc2MgVGhlIFVSTHMgb2YgdGhlIE5ldyBZb3JrIENpdHkgYWVyaWFsIGltYWdlcnkgbWFwIHRpbGVzXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn1cclxuICovXG5cbkJhc2VtYXAuUEhPVE9fVVJMUyA9IHtcbiAgJzE5MjQnOiBgaHR0cHM6Ly8ke18yLmRlZmF1bHQuVElMRV9IT1NUU30vdG1zLzEuMC4wL3Bob3RvLzE5MjQve3p9L3t4fS97LXl9LnBuZzhgLFxuICAnMTk1MSc6IGBodHRwczovLyR7XzIuZGVmYXVsdC5USUxFX0hPU1RTfS90bXMvMS4wLjAvcGhvdG8vMTk1MS97en0ve3h9L3steX0ucG5nOGAsXG4gICcxOTk2JzogYGh0dHBzOi8vJHtfMi5kZWZhdWx0LlRJTEVfSE9TVFN9L3Rtcy8xLjAuMC9waG90by8xOTk2L3t6fS97eH0vey15fS5wbmc4YCxcbiAgJzIwMDEtMic6IGBodHRwczovLyR7XzIuZGVmYXVsdC5USUxFX0hPU1RTfS90bXMvMS4wLjAvcGhvdG8vMjAwMS0yL3t6fS97eH0vey15fS5wbmc4YCxcbiAgJzIwMDQnOiBgaHR0cHM6Ly8ke18yLmRlZmF1bHQuVElMRV9IT1NUU30vdG1zLzEuMC4wL3Bob3RvLzIwMDQve3p9L3t4fS97LXl9LnBuZzhgLFxuICAnMjAwNic6IGBodHRwczovLyR7XzIuZGVmYXVsdC5USUxFX0hPU1RTfS90bXMvMS4wLjAvcGhvdG8vMjAwNi97en0ve3h9L3steX0ucG5nOGAsXG4gICcyMDA4JzogYGh0dHBzOi8vJHtfMi5kZWZhdWx0LlRJTEVfSE9TVFN9L3Rtcy8xLjAuMC9waG90by8yMDA4L3t6fS97eH0vey15fS5wbmc4YCxcbiAgJzIwMTAnOiBgaHR0cHM6Ly8ke18yLmRlZmF1bHQuVElMRV9IT1NUU30vdG1zLzEuMC4wL3Bob3RvLzIwMTAve3p9L3t4fS97LXl9LnBuZzhgLFxuICAnMjAxMic6IGBodHRwczovLyR7XzIuZGVmYXVsdC5USUxFX0hPU1RTfS90bXMvMS4wLjAvcGhvdG8vMjAxMi97en0ve3h9L3steX0ucG5nOGAsXG4gICcyMDE0JzogYGh0dHBzOi8vJHtfMi5kZWZhdWx0LlRJTEVfSE9TVFN9L3Rtcy8xLjAuMC9waG90by8yMDE0L3t6fS97eH0vey15fS5wbmc4YCxcbiAgJzIwMTYnOiBgaHR0cHM6Ly8ke18yLmRlZmF1bHQuVElMRV9IT1NUU30vdG1zLzEuMC4wL3Bob3RvLzIwMTYve3p9L3t4fS97LXl9LnBuZzhgLFxuICAnMjAxOCc6IGBodHRwczovLyR7XzIuZGVmYXVsdC5USUxFX0hPU1RTfS90bXMvMS4wLjAvcGhvdG8vMjAxOC97en0ve3h9L3steX0ucG5nOGBcbiAgLyoqXHJcbiAgICogQGRlc2MgVGhlIFVSTHMgb2YgdGhlIE5ldyBZb3JrIENpdHkgYmFzZSBtYXAgbGFiZWwgdGlsZXNcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBjb25zdFxyXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxyXG4gICAqL1xuXG59O1xuQmFzZW1hcC5MQUJFTF9VUkxTID0ge1xuICBiYXNlOiBgaHR0cHM6Ly8ke18yLmRlZmF1bHQuVElMRV9IT1NUU30vdG1zLzEuMC4wL2NhcnRvL2xhYmVsL3t6fS97eH0vey15fS5wbmc4YCxcbiAgcGhvdG86IGBodHRwczovLyR7XzIuZGVmYXVsdC5USUxFX0hPU1RTfS90bXMvMS4wLjAvY2FydG8vbGFiZWwtbHQve3p9L3t4fS97LXl9LnBuZzhgXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQGNvbnN0XHJcbiAgICogQHR5cGUge29sLkV4dGVudH1cclxuICAgKi9cblxufTtcbkJhc2VtYXAuVU5JVkVSU0VfRVhURU5UID0gWy04NDUzMzIzLCA0Nzc0NTYxLCAtNzk4MzY5NSwgNTE2NTkyMF07XG4vKipcclxuICogQGRlc2MgVGhlIGJvdW5kcyBvZiBOZXcgWW9yayBDaXR5XHJcbiAqIEBwdWJsaWNcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtvbC5FeHRlbnR9XHJcbiAqL1xuXG5CYXNlbWFwLkVYVEVOVCA9IFstODI2NjUyMiwgNDkzNzg2NywgLTgyMDM3ODEsIDUwMDAyNzZdO1xuLyoqXHJcbiAqIEBkZXNjIFRoZSBjZW50ZXIgb2YgTmV3IFlvcmsgQ2l0eVxyXG4gKiBAcHVibGljXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7b2wuQ29vcmRpbmF0ZX1cclxuICovXG5cbkJhc2VtYXAuQ0VOVEVSID0gWy04MjM1MjUyLCA0OTY5MDczXTtcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RcclxuICogQHR5cGUge29sLkV4dGVudH1cclxuICovXG5cbkJhc2VtYXAuTEFCRUxfRVhURU5UID0gWy04MjY4MDAwLCA0ODcwOTAwLCAtODAwNTAwMCwgNTA1NTUwMF07XG4vKipcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtvbC5FeHRlbnR9XHJcbiAqL1xuXG5CYXNlbWFwLlBIT1RPX0VYVEVOVCA9IFstODI2ODM1NywgNDkzNzIzOCwgLTgyMDMwOTksIDUwMDE3MTZdO1xudmFyIF9kZWZhdWx0ID0gQmFzZW1hcDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7OztBQUdBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7OztBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQTdDQTtBQTZDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTkE7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBUEE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQXpPQTtBQTRPQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFiQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBSEE7QUFVQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///116\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Overlay = _interopRequireDefault(__webpack_require__(114));\n\nvar _easing = __webpack_require__(28);\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/Popup\r\n */\n\n/**\r\n * @desc A class to display popups on a map\r\n * @public\r\n * @class\r\n * @extends ol.Overlay\r\n * @see http://openlayers.org/en/latest/apidoc/module-ol_Overlay.html\r\n */\n\n\nvar Popup =\n/*#__PURE__*/\nfunction (_Overlay$default) {\n  _inherits(Popup, _Overlay$default);\n\n  /**\r\n   * @desc Create an instance of Popup\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/ol/Popup~Popup.Options} options Constructor options\r\n   */\n  function Popup(options) {\n    var _this;\n\n    _classCallCheck(this, Popup);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Popup).call(this, {\n      id: _["default"].nextId(\'Popup\'),\n      element: (0, _jquery["default"])(Popup.HTML).get(0),\n      // stopEvent: true,\n      autoPanMargin: options.autoPanMargin === undefined ? 10 : options.autoPanMargin,\n      autoPanAnimation: options.autoPanAnimation === undefined ? {\n        duration: 1000,\n        easing: _easing.linear\n      } : options.autoPanAnimation\n    }));\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.popup = (0, _jquery["default"])(_this.getElement());\n    /**\r\n     * @private\r\n     * @member {ol.Map}\r\n     */\n\n    _this.map = options.map;\n\n    _this.setMap(_this.map);\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n\n    _this.content = _this.popup.find(\'.content\');\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.fullscreen = (0, _jquery["default"])(Popup.FULLSCREEN_HTML);\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.closeFullscreen = _this.fullscreen.find(\'.btn-x\');\n    (0, _jquery["default"])(_this.map.getTargetElement()).append(_this.fullscreen);\n\n    _this.popup.find(\'.btn-x\').on(\'click tap\', _jquery["default"].proxy(_this.hide, _assertThisInitialized(_this)));\n\n    _this.popup.on(\'mouseover mousemove\', _jquery["default"].proxy(_this.hideTip, _assertThisInitialized(_this)));\n\n    return _this;\n  }\n  /**\r\n   * @desc Show the popup\r\n   * @public\r\n   * @method\r\n   * @param {module:nyc/ol/Popup~Popup.ShowOptions} options Overlay options\r\n   */\n\n\n  _createClass(Popup, [{\n    key: "show",\n    value: function show(options) {\n      if (options.html) {\n        this.content.html(options.html);\n        this.cssClass(options.css);\n      }\n\n      this.setPosition(options.coordinate);\n      this.popup.fadeIn(_jquery["default"].proxy(this.pan, this));\n      (0, _jquery["default"])(\'.f-tip\').fadeOut();\n    }\n    /**\r\n     * @desc Set a CSS class for the popup content\r\n     * @public\r\n     * @method\r\n     * @param {string} css A css class\r\n     */\n\n  }, {\n    key: "cssClass",\n    value: function cssClass(css) {\n      this.content.get(0).className = \'content\';\n      this.content.addClass(css);\n    }\n    /**\r\n     * @desc Hide the popup\r\n     * @public\r\n     * @method\r\n     */\n\n  }, {\n    key: "hide",\n    value: function hide() {\n      this.popup.fadeOut();\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: "hideTip",\n    value: function hideTip(event) {\n      event.stopPropagation();\n      (0, _jquery["default"])(\'.f-tip\').fadeOut();\n    }\n    /**\r\n     * @desc Pan the popup so it full appears on the map\r\n     * @public\r\n     * @method\r\n     */\n\n  }, {\n    key: "pan",\n    value: function pan() {\n      if (!this.isFullscreen() && this.popup.css(\'display\') !== \'none\') {\n        this.panIntoView();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @returns {boolean} True if fullscreen\r\n     */\n\n  }, {\n    key: "isFullscreen",\n    value: function isFullscreen() {\n      var pop = (0, _jquery["default"])(this.getElement());\n      var map = (0, _jquery["default"])(this.map.getTargetElement());\n\n      if (pop.height() > map.height()) {\n        this.goFullscreen();\n        return true;\n      }\n    }\n    /**\r\n     * @desc Make the popup fill the map\r\n     * @public\r\n     * @method\r\n     */\n\n  }, {\n    key: "goFullscreen",\n    value: function goFullscreen() {\n      var pop = (0, _jquery["default"])(this.getElement());\n      var content = this.content;\n      var fullscreen = this.fullscreen;\n\n      var hide = _jquery["default"].proxy(this.hide, this);\n\n      fullscreen.append(content);\n      this.closeFullscreen.click(function () {\n        fullscreen.fadeOut();\n        pop.append(content);\n      });\n      fullscreen.fadeIn(hide);\n    }\n  }]);\n\n  return Popup;\n}(_Overlay["default"]);\n/**\r\n * @desc Options for {@link module:nyc/ol/Popup~Popup#show}\r\n * @public\r\n * @typedef {Object}\r\n * @property {jQuery|Element|string} html The popup content\r\n * @property {ol.coordinate} coordinate The popup location\r\n * @property {string=} css A css class\r\n */\n\n\nPopup.ShowOptions;\n/**\r\n * @desc Constructor option for {@link module:nyc/ol/Popup~Popup}\r\n * @public\r\n * @typedef {Object}\r\n * @property {ol.Map} map The map\r\n * @property {number} [autoPanMargin=10] The margin the popup will maintain from the edge of the map\r\n */\n\nPopup.Options;\n/**\r\n * @private\r\n * @const {string}\r\n */\n\nPopup.HTML = \'<div class="pop">\' + \'<div class="content"></div>\' + \'<button class="btn btn-rnd btn-x">\' + \'<span class="screen-reader-only">Dismiss popup</span>\' + \'<span class="fas fa-times" role="img"></span>\' + \'</button>\' + \'</div>\';\n/**\r\n * @private\r\n * @const {string}\r\n */\n\nPopup.FULLSCREEN_HTML = \'<div class="pop fullscreen">\' + \'<button class="btn btn-rnd btn-x">\' + \'<span class="screen-reader-only">Close</span>\' + \'<span class="fas fa-times" role="img"></span>\' + \'</button>\' + \'</div>\';\nvar _default = Popup;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL1BvcHVwLmpzP2M4MjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfanF1ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwianF1ZXJ5XCIpKTtcblxudmFyIF9PdmVybGF5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvT3ZlcmxheVwiKSk7XG5cbnZhciBfZWFzaW5nID0gcmVxdWlyZShcIm9sL2Vhc2luZ1wiKTtcblxudmFyIF8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLy4uXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL29sL1BvcHVwXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQSBjbGFzcyB0byBkaXNwbGF5IHBvcHVwcyBvbiBhIG1hcFxyXG4gKiBAcHVibGljXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBvbC5PdmVybGF5XHJcbiAqIEBzZWUgaHR0cDovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX092ZXJsYXkuaHRtbFxyXG4gKi9cbmNsYXNzIFBvcHVwIGV4dGVuZHMgX092ZXJsYXkuZGVmYXVsdCB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBQb3B1cFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvb2wvUG9wdXB+UG9wdXAuT3B0aW9uc30gb3B0aW9ucyBDb25zdHJ1Y3RvciBvcHRpb25zXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBpZDogXy5kZWZhdWx0Lm5leHRJZCgnUG9wdXAnKSxcbiAgICAgIGVsZW1lbnQ6ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKFBvcHVwLkhUTUwpLmdldCgwKSxcbiAgICAgIC8vIHN0b3BFdmVudDogdHJ1ZSxcbiAgICAgIGF1dG9QYW5NYXJnaW46IG9wdGlvbnMuYXV0b1Bhbk1hcmdpbiA9PT0gdW5kZWZpbmVkID8gMTAgOiBvcHRpb25zLmF1dG9QYW5NYXJnaW4sXG4gICAgICBhdXRvUGFuQW5pbWF0aW9uOiBvcHRpb25zLmF1dG9QYW5BbmltYXRpb24gPT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICAgIGVhc2luZzogX2Vhc2luZy5saW5lYXJcbiAgICAgIH0gOiBvcHRpb25zLmF1dG9QYW5BbmltYXRpb25cbiAgICB9KTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtqUXVlcnl9XHJcbiAgICAgKi9cblxuICAgIHRoaXMucG9wdXAgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KSh0aGlzLmdldEVsZW1lbnQoKSk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7b2wuTWFwfVxyXG4gICAgICovXG5cbiAgICB0aGlzLm1hcCA9IG9wdGlvbnMubWFwO1xuICAgIHRoaXMuc2V0TWFwKHRoaXMubWFwKTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtqUXVlcnl9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuY29udGVudCA9IHRoaXMucG9wdXAuZmluZCgnLmNvbnRlbnQnKTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtqUXVlcnl9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuZnVsbHNjcmVlbiA9ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKFBvcHVwLkZVTExTQ1JFRU5fSFRNTCk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7alF1ZXJ5fVxyXG4gICAgICovXG5cbiAgICB0aGlzLmNsb3NlRnVsbHNjcmVlbiA9IHRoaXMuZnVsbHNjcmVlbi5maW5kKCcuYnRuLXgnKTtcbiAgICAoMCwgX2pxdWVyeS5kZWZhdWx0KSh0aGlzLm1hcC5nZXRUYXJnZXRFbGVtZW50KCkpLmFwcGVuZCh0aGlzLmZ1bGxzY3JlZW4pO1xuICAgIHRoaXMucG9wdXAuZmluZCgnLmJ0bi14Jykub24oJ2NsaWNrIHRhcCcsIF9qcXVlcnkuZGVmYXVsdC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpKTtcbiAgICB0aGlzLnBvcHVwLm9uKCdtb3VzZW92ZXIgbW91c2Vtb3ZlJywgX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMuaGlkZVRpcCwgdGhpcykpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFNob3cgdGhlIHBvcHVwXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvb2wvUG9wdXB+UG9wdXAuU2hvd09wdGlvbnN9IG9wdGlvbnMgT3ZlcmxheSBvcHRpb25zXHJcbiAgICovXG5cblxuICBzaG93KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5odG1sKSB7XG4gICAgICB0aGlzLmNvbnRlbnQuaHRtbChvcHRpb25zLmh0bWwpO1xuICAgICAgdGhpcy5jc3NDbGFzcyhvcHRpb25zLmNzcyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRQb3NpdGlvbihvcHRpb25zLmNvb3JkaW5hdGUpO1xuICAgIHRoaXMucG9wdXAuZmFkZUluKF9qcXVlcnkuZGVmYXVsdC5wcm94eSh0aGlzLnBhbiwgdGhpcykpO1xuICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKCcuZi10aXAnKS5mYWRlT3V0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgU2V0IGEgQ1NTIGNsYXNzIGZvciB0aGUgcG9wdXAgY29udGVudFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzcyBBIGNzcyBjbGFzc1xyXG4gICAqL1xuXG5cbiAgY3NzQ2xhc3MoY3NzKSB7XG4gICAgdGhpcy5jb250ZW50LmdldCgwKS5jbGFzc05hbWUgPSAnY29udGVudCc7XG4gICAgdGhpcy5jb250ZW50LmFkZENsYXNzKGNzcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgSGlkZSB0aGUgcG9wdXBcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqL1xuXG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnBvcHVwLmZhZGVPdXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XHJcbiAgICovXG5cblxuICBoaWRlVGlwKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoJy5mLXRpcCcpLmZhZGVPdXQoKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBQYW4gdGhlIHBvcHVwIHNvIGl0IGZ1bGwgYXBwZWFycyBvbiB0aGUgbWFwXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKi9cblxuXG4gIHBhbigpIHtcbiAgICBpZiAoIXRoaXMuaXNGdWxsc2NyZWVuKCkgJiYgdGhpcy5wb3B1cC5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLnBhbkludG9WaWV3KCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGZ1bGxzY3JlZW5cclxuICAgKi9cblxuXG4gIGlzRnVsbHNjcmVlbigpIHtcbiAgICBjb25zdCBwb3AgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KSh0aGlzLmdldEVsZW1lbnQoKSk7XG4gICAgY29uc3QgbWFwID0gKDAsIF9qcXVlcnkuZGVmYXVsdCkodGhpcy5tYXAuZ2V0VGFyZ2V0RWxlbWVudCgpKTtcblxuICAgIGlmIChwb3AuaGVpZ2h0KCkgPiBtYXAuaGVpZ2h0KCkpIHtcbiAgICAgIHRoaXMuZ29GdWxsc2NyZWVuKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgTWFrZSB0aGUgcG9wdXAgZmlsbCB0aGUgbWFwXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKi9cblxuXG4gIGdvRnVsbHNjcmVlbigpIHtcbiAgICBjb25zdCBwb3AgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KSh0aGlzLmdldEVsZW1lbnQoKSk7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICBjb25zdCBmdWxsc2NyZWVuID0gdGhpcy5mdWxsc2NyZWVuO1xuXG4gICAgY29uc3QgaGlkZSA9IF9qcXVlcnkuZGVmYXVsdC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpO1xuXG4gICAgZnVsbHNjcmVlbi5hcHBlbmQoY29udGVudCk7XG4gICAgdGhpcy5jbG9zZUZ1bGxzY3JlZW4uY2xpY2soKCkgPT4ge1xuICAgICAgZnVsbHNjcmVlbi5mYWRlT3V0KCk7XG4gICAgICBwb3AuYXBwZW5kKGNvbnRlbnQpO1xuICAgIH0pO1xuICAgIGZ1bGxzY3JlZW4uZmFkZUluKGhpZGUpO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBAZGVzYyBPcHRpb25zIGZvciB7QGxpbmsgbW9kdWxlOm55Yy9vbC9Qb3B1cH5Qb3B1cCNzaG93fVxyXG4gKiBAcHVibGljXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSBodG1sIFRoZSBwb3B1cCBjb250ZW50XHJcbiAqIEBwcm9wZXJ0eSB7b2wuY29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgcG9wdXAgbG9jYXRpb25cclxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBjc3MgQSBjc3MgY2xhc3NcclxuICovXG5cblxuUG9wdXAuU2hvd09wdGlvbnM7XG4vKipcclxuICogQGRlc2MgQ29uc3RydWN0b3Igb3B0aW9uIGZvciB7QGxpbmsgbW9kdWxlOm55Yy9vbC9Qb3B1cH5Qb3B1cH1cclxuICogQHB1YmxpY1xyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fVxyXG4gKiBAcHJvcGVydHkge29sLk1hcH0gbWFwIFRoZSBtYXBcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthdXRvUGFuTWFyZ2luPTEwXSBUaGUgbWFyZ2luIHRoZSBwb3B1cCB3aWxsIG1haW50YWluIGZyb20gdGhlIGVkZ2Ugb2YgdGhlIG1hcFxyXG4gKi9cblxuUG9wdXAuT3B0aW9ucztcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3Qge3N0cmluZ31cclxuICovXG5cblBvcHVwLkhUTUwgPSAnPGRpdiBjbGFzcz1cInBvcFwiPicgKyAnPGRpdiBjbGFzcz1cImNvbnRlbnRcIj48L2Rpdj4nICsgJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLXJuZCBidG4teFwiPicgKyAnPHNwYW4gY2xhc3M9XCJzY3JlZW4tcmVhZGVyLW9ubHlcIj5EaXNtaXNzIHBvcHVwPC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJmYXMgZmEtdGltZXNcIiByb2xlPVwiaW1nXCI+PC9zcGFuPicgKyAnPC9idXR0b24+JyArICc8L2Rpdj4nO1xuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdCB7c3RyaW5nfVxyXG4gKi9cblxuUG9wdXAuRlVMTFNDUkVFTl9IVE1MID0gJzxkaXYgY2xhc3M9XCJwb3AgZnVsbHNjcmVlblwiPicgKyAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcm5kIGJ0bi14XCI+JyArICc8c3BhbiBjbGFzcz1cInNjcmVlbi1yZWFkZXItb25seVwiPkNsb3NlPC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJmYXMgZmEtdGltZXNcIiByb2xlPVwiaW1nXCI+PC9zcGFuPicgKyAnPC9idXR0b24+JyArICc8L2Rpdj4nO1xudmFyIF9kZWZhdWx0ID0gUG9wdXA7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUlBOzs7Ozs7Ozs7QUFPQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBVUE7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBN0NBO0FBNkNBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUF4SkE7QUEySkE7Ozs7Ozs7Ozs7QUFVQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///117\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nvar _Container = _interopRequireDefault(__webpack_require__(69));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\r\n * @module nyc/Tabs\r\n */\n\n/**\r\n * @desc  A class for creating and managing tabs\r\n * @public\r\n * @class\r\n * @extends module:nyc/Container~Container\r\n */\n\n\nvar Tabs =\n/*#__PURE__*/\nfunction (_Container$default) {\n  _inherits(Tabs, _Container$default);\n\n  /**\r\n   * @desc Create an instance of Tabs\r\n   * @constructor\r\n   * @param {module:nyc/Tabs~Tabs.Options} options Constructor options\r\n   */\n  function Tabs(options) {\n    var _this;\n\n    _classCallCheck(this, Tabs);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tabs).call(this, options.target));\n\n    _this.getContainer().append((0, _jquery[\"default\"])(Tabs.HTML)).addClass('tabs');\n\n    _this.btns = _this.find('.btns');\n    _this.tabs = _this.find('.container');\n    /**\r\n     * @desc The active tab\r\n     * @public\r\n     * @member {jQuery}\r\n     */\n\n    _this.active = null;\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.ready = false;\n\n    _this.render(options.tabs);\n\n    return _this;\n  }\n  /**\r\n   * @desc Open a tab\r\n   * @public\r\n   * @method\r\n   * @param {jQuery|Element|string} tab Tab panel\r\n   */\n\n\n  _createClass(Tabs, [{\n    key: \"open\",\n    value: function open(tab) {\n      tab = this.find(tab);\n      this.find('.btns h2').removeClass('active');\n      this.find('.tab').attr('aria-hidden', true).removeClass('active');\n      this.btns.find('.btn').removeClass('active');\n      tab.addClass('active').attr('aria-hidden', false).attr('tabindex', 1000).focus();\n      this.find('.btn').attr('aria-selected', false);\n      tab.data('btn').addClass('active').attr('aria-selected', true).parent().addClass('active');\n      this.active = tab;\n      this.trigger('change', this);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Array<module:nyc/Tabs~Tabs.Tab>} tabs The tabs\r\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(tabs) {\n      var _this2 = this;\n\n      var opened = false;\n      tabs.forEach(function (tab, i) {\n        var btnId = _[\"default\"].nextId('tab-btn');\n\n        var tb = (0, _jquery[\"default\"])(tab.tab).addClass(\"tab tab-\".concat(i)).attr('aria-labelledby', btnId).attr('role', 'tabpanel').attr('aria-hidden', true);\n\n        var pnlId = tb.attr('id') || _[\"default\"].nextId('tab-pnl');\n\n        tb.attr('id', pnlId);\n        var btn = (0, _jquery[\"default\"])(Tabs.BTN_HTML).attr('id', btnId).attr('aria-controls', pnlId).attr('aria-selected', false).click(_jquery[\"default\"].proxy(_this2.btnClick, _this2)).addClass(\"btn-tab btn-\".concat(i)).data('tab', tb).append(tab.title);\n        tb.data('btn', btn);\n\n        _this2.btns.append((0, _jquery[\"default\"])('<h2></h2>').append(btn));\n\n        _this2.tabs.append(tb);\n\n        if (tab.active) {\n          _this2.open(tb);\n\n          opened = true;\n        }\n      });\n\n      if (!opened) {\n        this.open(tabs[0].tab);\n      }\n\n      this.ready = true;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: \"btnClick\",\n    value: function btnClick(event) {\n      this.open((0, _jquery[\"default\"])(event.currentTarget).data('tab'));\n    }\n  }]);\n\n  return Tabs;\n}(_Container[\"default\"]);\n/**\r\n * @desc Contructor options for {@link module:nyc/Tabs~Tabs}\r\n * @public\r\n * @typedef {Object}\r\n * @property {jQuery|Element|string} target The target DOM node for Tabs\r\n * @property {Array<module:nyc/Tabs~Tabs.Tab>} tabs The tabs\r\n */\n\n\nTabs.Options;\n/**\r\n * @desc Object type to hold a tab definition\r\n * @public\r\n * @typedef {Object}\r\n * @property {jQuery|Element|string} tab The target DOM node for tab\r\n * @property {string} title The tab title\r\n * @property {boolean} [active=false] Active state of the tab\r\n */\n\nTabs.Tab;\n/**\r\n * @private\r\n * @const\r\n * @type {string}\r\n */\n\nTabs.HTML = '<div class=\"btns\" role=\"tablist\"></div>' + '<div class=\"container\" tabindex=\"-1\"></div>';\n/**\r\n * @private\r\n * @const\r\n * @type {string}\r\n */\n\nTabs.BTN_HTML = '<button class=\"btn\" role=\"tab\"></button>';\nvar _default = Tabs;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL1RhYnMuanM/NDdiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qcXVlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXG52YXIgXyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vXCIpKTtcblxudmFyIF9Db250YWluZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9UYWJzXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgIEEgY2xhc3MgZm9yIGNyZWF0aW5nIGFuZCBtYW5hZ2luZyB0YWJzXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIG1vZHVsZTpueWMvQ29udGFpbmVyfkNvbnRhaW5lclxyXG4gKi9cbmNsYXNzIFRhYnMgZXh0ZW5kcyBfQ29udGFpbmVyLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVGFic1xyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9UYWJzflRhYnMuT3B0aW9uc30gb3B0aW9ucyBDb25zdHJ1Y3RvciBvcHRpb25zXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zLnRhcmdldCk7XG4gICAgdGhpcy5nZXRDb250YWluZXIoKS5hcHBlbmQoKDAsIF9qcXVlcnkuZGVmYXVsdCkoVGFicy5IVE1MKSkuYWRkQ2xhc3MoJ3RhYnMnKTtcbiAgICB0aGlzLmJ0bnMgPSB0aGlzLmZpbmQoJy5idG5zJyk7XG4gICAgdGhpcy50YWJzID0gdGhpcy5maW5kKCcuY29udGFpbmVyJyk7XG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyBUaGUgYWN0aXZlIHRhYlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG1lbWJlciB7alF1ZXJ5fVxyXG4gICAgICovXG5cbiAgICB0aGlzLmFjdGl2ZSA9IG51bGw7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7alF1ZXJ5fVxyXG4gICAgICovXG5cbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXIob3B0aW9ucy50YWJzKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBPcGVuIGEgdGFiXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeXxFbGVtZW50fHN0cmluZ30gdGFiIFRhYiBwYW5lbFxyXG4gICAqL1xuXG5cbiAgb3Blbih0YWIpIHtcbiAgICB0YWIgPSB0aGlzLmZpbmQodGFiKTtcbiAgICB0aGlzLmZpbmQoJy5idG5zIGgyJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIHRoaXMuZmluZCgnLnRhYicpLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIHRoaXMuYnRucy5maW5kKCcuYnRuJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIHRhYi5hZGRDbGFzcygnYWN0aXZlJykuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSkuYXR0cigndGFiaW5kZXgnLCAxMDAwKS5mb2N1cygpO1xuICAgIHRoaXMuZmluZCgnLmJ0bicpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgdGFiLmRhdGEoJ2J0bicpLmFkZENsYXNzKCdhY3RpdmUnKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkucGFyZW50KCkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIHRoaXMuYWN0aXZlID0gdGFiO1xuICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtBcnJheTxtb2R1bGU6bnljL1RhYnN+VGFicy5UYWI+fSB0YWJzIFRoZSB0YWJzXHJcbiAgICovXG5cblxuICByZW5kZXIodGFicykge1xuICAgIGxldCBvcGVuZWQgPSBmYWxzZTtcbiAgICB0YWJzLmZvckVhY2goKHRhYiwgaSkgPT4ge1xuICAgICAgY29uc3QgYnRuSWQgPSBfLmRlZmF1bHQubmV4dElkKCd0YWItYnRuJyk7XG5cbiAgICAgIGNvbnN0IHRiID0gKDAsIF9qcXVlcnkuZGVmYXVsdCkodGFiLnRhYikuYWRkQ2xhc3MoYHRhYiB0YWItJHtpfWApLmF0dHIoJ2FyaWEtbGFiZWxsZWRieScsIGJ0bklkKS5hdHRyKCdyb2xlJywgJ3RhYnBhbmVsJykuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgY29uc3QgcG5sSWQgPSB0Yi5hdHRyKCdpZCcpIHx8IF8uZGVmYXVsdC5uZXh0SWQoJ3RhYi1wbmwnKTtcblxuICAgICAgdGIuYXR0cignaWQnLCBwbmxJZCk7XG4gICAgICBjb25zdCBidG4gPSAoMCwgX2pxdWVyeS5kZWZhdWx0KShUYWJzLkJUTl9IVE1MKS5hdHRyKCdpZCcsIGJ0bklkKS5hdHRyKCdhcmlhLWNvbnRyb2xzJywgcG5sSWQpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2xpY2soX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMuYnRuQ2xpY2ssIHRoaXMpKS5hZGRDbGFzcyhgYnRuLXRhYiBidG4tJHtpfWApLmRhdGEoJ3RhYicsIHRiKS5hcHBlbmQodGFiLnRpdGxlKTtcbiAgICAgIHRiLmRhdGEoJ2J0bicsIGJ0bik7XG4gICAgICB0aGlzLmJ0bnMuYXBwZW5kKCgwLCBfanF1ZXJ5LmRlZmF1bHQpKCc8aDI+PC9oMj4nKS5hcHBlbmQoYnRuKSk7XG4gICAgICB0aGlzLnRhYnMuYXBwZW5kKHRiKTtcblxuICAgICAgaWYgKHRhYi5hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5vcGVuKHRiKTtcbiAgICAgICAgb3BlbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghb3BlbmVkKSB7XG4gICAgICB0aGlzLm9wZW4odGFic1swXS50YWIpO1xuICAgIH1cblxuICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBldmVudCBFdmVudCBvYmplY3RcclxuICAgKi9cblxuXG4gIGJ0bkNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5vcGVuKCgwLCBfanF1ZXJ5LmRlZmF1bHQpKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoJ3RhYicpKTtcbiAgfVxuXG59XG4vKipcclxuICogQGRlc2MgQ29udHJ1Y3RvciBvcHRpb25zIGZvciB7QGxpbmsgbW9kdWxlOm55Yy9UYWJzflRhYnN9XHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtqUXVlcnl8RWxlbWVudHxzdHJpbmd9IHRhcmdldCBUaGUgdGFyZ2V0IERPTSBub2RlIGZvciBUYWJzXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bW9kdWxlOm55Yy9UYWJzflRhYnMuVGFiPn0gdGFicyBUaGUgdGFic1xyXG4gKi9cblxuXG5UYWJzLk9wdGlvbnM7XG4vKipcclxuICogQGRlc2MgT2JqZWN0IHR5cGUgdG8gaG9sZCBhIHRhYiBkZWZpbml0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtqUXVlcnl8RWxlbWVudHxzdHJpbmd9IHRhYiBUaGUgdGFyZ2V0IERPTSBub2RlIGZvciB0YWJcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRpdGxlIFRoZSB0YWIgdGl0bGVcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWN0aXZlPWZhbHNlXSBBY3RpdmUgc3RhdGUgb2YgdGhlIHRhYlxyXG4gKi9cblxuVGFicy5UYWI7XG4vKipcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG5UYWJzLkhUTUwgPSAnPGRpdiBjbGFzcz1cImJ0bnNcIiByb2xlPVwidGFibGlzdFwiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiIHRhYmluZGV4PVwiLTFcIj48L2Rpdj4nO1xuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxuVGFicy5CVE5fSFRNTCA9ICc8YnV0dG9uIGNsYXNzPVwiYnRuXCIgcm9sZT1cInRhYlwiPjwvYnV0dG9uPic7XG52YXIgX2RlZmF1bHQgPSBUYWJzO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUlBOzs7Ozs7OztBQU1BOzs7OztBQUNBOzs7OztBQUtBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQW5CQTtBQW1CQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7QUF4RkE7QUEyRkE7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///118\n")},,function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _papaparse = _interopRequireDefault(__webpack_require__(121));\n\nvar _textEncoding = _interopRequireDefault(__webpack_require__(122));\n\nvar _Feature = _interopRequireDefault(__webpack_require__(59));\n\nvar _Feature2 = _interopRequireDefault(__webpack_require__(71));\n\nvar _Point = _interopRequireDefault(__webpack_require__(52));\n\nvar _FormatType = _interopRequireDefault(__webpack_require__(57));\n\nvar _StandardCsv = _interopRequireDefault(__webpack_require__(123));\n\nvar _proj = __webpack_require__(10);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/format/CsvPoint\r\n */\n\n/**\r\n * @desc Class to create point features from CSV data\r\n * @public\r\n * @class\r\n * @extends ol.format.Feature\r\n * @see http://openlayers.org/en/latest/apidoc/module-ol_format_Feature-FeatureFormat.html\r\n */\n\n\nvar CsvPoint =\n/*#__PURE__*/\nfunction (_Feature2$default) {\n  _inherits(CsvPoint, _Feature2$default);\n\n  /**\r\n   * @desc Create an instance of CsvPoint\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/ol/format/CsvPoint~CsvPoint.Options} options Constructor options\r\n   */\n  function CsvPoint(options) {\n    var _this;\n\n    _classCallCheck(this, CsvPoint);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(CsvPoint).call(this));\n    /**\r\n     * @private\r\n     * @member {boolean}\r\n     */\n\n    _this.autoDetect = options.autoDetect === true;\n    /**\r\n     * @private\r\n     * @member {ol.Projection}\r\n     */\n\n    _this.dataProjection = (0, _proj.get)(options.dataProjection || \'EPSG:4326\');\n    /**\r\n     * @private\r\n     * @member {ol.Projection}\r\n     */\n\n    _this.featureProjection = (0, _proj.get)(options.featureProjection || \'EPSG:3857\');\n    /**\r\n     * @private\r\n     * @member {string}\r\n     */\n\n    _this.id = options.id;\n    /**\r\n     * @private\r\n     * @member {string}\r\n     */\n\n    _this.x = options.x;\n    /**\r\n     * @private\r\n     * @member {string}\r\n     */\n\n    _this.y = options.y;\n    /**\r\n     * @private\r\n     * @member {number}\r\n     */\n\n    _this.lastId = 0;\n    return _this;\n  }\n  /**\r\n   * @desc Read a single feature from a source\r\n   * @public\r\n   * @method\r\n   * @param {Object} source A row from a CSV data source\r\n   * @param {olx.format.ReadOptions=} options Read options\r\n   * @return {ol.Feature} Feature\r\n   */\n\n\n  _createClass(CsvPoint, [{\n    key: "readFeature",\n    value: function readFeature(source, options) {\n      var id;\n\n      if (source[this.id]) {\n        id = source[this.id];\n      } else {\n        id = this.lastId;\n        this.lastId += 1;\n      }\n\n      var feature = new _Feature["default"](source);\n      feature.setId(id);\n      this.setGeometry(feature, source, options);\n      return feature;\n    }\n    /**\r\n     * @desc Set the feature geometry\r\n     * @public\r\n     * @method\r\n     * @param {ol.Feature} feature The feature\r\n     * @param {Object<string, string>} source A row from a CSV data source\r\n     * @param {olx.format.ReadOptions=} options Read options\r\n     */\n\n  }, {\n    key: "setGeometry",\n    value: function setGeometry(feature, source, options) {\n      var x = source[this.x] = parseFloat(source[this.x]);\n      var y = source[this.y] = parseFloat(source[this.y]);\n\n      if (isNaN(x) || isNaN(y)) {\n        throw "Invalid coordinate [".concat(x, ", ").concat(y, "] for id ").concat(feature.getId());\n      }\n\n      var point = new _Point["default"]([x, y]);\n      point.transform(options && options.dataProjection ? options.dataProjection : this.dataProjection, options && options.featureProjection ? options.featureProjection : this.featureProjection);\n      feature.setGeometry(point);\n    }\n    /**\r\n     * @desc Read all features from a source\r\n     * @public\r\n     * @method\r\n     * @param {Object} source Rows from a CSV data source\r\n     * @param {olx.format.ReadOptions=} options Read options\r\n     * @return {Array.<ol.Feature>} Features\r\n     */\n\n  }, {\n    key: "readFeatures",\n    value: function readFeatures(source, options) {\n      var _this2 = this;\n\n      var features = [];\n      source = this.parseSource(source);\n      source.forEach(function (row) {\n        try {\n          features.push(_this2.readFeature(row, options));\n        } catch (error) {\n          console.error(error, row);\n        }\n      });\n      return features;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} source Rows from a CSV data source\r\n     * @return {ol.proj.Projection} The projection\r\n     */\n\n  }, {\n    key: "parseSource",\n    value: function parseSource(source) {\n      if (source instanceof ArrayBuffer) {\n        source = new _textEncoding["default"].TextDecoder(\'utf-8\').decode(source);\n      }\n\n      if (typeof source === \'string\') {\n        source = _papaparse["default"].parse(source, {\n          header: true\n        }).data;\n      }\n\n      this.detectCsvFormat(source);\n      return source;\n    }\n    /**\r\n     * @desc Detect CSV columns and projection based on standard format\r\n     * @public\r\n     * @method\r\n     * @param {Object<string, Object>} source Parsed CSV data\r\n     */\n\n  }, {\n    key: "detectCsvFormat",\n    value: function detectCsvFormat(source) {\n      if (this.autoDetect) {\n        this.id = _StandardCsv["default"].ID;\n\n        if (source[0][_StandardCsv["default"].X]) {\n          this.x = _StandardCsv["default"].X;\n          this.y = _StandardCsv["default"].Y;\n          this.dataProjection = (0, _proj.get)(\'EPSG:2263\');\n        } else {\n          this.x = _StandardCsv["default"].LNG;\n          this.y = _StandardCsv["default"].LAT;\n          this.dataProjection = (0, _proj.get)(\'EPSG:4326\');\n        }\n      }\n    }\n    /**\r\n     * @desc Read the projection from a source\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @param {Document|Node|Object|string} source Source\r\n     * @return {ol.proj.Projection} The projection\r\n     */\n\n  }, {\n    key: "readProjection",\n    value: function readProjection(source) {\n      return this.dataProjection;\n    }\n    /**\r\n     * @desc Return format type\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @return {ol.format.FormatType} The format type\r\n     */\n\n  }, {\n    key: "getType",\n    value: function getType() {\n      return _FormatType["default"].ARRAY_BUFFER;\n    }\n  }]);\n\n  return CsvPoint;\n}(_Feature2["default"]);\n/**\r\n* @desc Constructor options for {@link module:nyc/ol/format/CsvPoint~CsvPoint}\r\n* @public\r\n* @typedef {Object}\r\n* @property {boolean} [autoDetect=false] Attempt to determine standard column names and projection\r\n* @property {string=} x The name of the field containing the x ordinate of the point\r\n* @property {string=} y The name of the field containing the y ordinate of the point\r\n* @property {string=} id The name of the field containing the unique id of the point\r\n* @property {ol.ProjectionLike} [dataProjection=EPSG:4326] The projection of the source data\r\n* @property {ol.ProjectionLike} [featureProjection=EPSG:3857] The projection of the resulting features\r\n*/\n\n\nCsvPoint.Options;\nvar _default = CsvPoint;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL2Zvcm1hdC9Dc3ZQb2ludC5qcz83ZTE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3BhcGFwYXJzZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInBhcGFwYXJzZVwiKSk7XG5cbnZhciBfdGV4dEVuY29kaW5nID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwidGV4dC1lbmNvZGluZ1wiKSk7XG5cbnZhciBfRmVhdHVyZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL0ZlYXR1cmVcIikpO1xuXG52YXIgX0ZlYXR1cmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvZm9ybWF0L0ZlYXR1cmVcIikpO1xuXG52YXIgX1BvaW50ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvZ2VvbS9Qb2ludFwiKSk7XG5cbnZhciBfRm9ybWF0VHlwZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL2Zvcm1hdC9Gb3JtYXRUeXBlXCIpKTtcblxudmFyIF9TdGFuZGFyZENzdiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vU3RhbmRhcmRDc3ZcIikpO1xuXG52YXIgX3Byb2ogPSByZXF1aXJlKFwib2wvcHJvalwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL29sL2Zvcm1hdC9Dc3ZQb2ludFxyXG4gKi9cblxuLyoqXHJcbiAqIEBkZXNjIENsYXNzIHRvIGNyZWF0ZSBwb2ludCBmZWF0dXJlcyBmcm9tIENTViBkYXRhXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIG9sLmZvcm1hdC5GZWF0dXJlXHJcbiAqIEBzZWUgaHR0cDovL29wZW5sYXllcnMub3JnL2VuL2xhdGVzdC9hcGlkb2MvbW9kdWxlLW9sX2Zvcm1hdF9GZWF0dXJlLUZlYXR1cmVGb3JtYXQuaHRtbFxyXG4gKi9cbmNsYXNzIENzdlBvaW50IGV4dGVuZHMgX0ZlYXR1cmUyLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQ3N2UG9pbnRcclxuICAgKiBAcHVibGljXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL29sL2Zvcm1hdC9Dc3ZQb2ludH5Dc3ZQb2ludC5PcHRpb25zfSBvcHRpb25zIENvbnN0cnVjdG9yIG9wdGlvbnNcclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gICAgdGhpcy5hdXRvRGV0ZWN0ID0gb3B0aW9ucy5hdXRvRGV0ZWN0ID09PSB0cnVlO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge29sLlByb2plY3Rpb259XHJcbiAgICAgKi9cblxuICAgIHRoaXMuZGF0YVByb2plY3Rpb24gPSAoMCwgX3Byb2ouZ2V0KShvcHRpb25zLmRhdGFQcm9qZWN0aW9uIHx8ICdFUFNHOjQzMjYnKTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtvbC5Qcm9qZWN0aW9ufVxyXG4gICAgICovXG5cbiAgICB0aGlzLmZlYXR1cmVQcm9qZWN0aW9uID0gKDAsIF9wcm9qLmdldCkob3B0aW9ucy5mZWF0dXJlUHJvamVjdGlvbiB8fCAnRVBTRzozODU3Jyk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXG5cbiAgICB0aGlzLmlkID0gb3B0aW9ucy5pZDtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cblxuICAgIHRoaXMueCA9IG9wdGlvbnMueDtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cblxuICAgIHRoaXMueSA9IG9wdGlvbnMueTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cblxuICAgIHRoaXMubGFzdElkID0gMDtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBSZWFkIGEgc2luZ2xlIGZlYXR1cmUgZnJvbSBhIHNvdXJjZVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBBIHJvdyBmcm9tIGEgQ1NWIGRhdGEgc291cmNlXHJcbiAgICogQHBhcmFtIHtvbHguZm9ybWF0LlJlYWRPcHRpb25zPX0gb3B0aW9ucyBSZWFkIG9wdGlvbnNcclxuICAgKiBAcmV0dXJuIHtvbC5GZWF0dXJlfSBGZWF0dXJlXHJcbiAgICovXG5cblxuICByZWFkRmVhdHVyZShzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBsZXQgaWQ7XG5cbiAgICBpZiAoc291cmNlW3RoaXMuaWRdKSB7XG4gICAgICBpZCA9IHNvdXJjZVt0aGlzLmlkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSB0aGlzLmxhc3RJZDtcbiAgICAgIHRoaXMubGFzdElkICs9IDE7XG4gICAgfVxuXG4gICAgY29uc3QgZmVhdHVyZSA9IG5ldyBfRmVhdHVyZS5kZWZhdWx0KHNvdXJjZSk7XG4gICAgZmVhdHVyZS5zZXRJZChpZCk7XG4gICAgdGhpcy5zZXRHZW9tZXRyeShmZWF0dXJlLCBzb3VyY2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFNldCB0aGUgZmVhdHVyZSBnZW9tZXRyeVxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtvbC5GZWF0dXJlfSBmZWF0dXJlIFRoZSBmZWF0dXJlXHJcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBzb3VyY2UgQSByb3cgZnJvbSBhIENTViBkYXRhIHNvdXJjZVxyXG4gICAqIEBwYXJhbSB7b2x4LmZvcm1hdC5SZWFkT3B0aW9ucz19IG9wdGlvbnMgUmVhZCBvcHRpb25zXHJcbiAgICovXG5cblxuICBzZXRHZW9tZXRyeShmZWF0dXJlLCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB4ID0gc291cmNlW3RoaXMueF0gPSBwYXJzZUZsb2F0KHNvdXJjZVt0aGlzLnhdKTtcbiAgICBjb25zdCB5ID0gc291cmNlW3RoaXMueV0gPSBwYXJzZUZsb2F0KHNvdXJjZVt0aGlzLnldKTtcblxuICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgICAgdGhyb3cgYEludmFsaWQgY29vcmRpbmF0ZSBbJHt4fSwgJHt5fV0gZm9yIGlkICR7ZmVhdHVyZS5nZXRJZCgpfWA7XG4gICAgfVxuXG4gICAgY29uc3QgcG9pbnQgPSBuZXcgX1BvaW50LmRlZmF1bHQoW3gsIHldKTtcbiAgICBwb2ludC50cmFuc2Zvcm0ob3B0aW9ucyAmJiBvcHRpb25zLmRhdGFQcm9qZWN0aW9uID8gb3B0aW9ucy5kYXRhUHJvamVjdGlvbiA6IHRoaXMuZGF0YVByb2plY3Rpb24sIG9wdGlvbnMgJiYgb3B0aW9ucy5mZWF0dXJlUHJvamVjdGlvbiA/IG9wdGlvbnMuZmVhdHVyZVByb2plY3Rpb24gOiB0aGlzLmZlYXR1cmVQcm9qZWN0aW9uKTtcbiAgICBmZWF0dXJlLnNldEdlb21ldHJ5KHBvaW50KTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBSZWFkIGFsbCBmZWF0dXJlcyBmcm9tIGEgc291cmNlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFJvd3MgZnJvbSBhIENTViBkYXRhIHNvdXJjZVxyXG4gICAqIEBwYXJhbSB7b2x4LmZvcm1hdC5SZWFkT3B0aW9ucz19IG9wdGlvbnMgUmVhZCBvcHRpb25zXHJcbiAgICogQHJldHVybiB7QXJyYXkuPG9sLkZlYXR1cmU+fSBGZWF0dXJlc1xyXG4gICAqL1xuXG5cbiAgcmVhZEZlYXR1cmVzKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgc291cmNlID0gdGhpcy5wYXJzZVNvdXJjZShzb3VyY2UpO1xuICAgIHNvdXJjZS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKHRoaXMucmVhZEZlYXR1cmUocm93LCBvcHRpb25zKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLCByb3cpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFJvd3MgZnJvbSBhIENTViBkYXRhIHNvdXJjZVxyXG4gICAqIEByZXR1cm4ge29sLnByb2ouUHJvamVjdGlvbn0gVGhlIHByb2plY3Rpb25cclxuICAgKi9cblxuXG4gIHBhcnNlU291cmNlKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgc291cmNlID0gbmV3IF90ZXh0RW5jb2RpbmcuZGVmYXVsdC5UZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUoc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZSA9IF9wYXBhcGFyc2UuZGVmYXVsdC5wYXJzZShzb3VyY2UsIHtcbiAgICAgICAgaGVhZGVyOiB0cnVlXG4gICAgICB9KS5kYXRhO1xuICAgIH1cblxuICAgIHRoaXMuZGV0ZWN0Q3N2Rm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBEZXRlY3QgQ1NWIGNvbHVtbnMgYW5kIHByb2plY3Rpb24gYmFzZWQgb24gc3RhbmRhcmQgZm9ybWF0XHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIE9iamVjdD59IHNvdXJjZSBQYXJzZWQgQ1NWIGRhdGFcclxuICAgKi9cblxuXG4gIGRldGVjdENzdkZvcm1hdChzb3VyY2UpIHtcbiAgICBpZiAodGhpcy5hdXRvRGV0ZWN0KSB7XG4gICAgICB0aGlzLmlkID0gX1N0YW5kYXJkQ3N2LmRlZmF1bHQuSUQ7XG5cbiAgICAgIGlmIChzb3VyY2VbMF1bX1N0YW5kYXJkQ3N2LmRlZmF1bHQuWF0pIHtcbiAgICAgICAgdGhpcy54ID0gX1N0YW5kYXJkQ3N2LmRlZmF1bHQuWDtcbiAgICAgICAgdGhpcy55ID0gX1N0YW5kYXJkQ3N2LmRlZmF1bHQuWTtcbiAgICAgICAgdGhpcy5kYXRhUHJvamVjdGlvbiA9ICgwLCBfcHJvai5nZXQpKCdFUFNHOjIyNjMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueCA9IF9TdGFuZGFyZENzdi5kZWZhdWx0LkxORztcbiAgICAgICAgdGhpcy55ID0gX1N0YW5kYXJkQ3N2LmRlZmF1bHQuTEFUO1xuICAgICAgICB0aGlzLmRhdGFQcm9qZWN0aW9uID0gKDAsIF9wcm9qLmdldCkoJ0VQU0c6NDMyNicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBSZWFkIHRoZSBwcm9qZWN0aW9uIGZyb20gYSBzb3VyY2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR8Tm9kZXxPYmplY3R8c3RyaW5nfSBzb3VyY2UgU291cmNlXHJcbiAgICogQHJldHVybiB7b2wucHJvai5Qcm9qZWN0aW9ufSBUaGUgcHJvamVjdGlvblxyXG4gICAqL1xuXG5cbiAgcmVhZFByb2plY3Rpb24oc291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVByb2plY3Rpb247XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgUmV0dXJuIGZvcm1hdCB0eXBlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJuIHtvbC5mb3JtYXQuRm9ybWF0VHlwZX0gVGhlIGZvcm1hdCB0eXBlXHJcbiAgICovXG5cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiBfRm9ybWF0VHlwZS5kZWZhdWx0LkFSUkFZX0JVRkZFUjtcbiAgfVxuXG59XG4vKipcclxuKiBAZGVzYyBDb25zdHJ1Y3RvciBvcHRpb25zIGZvciB7QGxpbmsgbW9kdWxlOm55Yy9vbC9mb3JtYXQvQ3N2UG9pbnR+Q3N2UG9pbnR9XHJcbiogQHB1YmxpY1xyXG4qIEB0eXBlZGVmIHtPYmplY3R9XHJcbiogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b0RldGVjdD1mYWxzZV0gQXR0ZW1wdCB0byBkZXRlcm1pbmUgc3RhbmRhcmQgY29sdW1uIG5hbWVzIGFuZCBwcm9qZWN0aW9uXHJcbiogQHByb3BlcnR5IHtzdHJpbmc9fSB4IFRoZSBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIHRoZSB4IG9yZGluYXRlIG9mIHRoZSBwb2ludFxyXG4qIEBwcm9wZXJ0eSB7c3RyaW5nPX0geSBUaGUgbmFtZSBvZiB0aGUgZmllbGQgY29udGFpbmluZyB0aGUgeSBvcmRpbmF0ZSBvZiB0aGUgcG9pbnRcclxuKiBAcHJvcGVydHkge3N0cmluZz19IGlkIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIHRoZSB1bmlxdWUgaWQgb2YgdGhlIHBvaW50XHJcbiogQHByb3BlcnR5IHtvbC5Qcm9qZWN0aW9uTGlrZX0gW2RhdGFQcm9qZWN0aW9uPUVQU0c6NDMyNl0gVGhlIHByb2plY3Rpb24gb2YgdGhlIHNvdXJjZSBkYXRhXHJcbiogQHByb3BlcnR5IHtvbC5Qcm9qZWN0aW9uTGlrZX0gW2ZlYXR1cmVQcm9qZWN0aW9uPUVQU0c6Mzg1N10gVGhlIHByb2plY3Rpb24gb2YgdGhlIHJlc3VsdGluZyBmZWF0dXJlc1xyXG4qL1xuXG5cbkNzdlBvaW50Lk9wdGlvbnM7XG52YXIgX2RlZmF1bHQgPSBDc3ZQb2ludDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUlBOzs7Ozs7Ozs7QUFPQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUEzQ0E7QUE0Q0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7O0FBOUxBO0FBaU1BOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///120\n')},function(module,exports){eval("module.exports = (window.Papa || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiKHdpbmRvdy5QYXBhIHx8IHt9KVwiP2E3ZGQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAod2luZG93LlBhcGEgfHwge30pOyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///121\n")},function(module,exports){eval("module.exports = window;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwid2luZG93XCI/YTBhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdzsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///122\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n/**\n * @module nyc/ol/format/StandardCsv\n */\n\n/**\n * @desc A static class with static members that define a standard set of colums for CSV data to be used with {@link module:nyc/ol/FrameworkMap~FrameworkMap}\n *\n * &bull; CSV data must include <b><i>NAME</i></b> and <b><i>ADDR1</i></b>\n *\n * &bull; CSV data must include <b><i>CITY</i></b> or <b><i>BORO</i></b>\n *\n * &bull; 'NY' is assumed when <b><i>STATE</i></b> is not included\n * @public\n * @static\n * @class\n */\n\nvar StandardCsv = function StandardCsv() {\n  _classCallCheck(this, StandardCsv);\n};\n/**\n * @desc The Identifier column name - <b></i>ID</i></b>\n * @public\n * @const {string}\n */\n\n\nStandardCsv.ID = 'ID';\n/**\n * @desc The X ordinate column name - <b><i>X</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.X = 'X';\n/**\n * @desc The Y ordinate column name - <b><i>Y</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.Y = 'Y';\n/**\n * @desc The Longitude column name - <b><i>LNG</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.LNG = 'LNG';\n/**\n * @desc The Latitude column name - <b><i>LAT</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.LAT = 'LAT';\n/**\n * @desc The Name column name - <b><i>NAME</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.NAME = 'NAME';\n/**\n * @desc The Address Line 1 column name - <b><i>ADDR1</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.ADDR1 = 'ADDR1';\n/**\n * @desc The Address Line 2 column name - <b><i>ADDR2</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.ADDR2 = 'ADDR2';\n/**\n * @desc The City column name - <b><i>CITY</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.CITY = 'CITY';\n/**\n * @desc The Borough column name - <b><i>BORO</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.BORO = 'BORO';\n/**\n * @desc The State column name - <b><i>STATE</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.STATE = 'STATE';\n/**\n * @desc The ZIP Code column name - <b><i>ZIP</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.ZIP = 'ZIP';\n/**\n * @desc The Phone Number column name - <b><i>PHONE</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.PHONE = 'PHONE';\n/**\n * @desc The Email column name - <b><i>EMAIL</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.EMAIL = 'EMAIL';\n/**\n * @desc The Web Site column name - <b><i>WEBSITE</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.WEBSITE = 'WEBSITE';\n/**\n * @desc The Details column name - <b><i>DETAIL</i></b>\n * @public\n * @const {string}\n */\n\nStandardCsv.DETAIL = 'DETAIL';\nvar _default = StandardCsv;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL2Zvcm1hdC9TdGFuZGFyZENzdi5qcz80OTQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG4vKipcbiAqIEBtb2R1bGUgbnljL29sL2Zvcm1hdC9TdGFuZGFyZENzdlxuICovXG5cbi8qKlxuICogQGRlc2MgQSBzdGF0aWMgY2xhc3Mgd2l0aCBzdGF0aWMgbWVtYmVycyB0aGF0IGRlZmluZSBhIHN0YW5kYXJkIHNldCBvZiBjb2x1bXMgZm9yIENTViBkYXRhIHRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgbW9kdWxlOm55Yy9vbC9GcmFtZXdvcmtNYXB+RnJhbWV3b3JrTWFwfVxuICpcbiAqICZidWxsOyBDU1YgZGF0YSBtdXN0IGluY2x1ZGUgPGI+PGk+TkFNRTwvaT48L2I+IGFuZCA8Yj48aT5BRERSMTwvaT48L2I+XG4gKlxuICogJmJ1bGw7IENTViBkYXRhIG11c3QgaW5jbHVkZSA8Yj48aT5DSVRZPC9pPjwvYj4gb3IgPGI+PGk+Qk9STzwvaT48L2I+XG4gKlxuICogJmJ1bGw7ICdOWScgaXMgYXNzdW1lZCB3aGVuIDxiPjxpPlNUQVRFPC9pPjwvYj4gaXMgbm90IGluY2x1ZGVkXG4gKiBAcHVibGljXG4gKiBAc3RhdGljXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgU3RhbmRhcmRDc3Yge31cbi8qKlxuICogQGRlc2MgVGhlIElkZW50aWZpZXIgY29sdW1uIG5hbWUgLSA8Yj48L2k+SUQ8L2k+PC9iPlxuICogQHB1YmxpY1xuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cblxuXG5TdGFuZGFyZENzdi5JRCA9ICdJRCc7XG4vKipcbiAqIEBkZXNjIFRoZSBYIG9yZGluYXRlIGNvbHVtbiBuYW1lIC0gPGI+PGk+WDwvaT48L2I+XG4gKiBAcHVibGljXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuXG5TdGFuZGFyZENzdi5YID0gJ1gnO1xuLyoqXG4gKiBAZGVzYyBUaGUgWSBvcmRpbmF0ZSBjb2x1bW4gbmFtZSAtIDxiPjxpPlk8L2k+PC9iPlxuICogQHB1YmxpY1xuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cblxuU3RhbmRhcmRDc3YuWSA9ICdZJztcbi8qKlxuICogQGRlc2MgVGhlIExvbmdpdHVkZSBjb2x1bW4gbmFtZSAtIDxiPjxpPkxORzwvaT48L2I+XG4gKiBAcHVibGljXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuXG5TdGFuZGFyZENzdi5MTkcgPSAnTE5HJztcbi8qKlxuICogQGRlc2MgVGhlIExhdGl0dWRlIGNvbHVtbiBuYW1lIC0gPGI+PGk+TEFUPC9pPjwvYj5cbiAqIEBwdWJsaWNcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5cblN0YW5kYXJkQ3N2LkxBVCA9ICdMQVQnO1xuLyoqXG4gKiBAZGVzYyBUaGUgTmFtZSBjb2x1bW4gbmFtZSAtIDxiPjxpPk5BTUU8L2k+PC9iPlxuICogQHB1YmxpY1xuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cblxuU3RhbmRhcmRDc3YuTkFNRSA9ICdOQU1FJztcbi8qKlxuICogQGRlc2MgVGhlIEFkZHJlc3MgTGluZSAxIGNvbHVtbiBuYW1lIC0gPGI+PGk+QUREUjE8L2k+PC9iPlxuICogQHB1YmxpY1xuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cblxuU3RhbmRhcmRDc3YuQUREUjEgPSAnQUREUjEnO1xuLyoqXG4gKiBAZGVzYyBUaGUgQWRkcmVzcyBMaW5lIDIgY29sdW1uIG5hbWUgLSA8Yj48aT5BRERSMjwvaT48L2I+XG4gKiBAcHVibGljXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuXG5TdGFuZGFyZENzdi5BRERSMiA9ICdBRERSMic7XG4vKipcbiAqIEBkZXNjIFRoZSBDaXR5IGNvbHVtbiBuYW1lIC0gPGI+PGk+Q0lUWTwvaT48L2I+XG4gKiBAcHVibGljXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuXG5TdGFuZGFyZENzdi5DSVRZID0gJ0NJVFknO1xuLyoqXG4gKiBAZGVzYyBUaGUgQm9yb3VnaCBjb2x1bW4gbmFtZSAtIDxiPjxpPkJPUk88L2k+PC9iPlxuICogQHB1YmxpY1xuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cblxuU3RhbmRhcmRDc3YuQk9STyA9ICdCT1JPJztcbi8qKlxuICogQGRlc2MgVGhlIFN0YXRlIGNvbHVtbiBuYW1lIC0gPGI+PGk+U1RBVEU8L2k+PC9iPlxuICogQHB1YmxpY1xuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cblxuU3RhbmRhcmRDc3YuU1RBVEUgPSAnU1RBVEUnO1xuLyoqXG4gKiBAZGVzYyBUaGUgWklQIENvZGUgY29sdW1uIG5hbWUgLSA8Yj48aT5aSVA8L2k+PC9iPlxuICogQHB1YmxpY1xuICogQGNvbnN0IHtzdHJpbmd9XG4gKi9cblxuU3RhbmRhcmRDc3YuWklQID0gJ1pJUCc7XG4vKipcbiAqIEBkZXNjIFRoZSBQaG9uZSBOdW1iZXIgY29sdW1uIG5hbWUgLSA8Yj48aT5QSE9ORTwvaT48L2I+XG4gKiBAcHVibGljXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuXG5TdGFuZGFyZENzdi5QSE9ORSA9ICdQSE9ORSc7XG4vKipcbiAqIEBkZXNjIFRoZSBFbWFpbCBjb2x1bW4gbmFtZSAtIDxiPjxpPkVNQUlMPC9pPjwvYj5cbiAqIEBwdWJsaWNcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5cblN0YW5kYXJkQ3N2LkVNQUlMID0gJ0VNQUlMJztcbi8qKlxuICogQGRlc2MgVGhlIFdlYiBTaXRlIGNvbHVtbiBuYW1lIC0gPGI+PGk+V0VCU0lURTwvaT48L2I+XG4gKiBAcHVibGljXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuXG5TdGFuZGFyZENzdi5XRUJTSVRFID0gJ1dFQlNJVEUnO1xuLyoqXG4gKiBAZGVzYyBUaGUgRGV0YWlscyBjb2x1bW4gbmFtZSAtIDxiPjxpPkRFVEFJTDwvaT48L2I+XG4gKiBAcHVibGljXG4gKiBAY29uc3Qge3N0cmluZ31cbiAqL1xuXG5TdGFuZGFyZENzdi5ERVRBSUwgPSAnREVUQUlMJztcbnZhciBfZGVmYXVsdCA9IFN0YW5kYXJkQ3N2O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBOzs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7QUFZQTs7O0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///123\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n/**\r\n * @module nyc/ReplaceTokens\r\n */\n\n/**\r\n * @desc Class to provide string replacement functionality\r\n * @public\r\n * @abstract\r\n * @class\r\n * @constructor\r\n */\n\nvar ReplaceTokens =\n/*#__PURE__*/\nfunction () {\n  function ReplaceTokens() {\n    _classCallCheck(this, ReplaceTokens);\n  }\n\n  _createClass(ReplaceTokens, [{\n    key: "replace",\n\n    /**\r\n     * @desc Replace tokens in a string with values from a provided object\r\n     * @public\r\n     * @method\r\n     * @param {string} str String with tokens to be replaced\r\n     * @param {Object<string, string>} values Values token for replacement\r\n     * @return {string} String with replacement value substitution\r\n     */\n    value: function replace(str, values) {\n      Object.keys(values).forEach(function (name) {\n        str = str.replace(new RegExp(\'\\\\$\\\\{\' + name + \'\\\\}\', \'g\'), values[name] !== undefined ? values[name] : \'\');\n      });\n      return str;\n    }\n  }]);\n\n  return ReplaceTokens;\n}();\n\nvar _default = ReplaceTokens;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL1JlcGxhY2VUb2tlbnMuanM/MDVjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL1JlcGxhY2VUb2tlbnNcclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBDbGFzcyB0byBwcm92aWRlIHN0cmluZyByZXBsYWNlbWVudCBmdW5jdGlvbmFsaXR5XHJcbiAqIEBwdWJsaWNcclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzc1xyXG4gKiBAY29uc3RydWN0b3JcclxuICovXG5jbGFzcyBSZXBsYWNlVG9rZW5zIHtcbiAgLyoqXHJcbiAgICogQGRlc2MgUmVwbGFjZSB0b2tlbnMgaW4gYSBzdHJpbmcgd2l0aCB2YWx1ZXMgZnJvbSBhIHByb3ZpZGVkIG9iamVjdFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgd2l0aCB0b2tlbnMgdG8gYmUgcmVwbGFjZWRcclxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IHZhbHVlcyBWYWx1ZXMgdG9rZW4gZm9yIHJlcGxhY2VtZW50XHJcbiAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgd2l0aCByZXBsYWNlbWVudCB2YWx1ZSBzdWJzdGl0dXRpb25cclxuICAgKi9cbiAgcmVwbGFjZShzdHIsIHZhbHVlcykge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFwkXFxcXHsnICsgbmFtZSArICdcXFxcfScsICdnJyksIHZhbHVlc1tuYW1lXSAhPT0gdW5kZWZpbmVkID8gdmFsdWVzW25hbWVdIDogJycpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxufVxuXG52YXIgX2RlZmF1bHQgPSBSZXBsYWNlVG9rZW5zO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTs7OztBQUlBOzs7Ozs7OztBQU9BOzs7Ozs7Ozs7O0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFJQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///124\n')},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n})(this, function () {\n  'use strict';\n\n  function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);\n  }\n\n  function quickselectStep(arr, k, left, right, compare) {\n    while (right > left) {\n      if (right - left > 600) {\n        var n = right - left + 1;\n        var m = k - left + 1;\n        var z = Math.log(n);\n        var s = 0.5 * Math.exp(2 * z / 3);\n        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n        quickselectStep(arr, k, newLeft, newRight, compare);\n      }\n\n      var t = arr[k];\n      var i = left;\n      var j = right;\n      swap(arr, left, k);\n      if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n      while (i < j) {\n        swap(arr, i, j);\n        i++;\n        j--;\n\n        while (compare(arr[i], t) < 0) {\n          i++;\n        }\n\n        while (compare(arr[j], t) > 0) {\n          j--;\n        }\n      }\n\n      if (compare(arr[left], t) === 0) swap(arr, left, j);else {\n        j++;\n        swap(arr, j, right);\n      }\n      if (j <= k) left = j + 1;\n      if (k <= j) right = j - 1;\n    }\n  }\n\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n  function defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  return quickselect;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0L3F1aWNrc2VsZWN0LmpzPzYxY2EiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLnF1aWNrc2VsZWN0ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBxdWlja3NlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG4gICAgcXVpY2tzZWxlY3RTdGVwKGFyciwgaywgbGVmdCB8fCAwLCByaWdodCB8fCAoYXJyLmxlbmd0aCAtIDEpLCBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlKTtcbn1cblxuZnVuY3Rpb24gcXVpY2tzZWxlY3RTdGVwKGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgdmFyIG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgdmFyIHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IGFycltrXTtcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xuICAgICAgICB2YXIgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG5yZXR1cm4gcXVpY2tzZWxlY3Q7XG5cbn0pKSk7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///125\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\r\n * @module nyc/BasemapHelper\r\n */\n\n/**\r\n * @desc A helper object for creating and manipulating the NYC basemap\r\n * @public\r\n * @mixin\r\n */\n\n\nvar BasemapHelper = {\n  /**\r\n   * @desc Hook up events\r\n   * @public\r\n   * @method\r\n   * @param {Element} node The DOM node for the map\r\n   */\n  hookupEvents: function hookupEvents(node) {\n    (0, _jquery[\"default\"])(node).on('drop', _jquery[\"default\"].proxy(this.loadLayer, this));\n    (0, _jquery[\"default\"])(node).on('dragover', function (event) {\n      event.preventDefault();\n    });\n  },\n\n  /**\r\n   * @desc Loads a layer from a file\r\n   * @public\r\n   * @method\r\n   * @param {jQuery.Event} event Event object\r\n   */\n  loadLayer: function loadLayer(event) {\n    var transfer = event.originalEvent.dataTransfer;\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (transfer && transfer.files.length) {\n      var files = transfer.files;\n      var ext = files[0].name.split('.').pop().toLowerCase();\n\n      if (ext === 'json') {\n        this.storage.loadGeoJsonFile(this, null, files[0]);\n      } else {\n        this.storage.loadShapeFile(this, null, files);\n      }\n    }\n  },\n\n  /**\r\n   * @desc Returns the photo layers ordered by year\r\n   * @public\r\n   * @method\r\n   * @return {Array<ol.layer.Base|L.Layer>} Array of photo layers\r\n   */\n  sortedPhotos: function sortedPhotos() {\n    var _this = this;\n\n    var sorted = [];\n    Object.keys(this.photos).forEach(function (photo) {\n      sorted.push(_this.photos[photo]);\n    });\n    /* sort descending on the first 4 digits - puts 2001-2 in the proper place */\n\n    return sorted.sort(function (a, b) {\n      var aName = a.name || a.get('name');\n      var bName = b.name || b.get('name');\n      return bName.substr(0, 4) - aName.substr(0, 4);\n    });\n  },\n\n  /**\r\n   * @desc Enumerator for label types\r\n   * @public\r\n   * @enum {string}\r\n   */\n  LabelType: {\n    /**\r\n     * @desc Label type for base layer\r\n     */\n    BASE: 'base',\n\n    /**\r\n     * @desc Label type for photo layer\r\n     */\n    PHOTO: 'photo'\n    /**\r\n     * @desc Object type to hold base layers\r\n     * @public\r\n     * @typedef {Object}\r\n     * @property {Object} base The base layer\r\n     * @property {Object<string, ol.layer.Base|L.Layer>} labels The label layers\r\n     * @property {Object<string, ol.layer.Base|L.Layer>} photos The photo layers\r\n     */\n\n  }\n};\nBasemapHelper.BaseLayers;\nvar _default = BasemapHelper;\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0Jhc2VtYXBIZWxwZXIuanM/Y2NjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qcXVlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogQG1vZHVsZSBueWMvQmFzZW1hcEhlbHBlclxyXG4gKi9cblxuLyoqXHJcbiAqIEBkZXNjIEEgaGVscGVyIG9iamVjdCBmb3IgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyB0aGUgTllDIGJhc2VtYXBcclxuICogQHB1YmxpY1xyXG4gKiBAbWl4aW5cclxuICovXG5jb25zdCBCYXNlbWFwSGVscGVyID0ge1xuICAvKipcclxuICAgKiBAZGVzYyBIb29rIHVwIGV2ZW50c1xyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBET00gbm9kZSBmb3IgdGhlIG1hcFxyXG4gICAqL1xuICBob29rdXBFdmVudHMobm9kZSkge1xuICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKG5vZGUpLm9uKCdkcm9wJywgX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMubG9hZExheWVyLCB0aGlzKSk7XG4gICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkobm9kZSkub24oJ2RyYWdvdmVyJywgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBAZGVzYyBMb2FkcyBhIGxheWVyIGZyb20gYSBmaWxlXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XHJcbiAgICovXG4gIGxvYWRMYXllcihldmVudCkge1xuICAgIGNvbnN0IHRyYW5zZmVyID0gZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXI7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmICh0cmFuc2ZlciAmJiB0cmFuc2Zlci5maWxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZpbGVzID0gdHJhbnNmZXIuZmlsZXM7XG4gICAgICBjb25zdCBleHQgPSBmaWxlc1swXS5uYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKGV4dCA9PT0gJ2pzb24nKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZS5sb2FkR2VvSnNvbkZpbGUodGhpcywgbnVsbCwgZmlsZXNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlLmxvYWRTaGFwZUZpbGUodGhpcywgbnVsbCwgZmlsZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBAZGVzYyBSZXR1cm5zIHRoZSBwaG90byBsYXllcnMgb3JkZXJlZCBieSB5ZWFyXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJuIHtBcnJheTxvbC5sYXllci5CYXNlfEwuTGF5ZXI+fSBBcnJheSBvZiBwaG90byBsYXllcnNcclxuICAgKi9cbiAgc29ydGVkUGhvdG9zKCkge1xuICAgIGNvbnN0IHNvcnRlZCA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHRoaXMucGhvdG9zKS5mb3JFYWNoKHBob3RvID0+IHtcbiAgICAgIHNvcnRlZC5wdXNoKHRoaXMucGhvdG9zW3Bob3RvXSk7XG4gICAgfSk7XG4gICAgLyogc29ydCBkZXNjZW5kaW5nIG9uIHRoZSBmaXJzdCA0IGRpZ2l0cyAtIHB1dHMgMjAwMS0yIGluIHRoZSBwcm9wZXIgcGxhY2UgKi9cblxuICAgIHJldHVybiBzb3J0ZWQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgYU5hbWUgPSBhLm5hbWUgfHwgYS5nZXQoJ25hbWUnKTtcbiAgICAgIGNvbnN0IGJOYW1lID0gYi5uYW1lIHx8IGIuZ2V0KCduYW1lJyk7XG4gICAgICByZXR1cm4gYk5hbWUuc3Vic3RyKDAsIDQpIC0gYU5hbWUuc3Vic3RyKDAsIDQpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEBkZXNjIEVudW1lcmF0b3IgZm9yIGxhYmVsIHR5cGVzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBlbnVtIHtzdHJpbmd9XHJcbiAgICovXG4gIExhYmVsVHlwZToge1xuICAgIC8qKlxyXG4gICAgICogQGRlc2MgTGFiZWwgdHlwZSBmb3IgYmFzZSBsYXllclxyXG4gICAgICovXG4gICAgQkFTRTogJ2Jhc2UnLFxuXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyBMYWJlbCB0eXBlIGZvciBwaG90byBsYXllclxyXG4gICAgICovXG4gICAgUEhPVE86ICdwaG90bydcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBPYmplY3QgdHlwZSB0byBob2xkIGJhc2UgbGF5ZXJzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9XHJcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IGJhc2UgVGhlIGJhc2UgbGF5ZXJcclxuICAgKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIG9sLmxheWVyLkJhc2V8TC5MYXllcj59IGxhYmVscyBUaGUgbGFiZWwgbGF5ZXJzXHJcbiAgICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBvbC5sYXllci5CYXNlfEwuTGF5ZXI+fSBwaG90b3MgVGhlIHBob3RvIGxheWVyc1xyXG4gICAqL1xuXG59O1xuQmFzZW1hcEhlbHBlci5CYXNlTGF5ZXJzO1xudmFyIF9kZWZhdWx0ID0gQmFzZW1hcEhlbHBlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBSUE7Ozs7Ozs7QUFLQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUVBOzs7Ozs7Ozs7QUFYQTtBQTlEQTtBQW1GQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///126\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _GeoJSON = _interopRequireDefault(__webpack_require__(77));\n\nvar _Vector = _interopRequireDefault(__webpack_require__(83));\n\nvar _Vector2 = _interopRequireDefault(__webpack_require__(84));\n\nvar _LocalStorage = _interopRequireDefault(__webpack_require__(105));\n\nvar _proj = __webpack_require__(112);\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n\nvar proj4 = _["default"].proj4;\n/**\r\n * @desc Class to provide access to localStorage and filesystem\r\n * @public\r\n * @class\r\n * @extends module:nyc/LocalStorage~LocalStorage\r\n */\n\nvar LocalStorage =\n/*#__PURE__*/\nfunction (_LocalStorage$default) {\n  _inherits(LocalStorage, _LocalStorage$default);\n\n  /**\r\n   * @desc Create an instance pf LocalStorage\r\n   * @public\r\n   * @constructor\r\n   */\n  function LocalStorage() {\n    _classCallCheck(this, LocalStorage);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(LocalStorage).call(this));\n  }\n  /**\r\n   * @public\r\n   * @override\r\n   * @method\r\n   * @param {ol.Map} map The map on which to display the new layer\r\n   * @param {string|Array<Object>} features The features from which to create the new layer\r\n   * @param {string} projcs The projection\r\n   * @return {ol.layer.Vector} The new layer\r\n   */\n\n\n  _createClass(LocalStorage, [{\n    key: "addToMap",\n    value: function addToMap(map, features, projcs) {\n      var options = {\n        featureProjection: map.getView().getProjection().getCode(),\n        dataProjection: this.customProj(projcs, proj4) // customProj changes proj4.defs so we need to re-register\n\n      };\n      (0, _proj.register)(proj4);\n\n      if (_typeof(features) === \'object\') {\n        features = {\n          type: \'FeatureCollection\',\n          features: features\n        };\n      }\n\n      var source = new _Vector["default"]();\n      var layer = new _Vector2["default"]({\n        source: source\n      });\n      source.addFeatures(new _GeoJSON["default"]().readFeatures(features, options));\n      map.addLayer(layer);\n      return layer;\n    }\n  }]);\n\n  return LocalStorage;\n}(_LocalStorage["default"]);\n\nexports["default"] = LocalStorage;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL0xvY2FsU3RvcmFnZS5qcz9jZDViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX0dlb0pTT04gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9mb3JtYXQvR2VvSlNPTlwiKSk7XG5cbnZhciBfVmVjdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvc291cmNlL1ZlY3RvclwiKSk7XG5cbnZhciBfVmVjdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL2xheWVyL1ZlY3RvclwiKSk7XG5cbnZhciBfTG9jYWxTdG9yYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vTG9jYWxTdG9yYWdlXCIpKTtcblxudmFyIF9wcm9qID0gcmVxdWlyZShcIm9sL3Byb2ovcHJvajRcIik7XG5cbnZhciBfID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi8uLlwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IHByb2o0ID0gXy5kZWZhdWx0LnByb2o0O1xuLyoqXHJcbiAqIEBkZXNjIENsYXNzIHRvIHByb3ZpZGUgYWNjZXNzIHRvIGxvY2FsU3RvcmFnZSBhbmQgZmlsZXN5c3RlbVxyXG4gKiBAcHVibGljXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBtb2R1bGU6bnljL0xvY2FsU3RvcmFnZX5Mb2NhbFN0b3JhZ2VcclxuICovXG5cbmNsYXNzIExvY2FsU3RvcmFnZSBleHRlbmRzIF9Mb2NhbFN0b3JhZ2UuZGVmYXVsdCB7XG4gIC8qKlxyXG4gICAqIEBkZXNjIENyZWF0ZSBhbiBpbnN0YW5jZSBwZiBMb2NhbFN0b3JhZ2VcclxuICAgKiBAcHVibGljXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge29sLk1hcH0gbWFwIFRoZSBtYXAgb24gd2hpY2ggdG8gZGlzcGxheSB0aGUgbmV3IGxheWVyXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8T2JqZWN0Pn0gZmVhdHVyZXMgVGhlIGZlYXR1cmVzIGZyb20gd2hpY2ggdG8gY3JlYXRlIHRoZSBuZXcgbGF5ZXJcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamNzIFRoZSBwcm9qZWN0aW9uXHJcbiAgICogQHJldHVybiB7b2wubGF5ZXIuVmVjdG9yfSBUaGUgbmV3IGxheWVyXHJcbiAgICovXG5cblxuICBhZGRUb01hcChtYXAsIGZlYXR1cmVzLCBwcm9qY3MpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZmVhdHVyZVByb2plY3Rpb246IG1hcC5nZXRWaWV3KCkuZ2V0UHJvamVjdGlvbigpLmdldENvZGUoKSxcbiAgICAgIGRhdGFQcm9qZWN0aW9uOiB0aGlzLmN1c3RvbVByb2oocHJvamNzLCBwcm9qNCkgLy8gY3VzdG9tUHJvaiBjaGFuZ2VzIHByb2o0LmRlZnMgc28gd2UgbmVlZCB0byByZS1yZWdpc3RlclxuXG4gICAgfTtcbiAgICAoMCwgX3Byb2oucmVnaXN0ZXIpKHByb2o0KTtcblxuICAgIGlmICh0eXBlb2YgZmVhdHVyZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBmZWF0dXJlcyA9IHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBfVmVjdG9yLmRlZmF1bHQoKTtcbiAgICBjb25zdCBsYXllciA9IG5ldyBfVmVjdG9yMi5kZWZhdWx0KHtcbiAgICAgIHNvdXJjZTogc291cmNlXG4gICAgfSk7XG4gICAgc291cmNlLmFkZEZlYXR1cmVzKG5ldyBfR2VvSlNPTi5kZWZhdWx0KCkucmVhZEZlYXR1cmVzKGZlYXR1cmVzLCBvcHRpb25zKSk7XG4gICAgbWFwLmFkZExheWVyKGxheWVyKTtcbiAgICByZXR1cm4gbGF5ZXI7XG4gIH1cblxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBMb2NhbFN0b3JhZ2U7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTs7Ozs7QUFDQTs7Ozs7QUFLQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBMUNBO0FBQ0E7QUE2Q0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///127\n')},function(module,exports){eval("module.exports = (window.shapefile || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiKHdpbmRvdy5zaGFwZWZpbGUgfHwge30pXCI/ZDQ0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9ICh3aW5kb3cuc2hhcGVmaWxlIHx8IHt9KTsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///128\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _LayerType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);\n/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18);\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(16);\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5);\n/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(74);\n/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(rbush__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);\n/* harmony import */ var _render_EventType_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(38);\n/* harmony import */ var _render_canvas_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(4);\n/* harmony import */ var _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(81);\n/* harmony import */ var _Layer_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(101);\n/* harmony import */ var _vector_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(51);\n/**\n * @module ol/renderer/canvas/VectorLayer\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\n\nvar CanvasVectorLayerRenderer =\n/*@__PURE__*/\nfunction (CanvasLayerRenderer) {\n  function CanvasVectorLayerRenderer(vectorLayer) {\n    CanvasLayerRenderer.call(this, vectorLayer);\n    /**\n     * Declutter tree.\n     * @private\n     */\n\n    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush__WEBPACK_IMPORTED_MODULE_6___default()(9, undefined) : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedRevision_ = -1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedResolution_ = NaN;\n    /**\n     * @private\n     * @type {import("../../extent.js").Extent}\n     */\n\n    this.renderedExtent_ = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["createEmpty"])();\n    /**\n     * @private\n     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}\n     */\n\n    this.renderedRenderOrder_ = null;\n    /**\n     * @private\n     * @type {import("../../render/canvas/ReplayGroup.js").default}\n     */\n\n    this.replayGroup_ = null;\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n\n    this.replayGroupChanged = true;\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.context = Object(_dom_js__WEBPACK_IMPORTED_MODULE_3__[/* createCanvasContext2D */ "a"])();\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__[/* listen */ "a"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__[/* labelCache */ "o"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].CLEAR, this.handleFontsChanged_, this);\n  }\n\n  if (CanvasLayerRenderer) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer;\n  CanvasVectorLayerRenderer.prototype = Object.create(CanvasLayerRenderer && CanvasLayerRenderer.prototype);\n  CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;\n  /**\n   * @inheritDoc\n   */\n\n  CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_4__[/* unlisten */ "c"])(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__[/* labelCache */ "o"], _events_EventType_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].CLEAR, this.handleFontsChanged_, this);\n    CanvasLayerRenderer.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @param {import("../../layer/Layer.js").State} layerState Layer state.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.compose = function compose(context, frameState, layerState) {\n    var extent = frameState.extent;\n    var pixelRatio = frameState.pixelRatio;\n    var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var rotation = viewState.rotation;\n    var projectionExtent = projection.getExtent();\n    var vectorSource =\n    /** @type {import("../../source/Vector.js").default} */\n    this.getLayer().getSource();\n    var transform = this.getTransform(frameState, 0); // clipped rendering if layer extent is set\n\n    var clipExtent = layerState.extent;\n    var clipped = clipExtent !== undefined;\n\n    if (clipped) {\n      this.clip(context, frameState,\n      /** @type {import("../../extent.js").Extent} */\n      clipExtent);\n    }\n\n    var replayGroup = this.replayGroup_;\n\n    if (replayGroup && !replayGroup.isEmpty()) {\n      if (this.declutterTree_) {\n        this.declutterTree_.clear();\n      }\n\n      var layer =\n      /** @type {import("../../layer/Vector.js").default} */\n      this.getLayer();\n      var drawOffsetX = 0;\n      var drawOffsetY = 0;\n      var replayContext;\n      var transparentLayer = layerState.opacity !== 1;\n      var hasRenderListeners = layer.hasListener(_render_EventType_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].RENDER);\n\n      if (transparentLayer || hasRenderListeners) {\n        var drawWidth = context.canvas.width;\n        var drawHeight = context.canvas.height;\n\n        if (rotation) {\n          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n          drawOffsetX = (drawSize - drawWidth) / 2;\n          drawOffsetY = (drawSize - drawHeight) / 2;\n          drawWidth = drawHeight = drawSize;\n        } // resize and clear\n\n\n        this.context.canvas.width = drawWidth;\n        this.context.canvas.height = drawHeight;\n        replayContext = this.context;\n      } else {\n        replayContext = context;\n      }\n\n      var alpha = replayContext.globalAlpha;\n\n      if (!transparentLayer) {\n        // for performance reasons, context.save / context.restore is not used\n        // to save and restore the transformation matrix and the opacity.\n        // see http://jsperf.com/context-save-restore-versus-variable\n        replayContext.globalAlpha = layerState.opacity;\n      }\n\n      if (replayContext != context) {\n        replayContext.translate(drawOffsetX, drawOffsetY);\n      }\n\n      var viewHints = frameState.viewHints;\n      var snapToPixel = !(viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ANIMATING] || viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].INTERACTING]);\n      var width = frameState.size[0] * pixelRatio;\n      var height = frameState.size[1] * pixelRatio;\n      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__[/* rotateAtOffset */ "s"])(replayContext, -rotation, width / 2, height / 2);\n      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n\n      if (vectorSource.getWrapX() && projection.canWrapX() && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(projectionExtent, extent)) {\n        var startX = extent[0];\n        var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(projectionExtent);\n        var world = 0;\n        var offsetX;\n\n        while (startX < projectionExtent[0]) {\n          --world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX += worldWidth;\n        }\n\n        world = 0;\n        startX = extent[2];\n\n        while (startX > projectionExtent[2]) {\n          ++world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX -= worldWidth;\n        }\n      }\n\n      Object(_render_canvas_js__WEBPACK_IMPORTED_MODULE_9__[/* rotateAtOffset */ "s"])(replayContext, rotation, width / 2, height / 2);\n\n      if (hasRenderListeners) {\n        this.dispatchRenderEvent(replayContext, frameState, transform);\n      }\n\n      if (replayContext != context) {\n        if (transparentLayer) {\n          var mainContextAlpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity;\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n          context.globalAlpha = mainContextAlpha;\n        } else {\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n        }\n\n        replayContext.translate(-drawOffsetX, -drawOffsetY);\n      }\n\n      if (!transparentLayer) {\n        replayContext.globalAlpha = alpha;\n      }\n    }\n\n    if (clipped) {\n      context.restore();\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    var transform = this.getTransform(frameState, 0);\n    this.preCompose(context, frameState, transform);\n    this.compose(context, frameState, layerState);\n    this.postCompose(context, frameState, layerState, transform);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      var resolution = frameState.viewState.resolution;\n      var rotation = frameState.viewState.rotation;\n      var layer =\n      /** @type {import("../../layer/Vector.js").default} */\n      this.getLayer();\n      /** @type {!Object<string, boolean>} */\n\n      var features = {};\n      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n      /**\n       * @param {import("../../Feature.js").FeatureLike} feature Feature.\n       * @return {?} Callback result.\n       */\n      function (feature) {\n        var key = Object(_util_js__WEBPACK_IMPORTED_MODULE_0__[/* getUid */ "c"])(feature);\n\n        if (!(key in features)) {\n          features[key] = true;\n          return callback.call(thisArg, feature, layer);\n        }\n      }, null);\n      return result;\n    }\n  };\n  /**\n   * @param {import("../../events/Event.js").default} event Event.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import("../../events/Event.js").default} event Image style change event.\n   * @private\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var vectorLayer =\n    /** @type {import("../../layer/Vector.js").default} */\n    this.getLayer();\n    var vectorSource =\n    /** @type {import("../../source/Vector.js").default} */\n    vectorLayer.getSource();\n    var animating = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].ANIMATING];\n    var interacting = frameState.viewHints[_ViewHint_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].INTERACTING];\n    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {\n      return true;\n    }\n\n    var frameStateExtent = frameState.extent;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var vectorLayerRevision = vectorLayer.getRevision();\n    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = _vector_js__WEBPACK_IMPORTED_MODULE_12__[/* defaultOrder */ "a"];\n    }\n\n    var extent = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["buffer"])(frameStateExtent, vectorLayerRenderBuffer * resolution);\n    var projectionExtent = viewState.projection.getExtent();\n\n    if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(projectionExtent, frameState.extent)) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180 to +180). To support geometries in a coordinate range from -540\n      // to +540, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      var worldWidth = Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(projectionExtent);\n      var gutter = Math.max(Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["getWidth"])(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n    }\n\n    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && Object(_extent_js__WEBPACK_IMPORTED_MODULE_7__["containsExtent"])(this.renderedExtent_, extent)) {\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n    this.dirty_ = false;\n    var replayGroup = new _render_canvas_ReplayGroup_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__[/* getTolerance */ "c"])(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {import("../../Feature.js").default} feature Feature.\n     * @this {CanvasVectorLayerRenderer}\n     */\n\n    var render = function (feature) {\n      var styles;\n      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n\n      if (styleFunction) {\n        styles = styleFunction(feature, resolution);\n      }\n\n      if (styles) {\n        var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n\n    if (vectorLayerRenderOrder) {\n      /** @type {Array<import("../../Feature.js").default>} */\n      var features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n      /**\n       * @param {import("../../Feature.js").default} feature Feature.\n       */\n      function (feature) {\n        features.push(feature);\n      });\n      features.sort(vectorLayerRenderOrder);\n\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        render(features[i]);\n      }\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, render);\n    }\n\n    replayGroup.finish();\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n    this.replayGroupChanged = true;\n    return true;\n  };\n  /**\n   * @param {import("../../Feature.js").default} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.\n   * @param {import("../../render/canvas/ReplayGroup.js").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, resolution, pixelRatio, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n\n    var loading = false;\n\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__[/* renderFeature */ "d"])(replayGroup, feature, styles[i], Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__[/* getSquaredTolerance */ "b"])(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__[/* renderFeature */ "d"])(replayGroup, feature, styles, Object(_vector_js__WEBPACK_IMPORTED_MODULE_12__[/* getSquaredTolerance */ "b"])(resolution, pixelRatio), this.handleStyleImageChange_, this);\n    }\n\n    return loading;\n  };\n\n  return CanvasVectorLayerRenderer;\n}(_Layer_js__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"]);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import("../../layer/Layer.js").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\nCanvasVectorLayerRenderer[\'handles\'] = function (layer) {\n  return layer.getType() === _LayerType_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].VECTOR;\n};\n/**\n * Create a layer renderer.\n * @param {import("../Map.js").default} mapRenderer The map renderer.\n * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.\n * @return {CanvasVectorLayerRenderer} The layer renderer.\n */\n\n\nCanvasVectorLayerRenderer[\'create\'] = function (mapRenderer, layer) {\n  return new CanvasVectorLayerRenderer(\n  /** @type {import("../../layer/Vector.js").default} */\n  layer);\n};\n\n/* harmony default export */ __webpack_exports__["default"] = (CanvasVectorLayerRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXJlci9jYW52YXMvVmVjdG9yTGF5ZXIuanM/ZGM2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi8uLi91dGlsLmpzJztcbmltcG9ydCBMYXllclR5cGUgZnJvbSAnLi4vLi4vTGF5ZXJUeXBlLmpzJztcbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi8uLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3Rlbn0gZnJvbSAnLi4vLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgcmJ1c2ggZnJvbSAncmJ1c2gnO1xuaW1wb3J0IHtidWZmZXIsIGNyZWF0ZUVtcHR5LCBjb250YWluc0V4dGVudCwgZ2V0V2lkdGh9IGZyb20gJy4uLy4uL2V4dGVudC5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uLy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtsYWJlbENhY2hlLCByb3RhdGVBdE9mZnNldH0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5R3JvdXAgZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cC5qcyc7XG5pbXBvcnQgQ2FudmFzTGF5ZXJSZW5kZXJlciBmcm9tICcuL0xheWVyLmpzJztcbmltcG9ydCB7ZGVmYXVsdE9yZGVyIGFzIGRlZmF1bHRSZW5kZXJPcmRlciwgZ2V0VG9sZXJhbmNlIGFzIGdldFJlbmRlclRvbGVyYW5jZSwgZ2V0U3F1YXJlZFRvbGVyYW5jZSBhcyBnZXRTcXVhcmVkUmVuZGVyVG9sZXJhbmNlLCByZW5kZXJGZWF0dXJlfSBmcm9tICcuLi92ZWN0b3IuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyByZW5kZXJlciBmb3IgdmVjdG9yIGxheWVycy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlciBleHRlbmRzIENhbnZhc0xheWVyUmVuZGVyZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSB2ZWN0b3JMYXllciBWZWN0b3IgbGF5ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2ZWN0b3JMYXllcikge1xuXG4gICAgc3VwZXIodmVjdG9yTGF5ZXIpO1xuXG4gICAgLyoqXG4gICAgICogRGVjbHV0dGVyIHRyZWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlY2x1dHRlclRyZWVfID0gdmVjdG9yTGF5ZXIuZ2V0RGVjbHV0dGVyKCkgPyByYnVzaCg5LCB1bmRlZmluZWQpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5kaXJ0eV8gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkUmV2aXNpb25fID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZFJlc29sdXRpb25fID0gTmFOO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkRXh0ZW50XyA9IGNyZWF0ZUVtcHR5KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHQsIGltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdCk6IG51bWJlcnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZWRSZW5kZXJPcmRlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyL2NhbnZhcy9SZXBsYXlHcm91cC5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMucmVwbGF5R3JvdXBfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEEgbmV3IHJlcGxheSBncm91cCBoYWQgdG8gYmUgY3JlYXRlZCBieSBgcHJlcGFyZUZyYW1lKClgXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXBsYXlHcm91cENoYW5nZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoKTtcblxuICAgIGxpc3RlbihsYWJlbENhY2hlLCBFdmVudFR5cGUuQ0xFQVIsIHRoaXMuaGFuZGxlRm9udHNDaGFuZ2VkXywgdGhpcyk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHVubGlzdGVuKGxhYmVsQ2FjaGUsIEV2ZW50VHlwZS5DTEVBUiwgdGhpcy5oYW5kbGVGb250c0NoYW5nZWRfLCB0aGlzKTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCBDb250ZXh0LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLlN0YXRlfSBsYXllclN0YXRlIExheWVyIHN0YXRlLlxuICAgKi9cbiAgY29tcG9zZShjb250ZXh0LCBmcmFtZVN0YXRlLCBsYXllclN0YXRlKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gZnJhbWVTdGF0ZS5leHRlbnQ7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICBjb25zdCBza2lwcGVkRmVhdHVyZVVpZHMgPSBsYXllclN0YXRlLm1hbmFnZWQgP1xuICAgICAgZnJhbWVTdGF0ZS5za2lwcGVkRmVhdHVyZVVpZHMgOiB7fTtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3U3RhdGUucm90YXRpb247XG4gICAgY29uc3QgcHJvamVjdGlvbkV4dGVudCA9IHByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG4gICAgY29uc3QgdmVjdG9yU291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkuZ2V0U291cmNlKCkpO1xuXG4gICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIDApO1xuXG4gICAgLy8gY2xpcHBlZCByZW5kZXJpbmcgaWYgbGF5ZXIgZXh0ZW50IGlzIHNldFxuICAgIGNvbnN0IGNsaXBFeHRlbnQgPSBsYXllclN0YXRlLmV4dGVudDtcbiAgICBjb25zdCBjbGlwcGVkID0gY2xpcEV4dGVudCAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICB0aGlzLmNsaXAoY29udGV4dCwgZnJhbWVTdGF0ZSwgLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9leHRlbnQuanNcIikuRXh0ZW50fSAqLyAoY2xpcEV4dGVudCkpO1xuICAgIH1cbiAgICBjb25zdCByZXBsYXlHcm91cCA9IHRoaXMucmVwbGF5R3JvdXBfO1xuICAgIGlmIChyZXBsYXlHcm91cCAmJiAhcmVwbGF5R3JvdXAuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAodGhpcy5kZWNsdXR0ZXJUcmVlXykge1xuICAgICAgICB0aGlzLmRlY2x1dHRlclRyZWVfLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgICAgbGV0IGRyYXdPZmZzZXRYID0gMDtcbiAgICAgIGxldCBkcmF3T2Zmc2V0WSA9IDA7XG4gICAgICBsZXQgcmVwbGF5Q29udGV4dDtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50TGF5ZXIgPSBsYXllclN0YXRlLm9wYWNpdHkgIT09IDE7XG4gICAgICBjb25zdCBoYXNSZW5kZXJMaXN0ZW5lcnMgPSBsYXllci5oYXNMaXN0ZW5lcihSZW5kZXJFdmVudFR5cGUuUkVOREVSKTtcbiAgICAgIGlmICh0cmFuc3BhcmVudExheWVyIHx8IGhhc1JlbmRlckxpc3RlbmVycykge1xuICAgICAgICBsZXQgZHJhd1dpZHRoID0gY29udGV4dC5jYW52YXMud2lkdGg7XG4gICAgICAgIGxldCBkcmF3SGVpZ2h0ID0gY29udGV4dC5jYW52YXMuaGVpZ2h0O1xuICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICBjb25zdCBkcmF3U2l6ZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KGRyYXdXaWR0aCAqIGRyYXdXaWR0aCArIGRyYXdIZWlnaHQgKiBkcmF3SGVpZ2h0KSk7XG4gICAgICAgICAgZHJhd09mZnNldFggPSAoZHJhd1NpemUgLSBkcmF3V2lkdGgpIC8gMjtcbiAgICAgICAgICBkcmF3T2Zmc2V0WSA9IChkcmF3U2l6ZSAtIGRyYXdIZWlnaHQpIC8gMjtcbiAgICAgICAgICBkcmF3V2lkdGggPSBkcmF3SGVpZ2h0ID0gZHJhd1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzaXplIGFuZCBjbGVhclxuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzLndpZHRoID0gZHJhd1dpZHRoO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzLmhlaWdodCA9IGRyYXdIZWlnaHQ7XG4gICAgICAgIHJlcGxheUNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYXlDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWxwaGEgPSByZXBsYXlDb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgICAgaWYgKCF0cmFuc3BhcmVudExheWVyKSB7XG4gICAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBjb250ZXh0LnNhdmUgLyBjb250ZXh0LnJlc3RvcmUgaXMgbm90IHVzZWRcbiAgICAgICAgLy8gdG8gc2F2ZSBhbmQgcmVzdG9yZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGFuZCB0aGUgb3BhY2l0eS5cbiAgICAgICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnRleHQtc2F2ZS1yZXN0b3JlLXZlcnN1cy12YXJpYWJsZVxuICAgICAgICByZXBsYXlDb250ZXh0Lmdsb2JhbEFscGhhID0gbGF5ZXJTdGF0ZS5vcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVwbGF5Q29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgIHJlcGxheUNvbnRleHQudHJhbnNsYXRlKGRyYXdPZmZzZXRYLCBkcmF3T2Zmc2V0WSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZpZXdIaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgICAgY29uc3Qgc25hcFRvUGl4ZWwgPSAhKHZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddIHx8IHZpZXdIaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10pO1xuICAgICAgY29uc3Qgd2lkdGggPSBmcmFtZVN0YXRlLnNpemVbMF0gKiBwaXhlbFJhdGlvO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gZnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbztcbiAgICAgIHJvdGF0ZUF0T2Zmc2V0KHJlcGxheUNvbnRleHQsIC1yb3RhdGlvbixcbiAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgIHJlcGxheUdyb3VwLnJlcGxheShyZXBsYXlDb250ZXh0LCB0cmFuc2Zvcm0sIHJvdGF0aW9uLCBza2lwcGVkRmVhdHVyZVVpZHMsIHNuYXBUb1BpeGVsKTtcbiAgICAgIGlmICh2ZWN0b3JTb3VyY2UuZ2V0V3JhcFgoKSAmJiBwcm9qZWN0aW9uLmNhbldyYXBYKCkgJiZcbiAgICAgICAgICAhY29udGFpbnNFeHRlbnQocHJvamVjdGlvbkV4dGVudCwgZXh0ZW50KSkge1xuICAgICAgICBsZXQgc3RhcnRYID0gZXh0ZW50WzBdO1xuICAgICAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgICAgIGxldCB3b3JsZCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXRYO1xuICAgICAgICB3aGlsZSAoc3RhcnRYIDwgcHJvamVjdGlvbkV4dGVudFswXSkge1xuICAgICAgICAgIC0td29ybGQ7XG4gICAgICAgICAgb2Zmc2V0WCA9IHdvcmxkV2lkdGggKiB3b3JsZDtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSB0aGlzLmdldFRyYW5zZm9ybShmcmFtZVN0YXRlLCBvZmZzZXRYKTtcbiAgICAgICAgICByZXBsYXlHcm91cC5yZXBsYXkocmVwbGF5Q29udGV4dCwgdHJhbnNmb3JtLCByb3RhdGlvbiwgc2tpcHBlZEZlYXR1cmVVaWRzLCBzbmFwVG9QaXhlbCk7XG4gICAgICAgICAgc3RhcnRYICs9IHdvcmxkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgd29ybGQgPSAwO1xuICAgICAgICBzdGFydFggPSBleHRlbnRbMl07XG4gICAgICAgIHdoaWxlIChzdGFydFggPiBwcm9qZWN0aW9uRXh0ZW50WzJdKSB7XG4gICAgICAgICAgKyt3b3JsZDtcbiAgICAgICAgICBvZmZzZXRYID0gd29ybGRXaWR0aCAqIHdvcmxkO1xuICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIG9mZnNldFgpO1xuICAgICAgICAgIHJlcGxheUdyb3VwLnJlcGxheShyZXBsYXlDb250ZXh0LCB0cmFuc2Zvcm0sIHJvdGF0aW9uLCBza2lwcGVkRmVhdHVyZVVpZHMsIHNuYXBUb1BpeGVsKTtcbiAgICAgICAgICBzdGFydFggLT0gd29ybGRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcm90YXRlQXRPZmZzZXQocmVwbGF5Q29udGV4dCwgcm90YXRpb24sXG4gICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmIChoYXNSZW5kZXJMaXN0ZW5lcnMpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50KHJlcGxheUNvbnRleHQsIGZyYW1lU3RhdGUsIHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAocmVwbGF5Q29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0cmFuc3BhcmVudExheWVyKSB7XG4gICAgICAgICAgY29uc3QgbWFpbkNvbnRleHRBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGxheWVyU3RhdGUub3BhY2l0eTtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShyZXBsYXlDb250ZXh0LmNhbnZhcywgLWRyYXdPZmZzZXRYLCAtZHJhd09mZnNldFkpO1xuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBtYWluQ29udGV4dEFscGhhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHJlcGxheUNvbnRleHQuY2FudmFzLCAtZHJhd09mZnNldFgsIC1kcmF3T2Zmc2V0WSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGF5Q29udGV4dC50cmFuc2xhdGUoLWRyYXdPZmZzZXRYLCAtZHJhd09mZnNldFkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYW5zcGFyZW50TGF5ZXIpIHtcbiAgICAgICAgcmVwbGF5Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbGlwcGVkKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGNvbXBvc2VGcmFtZShmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBjb250ZXh0KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSwgMCk7XG4gICAgdGhpcy5wcmVDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUsIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5jb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpO1xuICAgIHRoaXMucG9zdENvbXBvc2UoY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSwgdHJhbnNmb3JtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGlmICghdGhpcy5yZXBsYXlHcm91cF8pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgICAgY29uc3Qgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICAgIGNvbnN0IGxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn0gKi9cbiAgICAgIGNvbnN0IGZlYXR1cmVzID0ge307XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnJlcGxheUdyb3VwXy5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShjb29yZGluYXRlLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgaGl0VG9sZXJhbmNlLCB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZX0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fSBDYWxsYmFjayByZXN1bHQuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgICAgICAgIGlmICghKGtleSBpbiBmZWF0dXJlcykpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZmVhdHVyZSwgbGF5ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgbnVsbCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBFdmVudC5cbiAgICovXG4gIGhhbmRsZUZvbnRzQ2hhbmdlZF8oZXZlbnQpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICBpZiAobGF5ZXIuZ2V0VmlzaWJsZSgpICYmIHRoaXMucmVwbGF5R3JvdXBfKSB7XG4gICAgICBsYXllci5jaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIGluIGltYWdlIHN0eWxlIHN0YXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2V2ZW50cy9FdmVudC5qc1wiKS5kZWZhdWx0fSBldmVudCBJbWFnZSBzdHlsZSBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTdHlsZUltYWdlQ2hhbmdlXyhldmVudCkge1xuICAgIHRoaXMucmVuZGVySWZSZWFkeUFuZFZpc2libGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgcHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICBjb25zdCB2ZWN0b3JMYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgIGNvbnN0IHZlY3RvclNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodmVjdG9yTGF5ZXIuZ2V0U291cmNlKCkpO1xuXG4gICAgY29uc3QgYW5pbWF0aW5nID0gZnJhbWVTdGF0ZS52aWV3SGludHNbVmlld0hpbnQuQU5JTUFUSU5HXTtcbiAgICBjb25zdCBpbnRlcmFjdGluZyA9IGZyYW1lU3RhdGUudmlld0hpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXTtcbiAgICBjb25zdCB1cGRhdGVXaGlsZUFuaW1hdGluZyA9IHZlY3RvckxheWVyLmdldFVwZGF0ZVdoaWxlQW5pbWF0aW5nKCk7XG4gICAgY29uc3QgdXBkYXRlV2hpbGVJbnRlcmFjdGluZyA9IHZlY3RvckxheWVyLmdldFVwZGF0ZVdoaWxlSW50ZXJhY3RpbmcoKTtcblxuICAgIGlmICghdGhpcy5kaXJ0eV8gJiYgKCF1cGRhdGVXaGlsZUFuaW1hdGluZyAmJiBhbmltYXRpbmcpIHx8XG4gICAgICAgICghdXBkYXRlV2hpbGVJbnRlcmFjdGluZyAmJiBpbnRlcmFjdGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGZyYW1lU3RhdGVFeHRlbnQgPSBmcmFtZVN0YXRlLmV4dGVudDtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlld1N0YXRlLnByb2plY3Rpb247XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3QgdmVjdG9yTGF5ZXJSZXZpc2lvbiA9IHZlY3RvckxheWVyLmdldFJldmlzaW9uKCk7XG4gICAgY29uc3QgdmVjdG9yTGF5ZXJSZW5kZXJCdWZmZXIgPSB2ZWN0b3JMYXllci5nZXRSZW5kZXJCdWZmZXIoKTtcbiAgICBsZXQgdmVjdG9yTGF5ZXJSZW5kZXJPcmRlciA9IHZlY3RvckxheWVyLmdldFJlbmRlck9yZGVyKCk7XG5cbiAgICBpZiAodmVjdG9yTGF5ZXJSZW5kZXJPcmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ZWN0b3JMYXllclJlbmRlck9yZGVyID0gZGVmYXVsdFJlbmRlck9yZGVyO1xuICAgIH1cblxuICAgIGNvbnN0IGV4dGVudCA9IGJ1ZmZlcihmcmFtZVN0YXRlRXh0ZW50LFxuICAgICAgdmVjdG9yTGF5ZXJSZW5kZXJCdWZmZXIgKiByZXNvbHV0aW9uKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gdmlld1N0YXRlLnByb2plY3Rpb24uZ2V0RXh0ZW50KCk7XG5cbiAgICBpZiAodmVjdG9yU291cmNlLmdldFdyYXBYKCkgJiYgdmlld1N0YXRlLnByb2plY3Rpb24uY2FuV3JhcFgoKSAmJlxuICAgICAgICAhY29udGFpbnNFeHRlbnQocHJvamVjdGlvbkV4dGVudCwgZnJhbWVTdGF0ZS5leHRlbnQpKSB7XG4gICAgICAvLyBGb3IgdGhlIHJlcGxheSBncm91cCwgd2UgbmVlZCBhbiBleHRlbnQgdGhhdCBpbnRlcnNlY3RzIHRoZSByZWFsIHdvcmxkXG4gICAgICAvLyAoLTE4MMKwIHRvICsxODDCsCkuIFRvIHN1cHBvcnQgZ2VvbWV0cmllcyBpbiBhIGNvb3JkaW5hdGUgcmFuZ2UgZnJvbSAtNTQwwrBcbiAgICAgIC8vIHRvICs1NDDCsCwgd2UgYWRkIGF0IGxlYXN0IDEgd29ybGQgd2lkdGggb24gZWFjaCBzaWRlIG9mIHRoZSBwcm9qZWN0aW9uXG4gICAgICAvLyBleHRlbnQuIElmIHRoZSB2aWV3cG9ydCBpcyB3aWRlciB0aGFuIHRoZSB3b3JsZCwgd2UgbmVlZCB0byBhZGQgaGFsZiBvZlxuICAgICAgLy8gdGhlIHZpZXdwb3J0IHdpZHRoIHRvIG1ha2Ugc3VyZSB3ZSBjb3ZlciB0aGUgd2hvbGUgdmlld3BvcnQuXG4gICAgICBjb25zdCB3b3JsZFdpZHRoID0gZ2V0V2lkdGgocHJvamVjdGlvbkV4dGVudCk7XG4gICAgICBjb25zdCBndXR0ZXIgPSBNYXRoLm1heChnZXRXaWR0aChleHRlbnQpIC8gMiwgd29ybGRXaWR0aCk7XG4gICAgICBleHRlbnRbMF0gPSBwcm9qZWN0aW9uRXh0ZW50WzBdIC0gZ3V0dGVyO1xuICAgICAgZXh0ZW50WzJdID0gcHJvamVjdGlvbkV4dGVudFsyXSArIGd1dHRlcjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGlydHlfICYmXG4gICAgICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9PSByZXNvbHV0aW9uICYmXG4gICAgICAgIHRoaXMucmVuZGVyZWRSZXZpc2lvbl8gPT0gdmVjdG9yTGF5ZXJSZXZpc2lvbiAmJlxuICAgICAgICB0aGlzLnJlbmRlcmVkUmVuZGVyT3JkZXJfID09IHZlY3RvckxheWVyUmVuZGVyT3JkZXIgJiZcbiAgICAgICAgY29udGFpbnNFeHRlbnQodGhpcy5yZW5kZXJlZEV4dGVudF8sIGV4dGVudCkpIHtcbiAgICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcGxheUdyb3VwXyA9IG51bGw7XG5cbiAgICB0aGlzLmRpcnR5XyA9IGZhbHNlO1xuXG4gICAgY29uc3QgcmVwbGF5R3JvdXAgPSBuZXcgQ2FudmFzUmVwbGF5R3JvdXAoXG4gICAgICBnZXRSZW5kZXJUb2xlcmFuY2UocmVzb2x1dGlvbiwgcGl4ZWxSYXRpbyksIGV4dGVudCwgcmVzb2x1dGlvbixcbiAgICAgIHBpeGVsUmF0aW8sIHZlY3RvclNvdXJjZS5nZXRPdmVybGFwcygpLCB0aGlzLmRlY2x1dHRlclRyZWVfLCB2ZWN0b3JMYXllci5nZXRSZW5kZXJCdWZmZXIoKSk7XG4gICAgdmVjdG9yU291cmNlLmxvYWRGZWF0dXJlcyhleHRlbnQsIHJlc29sdXRpb24sIHByb2plY3Rpb24pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0fSBmZWF0dXJlIEZlYXR1cmUuXG4gICAgICogQHRoaXMge0NhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXJ9XG4gICAgICovXG4gICAgY29uc3QgcmVuZGVyID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgbGV0IHN0eWxlcztcbiAgICAgIGNvbnN0IHN0eWxlRnVuY3Rpb24gPSBmZWF0dXJlLmdldFN0eWxlRnVuY3Rpb24oKSB8fCB2ZWN0b3JMYXllci5nZXRTdHlsZUZ1bmN0aW9uKCk7XG4gICAgICBpZiAoc3R5bGVGdW5jdGlvbikge1xuICAgICAgICBzdHlsZXMgPSBzdHlsZUZ1bmN0aW9uKGZlYXR1cmUsIHJlc29sdXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICBjb25zdCBkaXJ0eSA9IHRoaXMucmVuZGVyRmVhdHVyZShcbiAgICAgICAgICBmZWF0dXJlLCByZXNvbHV0aW9uLCBwaXhlbFJhdGlvLCBzdHlsZXMsIHJlcGxheUdyb3VwKTtcbiAgICAgICAgdGhpcy5kaXJ0eV8gPSB0aGlzLmRpcnR5XyB8fCBkaXJ0eTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG4gICAgaWYgKHZlY3RvckxheWVyUmVuZGVyT3JkZXIpIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vLi4vRmVhdHVyZS5qc1wiKS5kZWZhdWx0Pn0gKi9cbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gW107XG4gICAgICB2ZWN0b3JTb3VyY2UuZm9yRWFjaEZlYXR1cmVJbkV4dGVudChleHRlbnQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgIH0pO1xuICAgICAgZmVhdHVyZXMuc29ydCh2ZWN0b3JMYXllclJlbmRlck9yZGVyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgcmVuZGVyKGZlYXR1cmVzW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmVjdG9yU291cmNlLmZvckVhY2hGZWF0dXJlSW5FeHRlbnQoZXh0ZW50LCByZW5kZXIpO1xuICAgIH1cbiAgICByZXBsYXlHcm91cC5maW5pc2goKTtcblxuICAgIHRoaXMucmVuZGVyZWRSZXNvbHV0aW9uXyA9IHJlc29sdXRpb247XG4gICAgdGhpcy5yZW5kZXJlZFJldmlzaW9uXyA9IHZlY3RvckxheWVyUmV2aXNpb247XG4gICAgdGhpcy5yZW5kZXJlZFJlbmRlck9yZGVyXyA9IHZlY3RvckxheWVyUmVuZGVyT3JkZXI7XG4gICAgdGhpcy5yZW5kZXJlZEV4dGVudF8gPSBleHRlbnQ7XG4gICAgdGhpcy5yZXBsYXlHcm91cF8gPSByZXBsYXlHcm91cDtcblxuICAgIHRoaXMucmVwbGF5R3JvdXBDaGFuZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuZGVmYXVsdH0gZmVhdHVyZSBGZWF0dXJlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiBSZXNvbHV0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9zdHlsZS9TdHlsZS5qc1wiKS5kZWZhdWx0fEFycmF5PGltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHQ+fSBzdHlsZXMgVGhlIHN0eWxlIG9yIGFycmF5IG9mIHN0eWxlcy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9yZW5kZXIvY2FudmFzL1JlcGxheUdyb3VwLmpzXCIpLmRlZmF1bHR9IHJlcGxheUdyb3VwIFJlcGxheSBncm91cC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIGFuIGltYWdlIGlzIGxvYWRpbmcuXG4gICAqL1xuICByZW5kZXJGZWF0dXJlKGZlYXR1cmUsIHJlc29sdXRpb24sIHBpeGVsUmF0aW8sIHN0eWxlcywgcmVwbGF5R3JvdXApIHtcbiAgICBpZiAoIXN0eWxlcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbG9hZGluZyA9IGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHN0eWxlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxvYWRpbmcgPSByZW5kZXJGZWF0dXJlKFxuICAgICAgICAgIHJlcGxheUdyb3VwLCBmZWF0dXJlLCBzdHlsZXNbaV0sXG4gICAgICAgICAgZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSxcbiAgICAgICAgICB0aGlzLmhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLCB0aGlzKSB8fCBsb2FkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkaW5nID0gcmVuZGVyRmVhdHVyZShcbiAgICAgICAgcmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlcyxcbiAgICAgICAgZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKSxcbiAgICAgICAgdGhpcy5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBsb2FkaW5nO1xuICB9XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhpcyByZW5kZXJlciBoYW5kbGVzIHRoZSBwcm92aWRlZCBsYXllci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgVGhlIGNhbmRpZGF0ZSBsYXllci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZW5kZXJlciBjYW4gcmVuZGVyIHRoZSBsYXllci5cbiAqL1xuQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlclsnaGFuZGxlcyddID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgcmV0dXJuIGxheWVyLmdldFR5cGUoKSA9PT0gTGF5ZXJUeXBlLlZFQ1RPUjtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciByZW5kZXJlci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcFJlbmRlcmVyIFRoZSBtYXAgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIFRoZSBsYXllciB0byBiZSByZW5kZXJlcmQuXG4gKiBAcmV0dXJuIHtDYW52YXNWZWN0b3JMYXllclJlbmRlcmVyfSBUaGUgbGF5ZXIgcmVuZGVyZXIuXG4gKi9cbkNhbnZhc1ZlY3RvckxheWVyUmVuZGVyZXJbJ2NyZWF0ZSddID0gZnVuY3Rpb24obWFwUmVuZGVyZXIsIGxheWVyKSB7XG4gIHJldHVybiBuZXcgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIpKTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQ2FudmFzVmVjdG9yTGF5ZXJSZW5kZXJlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUFBO0FBS0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7OztBQUtBO0FBRUE7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7OztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFHQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQXRZQTs7Ozs7Ozs7QUE4WUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///129\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);\n/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);\n/**\n * @module ol/interaction/DoubleClickZoom\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [delta=1] The zoom delta applied on each double click.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom by double-clicking on the map.\n * @api\n */\n\nvar DoubleClickZoom =\n/*@__PURE__*/\nfunction (Interaction) {\n  function DoubleClickZoom(opt_options) {\n    Interaction.call(this, {\n      handleEvent: handleEvent\n    });\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.delta_ = options.delta ? options.delta : 1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  if (Interaction) DoubleClickZoom.__proto__ = Interaction;\n  DoubleClickZoom.prototype = Object.create(Interaction && Interaction.prototype);\n  DoubleClickZoom.prototype.constructor = DoubleClickZoom;\n  return DoubleClickZoom;\n}(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n/**\n * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a\n * doubleclick) and eventually zooms the map.\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {DoubleClickZoom}\n */\n\n\nfunction handleEvent(mapBrowserEvent) {\n  var stopEvent = false;\n\n  if (mapBrowserEvent.type == _MapBrowserEventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].DBLCLICK) {\n    var browserEvent =\n    /** @type {MouseEvent} */\n    mapBrowserEvent.originalEvent;\n    var map = mapBrowserEvent.map;\n    var anchor = mapBrowserEvent.coordinate;\n    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n    var view = map.getView();\n    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_1__[/* zoomByDelta */ "d"])(view, delta, anchor, this.duration_);\n    mapBrowserEvent.preventDefault();\n    stopEvent = true;\n  }\n\n  return !stopEvent;\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (DoubleClickZoom);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9pbnRlcmFjdGlvbi9Eb3VibGVDbGlja1pvb20uanM/ZjFlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vRG91YmxlQ2xpY2tab29tXG4gKi9cbmltcG9ydCBNYXBCcm93c2VyRXZlbnRUeXBlIGZyb20gJy4uL01hcEJyb3dzZXJFdmVudFR5cGUuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uLCB7em9vbUJ5RGVsdGF9IGZyb20gJy4vSW50ZXJhY3Rpb24uanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0yNTBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2RlbHRhPTFdIFRoZSB6b29tIGRlbHRhIGFwcGxpZWQgb24gZWFjaCBkb3VibGUgY2xpY2suXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIGJ5IGRvdWJsZS1jbGlja2luZyBvbiB0aGUgbWFwLlxuICogQGFwaVxuICovXG5jbGFzcyBEb3VibGVDbGlja1pvb20gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhXyA9IG9wdGlvbnMuZGVsdGEgPyBvcHRpb25zLmRlbHRhIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgfVxuXG59XG5cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhXG4gKiBkb3VibGVjbGljaykgYW5kIGV2ZW50dWFsbHkgem9vbXMgdGhlIG1hcC5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBNYXAgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IGBmYWxzZWAgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbi5cbiAqIEB0aGlzIHtEb3VibGVDbGlja1pvb219XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICBsZXQgc3RvcEV2ZW50ID0gZmFsc2U7XG4gIGlmIChtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLKSB7XG4gICAgY29uc3QgYnJvd3NlckV2ZW50ID0gLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAobWFwQnJvd3NlckV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3QgYW5jaG9yID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgY29uc3QgZGVsdGEgPSBicm93c2VyRXZlbnQuc2hpZnRLZXkgPyAtdGhpcy5kZWx0YV8gOiB0aGlzLmRlbHRhXztcbiAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICB6b29tQnlEZWx0YSh2aWV3LCBkZWx0YSwgYW5jaG9yLCB0aGlzLmR1cmF0aW9uXyk7XG4gICAgbWFwQnJvd3NlckV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgc3RvcEV2ZW50ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gIXN0b3BFdmVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRG91YmxlQ2xpY2tab29tO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWVBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBSUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7QUF4QkE7Ozs7Ozs7Ozs7QUFvQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///130\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);\n/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);\n/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);\n/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20);\n/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62);\n/**\n * @module ol/interaction/DragPan\n */\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition~noModifierKeys}.\n * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\n\nvar DragPan =\n/*@__PURE__*/\nfunction (PointerInteraction) {\n  function DragPan(opt_options) {\n    PointerInteraction.call(this, {\n      stopDown: _functions_js__WEBPACK_IMPORTED_MODULE_4__[/* FALSE */ "a"]\n    });\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {import("../Kinetic.js").default|undefined}\n     */\n\n    this.kinetic_ = options.kinetic;\n    /**\n     * @type {import("../pixel.js").Pixel}\n     */\n\n    this.lastCentroid = null;\n    /**\n     * @type {number}\n     */\n\n    this.lastPointersCount_;\n    /**\n     * @type {boolean}\n     */\n\n    this.panning_ = false;\n    /**\n     * @private\n     * @type {import("../events/condition.js").Condition}\n     */\n\n    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_3__[/* noModifierKeys */ "d"];\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.noKinetic_ = false;\n  }\n\n  if (PointerInteraction) DragPan.__proto__ = PointerInteraction;\n  DragPan.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  DragPan.prototype.constructor = DragPan;\n  /**\n   * @inheritDoc\n   */\n\n  DragPan.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n    if (!this.panning_) {\n      this.panning_ = true;\n      this.getMap().getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].INTERACTING, 1);\n    }\n\n    var targetPointers = this.targetPointers;\n    var centroid = Object(_Pointer_js__WEBPACK_IMPORTED_MODULE_5__[/* centroid */ "a"])(targetPointers);\n\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid[0], centroid[1]);\n      }\n\n      if (this.lastCentroid) {\n        var deltaX = this.lastCentroid[0] - centroid[0];\n        var deltaY = centroid[1] - this.lastCentroid[1];\n        var map = mapBrowserEvent.map;\n        var view = map.getView();\n        var center = [deltaX, deltaY];\n        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["scale"])(center, view.getResolution());\n        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["rotate"])(center, view.getRotation());\n        Object(_coordinate_js__WEBPACK_IMPORTED_MODULE_1__["add"])(center, view.getCenter());\n        center = view.constrainCenter(center);\n        view.setCenter(center);\n      }\n    } else if (this.kinetic_) {\n      // reset so we don\'t overestimate the kinetic energy after\n      // after one finger down, tiny drag, second finger down\n      this.kinetic_.begin();\n    }\n\n    this.lastCentroid = centroid;\n    this.lastPointersCount_ = targetPointers.length;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  DragPan.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        var distance = this.kinetic_.getDistance();\n        var angle = this.kinetic_.getAngle();\n        var center =\n        /** @type {!import("../coordinate.js").Coordinate} */\n        view.getCenter();\n        var centerpx = map.getPixelFromCoordinate(center);\n        var dest = map.getCoordinateFromPixel([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);\n        view.animate({\n          center: view.constrainCenter(dest),\n          duration: 500,\n          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"]\n        });\n      }\n\n      if (this.panning_) {\n        this.panning_ = false;\n        view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].INTERACTING, -1);\n      }\n\n      return false;\n    } else {\n      if (this.kinetic_) {\n        // reset so we don\'t overestimate the kinetic energy after\n        // after one finger up, tiny drag, second finger up\n        this.kinetic_.begin();\n      }\n\n      this.lastCentroid = null;\n      return true;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  DragPan.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      this.lastCentroid = null; // stop any current animation\n\n      if (view.getAnimating()) {\n        view.setCenter(mapBrowserEvent.frameState.viewState.center);\n      }\n\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      } // No kinetic as soon as more than one pointer on the screen is\n      // detected. This is to prevent nasty pans after pinch.\n\n\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return DragPan;\n}(_Pointer_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "b"]);\n\n/* harmony default export */ __webpack_exports__["default"] = (DragPan);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9pbnRlcmFjdGlvbi9EcmFnUGFuLmpzPzViM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdQYW5cbiAqL1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7c2NhbGUgYXMgc2NhbGVDb29yZGluYXRlLCByb3RhdGUgYXMgcm90YXRlQ29vcmRpbmF0ZSwgYWRkIGFzIGFkZENvb3JkaW5hdGV9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IHtub01vZGlmaWVyS2V5c30gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IFBvaW50ZXJJbnRlcmFjdGlvbiwge2NlbnRyb2lkIGFzIGNlbnRyb2lkRnJvbVBvaW50ZXJzfSBmcm9tICcuL1BvaW50ZXIuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYSBib29sZWFuXG4gKiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKiBEZWZhdWx0IGlzIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5ub01vZGlmaWVyS2V5c30uXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL0tpbmV0aWMuanNcIikuZGVmYXVsdH0gW2tpbmV0aWNdIEtpbmV0aWMgaW5lcnRpYSB0byBhcHBseSB0byB0aGUgcGFuLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcGFuIHRoZSBtYXAgYnkgZHJhZ2dpbmcgdGhlIG1hcC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ1BhbiBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X29wdGlvbnMpIHtcblxuICAgIHN1cGVyKHtcbiAgICAgIHN0b3BEb3duOiBGQUxTRVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL0tpbmV0aWMuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5raW5ldGljXyA9IG9wdGlvbnMua2luZXRpYztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RDZW50cm9pZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFBvaW50ZXJzQ291bnRfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5wYW5uaW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259XG4gICAgICovXG4gICAgdGhpcy5jb25kaXRpb25fID0gb3B0aW9ucy5jb25kaXRpb24gPyBvcHRpb25zLmNvbmRpdGlvbiA6IG5vTW9kaWZpZXJLZXlzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm5vS2luZXRpY18gPSBmYWxzZTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBoYW5kbGVEcmFnRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnBhbm5pbmdfKSB7XG4gICAgICB0aGlzLnBhbm5pbmdfID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2V0TWFwKCkuZ2V0VmlldygpLnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIDEpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRQb2ludGVycyA9IHRoaXMudGFyZ2V0UG9pbnRlcnM7XG4gICAgY29uc3QgY2VudHJvaWQgPSBjZW50cm9pZEZyb21Qb2ludGVycyh0YXJnZXRQb2ludGVycyk7XG4gICAgaWYgKHRhcmdldFBvaW50ZXJzLmxlbmd0aCA9PSB0aGlzLmxhc3RQb2ludGVyc0NvdW50Xykge1xuICAgICAgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgICAgdGhpcy5raW5ldGljXy51cGRhdGUoY2VudHJvaWRbMF0sIGNlbnRyb2lkWzFdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxhc3RDZW50cm9pZCkge1xuICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLmxhc3RDZW50cm9pZFswXSAtIGNlbnRyb2lkWzBdO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBjZW50cm9pZFsxXSAtIHRoaXMubGFzdENlbnRyb2lkWzFdO1xuICAgICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgICAgbGV0IGNlbnRlciA9IFtkZWx0YVgsIGRlbHRhWV07XG4gICAgICAgIHNjYWxlQ29vcmRpbmF0ZShjZW50ZXIsIHZpZXcuZ2V0UmVzb2x1dGlvbigpKTtcbiAgICAgICAgcm90YXRlQ29vcmRpbmF0ZShjZW50ZXIsIHZpZXcuZ2V0Um90YXRpb24oKSk7XG4gICAgICAgIGFkZENvb3JkaW5hdGUoY2VudGVyLCB2aWV3LmdldENlbnRlcigpKTtcbiAgICAgICAgY2VudGVyID0gdmlldy5jb25zdHJhaW5DZW50ZXIoY2VudGVyKTtcbiAgICAgICAgdmlldy5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZXRpY18pIHtcbiAgICAgIC8vIHJlc2V0IHNvIHdlIGRvbid0IG92ZXJlc3RpbWF0ZSB0aGUga2luZXRpYyBlbmVyZ3kgYWZ0ZXJcbiAgICAgIC8vIGFmdGVyIG9uZSBmaW5nZXIgZG93biwgdGlueSBkcmFnLCBzZWNvbmQgZmluZ2VyIGRvd25cbiAgICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q2VudHJvaWQgPSBjZW50cm9pZDtcbiAgICB0aGlzLmxhc3RQb2ludGVyc0NvdW50XyA9IHRhcmdldFBvaW50ZXJzLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgaGFuZGxlVXBFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLm5vS2luZXRpY18gJiYgdGhpcy5raW5ldGljXyAmJiB0aGlzLmtpbmV0aWNfLmVuZCgpKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5raW5ldGljXy5nZXREaXN0YW5jZSgpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IHRoaXMua2luZXRpY18uZ2V0QW5nbGUoKTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSAqLyAodmlldy5nZXRDZW50ZXIoKSk7XG4gICAgICAgIGNvbnN0IGNlbnRlcnB4ID0gbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoY2VudGVyKTtcbiAgICAgICAgY29uc3QgZGVzdCA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKFtcbiAgICAgICAgICBjZW50ZXJweFswXSAtIGRpc3RhbmNlICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIGNlbnRlcnB4WzFdIC0gZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICAgXSk7XG4gICAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgICAgY2VudGVyOiB2aWV3LmNvbnN0cmFpbkNlbnRlcihkZXN0KSxcbiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhbm5pbmdfKSB7XG4gICAgICAgIHRoaXMucGFubmluZ18gPSBmYWxzZTtcbiAgICAgICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAgIC8vIHJlc2V0IHNvIHdlIGRvbid0IG92ZXJlc3RpbWF0ZSB0aGUga2luZXRpYyBlbmVyZ3kgYWZ0ZXJcbiAgICAgICAgLy8gYWZ0ZXIgb25lIGZpbmdlciB1cCwgdGlueSBkcmFnLCBzZWNvbmQgZmluZ2VyIHVwXG4gICAgICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+IDAgJiYgdGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHRoaXMubGFzdENlbnRyb2lkID0gbnVsbDtcbiAgICAgIC8vIHN0b3AgYW55IGN1cnJlbnQgYW5pbWF0aW9uXG4gICAgICBpZiAodmlldy5nZXRBbmltYXRpbmcoKSkge1xuICAgICAgICB2aWV3LnNldENlbnRlcihtYXBCcm93c2VyRXZlbnQuZnJhbWVTdGF0ZS52aWV3U3RhdGUuY2VudGVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmtpbmV0aWNfKSB7XG4gICAgICAgIHRoaXMua2luZXRpY18uYmVnaW4oKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vIGtpbmV0aWMgYXMgc29vbiBhcyBtb3JlIHRoYW4gb25lIHBvaW50ZXIgb24gdGhlIHNjcmVlbiBpc1xuICAgICAgLy8gZGV0ZWN0ZWQuIFRoaXMgaXMgdG8gcHJldmVudCBuYXN0eSBwYW5zIGFmdGVyIHBpbmNoLlxuICAgICAgdGhpcy5ub0tpbmV0aWNfID0gdGhpcy50YXJnZXRQb2ludGVycy5sZW5ndGggPiAxO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRHJhZ1BhbjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBREE7QUFJQTs7Ozs7O0FBTUE7Ozs7O0FBS0E7Ozs7O0FBS0E7Ozs7O0FBS0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQS9JQTtBQUNBO0FBZ0pBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///131\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\n/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);\n/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);\n/**\n * @module ol/interaction/KeyboardZoom\n */\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {import("../events/condition.js").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition~targetNotEditable}.\n * @property {number} [delta=1] The zoom level delta on each key press.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map using keyboard + and -.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.\n * @api\n */\n\nvar KeyboardZoom =\n/*@__PURE__*/\nfunction (Interaction) {\n  function KeyboardZoom(opt_options) {\n    Interaction.call(this, {\n      handleEvent: handleEvent\n    });\n    var options = opt_options ? opt_options : {};\n    /**\n     * @private\n     * @type {import("../events/condition.js").Condition}\n     */\n\n    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__[/* targetNotEditable */ "f"];\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.delta_ = options.delta ? options.delta : 1;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n  }\n\n  if (Interaction) KeyboardZoom.__proto__ = Interaction;\n  KeyboardZoom.prototype = Object.create(Interaction && Interaction.prototype);\n  KeyboardZoom.prototype.constructor = KeyboardZoom;\n  return KeyboardZoom;\n}(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);\n/**\n * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a\n * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\n * key pressed was \'+\' or \'-\').\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {KeyboardZoom}\n */\n\n\nfunction handleEvent(mapBrowserEvent) {\n  var stopEvent = false;\n\n  if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].KEYDOWN || mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].KEYPRESS) {\n    var keyEvent =\n    /** @type {KeyboardEvent} */\n    mapBrowserEvent.originalEvent;\n    var charCode = keyEvent.charCode;\n\n    if (this.condition_(mapBrowserEvent) && (charCode == \'+\'.charCodeAt(0) || charCode == \'-\'.charCodeAt(0))) {\n      var map = mapBrowserEvent.map;\n      var delta = charCode == \'+\'.charCodeAt(0) ? this.delta_ : -this.delta_;\n      var view = map.getView();\n      Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__[/* zoomByDelta */ "d"])(view, delta, undefined, this.duration_);\n      mapBrowserEvent.preventDefault();\n      stopEvent = true;\n    }\n  }\n\n  return !stopEvent;\n}\n\n/* harmony default export */ __webpack_exports__["default"] = (KeyboardZoom);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb20uanM/NTJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tXG4gKi9cbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge3RhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3pvb21CeURlbHRhfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249MTAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn0gW2NvbmRpdGlvbl0gQSBmdW5jdGlvbiB0aGF0XG4gKiB0YWtlcyBhbiB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9IGFuZCByZXR1cm5zIGFcbiAqIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGF0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkLiBEZWZhdWx0IGlzXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+dGFyZ2V0Tm90RWRpdGFibGV9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZWx0YT0xXSBUaGUgem9vbSBsZXZlbCBkZWx0YSBvbiBlYWNoIGtleSBwcmVzcy5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCB1c2luZyBrZXlib2FyZCArIGFuZCAtLlxuICogTm90ZSB0aGF0LCBhbHRob3VnaCB0aGlzIGludGVyYWN0aW9uIGlzIGJ5IGRlZmF1bHQgaW5jbHVkZWQgaW4gbWFwcyxcbiAqIHRoZSBrZXlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBicm93c2VyIGZvY3VzIGlzIG9uIHRoZSBlbGVtZW50IHRvIHdoaWNoXG4gKiB0aGUga2V5Ym9hcmQgZXZlbnRzIGFyZSBhdHRhY2hlZC4gQnkgZGVmYXVsdCwgdGhpcyBpcyB0aGUgbWFwIGRpdixcbiAqIHRob3VnaCB5b3UgY2FuIGNoYW5nZSB0aGlzIHdpdGggdGhlIGBrZXlib2FyZEV2ZW50VGFyZ2V0YCBpblxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfS4gYGRvY3VtZW50YCBuZXZlciBsb3NlcyBmb2N1cyBidXQsIGZvciBhbnkgb3RoZXJcbiAqIGVsZW1lbnQsIGZvY3VzIHdpbGwgaGF2ZSB0byBiZSBvbiwgYW5kIHJldHVybmVkIHRvLCB0aGlzIGVsZW1lbnQgaWYgdGhlIGtleXNcbiAqIGFyZSB0byBmdW5jdGlvbi5cbiAqIFNlZSBhbHNvIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW5+S2V5Ym9hcmRQYW59LlxuICogQGFwaVxuICovXG5jbGFzcyBLZXlib2FyZFpvb20gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X29wdGlvbnMpIHtcblxuICAgIHN1cGVyKHtcbiAgICAgIGhhbmRsZUV2ZW50OiBoYW5kbGVFdmVudFxuICAgIH0pO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zID8gb3B0X29wdGlvbnMgOiB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiB0YXJnZXROb3RFZGl0YWJsZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhXyA9IG9wdGlvbnMuZGVsdGEgPyBvcHRpb25zLmRlbHRhIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDA7XG5cbiAgfVxuXG59XG5cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gaWYgaXQgd2FzIGFcbiAqIGBLZXlFdmVudGAsIGFuZCBkZWNpZGVzIHdoZXRoZXIgdG8gem9vbSBpbiBvciBvdXQgKGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZVxuICoga2V5IHByZXNzZWQgd2FzICcrJyBvciAnLScpLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge0tleWJvYXJkWm9vbX1cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gIGxldCBzdG9wRXZlbnQgPSBmYWxzZTtcbiAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5LRVlET1dOIHx8XG4gICAgICBtYXBCcm93c2VyRXZlbnQudHlwZSA9PSBFdmVudFR5cGUuS0VZUFJFU1MpIHtcbiAgICBjb25zdCBrZXlFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgICBjb25zdCBjaGFyQ29kZSA9IGtleUV2ZW50LmNoYXJDb2RlO1xuICAgIGlmICh0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgICAoY2hhckNvZGUgPT0gJysnLmNoYXJDb2RlQXQoMCkgfHwgY2hhckNvZGUgPT0gJy0nLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgZGVsdGEgPSAoY2hhckNvZGUgPT0gJysnLmNoYXJDb2RlQXQoMCkpID8gdGhpcy5kZWx0YV8gOiAtdGhpcy5kZWx0YV87XG4gICAgICBjb25zdCB2aWV3ID0gbWFwLmdldFZpZXcoKTtcbiAgICAgIHpvb21CeURlbHRhKHZpZXcsIGRlbHRhLCB1bmRlZmluZWQsIHRoaXMuZHVyYXRpb25fKTtcbiAgICAgIG1hcEJyb3dzZXJFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3RvcEV2ZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFzdG9wRXZlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEtleWJvYXJkWm9vbTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQURBO0FBSUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7O0FBOUJBOzs7Ozs7Ozs7OztBQTJDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///132\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mode", function() { return Mode; });\n/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);\n/* harmony import */ var _events_condition_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);\n/* harmony import */ var _easing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);\n/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);\n/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30);\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);\n/**\n * @module ol/interaction/MouseWheelZoom\n */\n\n\n\n\n\n\n\n/**\n * Maximum mouse wheel delta.\n * @type {number}\n */\n\nvar MAX_DELTA = 1;\n/**\n * @enum {string}\n */\n\nvar Mode = {\n  TRACKPAD: \'trackpad\',\n  WHEEL: \'wheel\'\n};\n/**\n * @typedef {Object} Options\n * @property {import("../events/condition.js").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition~always}.\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.\n * @property {boolean} [constrainResolution=false] When using a trackpad or\n * magic mouse, zoom to the closest integer zoom level after the scroll gesture\n * ends.\n * @property {boolean} [useAnchor=true] Enable zooming using the mouse\'s\n * location as the anchor. When set to `false`, zooming in and out will zoom to\n * the center of the screen instead of zooming on the mouse\'s location.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by scrolling the mouse wheel.\n * @api\n */\n\nvar MouseWheelZoom =\n/*@__PURE__*/\nfunction (Interaction) {\n  function MouseWheelZoom(opt_options) {\n    var options = opt_options ? opt_options : {};\n    Interaction.call(\n    /** @type {import("./Interaction.js").InteractionOptions} */\n    this, options);\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.delta_ = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.constrainResolution_ = options.constrainResolution || false;\n    /**\n     * @private\n     * @type {import("../events/condition.js").Condition}\n     */\n\n    this.condition_ = options.condition ? options.condition : _events_condition_js__WEBPACK_IMPORTED_MODULE_1__[/* always */ "a"];\n    /**\n     * @private\n     * @type {?import("../coordinate.js").Coordinate}\n     */\n\n    this.lastAnchor_ = null;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.startTime_ = undefined;\n    /**\n     * @private\n     * @type {?}\n     */\n\n    this.timeoutId_;\n    /**\n     * @private\n     * @type {Mode|undefined}\n     */\n\n    this.mode_ = undefined;\n    /**\n     * Trackpad events separated by this delay will be considered separate\n     * interactions.\n     * @type {number}\n     */\n\n    this.trackpadEventGap_ = 400;\n    /**\n     * @type {?}\n     */\n\n    this.trackpadTimeoutId_;\n    /**\n     * The number of delta values per zoom level\n     * @private\n     * @type {number}\n     */\n\n    this.trackpadDeltaPerZoom_ = 300;\n    /**\n     * The zoom factor by which scroll zooming is allowed to exceed the limits.\n     * @private\n     * @type {number}\n     */\n\n    this.trackpadZoomBuffer_ = 1.5;\n  }\n\n  if (Interaction) MouseWheelZoom.__proto__ = Interaction;\n  MouseWheelZoom.prototype = Object.create(Interaction && Interaction.prototype);\n  MouseWheelZoom.prototype.constructor = MouseWheelZoom;\n  /**\n   * @private\n   */\n\n  MouseWheelZoom.prototype.decrementInteractingHint_ = function decrementInteractingHint_() {\n    this.trackpadTimeoutId_ = undefined;\n    var view = this.getMap().getView();\n    view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].INTERACTING, -1);\n  };\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually\n   * zooms the map.\n   * @override\n   */\n\n\n  MouseWheelZoom.prototype.handleEvent = function handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n\n    var type = mapBrowserEvent.type;\n\n    if (type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].WHEEL && type !== _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].MOUSEWHEEL) {\n      return true;\n    }\n\n    mapBrowserEvent.preventDefault();\n    var map = mapBrowserEvent.map;\n    var wheelEvent =\n    /** @type {WheelEvent} */\n    mapBrowserEvent.originalEvent;\n\n    if (this.useAnchor_) {\n      this.lastAnchor_ = mapBrowserEvent.coordinate;\n    } // Delta normalisation inspired by\n    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\n\n\n    var delta;\n\n    if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].WHEEL) {\n      delta = wheelEvent.deltaY;\n\n      if (_has_js__WEBPACK_IMPORTED_MODULE_4__[/* FIREFOX */ "c"] && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n        delta /= _has_js__WEBPACK_IMPORTED_MODULE_4__[/* DEVICE_PIXEL_RATIO */ "b"];\n      }\n\n      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        delta *= 40;\n      }\n    } else if (mapBrowserEvent.type == _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].MOUSEWHEEL) {\n      delta = -wheelEvent.wheelDeltaY;\n\n      if (_has_js__WEBPACK_IMPORTED_MODULE_4__[/* SAFARI */ "h"]) {\n        delta /= 3;\n      }\n    }\n\n    if (delta === 0) {\n      return false;\n    }\n\n    var now = Date.now();\n\n    if (this.startTime_ === undefined) {\n      this.startTime_ = now;\n    }\n\n    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\n      this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;\n    }\n\n    if (this.mode_ === Mode.TRACKPAD) {\n      var view = map.getView();\n\n      if (this.trackpadTimeoutId_) {\n        clearTimeout(this.trackpadTimeoutId_);\n      } else {\n        view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].INTERACTING, 1);\n      }\n\n      this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);\n      var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);\n      var minResolution = view.getMinResolution();\n      var maxResolution = view.getMaxResolution();\n      var rebound = 0;\n\n      if (resolution < minResolution) {\n        resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);\n        rebound = 1;\n      } else if (resolution > maxResolution) {\n        resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);\n        rebound = -1;\n      }\n\n      if (this.lastAnchor_) {\n        var center = view.calculateCenterZoom(resolution, this.lastAnchor_);\n        view.setCenter(view.constrainCenter(center));\n      }\n\n      view.setResolution(resolution);\n\n      if (rebound === 0 && this.constrainResolution_) {\n        view.animate({\n          resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),\n          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],\n          anchor: this.lastAnchor_,\n          duration: this.duration_\n        });\n      }\n\n      if (rebound > 0) {\n        view.animate({\n          resolution: minResolution,\n          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],\n          anchor: this.lastAnchor_,\n          duration: 500\n        });\n      } else if (rebound < 0) {\n        view.animate({\n          resolution: maxResolution,\n          easing: _easing_js__WEBPACK_IMPORTED_MODULE_2__["easeOut"],\n          anchor: this.lastAnchor_,\n          duration: 500\n        });\n      }\n\n      this.startTime_ = now;\n      return false;\n    }\n\n    this.delta_ += delta;\n    var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\n    clearTimeout(this.timeoutId_);\n    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);\n    return false;\n  };\n  /**\n   * @private\n   * @param {import("../PluggableMap.js").default} map Map.\n   */\n\n\n  MouseWheelZoom.prototype.handleWheelZoom_ = function handleWheelZoom_(map) {\n    var view = map.getView();\n\n    if (view.getAnimating()) {\n      view.cancelAnimations();\n    }\n\n    var maxDelta = MAX_DELTA;\n    var delta = Object(_math_js__WEBPACK_IMPORTED_MODULE_6__[/* clamp */ "a"])(this.delta_, -maxDelta, maxDelta);\n    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_5__[/* zoomByDelta */ "d"])(view, -delta, this.lastAnchor_, this.duration_);\n    this.mode_ = undefined;\n    this.delta_ = 0;\n    this.lastAnchor_ = null;\n    this.startTime_ = undefined;\n    this.timeoutId_ = undefined;\n  };\n  /**\n   * Enable or disable using the mouse\'s location as an anchor when zooming\n   * @param {boolean} useAnchor true to zoom to the mouse\'s location, false\n   * to zoom to the center of the map\n   * @api\n   */\n\n\n  MouseWheelZoom.prototype.setMouseAnchor = function setMouseAnchor(useAnchor) {\n    this.useAnchor_ = useAnchor;\n\n    if (!useAnchor) {\n      this.lastAnchor_ = null;\n    }\n  };\n\n  return MouseWheelZoom;\n}(_Interaction_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["default"] = (MouseWheelZoom);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbS5qcz8zNGJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9pbnRlcmFjdGlvbi9Nb3VzZVdoZWVsWm9vbVxuICovXG5pbXBvcnQgVmlld0hpbnQgZnJvbSAnLi4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHthbHdheXN9IGZyb20gJy4uL2V2ZW50cy9jb25kaXRpb24uanMnO1xuaW1wb3J0IHtlYXNlT3V0fSBmcm9tICcuLi9lYXNpbmcuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7REVWSUNFX1BJWEVMX1JBVElPLCBGSVJFRk9YLCBTQUZBUkl9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQgSW50ZXJhY3Rpb24sIHt6b29tQnlEZWx0YX0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQge2NsYW1wfSBmcm9tICcuLi9tYXRoLmpzJztcblxuXG4vKipcbiAqIE1heGltdW0gbW91c2Ugd2hlZWwgZGVsdGEuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBNQVhfREVMVEEgPSAxO1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IE1vZGUgPSB7XG4gIFRSQUNLUEFEOiAndHJhY2twYWQnLFxuICBXSEVFTDogJ3doZWVsJ1xufTtcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC4gRGVmYXVsdCBpc1xuICoge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufmFsd2F5c30uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTI1MF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGltZW91dD04MF0gTW91c2Ugd2hlZWwgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjb25zdHJhaW5SZXNvbHV0aW9uPWZhbHNlXSBXaGVuIHVzaW5nIGEgdHJhY2twYWQgb3JcbiAqIG1hZ2ljIG1vdXNlLCB6b29tIHRvIHRoZSBjbG9zZXN0IGludGVnZXIgem9vbSBsZXZlbCBhZnRlciB0aGUgc2Nyb2xsIGdlc3R1cmVcbiAqIGVuZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VBbmNob3I9dHJ1ZV0gRW5hYmxlIHpvb21pbmcgdXNpbmcgdGhlIG1vdXNlJ3NcbiAqIGxvY2F0aW9uIGFzIHRoZSBhbmNob3IuIFdoZW4gc2V0IHRvIGBmYWxzZWAsIHpvb21pbmcgaW4gYW5kIG91dCB3aWxsIHpvb20gdG9cbiAqIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlbiBpbnN0ZWFkIG9mIHpvb21pbmcgb24gdGhlIG1vdXNlJ3MgbG9jYXRpb24uXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgYnkgc2Nyb2xsaW5nIHRoZSBtb3VzZSB3aGVlbC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgTW91c2VXaGVlbFpvb20gZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X29wdGlvbnMpIHtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBzdXBlcigvKiogQHR5cGUge2ltcG9ydChcIi4vSW50ZXJhY3Rpb24uanNcIikuSW50ZXJhY3Rpb25PcHRpb25zfSAqLyAob3B0aW9ucykpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyNTA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aW1lb3V0XyA9IG9wdGlvbnMudGltZW91dCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50aW1lb3V0IDogODA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlQW5jaG9yXyA9IG9wdGlvbnMudXNlQW5jaG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnVzZUFuY2hvciA6IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWluUmVzb2x1dGlvbl8gPSBvcHRpb25zLmNvbnN0cmFpblJlc29sdXRpb24gfHwgZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogYWx3YXlzO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFRpbWVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICB0aGlzLnRpbWVvdXRJZF87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNb2RlfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVfID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVHJhY2twYWQgZXZlbnRzIHNlcGFyYXRlZCBieSB0aGlzIGRlbGF5IHdpbGwgYmUgY29uc2lkZXJlZCBzZXBhcmF0ZVxuICAgICAqIGludGVyYWN0aW9ucy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRFdmVudEdhcF8gPSA0MDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7P31cbiAgICAgKi9cbiAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXztcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGVsdGEgdmFsdWVzIHBlciB6b29tIGxldmVsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWREZWx0YVBlclpvb21fID0gMzAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHpvb20gZmFjdG9yIGJ5IHdoaWNoIHNjcm9sbCB6b29taW5nIGlzIGFsbG93ZWQgdG8gZXhjZWVkIHRoZSBsaW1pdHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudHJhY2twYWRab29tQnVmZmVyXyA9IDEuNTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNyZW1lbnRJbnRlcmFjdGluZ0hpbnRfKCkge1xuICAgIHRoaXMudHJhY2twYWRUaW1lb3V0SWRfID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHZpZXcgPSB0aGlzLmdldE1hcCgpLmdldFZpZXcoKTtcbiAgICB2aWV3LnNldEhpbnQoVmlld0hpbnQuSU5URVJBQ1RJTkcsIC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudCBtYXAgYnJvd3NlciBldmVudH0gKGlmIGl0IHdhcyBhIG1vdXNld2hlZWwtZXZlbnQpIGFuZCBldmVudHVhbGx5XG4gICAqIHpvb21zIHRoZSBtYXAuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgaGFuZGxlRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBtYXBCcm93c2VyRXZlbnQudHlwZTtcbiAgICBpZiAodHlwZSAhPT0gRXZlbnRUeXBlLldIRUVMICYmIHR5cGUgIT09IEV2ZW50VHlwZS5NT1VTRVdIRUVMKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBtYXBCcm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IG1hcCA9IG1hcEJyb3dzZXJFdmVudC5tYXA7XG4gICAgY29uc3Qgd2hlZWxFdmVudCA9IC8qKiBAdHlwZSB7V2hlZWxFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcblxuICAgIGlmICh0aGlzLnVzZUFuY2hvcl8pIHtcbiAgICAgIHRoaXMubGFzdEFuY2hvcl8gPSBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZTtcbiAgICB9XG5cbiAgICAvLyBEZWx0YSBub3JtYWxpc2F0aW9uIGluc3BpcmVkIGJ5XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9tYXBib3gtZ2wtanMvYmxvYi8wMDFjN2I5L2pzL3VpL2hhbmRsZXIvc2Nyb2xsX3pvb20uanNcbiAgICBsZXQgZGVsdGE7XG4gICAgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5XSEVFTCkge1xuICAgICAgZGVsdGEgPSB3aGVlbEV2ZW50LmRlbHRhWTtcbiAgICAgIGlmIChGSVJFRk9YICYmXG4gICAgICAgICAgd2hlZWxFdmVudC5kZWx0YU1vZGUgPT09IFdoZWVsRXZlbnQuRE9NX0RFTFRBX1BJWEVMKSB7XG4gICAgICAgIGRlbHRhIC89IERFVklDRV9QSVhFTF9SQVRJTztcbiAgICAgIH1cbiAgICAgIGlmICh3aGVlbEV2ZW50LmRlbHRhTW9kZSA9PT0gV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkge1xuICAgICAgICBkZWx0YSAqPSA0MDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hcEJyb3dzZXJFdmVudC50eXBlID09IEV2ZW50VHlwZS5NT1VTRVdIRUVMKSB7XG4gICAgICBkZWx0YSA9IC13aGVlbEV2ZW50LndoZWVsRGVsdGFZO1xuICAgICAgaWYgKFNBRkFSSSkge1xuICAgICAgICBkZWx0YSAvPSAzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAodGhpcy5zdGFydFRpbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMubW9kZV8gfHwgbm93IC0gdGhpcy5zdGFydFRpbWVfID4gdGhpcy50cmFja3BhZEV2ZW50R2FwXykge1xuICAgICAgdGhpcy5tb2RlXyA9IE1hdGguYWJzKGRlbHRhKSA8IDQgP1xuICAgICAgICBNb2RlLlRSQUNLUEFEIDpcbiAgICAgICAgTW9kZS5XSEVFTDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb2RlXyA9PT0gTW9kZS5UUkFDS1BBRCkge1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICBpZiAodGhpcy50cmFja3BhZFRpbWVvdXRJZF8pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudHJhY2twYWRUaW1lb3V0SWRfKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXcuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNrcGFkVGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5kZWNyZW1lbnRJbnRlcmFjdGluZ0hpbnRfLmJpbmQodGhpcyksIHRoaXMudHJhY2twYWRFdmVudEdhcF8pO1xuICAgICAgbGV0IHJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKSAqIE1hdGgucG93KDIsIGRlbHRhIC8gdGhpcy50cmFja3BhZERlbHRhUGVyWm9vbV8pO1xuICAgICAgY29uc3QgbWluUmVzb2x1dGlvbiA9IHZpZXcuZ2V0TWluUmVzb2x1dGlvbigpO1xuICAgICAgY29uc3QgbWF4UmVzb2x1dGlvbiA9IHZpZXcuZ2V0TWF4UmVzb2x1dGlvbigpO1xuICAgICAgbGV0IHJlYm91bmQgPSAwO1xuICAgICAgaWYgKHJlc29sdXRpb24gPCBtaW5SZXNvbHV0aW9uKSB7XG4gICAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1heChyZXNvbHV0aW9uLCBtaW5SZXNvbHV0aW9uIC8gdGhpcy50cmFja3BhZFpvb21CdWZmZXJfKTtcbiAgICAgICAgcmVib3VuZCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHJlc29sdXRpb24gPiBtYXhSZXNvbHV0aW9uKSB7XG4gICAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1pbihyZXNvbHV0aW9uLCBtYXhSZXNvbHV0aW9uICogdGhpcy50cmFja3BhZFpvb21CdWZmZXJfKTtcbiAgICAgICAgcmVib3VuZCA9IC0xO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGFzdEFuY2hvcl8pIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gdmlldy5jYWxjdWxhdGVDZW50ZXJab29tKHJlc29sdXRpb24sIHRoaXMubGFzdEFuY2hvcl8pO1xuICAgICAgICB2aWV3LnNldENlbnRlcih2aWV3LmNvbnN0cmFpbkNlbnRlcihjZW50ZXIpKTtcbiAgICAgIH1cbiAgICAgIHZpZXcuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcblxuICAgICAgaWYgKHJlYm91bmQgPT09IDAgJiYgdGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uXykge1xuICAgICAgICB2aWV3LmFuaW1hdGUoe1xuICAgICAgICAgIHJlc29sdXRpb246IHZpZXcuY29uc3RyYWluUmVzb2x1dGlvbihyZXNvbHV0aW9uLCBkZWx0YSA+IDAgPyAtMSA6IDEpLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgICBhbmNob3I6IHRoaXMubGFzdEFuY2hvcl8sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25fXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVib3VuZCA+IDApIHtcbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBtaW5SZXNvbHV0aW9uLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgICBhbmNob3I6IHRoaXMubGFzdEFuY2hvcl8sXG4gICAgICAgICAgZHVyYXRpb246IDUwMFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAocmVib3VuZCA8IDApIHtcbiAgICAgICAgdmlldy5hbmltYXRlKHtcbiAgICAgICAgICByZXNvbHV0aW9uOiBtYXhSZXNvbHV0aW9uLFxuICAgICAgICAgIGVhc2luZzogZWFzZU91dCxcbiAgICAgICAgICBhbmNob3I6IHRoaXMubGFzdEFuY2hvcl8sXG4gICAgICAgICAgZHVyYXRpb246IDUwMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnRUaW1lXyA9IG5vdztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRlbHRhXyArPSBkZWx0YTtcblxuICAgIGNvbnN0IHRpbWVMZWZ0ID0gTWF0aC5tYXgodGhpcy50aW1lb3V0XyAtIChub3cgLSB0aGlzLnN0YXJ0VGltZV8pLCAwKTtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVXaGVlbFpvb21fLmJpbmQodGhpcywgbWFwKSwgdGltZUxlZnQpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqL1xuICBoYW5kbGVXaGVlbFpvb21fKG1hcCkge1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3LmdldEFuaW1hdGluZygpKSB7XG4gICAgICB2aWV3LmNhbmNlbEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgY29uc3QgbWF4RGVsdGEgPSBNQVhfREVMVEE7XG4gICAgY29uc3QgZGVsdGEgPSBjbGFtcCh0aGlzLmRlbHRhXywgLW1heERlbHRhLCBtYXhEZWx0YSk7XG4gICAgem9vbUJ5RGVsdGEodmlldywgLWRlbHRhLCB0aGlzLmxhc3RBbmNob3JfLCB0aGlzLmR1cmF0aW9uXyk7XG4gICAgdGhpcy5tb2RlXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRlbHRhXyA9IDA7XG4gICAgdGhpcy5sYXN0QW5jaG9yXyA9IG51bGw7XG4gICAgdGhpcy5zdGFydFRpbWVfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSB1c2luZyB0aGUgbW91c2UncyBsb2NhdGlvbiBhcyBhbiBhbmNob3Igd2hlbiB6b29taW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQW5jaG9yIHRydWUgdG8gem9vbSB0byB0aGUgbW91c2UncyBsb2NhdGlvbiwgZmFsc2VcbiAgICogdG8gem9vbSB0byB0aGUgY2VudGVyIG9mIHRoZSBtYXBcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TW91c2VBbmNob3IodXNlQW5jaG9yKSB7XG4gICAgdGhpcy51c2VBbmNob3JfID0gdXNlQW5jaG9yO1xuICAgIGlmICghdXNlQW5jaG9yKSB7XG4gICAgICB0aGlzLmxhc3RBbmNob3JfID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTW91c2VXaGVlbFpvb207XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBT0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFFQTtBQUFBO0FBQUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7O0FBT0E7Ozs7O0FBS0E7Ozs7Ozs7QUFPQTs7Ozs7OztBQU9BOzs7OztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5RQTtBQUNBO0FBb1FBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///133\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ViewHint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18);\n/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);\n/* harmony import */ var _Interaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);\n/* harmony import */ var _Pointer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62);\n/**\n * @module ol/interaction/PinchZoom\n */\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=400] Animation duration in milliseconds.\n * @property {boolean} [constrainResolution=false] Zoom to the closest integer\n * zoom level after the pinch gesture ends.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by pinching with two fingers\n * on a touch screen.\n * @api\n */\n\nvar PinchZoom =\n/*@__PURE__*/\nfunction (PointerInteraction) {\n  function PinchZoom(opt_options) {\n    var options = opt_options ? opt_options : {};\n    var pointerOptions =\n    /** @type {import("./Pointer.js").Options} */\n    options;\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = _functions_js__WEBPACK_IMPORTED_MODULE_1__[/* FALSE */ "a"];\n    }\n\n    PointerInteraction.call(this, pointerOptions);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.constrainResolution_ = options.constrainResolution || false;\n    /**\n     * @private\n     * @type {import("../coordinate.js").Coordinate}\n     */\n\n    this.anchor_ = null;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.lastDistance_ = undefined;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.lastScaleDelta_ = 1;\n  }\n\n  if (PointerInteraction) PinchZoom.__proto__ = PointerInteraction;\n  PinchZoom.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  PinchZoom.prototype.constructor = PinchZoom;\n  /**\n   * @inheritDoc\n   */\n\n  PinchZoom.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n    var scaleDelta = 1.0;\n    var touch0 = this.targetPointers[0];\n    var touch1 = this.targetPointers[1];\n    var dx = touch0.clientX - touch1.clientX;\n    var dy = touch0.clientY - touch1.clientY; // distance between touches\n\n    var distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (this.lastDistance_ !== undefined) {\n      scaleDelta = this.lastDistance_ / distance;\n    }\n\n    this.lastDistance_ = distance;\n    var map = mapBrowserEvent.map;\n    var view = map.getView();\n    var resolution = view.getResolution();\n    var maxResolution = view.getMaxResolution();\n    var minResolution = view.getMinResolution();\n    var newResolution = resolution * scaleDelta;\n\n    if (newResolution > maxResolution) {\n      scaleDelta = maxResolution / resolution;\n      newResolution = maxResolution;\n    } else if (newResolution < minResolution) {\n      scaleDelta = minResolution / resolution;\n      newResolution = minResolution;\n    }\n\n    if (scaleDelta != 1.0) {\n      this.lastScaleDelta_ = scaleDelta;\n    } // scale anchor point.\n\n\n    var viewportPosition = map.getViewport().getBoundingClientRect();\n    var centroid = Object(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__[/* centroid */ "a"])(this.targetPointers);\n    centroid[0] -= viewportPosition.left;\n    centroid[1] -= viewportPosition.top;\n    this.anchor_ = map.getCoordinateFromPixel(centroid); // scale, bypass the resolution constraint\n\n    map.render();\n    Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__[/* zoomWithoutConstraints */ "e"])(view, newResolution, this.anchor_);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PinchZoom.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      view.setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].INTERACTING, -1);\n      var resolution = view.getResolution();\n\n      if (this.constrainResolution_ || resolution < view.getMinResolution() || resolution > view.getMaxResolution()) {\n        // Zoom to final resolution, with an animation, and provide a\n        // direction not to zoom out/in if user was pinching in/out.\n        // Direction is > 0 if pinching out, and < 0 if pinching in.\n        var direction = this.lastScaleDelta_ - 1;\n        Object(_Interaction_js__WEBPACK_IMPORTED_MODULE_2__[/* zoom */ "c"])(view, resolution, this.anchor_, this.duration_, direction);\n      }\n\n      return false;\n    } else {\n      return true;\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PinchZoom.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      var map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastDistance_ = undefined;\n      this.lastScaleDelta_ = 1;\n\n      if (!this.handlingDownUpSequence) {\n        map.getView().setHint(_ViewHint_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].INTERACTING, 1);\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return PinchZoom;\n}(_Pointer_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "b"]);\n\n/* harmony default export */ __webpack_exports__["default"] = (PinchZoom);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9pbnRlcmFjdGlvbi9QaW5jaFpvb20uanM/YmQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvaW50ZXJhY3Rpb24vUGluY2hab29tXG4gKi9cbmltcG9ydCBWaWV3SGludCBmcm9tICcuLi9WaWV3SGludC5qcyc7XG5pbXBvcnQge0ZBTFNFfSBmcm9tICcuLi9mdW5jdGlvbnMuanMnO1xuaW1wb3J0IHt6b29tLCB6b29tV2l0aG91dENvbnN0cmFpbnRzfSBmcm9tICcuL0ludGVyYWN0aW9uLmpzJztcbmltcG9ydCBQb2ludGVySW50ZXJhY3Rpb24sIHtjZW50cm9pZCBhcyBjZW50cm9pZEZyb21Qb2ludGVyc30gZnJvbSAnLi9Qb2ludGVyLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZHVyYXRpb249NDAwXSBBbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29uc3RyYWluUmVzb2x1dGlvbj1mYWxzZV0gWm9vbSB0byB0aGUgY2xvc2VzdCBpbnRlZ2VyXG4gKiB6b29tIGxldmVsIGFmdGVyIHRoZSBwaW5jaCBnZXN0dXJlIGVuZHMuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byB6b29tIHRoZSBtYXAgYnkgcGluY2hpbmcgd2l0aCB0d28gZmluZ2Vyc1xuICogb24gYSB0b3VjaCBzY3JlZW4uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIFBpbmNoWm9vbSBleHRlbmRzIFBvaW50ZXJJbnRlcmFjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0X29wdGlvbnMpIHtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBjb25zdCBwb2ludGVyT3B0aW9ucyA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9Qb2ludGVyLmpzXCIpLk9wdGlvbnN9ICovIChvcHRpb25zKTtcblxuICAgIGlmICghcG9pbnRlck9wdGlvbnMuc3RvcERvd24pIHtcbiAgICAgIHBvaW50ZXJPcHRpb25zLnN0b3BEb3duID0gRkFMU0U7XG4gICAgfVxuXG4gICAgc3VwZXIocG9pbnRlck9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpblJlc29sdXRpb25fID0gb3B0aW9ucy5jb25zdHJhaW5SZXNvbHV0aW9uIHx8IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kdXJhdGlvbl8gPSBvcHRpb25zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmR1cmF0aW9uIDogNDAwO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmxhc3REaXN0YW5jZV8gPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sYXN0U2NhbGVEZWx0YV8gPSAxO1xuXG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBsZXQgc2NhbGVEZWx0YSA9IDEuMDtcblxuICAgIGNvbnN0IHRvdWNoMCA9IHRoaXMudGFyZ2V0UG9pbnRlcnNbMF07XG4gICAgY29uc3QgdG91Y2gxID0gdGhpcy50YXJnZXRQb2ludGVyc1sxXTtcbiAgICBjb25zdCBkeCA9IHRvdWNoMC5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFg7XG4gICAgY29uc3QgZHkgPSB0b3VjaDAuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgLy8gZGlzdGFuY2UgYmV0d2VlbiB0b3VjaGVzXG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgaWYgKHRoaXMubGFzdERpc3RhbmNlXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzY2FsZURlbHRhID0gdGhpcy5sYXN0RGlzdGFuY2VfIC8gZGlzdGFuY2U7XG4gICAgfVxuICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IGRpc3RhbmNlO1xuXG5cbiAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgIGNvbnN0IHJlc29sdXRpb24gPSB2aWV3LmdldFJlc29sdXRpb24oKTtcbiAgICBjb25zdCBtYXhSZXNvbHV0aW9uID0gdmlldy5nZXRNYXhSZXNvbHV0aW9uKCk7XG4gICAgY29uc3QgbWluUmVzb2x1dGlvbiA9IHZpZXcuZ2V0TWluUmVzb2x1dGlvbigpO1xuICAgIGxldCBuZXdSZXNvbHV0aW9uID0gcmVzb2x1dGlvbiAqIHNjYWxlRGVsdGE7XG4gICAgaWYgKG5ld1Jlc29sdXRpb24gPiBtYXhSZXNvbHV0aW9uKSB7XG4gICAgICBzY2FsZURlbHRhID0gbWF4UmVzb2x1dGlvbiAvIHJlc29sdXRpb247XG4gICAgICBuZXdSZXNvbHV0aW9uID0gbWF4UmVzb2x1dGlvbjtcbiAgICB9IGVsc2UgaWYgKG5ld1Jlc29sdXRpb24gPCBtaW5SZXNvbHV0aW9uKSB7XG4gICAgICBzY2FsZURlbHRhID0gbWluUmVzb2x1dGlvbiAvIHJlc29sdXRpb247XG4gICAgICBuZXdSZXNvbHV0aW9uID0gbWluUmVzb2x1dGlvbjtcbiAgICB9XG5cbiAgICBpZiAoc2NhbGVEZWx0YSAhPSAxLjApIHtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gc2NhbGVEZWx0YTtcbiAgICB9XG5cbiAgICAvLyBzY2FsZSBhbmNob3IgcG9pbnQuXG4gICAgY29uc3Qgdmlld3BvcnRQb3NpdGlvbiA9IG1hcC5nZXRWaWV3cG9ydCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNlbnRyb2lkID0gY2VudHJvaWRGcm9tUG9pbnRlcnModGhpcy50YXJnZXRQb2ludGVycyk7XG4gICAgY2VudHJvaWRbMF0gLT0gdmlld3BvcnRQb3NpdGlvbi5sZWZ0O1xuICAgIGNlbnRyb2lkWzFdIC09IHZpZXdwb3J0UG9zaXRpb24udG9wO1xuICAgIHRoaXMuYW5jaG9yXyA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKGNlbnRyb2lkKTtcblxuICAgIC8vIHNjYWxlLCBieXBhc3MgdGhlIHJlc29sdXRpb24gY29uc3RyYWludFxuICAgIG1hcC5yZW5kZXIoKTtcbiAgICB6b29tV2l0aG91dENvbnN0cmFpbnRzKHZpZXcsIG5ld1Jlc29sdXRpb24sIHRoaXMuYW5jaG9yXyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGhhbmRsZVVwRXZlbnQobWFwQnJvd3NlckV2ZW50KSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0UG9pbnRlcnMubGVuZ3RoIDwgMikge1xuICAgICAgY29uc3QgbWFwID0gbWFwQnJvd3NlckV2ZW50Lm1hcDtcbiAgICAgIGNvbnN0IHZpZXcgPSBtYXAuZ2V0VmlldygpO1xuICAgICAgdmlldy5zZXRIaW50KFZpZXdIaW50LklOVEVSQUNUSU5HLCAtMSk7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdmlldy5nZXRSZXNvbHV0aW9uKCk7XG4gICAgICBpZiAodGhpcy5jb25zdHJhaW5SZXNvbHV0aW9uXyB8fFxuICAgICAgICAgIHJlc29sdXRpb24gPCB2aWV3LmdldE1pblJlc29sdXRpb24oKSB8fFxuICAgICAgICAgIHJlc29sdXRpb24gPiB2aWV3LmdldE1heFJlc29sdXRpb24oKSkge1xuICAgICAgICAvLyBab29tIHRvIGZpbmFsIHJlc29sdXRpb24sIHdpdGggYW4gYW5pbWF0aW9uLCBhbmQgcHJvdmlkZSBhXG4gICAgICAgIC8vIGRpcmVjdGlvbiBub3QgdG8gem9vbSBvdXQvaW4gaWYgdXNlciB3YXMgcGluY2hpbmcgaW4vb3V0LlxuICAgICAgICAvLyBEaXJlY3Rpb24gaXMgPiAwIGlmIHBpbmNoaW5nIG91dCwgYW5kIDwgMCBpZiBwaW5jaGluZyBpbi5cbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5sYXN0U2NhbGVEZWx0YV8gLSAxO1xuICAgICAgICB6b29tKHZpZXcsIHJlc29sdXRpb24sIHRoaXMuYW5jaG9yXywgdGhpcy5kdXJhdGlvbl8sIGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICh0aGlzLnRhcmdldFBvaW50ZXJzLmxlbmd0aCA+PSAyKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgdGhpcy5hbmNob3JfID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdERpc3RhbmNlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGFzdFNjYWxlRGVsdGFfID0gMTtcbiAgICAgIGlmICghdGhpcy5oYW5kbGluZ0Rvd25VcFNlcXVlbmNlKSB7XG4gICAgICAgIG1hcC5nZXRWaWV3KCkuc2V0SGludChWaWV3SGludC5JTlRFUkFDVElORywgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaW5jaFpvb207XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0lBO0FBQ0E7QUE0SUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///134\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nvar _EventHandling = _interopRequireDefault(__webpack_require__(64));\n\nvar _Dialog = _interopRequireDefault(__webpack_require__(113));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/LocationMgr\r\n */\n\n\nvar proj4 = _["default"].proj4;\n/**\r\n * @desc A class for managing user-specified location information\r\n * @public\r\n * @class\r\n * @extends module:nyc/EventHandling~EventHandling\r\n * @fires module:nyc/Locator~Locator#geocoded\r\n * @fires module:nyc/Locator~Locator#geolocated\r\n */\n\nvar LocationMgr =\n/*#__PURE__*/\nfunction (_EventHandling$defaul) {\n  _inherits(LocationMgr, _EventHandling$defaul);\n\n  /**\r\n   * @desc Create an instance of LocationMgr\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/LocationMgr~LocationMgr.Options} options Constructor options\r\n   */\n  function LocationMgr(options) {\n    var _this;\n\n    _classCallCheck(this, LocationMgr);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LocationMgr).call(this));\n    /**\r\n     * @desc The Zoom\r\n     * @public\r\n     * @member {module:nyc/Zoom~Zoom}\r\n     */\n\n    _this.zoom = options.zoom;\n    /**\r\n     * @desc The Geolocate\r\n     * @public\r\n     * @member {module:nyc/Geolocate~Geolocate}\r\n     */\n\n    _this.geolocate = options.geolocate;\n    /**\r\n     * @desc The Search\r\n     * @public\r\n     * @member {module:nyc/Search~Search}\r\n     */\n\n    _this.search = options.search;\n    /**\r\n     * @desc The Locator\r\n     * @public\r\n     * @member {module:nyc/Locator~Locator}\r\n     */\n\n    _this.locator = options.locator;\n    /**\r\n     * @private\r\n     * @member {module:nyc/MapLocator~MapLocator}\r\n     */\n\n    _this.mapLocator = options.mapLocator;\n    /**\r\n     * @private\r\n     * @member {module:nyc/Dialog~Dialog}\r\n     */\n\n    _this.dialog = new _Dialog["default"]({\n      target: options.dialogTarget\n    });\n    /**\r\n     * @private\r\n     * @member {boolean}\r\n     */\n\n    _this.autoLocate = options.autoLocate || false;\n\n    _this.hookupEvents();\n\n    _this.locateFromQueryString(document.location.search);\n\n    return _this;\n  }\n  /**\r\n   * @desc Zoom and center on the provided location\r\n   * @public\r\n   * @method\r\n   * @param {module:nyc/Locator~Locator.Result} data The location\r\n   */\n\n\n  _createClass(LocationMgr, [{\n    key: "setLocation",\n    value: function setLocation(data) {\n      this.mapLocator.setLocation(data);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "hookupEvents",\n    value: function hookupEvents() {\n      this.locator.on(\'geocoded\', this.located, this);\n      this.locator.on(\'geolocated\', this.located, this);\n      this.locator.on(\'ambiguous\', this.ambiguous, this);\n      this.locator.on(\'error\', this.error, this);\n      this.search.on(\'disambiguated\', this.located, this);\n      this.search.on(\'search\', this.locator.search, this.locator);\n      this.geolocate.on(\'geolocate\', this.locator.locate, this.locator);\n    }\n    /**\r\n     * @desc Navigate the map to a given location\r\n     * @public\r\n     * @method\r\n     * @param {string} location A location\r\n     */\n\n  }, {\n    key: "goTo",\n    value: function goTo(location) {\n      if (location.indexOf(\'EPSG\') > -1) {\n        location = location.split(\',\');\n        var proj = this.mapLocator.getProjection();\n        var coord = proj4(location[2], proj, [location[0] * 1, location[1] * 1]);\n        this.mapLocator.zoomLocation({\n          coordinate: coord\n        });\n      } else {\n        this.locator.search(location);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {string} qstr Query string\r\n     */\n\n  }, {\n    key: "locateFromQueryString",\n    value: function locateFromQueryString(qstr) {\n      var args = {};\n\n      try {\n        qstr = decodeURIComponent(qstr);\n        qstr.substr(1).split(\'&\').forEach(function (param) {\n          var p = param.split(\'=\');\n          args[p[0]] = decodeURIComponent(p[1]);\n        });\n      } catch (ignore) {\n        /* empty */\n      }\n\n      if (args.location) {\n        this.goTo(args.location);\n      } else if (this.autoLocate) {\n        this.locator.locate();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {module:nyc/Locator~Locator.Result} data Result data\r\n     */\n\n  }, {\n    key: "located",\n    value: function located(data) {\n      var _this2 = this;\n\n      this.search.val(data.type === \'geolocated\' ? \'\' : data.name);\n      this.mapLocator.zoomLocation(data, function () {\n        _this2.trigger(data.type, data);\n      });\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {module:nyc/Locator~Locator.Ambiguous} data Data\r\n     */\n\n  }, {\n    key: "ambiguous",\n    value: function ambiguous(data) {\n      if (data.possible.length) {\n        this.search.disambiguate(data);\n      } else {\n        this.dialog.ok({\n          message: \'The location you entered was not understood\'\n        });\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "error",\n    value: function error() {\n      this.dialog.ok({\n        message: \'Failed to contact geocoder\'\n      });\n    }\n  }]);\n\n  return LocationMgr;\n}(_EventHandling["default"]);\n/**\r\n * @desc Constructor options for {@link module:nyc/LocationMgr~LocationMgr}\r\n * @public\r\n * @typedef {Object}\r\n * @property {module:nyc/Zoom~Zoom} zoom The UX zoom control for user input\r\n * @property {module:nyc/Geolocate~Geolocate} geolocate The UX geolocate control for user input\r\n * @property {module:nyc/Search~Search} search The UX search control for user input\r\n * @property {module:nyc/Locator~Locator} locator The geocoding and geolocation provider\r\n * @property {module:nyc/MapLocator~MapLocator} mapLocator The mapLocator used to manipulate a map\r\n * @property {boolean} [autoLocate=false] Automatically locator using device geolocation on load\r\n * @property {jQuery|Element|string} [dialogTarget=body] The DOM target in which to display error dialog\r\n */\n\n\nLocationMgr.Options;\nvar _default = LocationMgr;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0xvY2F0aW9uTWdyLmpzP2YwMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9cIikpO1xuXG52YXIgX0V2ZW50SGFuZGxpbmcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0V2ZW50SGFuZGxpbmdcIikpO1xuXG52YXIgX0RpYWxvZyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRGlhbG9nXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL0xvY2F0aW9uTWdyXHJcbiAqL1xuY29uc3QgcHJvajQgPSBfLmRlZmF1bHQucHJvajQ7XG4vKipcclxuICogQGRlc2MgQSBjbGFzcyBmb3IgbWFuYWdpbmcgdXNlci1zcGVjaWZpZWQgbG9jYXRpb24gaW5mb3JtYXRpb25cclxuICogQHB1YmxpY1xyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgbW9kdWxlOm55Yy9FdmVudEhhbmRsaW5nfkV2ZW50SGFuZGxpbmdcclxuICogQGZpcmVzIG1vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yI2dlb2NvZGVkXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvciNnZW9sb2NhdGVkXHJcbiAqL1xuXG5jbGFzcyBMb2NhdGlvbk1nciBleHRlbmRzIF9FdmVudEhhbmRsaW5nLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTG9jYXRpb25NZ3JcclxuICAgKiBAcHVibGljXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0xvY2F0aW9uTWdyfkxvY2F0aW9uTWdyLk9wdGlvbnN9IG9wdGlvbnMgQ29uc3RydWN0b3Igb3B0aW9uc1xyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcclxuICAgICAqIEBkZXNjIFRoZSBab29tXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAbWVtYmVyIHttb2R1bGU6bnljL1pvb21+Wm9vbX1cclxuICAgICAqL1xuXG4gICAgdGhpcy56b29tID0gb3B0aW9ucy56b29tO1xuICAgIC8qKlxyXG4gICAgICogQGRlc2MgVGhlIEdlb2xvY2F0ZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG1lbWJlciB7bW9kdWxlOm55Yy9HZW9sb2NhdGV+R2VvbG9jYXRlfVxyXG4gICAgICovXG5cbiAgICB0aGlzLmdlb2xvY2F0ZSA9IG9wdGlvbnMuZ2VvbG9jYXRlO1xuICAgIC8qKlxyXG4gICAgICogQGRlc2MgVGhlIFNlYXJjaFxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG1lbWJlciB7bW9kdWxlOm55Yy9TZWFyY2h+U2VhcmNofVxyXG4gICAgICovXG5cbiAgICB0aGlzLnNlYXJjaCA9IG9wdGlvbnMuc2VhcmNoO1xuICAgIC8qKlxyXG4gICAgICogQGRlc2MgVGhlIExvY2F0b3JcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBtZW1iZXIge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yfVxyXG4gICAgICovXG5cbiAgICB0aGlzLmxvY2F0b3IgPSBvcHRpb25zLmxvY2F0b3I7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7bW9kdWxlOm55Yy9NYXBMb2NhdG9yfk1hcExvY2F0b3J9XHJcbiAgICAgKi9cblxuICAgIHRoaXMubWFwTG9jYXRvciA9IG9wdGlvbnMubWFwTG9jYXRvcjtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHttb2R1bGU6bnljL0RpYWxvZ35EaWFsb2d9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuZGlhbG9nID0gbmV3IF9EaWFsb2cuZGVmYXVsdCh7XG4gICAgICB0YXJnZXQ6IG9wdGlvbnMuZGlhbG9nVGFyZ2V0XG4gICAgfSk7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xuXG4gICAgdGhpcy5hdXRvTG9jYXRlID0gb3B0aW9ucy5hdXRvTG9jYXRlIHx8IGZhbHNlO1xuICAgIHRoaXMuaG9va3VwRXZlbnRzKCk7XG4gICAgdGhpcy5sb2NhdGVGcm9tUXVlcnlTdHJpbmcoZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBab29tIGFuZCBjZW50ZXIgb24gdGhlIHByb3ZpZGVkIGxvY2F0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLlJlc3VsdH0gZGF0YSBUaGUgbG9jYXRpb25cclxuICAgKi9cblxuXG4gIHNldExvY2F0aW9uKGRhdGEpIHtcbiAgICB0aGlzLm1hcExvY2F0b3Iuc2V0TG9jYXRpb24oZGF0YSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICovXG5cblxuICBob29rdXBFdmVudHMoKSB7XG4gICAgdGhpcy5sb2NhdG9yLm9uKCdnZW9jb2RlZCcsIHRoaXMubG9jYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5sb2NhdG9yLm9uKCdnZW9sb2NhdGVkJywgdGhpcy5sb2NhdGVkLCB0aGlzKTtcbiAgICB0aGlzLmxvY2F0b3Iub24oJ2FtYmlndW91cycsIHRoaXMuYW1iaWd1b3VzLCB0aGlzKTtcbiAgICB0aGlzLmxvY2F0b3Iub24oJ2Vycm9yJywgdGhpcy5lcnJvciwgdGhpcyk7XG4gICAgdGhpcy5zZWFyY2gub24oJ2Rpc2FtYmlndWF0ZWQnLCB0aGlzLmxvY2F0ZWQsIHRoaXMpO1xuICAgIHRoaXMuc2VhcmNoLm9uKCdzZWFyY2gnLCB0aGlzLmxvY2F0b3Iuc2VhcmNoLCB0aGlzLmxvY2F0b3IpO1xuICAgIHRoaXMuZ2VvbG9jYXRlLm9uKCdnZW9sb2NhdGUnLCB0aGlzLmxvY2F0b3IubG9jYXRlLCB0aGlzLmxvY2F0b3IpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIE5hdmlnYXRlIHRoZSBtYXAgdG8gYSBnaXZlbiBsb2NhdGlvblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIEEgbG9jYXRpb25cclxuICAgKi9cblxuXG4gIGdvVG8obG9jYXRpb24pIHtcbiAgICBpZiAobG9jYXRpb24uaW5kZXhPZignRVBTRycpID4gLTEpIHtcbiAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24uc3BsaXQoJywnKTtcbiAgICAgIGNvbnN0IHByb2ogPSB0aGlzLm1hcExvY2F0b3IuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgY29uc3QgY29vcmQgPSBwcm9qNChsb2NhdGlvblsyXSwgcHJvaiwgW2xvY2F0aW9uWzBdICogMSwgbG9jYXRpb25bMV0gKiAxXSk7XG4gICAgICB0aGlzLm1hcExvY2F0b3Iuem9vbUxvY2F0aW9uKHtcbiAgICAgICAgY29vcmRpbmF0ZTogY29vcmRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvY2F0b3Iuc2VhcmNoKGxvY2F0aW9uKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHFzdHIgUXVlcnkgc3RyaW5nXHJcbiAgICovXG5cblxuICBsb2NhdGVGcm9tUXVlcnlTdHJpbmcocXN0cikge1xuICAgIGNvbnN0IGFyZ3MgPSB7fTtcblxuICAgIHRyeSB7XG4gICAgICBxc3RyID0gZGVjb2RlVVJJQ29tcG9uZW50KHFzdHIpO1xuICAgICAgcXN0ci5zdWJzdHIoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgICAgY29uc3QgcCA9IHBhcmFtLnNwbGl0KCc9Jyk7XG4gICAgICAgIGFyZ3NbcFswXV0gPSBkZWNvZGVVUklDb21wb25lbnQocFsxXSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubG9jYXRpb24pIHtcbiAgICAgIHRoaXMuZ29UbyhhcmdzLmxvY2F0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b0xvY2F0ZSkge1xuICAgICAgdGhpcy5sb2NhdG9yLmxvY2F0ZSgpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLlJlc3VsdH0gZGF0YSBSZXN1bHQgZGF0YVxyXG4gICAqL1xuXG5cbiAgbG9jYXRlZChkYXRhKSB7XG4gICAgdGhpcy5zZWFyY2gudmFsKGRhdGEudHlwZSA9PT0gJ2dlb2xvY2F0ZWQnID8gJycgOiBkYXRhLm5hbWUpO1xuICAgIHRoaXMubWFwTG9jYXRvci56b29tTG9jYXRpb24oZGF0YSwgKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKGRhdGEudHlwZSwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5BbWJpZ3VvdXN9IGRhdGEgRGF0YVxyXG4gICAqL1xuXG5cbiAgYW1iaWd1b3VzKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5wb3NzaWJsZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc2VhcmNoLmRpc2FtYmlndWF0ZShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaWFsb2cub2soe1xuICAgICAgICBtZXNzYWdlOiAnVGhlIGxvY2F0aW9uIHlvdSBlbnRlcmVkIHdhcyBub3QgdW5kZXJzdG9vZCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKi9cblxuXG4gIGVycm9yKCkge1xuICAgIHRoaXMuZGlhbG9nLm9rKHtcbiAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gY29udGFjdCBnZW9jb2RlcidcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcclxuICogQGRlc2MgQ29uc3RydWN0b3Igb3B0aW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpueWMvTG9jYXRpb25NZ3J+TG9jYXRpb25NZ3J9XHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHttb2R1bGU6bnljL1pvb21+Wm9vbX0gem9vbSBUaGUgVVggem9vbSBjb250cm9sIGZvciB1c2VyIGlucHV0XHJcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm55Yy9HZW9sb2NhdGV+R2VvbG9jYXRlfSBnZW9sb2NhdGUgVGhlIFVYIGdlb2xvY2F0ZSBjb250cm9sIGZvciB1c2VyIGlucHV0XHJcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm55Yy9TZWFyY2h+U2VhcmNofSBzZWFyY2ggVGhlIFVYIHNlYXJjaCBjb250cm9sIGZvciB1c2VyIGlucHV0XHJcbiAqIEBwcm9wZXJ0eSB7bW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3J9IGxvY2F0b3IgVGhlIGdlb2NvZGluZyBhbmQgZ2VvbG9jYXRpb24gcHJvdmlkZXJcclxuICogQHByb3BlcnR5IHttb2R1bGU6bnljL01hcExvY2F0b3J+TWFwTG9jYXRvcn0gbWFwTG9jYXRvciBUaGUgbWFwTG9jYXRvciB1c2VkIHRvIG1hbmlwdWxhdGUgYSBtYXBcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXV0b0xvY2F0ZT1mYWxzZV0gQXV0b21hdGljYWxseSBsb2NhdG9yIHVzaW5nIGRldmljZSBnZW9sb2NhdGlvbiBvbiBsb2FkXHJcbiAqIEBwcm9wZXJ0eSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSBbZGlhbG9nVGFyZ2V0PWJvZHldIFRoZSBET00gdGFyZ2V0IGluIHdoaWNoIHRvIGRpc3BsYXkgZXJyb3IgZGlhbG9nXHJcbiAqL1xuXG5cbkxvY2F0aW9uTWdyLk9wdGlvbnM7XG52YXIgX2RlZmF1bHQgPSBMb2NhdGlvbk1ncjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7O0FBR0E7QUFDQTs7Ozs7Ozs7O0FBU0E7Ozs7O0FBQ0E7Ozs7OztBQU1BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQURBO0FBR0E7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBcERBO0FBb0RBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7QUEzS0E7QUE4S0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///135\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nvar _Locator = _interopRequireDefault(__webpack_require__(103));\n\nvar _Geolocation = _interopRequireDefault(__webpack_require__(137));\n\nvar _coordinate = __webpack_require__(41);\n\nvar _extent = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/Locator\r\n */\n\n\nvar proj4 = _["default"].proj4;\n/**\r\n * @desc A class for geocoding and geolocating in OpenLayers\r\n * @public\r\n * @class\r\n * @extends module:nyc/Locator~Locator\r\n */\n\nvar Locator =\n/*#__PURE__*/\nfunction (_Locator$default) {\n  _inherits(Locator, _Locator$default);\n\n  /**\r\n   * @desc Create an instance of Locator\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/ol/Locator~Locator.Options} options Constructor options\r\n   */\n  function Locator(options) {\n    var _this;\n\n    _classCallCheck(this, Locator);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Locator).call(this, options));\n    /**\r\n     * @private\r\n     * @member {boolean}\r\n     */\n\n    _this.locating = false;\n    /**\r\n     * @private\r\n     * @member {ol.Extent}\r\n     */\n\n    _this.extentLimit = options.extentLimit;\n    /**\r\n     * @private\r\n     * @member {ol.Geolocation}\r\n     */\n\n    _this.geolocation = new _Geolocation["default"]({\n      trackingOptions: {\n        maximumAge: 10000,\n        enableHighAccuracy: true,\n        timeout: 600000\n      }\n    });\n\n    _this.geolocation.on(\'change\', _jquery["default"].proxy(_this.geolocationChange, _assertThisInitialized(_this)));\n\n    _this.geolocation.on(\'error\', _jquery["default"].proxy(_this.geolocationError, _assertThisInitialized(_this)));\n\n    return _this;\n  }\n  /**\r\n   * @desc Locate once using device geolocation\r\n   * @public\r\n   * @override\r\n   * @method\r\n   */\n\n\n  _createClass(Locator, [{\n    key: "locate",\n    value: function locate() {\n      this.locating = true;\n      this.geolocation.setTracking(true);\n    }\n    /**\r\n     * @desc Track using device geolocation\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @param {boolean} track Track or not\r\n     */\n\n  }, {\n    key: "track",\n    value: function track(_track) {\n      this.geolocation.setTracking(_track);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} error Error object\r\n     */\n\n  }, {\n    key: "geolocationError",\n    value: function geolocationError(error) {\n      console.error(error.message, error);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "geolocationChange",\n    value: function geolocationChange() {\n      var geo = this.geolocation;\n      var p = geo.getPosition();\n      var name = (0, _coordinate.toStringHDMS)(p);\n      p = proj4(\'EPSG:4326\', this.projection, p);\n\n      if (this.withinLimit(p)) {\n        if (this.locating) {\n          this.track(false);\n          this.locating = false;\n        }\n\n        this.trigger(\'geolocated\', {\n          coordinate: p,\n          heading: geo.getHeading(),\n          accuracy: geo.getAccuracy() / this.metersPerUnit(),\n          type: \'geolocated\',\n          name: name\n        });\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {ol.Coordinate} coordinates Coordinates\r\n     * @return {boolean} true if extent contains coordinate\r\n     */\n\n  }, {\n    key: "withinLimit",\n    value: function withinLimit(coordinates) {\n      return this.extentLimit ? (0, _extent.containsCoordinate)(this.extentLimit, coordinates) : true;\n    }\n  }]);\n\n  return Locator;\n}(_Locator["default"]);\n/**\r\n * @desc constructor options for {@link module:nyc/ol/Locator~Locator}\r\n * @public\r\n * @typedef {Object}\r\n * @property {module:nyc/Geocoder~Geocoder} geocoder A geocoder\r\n * @property {string} [projection=EPSG:3857] The EPSG code of the projection for output geometries (i.e. EPSG:2263)\r\n * @property {ol.Extent=} extentLimit Geolocation coordinates outside of this bounding box are ignored\r\n */\n\n\nLocator.Options;\nvar _default = Locator;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL0xvY2F0b3IuanM/ZGQzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qcXVlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXG52YXIgXyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vLi5cIikpO1xuXG52YXIgX0xvY2F0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9Mb2NhdG9yXCIpKTtcblxudmFyIF9HZW9sb2NhdGlvbiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL0dlb2xvY2F0aW9uXCIpKTtcblxudmFyIF9jb29yZGluYXRlID0gcmVxdWlyZShcIm9sL2Nvb3JkaW5hdGVcIik7XG5cbnZhciBfZXh0ZW50ID0gcmVxdWlyZShcIm9sL2V4dGVudFwiKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL29sL0xvY2F0b3JcclxuICovXG5jb25zdCBwcm9qNCA9IF8uZGVmYXVsdC5wcm9qNDtcbi8qKlxyXG4gKiBAZGVzYyBBIGNsYXNzIGZvciBnZW9jb2RpbmcgYW5kIGdlb2xvY2F0aW5nIGluIE9wZW5MYXllcnNcclxuICogQHB1YmxpY1xyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgbW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3JcclxuICovXG5cbmNsYXNzIExvY2F0b3IgZXh0ZW5kcyBfTG9jYXRvci5kZWZhdWx0IHtcbiAgLyoqXHJcbiAgICogQGRlc2MgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIExvY2F0b3JcclxuICAgKiBAcHVibGljXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL29sL0xvY2F0b3J+TG9jYXRvci5PcHRpb25zfSBvcHRpb25zIENvbnN0cnVjdG9yIG9wdGlvbnNcclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cblxuICAgIHRoaXMubG9jYXRpbmcgPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtvbC5FeHRlbnR9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuZXh0ZW50TGltaXQgPSBvcHRpb25zLmV4dGVudExpbWl0O1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge29sLkdlb2xvY2F0aW9ufVxyXG4gICAgICovXG5cbiAgICB0aGlzLmdlb2xvY2F0aW9uID0gbmV3IF9HZW9sb2NhdGlvbi5kZWZhdWx0KHtcbiAgICAgIHRyYWNraW5nT3B0aW9uczoge1xuICAgICAgICBtYXhpbXVtQWdlOiAxMDAwMCxcbiAgICAgICAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxuICAgICAgICB0aW1lb3V0OiA2MDAwMDBcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmdlb2xvY2F0aW9uLm9uKCdjaGFuZ2UnLCBfanF1ZXJ5LmRlZmF1bHQucHJveHkodGhpcy5nZW9sb2NhdGlvbkNoYW5nZSwgdGhpcykpO1xuICAgIHRoaXMuZ2VvbG9jYXRpb24ub24oJ2Vycm9yJywgX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMuZ2VvbG9jYXRpb25FcnJvciwgdGhpcykpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIExvY2F0ZSBvbmNlIHVzaW5nIGRldmljZSBnZW9sb2NhdGlvblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICovXG5cblxuICBsb2NhdGUoKSB7XG4gICAgdGhpcy5sb2NhdGluZyA9IHRydWU7XG4gICAgdGhpcy5nZW9sb2NhdGlvbi5zZXRUcmFja2luZyh0cnVlKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBUcmFjayB1c2luZyBkZXZpY2UgZ2VvbG9jYXRpb25cclxuICAgKiBAcHVibGljXHJcbiAgICogQG92ZXJyaWRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhY2sgVHJhY2sgb3Igbm90XHJcbiAgICovXG5cblxuICB0cmFjayh0cmFjaykge1xuICAgIHRoaXMuZ2VvbG9jYXRpb24uc2V0VHJhY2tpbmcodHJhY2spO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciBFcnJvciBvYmplY3RcclxuICAgKi9cblxuXG4gIGdlb2xvY2F0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKi9cblxuXG4gIGdlb2xvY2F0aW9uQ2hhbmdlKCkge1xuICAgIGNvbnN0IGdlbyA9IHRoaXMuZ2VvbG9jYXRpb247XG4gICAgbGV0IHAgPSBnZW8uZ2V0UG9zaXRpb24oKTtcbiAgICBjb25zdCBuYW1lID0gKDAsIF9jb29yZGluYXRlLnRvU3RyaW5nSERNUykocCk7XG4gICAgcCA9IHByb2o0KCdFUFNHOjQzMjYnLCB0aGlzLnByb2plY3Rpb24sIHApO1xuXG4gICAgaWYgKHRoaXMud2l0aGluTGltaXQocCkpIHtcbiAgICAgIGlmICh0aGlzLmxvY2F0aW5nKSB7XG4gICAgICAgIHRoaXMudHJhY2soZmFsc2UpO1xuICAgICAgICB0aGlzLmxvY2F0aW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcignZ2VvbG9jYXRlZCcsIHtcbiAgICAgICAgY29vcmRpbmF0ZTogcCxcbiAgICAgICAgaGVhZGluZzogZ2VvLmdldEhlYWRpbmcoKSxcbiAgICAgICAgYWNjdXJhY3k6IGdlby5nZXRBY2N1cmFjeSgpIC8gdGhpcy5tZXRlcnNQZXJVbml0KCksXG4gICAgICAgIHR5cGU6ICdnZW9sb2NhdGVkJyxcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7b2wuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXNcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGV4dGVudCBjb250YWlucyBjb29yZGluYXRlXHJcbiAgICovXG5cblxuICB3aXRoaW5MaW1pdChjb29yZGluYXRlcykge1xuICAgIHJldHVybiB0aGlzLmV4dGVudExpbWl0ID8gKDAsIF9leHRlbnQuY29udGFpbnNDb29yZGluYXRlKSh0aGlzLmV4dGVudExpbWl0LCBjb29yZGluYXRlcykgOiB0cnVlO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBAZGVzYyBjb25zdHJ1Y3RvciBvcHRpb25zIGZvciB7QGxpbmsgbW9kdWxlOm55Yy9vbC9Mb2NhdG9yfkxvY2F0b3J9XHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHttb2R1bGU6bnljL0dlb2NvZGVyfkdlb2NvZGVyfSBnZW9jb2RlciBBIGdlb2NvZGVyXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcHJvamVjdGlvbj1FUFNHOjM4NTddIFRoZSBFUFNHIGNvZGUgb2YgdGhlIHByb2plY3Rpb24gZm9yIG91dHB1dCBnZW9tZXRyaWVzIChpLmUuIEVQU0c6MjI2MylcclxuICogQHByb3BlcnR5IHtvbC5FeHRlbnQ9fSBleHRlbnRMaW1pdCBHZW9sb2NhdGlvbiBjb29yZGluYXRlcyBvdXRzaWRlIG9mIHRoaXMgYm91bmRpbmcgYm94IGFyZSBpZ25vcmVkXHJcbiAqL1xuXG5cbkxvY2F0b3IuT3B0aW9ucztcbnZhciBfZGVmYXVsdCA9IExvY2F0b3I7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFPQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBQ0E7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQTVCQTtBQTRCQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7OztBQTNHQTtBQThHQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///136\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);\n/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);\n/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);\n/* harmony import */ var _geom_Polygon_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(47);\n/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19);\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);\n/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10);\n/**\n * @module ol/Geolocation\n */\n\n\n\n\n\n\n\n\n/**\n * @enum {string}\n */\n\nvar Property = {\n  ACCURACY: \'accuracy\',\n  ACCURACY_GEOMETRY: \'accuracyGeometry\',\n  ALTITUDE: \'altitude\',\n  ALTITUDE_ACCURACY: \'altitudeAccuracy\',\n  HEADING: \'heading\',\n  POSITION: \'position\',\n  PROJECTION: \'projection\',\n  SPEED: \'speed\',\n  TRACKING: \'tracking\',\n  TRACKING_OPTIONS: \'trackingOptions\'\n};\n/**\n * @classdesc\n * Events emitted on Geolocation error.\n */\n\nvar GeolocationError =\n/*@__PURE__*/\nfunction (Event) {\n  function GeolocationError(error) {\n    Event.call(this, _events_EventType_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].ERROR);\n    /**\n     * @type {number}\n     */\n\n    this.code = error.code;\n    /**\n     * @type {string}\n     */\n\n    this.message = error.message;\n  }\n\n  if (Event) GeolocationError.__proto__ = Event;\n  GeolocationError.prototype = Object.create(Event && Event.prototype);\n  GeolocationError.prototype.constructor = GeolocationError;\n  return GeolocationError;\n}(_events_Event_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);\n/**\n * @typedef {Object} Options\n * @property {boolean} [tracking=false] Start Tracking right after\n * instantiation.\n * @property {PositionOptions} [trackingOptions] Tracking options.\n * See http://www.w3.org/TR/geolocation-API/#position_options_interface.\n * @property {import("./proj.js").ProjectionLike} [projection] The projection the position\n * is reported in.\n */\n\n/**\n * @classdesc\n * Helper class for providing HTML5 Geolocation capabilities.\n * The [Geolocation API](http://www.w3.org/TR/geolocation-API/)\n * is used to locate a user\'s position.\n *\n * To get notified of position changes, register a listener for the generic\n * `change` event on your instance of {@link module:ol/Geolocation~Geolocation}.\n *\n * Example:\n *\n *     var geolocation = new Geolocation({\n *       // take the projection to use from the map\'s view\n *       projection: view.getProjection()\n *     });\n *     // listen to changes in position\n *     geolocation.on(\'change\', function(evt) {\n *       window.console.log(geolocation.getPosition());\n *     });\n *\n * @fires error\n * @api\n */\n\n\nvar Geolocation =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function Geolocation(opt_options) {\n    BaseObject.call(this);\n    var options = opt_options || {};\n    /**\n     * The unprojected (EPSG:4326) device position.\n     * @private\n     * @type {import("./coordinate.js").Coordinate}\n     */\n\n    this.position_ = null;\n    /**\n     * @private\n     * @type {import("./proj.js").TransformFunction}\n     */\n\n    this.transform_ = _proj_js__WEBPACK_IMPORTED_MODULE_7__["identityTransform"];\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.watchId_ = undefined;\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__[/* listen */ "a"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* getChangeEventType */ "b"])(Property.PROJECTION), this.handleProjectionChanged_, this);\n    Object(_events_js__WEBPACK_IMPORTED_MODULE_1__[/* listen */ "a"])(this, Object(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* getChangeEventType */ "b"])(Property.TRACKING), this.handleTrackingChanged_, this);\n\n    if (options.projection !== undefined) {\n      this.setProjection(options.projection);\n    }\n\n    if (options.trackingOptions !== undefined) {\n      this.setTrackingOptions(options.trackingOptions);\n    }\n\n    this.setTracking(options.tracking !== undefined ? options.tracking : false);\n  }\n\n  if (BaseObject) Geolocation.__proto__ = BaseObject;\n  Geolocation.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Geolocation.prototype.constructor = Geolocation;\n  /**\n   * @inheritDoc\n   */\n\n  Geolocation.prototype.disposeInternal = function disposeInternal() {\n    this.setTracking(false);\n    BaseObject.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @private\n   */\n\n\n  Geolocation.prototype.handleProjectionChanged_ = function handleProjectionChanged_() {\n    var projection = this.getProjection();\n\n    if (projection) {\n      this.transform_ = Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["getTransformFromProjections"])(Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["get"])(\'EPSG:4326\'), projection);\n\n      if (this.position_) {\n        this.set(Property.POSITION, this.transform_(this.position_));\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  Geolocation.prototype.handleTrackingChanged_ = function handleTrackingChanged_() {\n    if (_has_js__WEBPACK_IMPORTED_MODULE_5__[/* GEOLOCATION */ "d"]) {\n      var tracking = this.getTracking();\n\n      if (tracking && this.watchId_ === undefined) {\n        this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());\n      } else if (!tracking && this.watchId_ !== undefined) {\n        navigator.geolocation.clearWatch(this.watchId_);\n        this.watchId_ = undefined;\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {Position} position position event.\n   */\n\n\n  Geolocation.prototype.positionChange_ = function positionChange_(position) {\n    var coords = position.coords;\n    this.set(Property.ACCURACY, coords.accuracy);\n    this.set(Property.ALTITUDE, coords.altitude === null ? undefined : coords.altitude);\n    this.set(Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy);\n    this.set(Property.HEADING, coords.heading === null ? undefined : Object(_math_js__WEBPACK_IMPORTED_MODULE_6__[/* toRadians */ "i"])(coords.heading));\n\n    if (!this.position_) {\n      this.position_ = [coords.longitude, coords.latitude];\n    } else {\n      this.position_[0] = coords.longitude;\n      this.position_[1] = coords.latitude;\n    }\n\n    var projectedPosition = this.transform_(this.position_);\n    this.set(Property.POSITION, projectedPosition);\n    this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);\n    var geometry = Object(_geom_Polygon_js__WEBPACK_IMPORTED_MODULE_4__[/* circular */ "a"])(this.position_, coords.accuracy);\n    geometry.applyTransform(this.transform_);\n    this.set(Property.ACCURACY_GEOMETRY, geometry);\n    this.changed();\n  };\n  /**\n   * Triggered when the Geolocation returns an error.\n   * @event error\n   * @api\n   */\n\n  /**\n   * @private\n   * @param {PositionError} error error object.\n   */\n\n\n  Geolocation.prototype.positionError_ = function positionError_(error) {\n    this.setTracking(false);\n    this.dispatchEvent(new GeolocationError(error));\n  };\n  /**\n   * Get the accuracy of the position in meters.\n   * @return {number|undefined} The accuracy of the position measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getAccuracy = function getAccuracy() {\n    return (\n      /** @type {number|undefined} */\n      this.get(Property.ACCURACY)\n    );\n  };\n  /**\n   * Get a geometry of the position accuracy.\n   * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getAccuracyGeometry = function getAccuracyGeometry() {\n    return (\n      /** @type {?import("./geom/Polygon.js").default} */\n      this.get(Property.ACCURACY_GEOMETRY) || null\n    );\n  };\n  /**\n   * Get the altitude associated with the position.\n   * @return {number|undefined} The altitude of the position in meters above mean\n   *     sea level.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getAltitude = function getAltitude() {\n    return (\n      /** @type {number|undefined} */\n      this.get(Property.ALTITUDE)\n    );\n  };\n  /**\n   * Get the altitude accuracy of the position.\n   * @return {number|undefined} The accuracy of the altitude measurement in\n   *     meters.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getAltitudeAccuracy = function getAltitudeAccuracy() {\n    return (\n      /** @type {number|undefined} */\n      this.get(Property.ALTITUDE_ACCURACY)\n    );\n  };\n  /**\n   * Get the heading as radians clockwise from North.\n   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`\n   * is set to `true` in the tracking options.\n   * @return {number|undefined} The heading of the device in radians from north.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getHeading = function getHeading() {\n    return (\n      /** @type {number|undefined} */\n      this.get(Property.HEADING)\n    );\n  };\n  /**\n   * Get the position of the device.\n   * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported\n   *     in the current projection.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getPosition = function getPosition() {\n    return (\n      /** @type {import("./coordinate.js").Coordinate|undefined} */\n      this.get(Property.POSITION)\n    );\n  };\n  /**\n   * Get the projection associated with the position.\n   * @return {import("./proj/Projection.js").default|undefined} The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getProjection = function getProjection() {\n    return (\n      /** @type {import("./proj/Projection.js").default|undefined} */\n      this.get(Property.PROJECTION)\n    );\n  };\n  /**\n   * Get the speed in meters per second.\n   * @return {number|undefined} The instantaneous speed of the device in meters\n   *     per second.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getSpeed = function getSpeed() {\n    return (\n      /** @type {number|undefined} */\n      this.get(Property.SPEED)\n    );\n  };\n  /**\n   * Determine if the device location is being tracked.\n   * @return {boolean} The device location is being tracked.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getTracking = function getTracking() {\n    return (\n      /** @type {boolean} */\n      this.get(Property.TRACKING)\n    );\n  };\n  /**\n   * Get the tracking options.\n   * See http://www.w3.org/TR/geolocation-API/#position-options.\n   * @return {PositionOptions|undefined} PositionOptions as defined by\n   *     the [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.getTrackingOptions = function getTrackingOptions() {\n    return (\n      /** @type {PositionOptions|undefined} */\n      this.get(Property.TRACKING_OPTIONS)\n    );\n  };\n  /**\n   * Set the projection to use for transforming the coordinates.\n   * @param {import("./proj.js").ProjectionLike} projection The projection the position is\n   *     reported in.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.setProjection = function setProjection(projection) {\n    this.set(Property.PROJECTION, Object(_proj_js__WEBPACK_IMPORTED_MODULE_7__["get"])(projection));\n  };\n  /**\n   * Enable or disable tracking.\n   * @param {boolean} tracking Enable tracking.\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.setTracking = function setTracking(tracking) {\n    this.set(Property.TRACKING, tracking);\n  };\n  /**\n   * Set the tracking options.\n   * See http://www.w3.org/TR/geolocation-API/#position-options.\n   * @param {PositionOptions} options PositionOptions as defined by the\n   *     [HTML5 Geolocation spec\n   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).\n   * @observable\n   * @api\n   */\n\n\n  Geolocation.prototype.setTrackingOptions = function setTrackingOptions(options) {\n    this.set(Property.TRACKING_OPTIONS, options);\n  };\n\n  return Geolocation;\n}(_Object_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);\n\n/* harmony default export */ __webpack_exports__["default"] = (Geolocation);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9HZW9sb2NhdGlvbi5qcz9kNTZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9HZW9sb2NhdGlvblxuICovXG5pbXBvcnQgQmFzZU9iamVjdCwge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi9PYmplY3QuanMnO1xuaW1wb3J0IHtsaXN0ZW59IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudCBmcm9tICcuL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQgRXZlbnRUeXBlIGZyb20gJy4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2NpcmN1bGFyIGFzIGNpcmN1bGFyUG9seWdvbn0gZnJvbSAnLi9nZW9tL1BvbHlnb24uanMnO1xuaW1wb3J0IHtHRU9MT0NBVElPTn0gZnJvbSAnLi9oYXMuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnN9IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQge2dldCBhcyBnZXRQcm9qZWN0aW9uLCBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMsIGlkZW50aXR5VHJhbnNmb3JtfSBmcm9tICcuL3Byb2ouanMnO1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgUHJvcGVydHkgPSB7XG4gIEFDQ1VSQUNZOiAnYWNjdXJhY3knLFxuICBBQ0NVUkFDWV9HRU9NRVRSWTogJ2FjY3VyYWN5R2VvbWV0cnknLFxuICBBTFRJVFVERTogJ2FsdGl0dWRlJyxcbiAgQUxUSVRVREVfQUNDVVJBQ1k6ICdhbHRpdHVkZUFjY3VyYWN5JyxcbiAgSEVBRElORzogJ2hlYWRpbmcnLFxuICBQT1NJVElPTjogJ3Bvc2l0aW9uJyxcbiAgUFJPSkVDVElPTjogJ3Byb2plY3Rpb24nLFxuICBTUEVFRDogJ3NwZWVkJyxcbiAgVFJBQ0tJTkc6ICd0cmFja2luZycsXG4gIFRSQUNLSU5HX09QVElPTlM6ICd0cmFja2luZ09wdGlvbnMnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgb24gR2VvbG9jYXRpb24gZXJyb3IuXG4gKi9cbmNsYXNzIEdlb2xvY2F0aW9uRXJyb3IgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Bvc2l0aW9uRXJyb3J9IGVycm9yIGVycm9yIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgc3VwZXIoRXZlbnRUeXBlLkVSUk9SKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jb2RlID0gZXJyb3IuY29kZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgfVxufVxuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbdHJhY2tpbmc9ZmFsc2VdIFN0YXJ0IFRyYWNraW5nIHJpZ2h0IGFmdGVyXG4gKiBpbnN0YW50aWF0aW9uLlxuICogQHByb3BlcnR5IHtQb3NpdGlvbk9wdGlvbnN9IFt0cmFja2luZ09wdGlvbnNdIFRyYWNraW5nIG9wdGlvbnMuXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvZ2VvbG9jYXRpb24tQVBJLyNwb3NpdGlvbl9vcHRpb25zX2ludGVyZmFjZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlByb2plY3Rpb25MaWtlfSBbcHJvamVjdGlvbl0gVGhlIHByb2plY3Rpb24gdGhlIHBvc2l0aW9uXG4gKiBpcyByZXBvcnRlZCBpbi5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogSGVscGVyIGNsYXNzIGZvciBwcm92aWRpbmcgSFRNTDUgR2VvbG9jYXRpb24gY2FwYWJpbGl0aWVzLlxuICogVGhlIFtHZW9sb2NhdGlvbiBBUEldKGh0dHA6Ly93d3cudzMub3JnL1RSL2dlb2xvY2F0aW9uLUFQSS8pXG4gKiBpcyB1c2VkIHRvIGxvY2F0ZSBhIHVzZXIncyBwb3NpdGlvbi5cbiAqXG4gKiBUbyBnZXQgbm90aWZpZWQgb2YgcG9zaXRpb24gY2hhbmdlcywgcmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgdGhlIGdlbmVyaWNcbiAqIGBjaGFuZ2VgIGV2ZW50IG9uIHlvdXIgaW5zdGFuY2Ugb2Yge0BsaW5rIG1vZHVsZTpvbC9HZW9sb2NhdGlvbn5HZW9sb2NhdGlvbn0uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgdmFyIGdlb2xvY2F0aW9uID0gbmV3IEdlb2xvY2F0aW9uKHtcbiAqICAgICAgIC8vIHRha2UgdGhlIHByb2plY3Rpb24gdG8gdXNlIGZyb20gdGhlIG1hcCdzIHZpZXdcbiAqICAgICAgIHByb2plY3Rpb246IHZpZXcuZ2V0UHJvamVjdGlvbigpXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gcG9zaXRpb25cbiAqICAgICBnZW9sb2NhdGlvbi5vbignY2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XG4gKiAgICAgICB3aW5kb3cuY29uc29sZS5sb2coZ2VvbG9jYXRpb24uZ2V0UG9zaXRpb24oKSk7XG4gKiAgICAgfSk7XG4gKlxuICogQGZpcmVzIGVycm9yXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEdlb2xvY2F0aW9uIGV4dGVuZHMgQmFzZU9iamVjdCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB1bnByb2plY3RlZCAoRVBTRzo0MzI2KSBkZXZpY2UgcG9zaXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9wcm9qLmpzXCIpLlRyYW5zZm9ybUZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtXyA9IGlkZW50aXR5VHJhbnNmb3JtO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLndhdGNoSWRfID0gdW5kZWZpbmVkO1xuXG4gICAgbGlzdGVuKFxuICAgICAgdGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKFByb3BlcnR5LlBST0pFQ1RJT04pLFxuICAgICAgdGhpcy5oYW5kbGVQcm9qZWN0aW9uQ2hhbmdlZF8sIHRoaXMpO1xuICAgIGxpc3RlbihcbiAgICAgIHRoaXMsIGdldENoYW5nZUV2ZW50VHlwZShQcm9wZXJ0eS5UUkFDS0lORyksXG4gICAgICB0aGlzLmhhbmRsZVRyYWNraW5nQ2hhbmdlZF8sIHRoaXMpO1xuXG4gICAgaWYgKG9wdGlvbnMucHJvamVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnNldFByb2plY3Rpb24ob3B0aW9ucy5wcm9qZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJhY2tpbmdPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2tpbmdPcHRpb25zKG9wdGlvbnMudHJhY2tpbmdPcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFRyYWNraW5nKG9wdGlvbnMudHJhY2tpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudHJhY2tpbmcgOiBmYWxzZSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMuc2V0VHJhY2tpbmcoZmFsc2UpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQcm9qZWN0aW9uQ2hhbmdlZF8oKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybV8gPSBnZXRUcmFuc2Zvcm1Gcm9tUHJvamVjdGlvbnMoXG4gICAgICAgIGdldFByb2plY3Rpb24oJ0VQU0c6NDMyNicpLCBwcm9qZWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uXykge1xuICAgICAgICB0aGlzLnNldChQcm9wZXJ0eS5QT1NJVElPTiwgdGhpcy50cmFuc2Zvcm1fKHRoaXMucG9zaXRpb25fKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUcmFja2luZ0NoYW5nZWRfKCkge1xuICAgIGlmIChHRU9MT0NBVElPTikge1xuICAgICAgY29uc3QgdHJhY2tpbmcgPSB0aGlzLmdldFRyYWNraW5nKCk7XG4gICAgICBpZiAodHJhY2tpbmcgJiYgdGhpcy53YXRjaElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMud2F0Y2hJZF8gPSBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24ud2F0Y2hQb3NpdGlvbihcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uQ2hhbmdlXy5iaW5kKHRoaXMpLFxuICAgICAgICAgIHRoaXMucG9zaXRpb25FcnJvcl8uYmluZCh0aGlzKSxcbiAgICAgICAgICB0aGlzLmdldFRyYWNraW5nT3B0aW9ucygpKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRyYWNraW5nICYmIHRoaXMud2F0Y2hJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLndhdGNoSWRfKTtcbiAgICAgICAgdGhpcy53YXRjaElkXyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQb3NpdGlvbn0gcG9zaXRpb24gcG9zaXRpb24gZXZlbnQuXG4gICAqL1xuICBwb3NpdGlvbkNoYW5nZV8ocG9zaXRpb24pIHtcbiAgICBjb25zdCBjb29yZHMgPSBwb3NpdGlvbi5jb29yZHM7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuQUNDVVJBQ1ksIGNvb3Jkcy5hY2N1cmFjeSk7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuQUxUSVRVREUsXG4gICAgICBjb29yZHMuYWx0aXR1ZGUgPT09IG51bGwgPyB1bmRlZmluZWQgOiBjb29yZHMuYWx0aXR1ZGUpO1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LkFMVElUVURFX0FDQ1VSQUNZLFxuICAgICAgY29vcmRzLmFsdGl0dWRlQWNjdXJhY3kgPT09IG51bGwgP1xuICAgICAgICB1bmRlZmluZWQgOiBjb29yZHMuYWx0aXR1ZGVBY2N1cmFjeSk7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuSEVBRElORywgY29vcmRzLmhlYWRpbmcgPT09IG51bGwgP1xuICAgICAgdW5kZWZpbmVkIDogdG9SYWRpYW5zKGNvb3Jkcy5oZWFkaW5nKSk7XG4gICAgaWYgKCF0aGlzLnBvc2l0aW9uXykge1xuICAgICAgdGhpcy5wb3NpdGlvbl8gPSBbY29vcmRzLmxvbmdpdHVkZSwgY29vcmRzLmxhdGl0dWRlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3NpdGlvbl9bMF0gPSBjb29yZHMubG9uZ2l0dWRlO1xuICAgICAgdGhpcy5wb3NpdGlvbl9bMV0gPSBjb29yZHMubGF0aXR1ZGU7XG4gICAgfVxuICAgIGNvbnN0IHByb2plY3RlZFBvc2l0aW9uID0gdGhpcy50cmFuc2Zvcm1fKHRoaXMucG9zaXRpb25fKTtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5QT1NJVElPTiwgcHJvamVjdGVkUG9zaXRpb24pO1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LlNQRUVELFxuICAgICAgY29vcmRzLnNwZWVkID09PSBudWxsID8gdW5kZWZpbmVkIDogY29vcmRzLnNwZWVkKTtcbiAgICBjb25zdCBnZW9tZXRyeSA9IGNpcmN1bGFyUG9seWdvbih0aGlzLnBvc2l0aW9uXywgY29vcmRzLmFjY3VyYWN5KTtcbiAgICBnZW9tZXRyeS5hcHBseVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybV8pO1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LkFDQ1VSQUNZX0dFT01FVFJZLCBnZW9tZXRyeSk7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIEdlb2xvY2F0aW9uIHJldHVybnMgYW4gZXJyb3IuXG4gICAqIEBldmVudCBlcnJvclxuICAgKiBAYXBpXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1Bvc2l0aW9uRXJyb3J9IGVycm9yIGVycm9yIG9iamVjdC5cbiAgICovXG4gIHBvc2l0aW9uRXJyb3JfKGVycm9yKSB7XG4gICAgdGhpcy5zZXRUcmFja2luZyhmYWxzZSk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBHZW9sb2NhdGlvbkVycm9yKGVycm9yKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhY2N1cmFjeSBvZiB0aGUgcG9zaXRpb24gaW4gbWV0ZXJzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ8dW5kZWZpbmVkfSBUaGUgYWNjdXJhY3kgb2YgdGhlIHBvc2l0aW9uIG1lYXN1cmVtZW50IGluXG4gICAqICAgICBtZXRlcnMuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEFjY3VyYWN5KCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovICh0aGlzLmdldChQcm9wZXJ0eS5BQ0NVUkFDWSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGdlb21ldHJ5IG9mIHRoZSBwb3NpdGlvbiBhY2N1cmFjeS5cbiAgICogQHJldHVybiB7P2ltcG9ydChcIi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9IEEgZ2VvbWV0cnkgb2YgdGhlIHBvc2l0aW9uIGFjY3VyYWN5LlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRBY2N1cmFjeUdlb21ldHJ5KCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUgez9pbXBvcnQoXCIuL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXQoUHJvcGVydHkuQUNDVVJBQ1lfR0VPTUVUUlkpIHx8IG51bGwpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFsdGl0dWRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSBhbHRpdHVkZSBvZiB0aGUgcG9zaXRpb24gaW4gbWV0ZXJzIGFib3ZlIG1lYW5cbiAgICogICAgIHNlYSBsZXZlbC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QWx0aXR1ZGUoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LkFMVElUVURFKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhbHRpdHVkZSBhY2N1cmFjeSBvZiB0aGUgcG9zaXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSBhY2N1cmFjeSBvZiB0aGUgYWx0aXR1ZGUgbWVhc3VyZW1lbnQgaW5cbiAgICogICAgIG1ldGVycy5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QWx0aXR1ZGVBY2N1cmFjeSgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfSAqLyAodGhpcy5nZXQoUHJvcGVydHkuQUxUSVRVREVfQUNDVVJBQ1kpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhlYWRpbmcgYXMgcmFkaWFucyBjbG9ja3dpc2UgZnJvbSBOb3J0aC5cbiAgICogTm90ZTogZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyLCB0aGUgaGVhZGluZyBpcyBvbmx5IGRlZmluZWQgaWYgdGhlIGBlbmFibGVIaWdoQWNjdXJhY3lgXG4gICAqIGlzIHNldCB0byBgdHJ1ZWAgaW4gdGhlIHRyYWNraW5nIG9wdGlvbnMuXG4gICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFRoZSBoZWFkaW5nIG9mIHRoZSBkZXZpY2UgaW4gcmFkaWFucyBmcm9tIG5vcnRoLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRIZWFkaW5nKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovICh0aGlzLmdldChQcm9wZXJ0eS5IRUFESU5HKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgZGV2aWNlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZXx1bmRlZmluZWR9IFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBkZXZpY2UgcmVwb3J0ZWRcbiAgICogICAgIGluIHRoZSBjdXJyZW50IHByb2plY3Rpb24uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFBvc2l0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LlBPU0lUSU9OKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJvamVjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gVGhlIHByb2plY3Rpb24gdGhlIHBvc2l0aW9uIGlzXG4gICAqICAgICByZXBvcnRlZCBpbi5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UHJvamVjdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL3Byb2ovUHJvamVjdGlvbi5qc1wiKS5kZWZhdWx0fHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LlBST0pFQ1RJT04pKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzcGVlZCBpbiBtZXRlcnMgcGVyIHNlY29uZC5cbiAgICogQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVGhlIGluc3RhbnRhbmVvdXMgc3BlZWQgb2YgdGhlIGRldmljZSBpbiBtZXRlcnNcbiAgICogICAgIHBlciBzZWNvbmQuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFNwZWVkKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovICh0aGlzLmdldChQcm9wZXJ0eS5TUEVFRCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGUgZGV2aWNlIGxvY2F0aW9uIGlzIGJlaW5nIHRyYWNrZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBkZXZpY2UgbG9jYXRpb24gaXMgYmVpbmcgdHJhY2tlZC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0VHJhY2tpbmcoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LlRSQUNLSU5HKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cmFja2luZyBvcHRpb25zLlxuICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvZ2VvbG9jYXRpb24tQVBJLyNwb3NpdGlvbi1vcHRpb25zLlxuICAgKiBAcmV0dXJuIHtQb3NpdGlvbk9wdGlvbnN8dW5kZWZpbmVkfSBQb3NpdGlvbk9wdGlvbnMgYXMgZGVmaW5lZCBieVxuICAgKiAgICAgdGhlIFtIVE1MNSBHZW9sb2NhdGlvbiBzcGVjXG4gICAqICAgICBdKGh0dHA6Ly93d3cudzMub3JnL1RSL2dlb2xvY2F0aW9uLUFQSS8jcG9zaXRpb25fb3B0aW9uc19pbnRlcmZhY2UpLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUcmFja2luZ09wdGlvbnMoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7UG9zaXRpb25PcHRpb25zfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KFByb3BlcnR5LlRSQUNLSU5HX09QVElPTlMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHByb2plY3Rpb24gdG8gdXNlIGZvciB0cmFuc2Zvcm1pbmcgdGhlIGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcHJvai5qc1wiKS5Qcm9qZWN0aW9uTGlrZX0gcHJvamVjdGlvbiBUaGUgcHJvamVjdGlvbiB0aGUgcG9zaXRpb24gaXNcbiAgICogICAgIHJlcG9ydGVkIGluLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgICB0aGlzLnNldChQcm9wZXJ0eS5QUk9KRUNUSU9OLCBnZXRQcm9qZWN0aW9uKHByb2plY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSB0cmFja2luZy5cbiAgICogQHBhcmFtIHtib29sZWFufSB0cmFja2luZyBFbmFibGUgdHJhY2tpbmcuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRyYWNraW5nKHRyYWNraW5nKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuVFJBQ0tJTkcsIHRyYWNraW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYWNraW5nIG9wdGlvbnMuXG4gICAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9nZW9sb2NhdGlvbi1BUEkvI3Bvc2l0aW9uLW9wdGlvbnMuXG4gICAqIEBwYXJhbSB7UG9zaXRpb25PcHRpb25zfSBvcHRpb25zIFBvc2l0aW9uT3B0aW9ucyBhcyBkZWZpbmVkIGJ5IHRoZVxuICAgKiAgICAgW0hUTUw1IEdlb2xvY2F0aW9uIHNwZWNcbiAgICogICAgIF0oaHR0cDovL3d3dy53My5vcmcvVFIvZ2VvbG9jYXRpb24tQVBJLyNwb3NpdGlvbl9vcHRpb25zX2ludGVyZmFjZSkuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRyYWNraW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5zZXQoUHJvcGVydHkuVFJBQ0tJTkdfT1BUSU9OUywgb3B0aW9ucyk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBHZW9sb2NhdGlvbjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBOzs7Ozs7QUFrQkE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7Ozs7QUFLQTs7Ozs7QUFLQTs7Ozs7QUFDQTs7QUFoQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQTtBQUFBO0FBQUE7QUFLQTtBQUVBO0FBRUE7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBRUE7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBR0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUdBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUdBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTs7QUEzUkE7QUFDQTtBQTZSQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///137\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _GeoJSON = _interopRequireDefault(__webpack_require__(77));\n\nvar _Style = _interopRequireDefault(__webpack_require__(72));\n\nvar _Icon = _interopRequireDefault(__webpack_require__(150));\n\nvar _Vector = _interopRequireDefault(__webpack_require__(83));\n\nvar _Vector2 = _interopRequireDefault(__webpack_require__(84));\n\nvar _Feature = _interopRequireDefault(__webpack_require__(59));\n\nvar _Point = _interopRequireDefault(__webpack_require__(52));\n\nvar _MapLocator = _interopRequireDefault(__webpack_require__(139));\n\nvar _FeatureTip = _interopRequireDefault(__webpack_require__(140));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/MapLocator\r\n */\n\n/**\r\n * @desc A class for managing map location\r\n * @public\r\n * @class\r\n * @extends module:nyc/MapLocator~MapLocator\r\n */\n\n\nvar MapLocator =\n/*#__PURE__*/\nfunction (_MapLocator$default) {\n  _inherits(MapLocator, _MapLocator$default);\n\n  /**\r\n   * @desc Create an instance of MapLocator\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/ol/MapLocator~MapLocator.Options} options Constructor options\r\n   */\n  function MapLocator(options) {\n    var _this;\n\n    _classCallCheck(this, MapLocator);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapLocator).call(this));\n    /**\r\n     * @desc The layer on which to render locations\r\n     * @public\r\n     * @member {ol.layer.Vector}\r\n     */\n\n    _this.layer = null;\n    /**\r\n     * @private\r\n     * @member {ol.source.Vector}\r\n     */\n\n    _this.source = null;\n    /**\r\n     * @private\r\n     * @member {ol.Map}\r\n     */\n\n    _this.map = options.map;\n    /**\r\n     * @private\r\n     * @member {ol.View}\r\n     */\n\n    _this.view = _this.map.getView();\n    /**\r\n     * @private\r\n     * @member {number}\r\n     */\n\n    _this.zoom = options.zoom !== undefined ? options.zoom : _MapLocator["default"].ZOOM_LEVEL;\n    /**\r\n     * @private\r\n     * @member {ol.format.GeoJSON}\r\n     */\n\n    _this.format = new _GeoJSON["default"]();\n    /**\r\n     * @private\r\n     * @member {module:nyc/ol/FeatureTip~FeatureTip}\r\n     */\n\n    _this.tip = null;\n\n    _this.createLayer(options.style);\n\n    return _this;\n  }\n  /**\r\n   * @desc Zoom to the provided location then optionally invoke a callback function\r\n   * @public\r\n   * @override\r\n   * @method\r\n   * @param {module:nyc/Locator~Locator.Result} data The location to which the map will be oriented\r\n   * @param {module:nyc/MapLocator~MapLocator#zoomLocationCallback=} callback The function to call after the locator has zoomed to the location\r\n   */\n\n\n  _createClass(MapLocator, [{\n    key: "zoomLocation",\n    value: function zoomLocation(data, callback) {\n      var map = this.map;\n      var view = this.view;\n      var source = this.source;\n      var feature = this.feature(data);\n\n      if (feature) {\n        var geom = feature.getGeometry();\n        source.clear();\n        source.addFeature(feature);\n\n        if (callback) {\n          map.once(\'moveend\', callback);\n        }\n\n        if (geom.getType() === \'Point\') {\n          view.animate({\n            center: data.coordinate,\n            zoom: this.zoom\n          });\n        } else {\n          view.fit(geom.getExtent(), {\n            size: map.getSize(),\n            duration: 500\n          });\n        }\n      }\n    }\n    /**\r\n     * @desc Set the location to the provided location without moving the map\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @param {module:nyc/Locator~Locator.Result} data The location to which the map will be oriented\r\n     */\n\n  }, {\n    key: "setLocation",\n    value: function setLocation(data) {\n      this.source.clear();\n      this.source.addFeature(this.feature(data));\n    }\n    /**\r\n     * @desc Get the projection of the map\r\n     * @public\r\n     * @override\r\n     * @method\r\n     * @returns {string} The map projection\r\n     */\n\n  }, {\n    key: "getProjection",\n    value: function getProjection() {\n      return this.view.getProjection();\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {module:nyc/Locator~Locator.Result} location Location\r\n     * @return {ol.Feature} The OpenLayers feature\r\n     */\n\n  }, {\n    key: "feature",\n    value: function feature(location) {\n      var geoJson = location.geometry;\n      var coord = location.coordinate;\n\n      if (!geoJson && !coord) {\n        console.error(\'Unable to map invalid geometry:\', location);\n      } else {\n        var feature = new _Feature["default"]({\n          name: location.name,\n          isFeature: location.isFeature\n        });\n\n        if (geoJson) {\n          feature.setGeometry(this.format.readGeometry(geoJson));\n        } else {\n          feature.setGeometry(new _Point["default"](coord));\n        }\n\n        return feature;\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {ol.style.Style|Array<ol.style.Style>|ol.StyleFunction=} style Style\r\n     */\n\n  }, {\n    key: "createLayer",\n    value: function createLayer(style) {\n      this.source = new _Vector["default"]();\n      this.layer = new _Vector2["default"]({\n        source: this.source,\n        style: style || MapLocator.LOCATION_STYLE,\n        zIndex: 10000\n      });\n      this.map.addLayer(this.layer);\n      this.tip = new _FeatureTip["default"]({\n        map: this.map,\n        tips: [{\n          layer: this.layer,\n          label: function label(feature) {\n            return {\n              css: \'nyc-user-location\',\n              html: feature.get(\'name\')\n            };\n          }\n        }]\n      });\n    }\n  }]);\n\n  return MapLocator;\n}(_MapLocator["default"]);\n/**\r\n * @desc Object type to hold constructor options for {@link module:nyc/ol/MapLocator~MapLocator}\r\n * @public\r\n * @typedef {Object}\r\n * @property {ol.Map} map The map on which location will be managed\r\n * @property {ol.style.Style=} style The style for the layer on which user-specified locations will be displayed\r\n * @property {number} [zoom={@link NycMapLocator.ZOOM_LEVEL}] The zoom level used when locating coordinate\r\n */\n\n\nMapLocator.Options;\n/**\r\n * @desc The marker icon style for user location\r\n * @public\r\n * @const {ol.style.Style}\r\n */\n\nMapLocator.LOCATION_STYLE = new _Style["default"]({\n  image: new _Icon["default"]({\n    scale: 48 / 512,\n    imgSize: [1024, 1024],\n    src: \'data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%221024%22%20height%3D%221024%22%3E%3Cfilter%20id%3D%22filter%22%20style%3D%22color-interpolation-filters%3AsRGB%22%20x%3D%22-0.035750399%22%20width%3D%221.0715008%22%20y%3D%22-0.03625311%22%20%20height%3D%221.0725062%22%3E%3CfeGaussianBlur%20stdDeviation%3D%226.0015266%22%2F%3E%3C%2Ffilter%3E%3Cpath%20style%3D%22opacity%3A0.1%3Bfill%3A%23000000%3Bfill-opacity%3A1%3Bstroke%3A%23000000%3Bstroke-width%3A10%3Bstroke-opacity%3A1%3Bfilter%3Aurl(%23filter)%22%20d%3D%22M%20868.91078%2C141.10492%20C%20806.53392%2C79.855774%20695.84806%2C89.539532%20621.70905%2C162.73227%20547.57005%2C235.92501%20492.08486%2C476.05139%20510.9101%2C494.53629%20529.73535%2C513.02119%20773.473%2C457.74384%20847.612%2C384.5511%20921.751%2C311.35836%20931.28764%2C202.35407%20868.91078%2C141.10492%20Z%20M%20645.16036%2C361.99953%20c%20-41.52967%2C-40.77885%20-35.13918%2C-113.58881%2014.19918%2C-162.29746%2049.33837%2C-48.70864%20123.27149%2C-55.19708%20164.80115%2C-14.41823%2041.52967%2C40.77885%2035.13918%2C113.58881%20-14.19918%2C162.29745%20-49.33837%2C48.70864%20-123.27149%2C55.19709%20-164.80115%2C14.41824%20z%22%2F%3E%3Cpath%20style%3D%22fill%3A%23000%3Bstroke%3A%23fff%3Bstroke-width%3A20%22%20d%3D%22m%20512%2C25.6%20c%20-95.4279%2C0%20-172.8%2C77.3721%20-172.8%2C172.8%200%2C95.4279%20144%2C288%20172.8%2C288%2028.8%2C0%20172.8%2C-192.5721%20172.8%2C-288%20C%20684.8%2C102.9721%20607.4279%2C25.6%20512%2C25.6%20Z%20m%200%2C288%20c%20-63.5346%2C0%20-115.2%2C-51.6942%20-115.2%2C-115.2%200%2C-63.5058%2051.6654%2C-115.2%20115.2%2C-115.2%2063.5346%2C0%20115.2%2C51.6942%20115.2%2C115.2%200%2C63.5058%20-51.6654%2C115.2%20-115.2%2C115.2%20z%22%2F%3E%3C%2Fsvg%3E\'\n  })\n});\nvar _default = MapLocator;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL01hcExvY2F0b3IuanM/NDFmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9HZW9KU09OID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvZm9ybWF0L0dlb0pTT05cIikpO1xuXG52YXIgX1N0eWxlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvc3R5bGUvU3R5bGVcIikpO1xuXG52YXIgX0ljb24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9zdHlsZS9JY29uXCIpKTtcblxudmFyIF9WZWN0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9zb3VyY2UvVmVjdG9yXCIpKTtcblxudmFyIF9WZWN0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvbGF5ZXIvVmVjdG9yXCIpKTtcblxudmFyIF9GZWF0dXJlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwib2wvRmVhdHVyZVwiKSk7XG5cbnZhciBfUG9pbnQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9nZW9tL1BvaW50XCIpKTtcblxudmFyIF9NYXBMb2NhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vTWFwTG9jYXRvclwiKSk7XG5cbnZhciBfRmVhdHVyZVRpcCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vRmVhdHVyZVRpcFwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9vbC9NYXBMb2NhdG9yXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQSBjbGFzcyBmb3IgbWFuYWdpbmcgbWFwIGxvY2F0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIG1vZHVsZTpueWMvTWFwTG9jYXRvcn5NYXBMb2NhdG9yXHJcbiAqL1xuY2xhc3MgTWFwTG9jYXRvciBleHRlbmRzIF9NYXBMb2NhdG9yLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTWFwTG9jYXRvclxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvb2wvTWFwTG9jYXRvcn5NYXBMb2NhdG9yLk9wdGlvbnN9IG9wdGlvbnMgQ29uc3RydWN0b3Igb3B0aW9uc1xyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcclxuICAgICAqIEBkZXNjIFRoZSBsYXllciBvbiB3aGljaCB0byByZW5kZXIgbG9jYXRpb25zXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAbWVtYmVyIHtvbC5sYXllci5WZWN0b3J9XHJcbiAgICAgKi9cblxuICAgIHRoaXMubGF5ZXIgPSBudWxsO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge29sLnNvdXJjZS5WZWN0b3J9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtvbC5NYXB9XHJcbiAgICAgKi9cblxuICAgIHRoaXMubWFwID0gb3B0aW9ucy5tYXA7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7b2wuVmlld31cclxuICAgICAqL1xuXG4gICAgdGhpcy52aWV3ID0gdGhpcy5tYXAuZ2V0VmlldygpO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xuXG4gICAgdGhpcy56b29tID0gb3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnpvb20gOiBfTWFwTG9jYXRvci5kZWZhdWx0LlpPT01fTEVWRUw7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQG1lbWJlciB7b2wuZm9ybWF0Lkdlb0pTT059XHJcbiAgICAgKi9cblxuICAgIHRoaXMuZm9ybWF0ID0gbmV3IF9HZW9KU09OLmRlZmF1bHQoKTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHttb2R1bGU6bnljL29sL0ZlYXR1cmVUaXB+RmVhdHVyZVRpcH1cclxuICAgICAqL1xuXG4gICAgdGhpcy50aXAgPSBudWxsO1xuICAgIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucy5zdHlsZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgWm9vbSB0byB0aGUgcHJvdmlkZWQgbG9jYXRpb24gdGhlbiBvcHRpb25hbGx5IGludm9rZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLlJlc3VsdH0gZGF0YSBUaGUgbG9jYXRpb24gdG8gd2hpY2ggdGhlIG1hcCB3aWxsIGJlIG9yaWVudGVkXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL01hcExvY2F0b3J+TWFwTG9jYXRvciN6b29tTG9jYXRpb25DYWxsYmFjaz19IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHRoZSBsb2NhdG9yIGhhcyB6b29tZWQgdG8gdGhlIGxvY2F0aW9uXHJcbiAgICovXG5cblxuICB6b29tTG9jYXRpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLm1hcDtcbiAgICBjb25zdCB2aWV3ID0gdGhpcy52aWV3O1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmZlYXR1cmUoZGF0YSk7XG5cbiAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgY29uc3QgZ2VvbSA9IGZlYXR1cmUuZ2V0R2VvbWV0cnkoKTtcbiAgICAgIHNvdXJjZS5jbGVhcigpO1xuICAgICAgc291cmNlLmFkZEZlYXR1cmUoZmVhdHVyZSk7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBtYXAub25jZSgnbW92ZWVuZCcsIGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGdlb20uZ2V0VHlwZSgpID09PSAnUG9pbnQnKSB7XG4gICAgICAgIHZpZXcuYW5pbWF0ZSh7XG4gICAgICAgICAgY2VudGVyOiBkYXRhLmNvb3JkaW5hdGUsXG4gICAgICAgICAgem9vbTogdGhpcy56b29tXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy5maXQoZ2VvbS5nZXRFeHRlbnQoKSwge1xuICAgICAgICAgIHNpemU6IG1hcC5nZXRTaXplKCksXG4gICAgICAgICAgZHVyYXRpb246IDUwMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgU2V0IHRoZSBsb2NhdGlvbiB0byB0aGUgcHJvdmlkZWQgbG9jYXRpb24gd2l0aG91dCBtb3ZpbmcgdGhlIG1hcFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5SZXN1bHR9IGRhdGEgVGhlIGxvY2F0aW9uIHRvIHdoaWNoIHRoZSBtYXAgd2lsbCBiZSBvcmllbnRlZFxyXG4gICAqL1xuXG5cbiAgc2V0TG9jYXRpb24oZGF0YSkge1xuICAgIHRoaXMuc291cmNlLmNsZWFyKCk7XG4gICAgdGhpcy5zb3VyY2UuYWRkRmVhdHVyZSh0aGlzLmZlYXR1cmUoZGF0YSkpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIEdldCB0aGUgcHJvamVjdGlvbiBvZiB0aGUgbWFwXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbWFwIHByb2plY3Rpb25cclxuICAgKi9cblxuXG4gIGdldFByb2plY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRQcm9qZWN0aW9uKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5SZXN1bHR9IGxvY2F0aW9uIExvY2F0aW9uXHJcbiAgICogQHJldHVybiB7b2wuRmVhdHVyZX0gVGhlIE9wZW5MYXllcnMgZmVhdHVyZVxyXG4gICAqL1xuXG5cbiAgZmVhdHVyZShsb2NhdGlvbikge1xuICAgIGNvbnN0IGdlb0pzb24gPSBsb2NhdGlvbi5nZW9tZXRyeTtcbiAgICBjb25zdCBjb29yZCA9IGxvY2F0aW9uLmNvb3JkaW5hdGU7XG5cbiAgICBpZiAoIWdlb0pzb24gJiYgIWNvb3JkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gbWFwIGludmFsaWQgZ2VvbWV0cnk6JywgbG9jYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmZWF0dXJlID0gbmV3IF9GZWF0dXJlLmRlZmF1bHQoe1xuICAgICAgICBuYW1lOiBsb2NhdGlvbi5uYW1lLFxuICAgICAgICBpc0ZlYXR1cmU6IGxvY2F0aW9uLmlzRmVhdHVyZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChnZW9Kc29uKSB7XG4gICAgICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkodGhpcy5mb3JtYXQucmVhZEdlb21ldHJ5KGdlb0pzb24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkobmV3IF9Qb2ludC5kZWZhdWx0KGNvb3JkKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge29sLnN0eWxlLlN0eWxlfEFycmF5PG9sLnN0eWxlLlN0eWxlPnxvbC5TdHlsZUZ1bmN0aW9uPX0gc3R5bGUgU3R5bGVcclxuICAgKi9cblxuXG4gIGNyZWF0ZUxheWVyKHN0eWxlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBuZXcgX1ZlY3Rvci5kZWZhdWx0KCk7XG4gICAgdGhpcy5sYXllciA9IG5ldyBfVmVjdG9yMi5kZWZhdWx0KHtcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICBzdHlsZTogc3R5bGUgfHwgTWFwTG9jYXRvci5MT0NBVElPTl9TVFlMRSxcbiAgICAgIHpJbmRleDogMTAwMDBcbiAgICB9KTtcbiAgICB0aGlzLm1hcC5hZGRMYXllcih0aGlzLmxheWVyKTtcbiAgICB0aGlzLnRpcCA9IG5ldyBfRmVhdHVyZVRpcC5kZWZhdWx0KHtcbiAgICAgIG1hcDogdGhpcy5tYXAsXG4gICAgICB0aXBzOiBbe1xuICAgICAgICBsYXllcjogdGhpcy5sYXllcixcbiAgICAgICAgbGFiZWw6IGZlYXR1cmUgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjc3M6ICdueWMtdXNlci1sb2NhdGlvbicsXG4gICAgICAgICAgICBodG1sOiBmZWF0dXJlLmdldCgnbmFtZScpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuXG59XG4vKipcclxuICogQGRlc2MgT2JqZWN0IHR5cGUgdG8gaG9sZCBjb25zdHJ1Y3RvciBvcHRpb25zIGZvciB7QGxpbmsgbW9kdWxlOm55Yy9vbC9NYXBMb2NhdG9yfk1hcExvY2F0b3J9XHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtvbC5NYXB9IG1hcCBUaGUgbWFwIG9uIHdoaWNoIGxvY2F0aW9uIHdpbGwgYmUgbWFuYWdlZFxyXG4gKiBAcHJvcGVydHkge29sLnN0eWxlLlN0eWxlPX0gc3R5bGUgVGhlIHN0eWxlIGZvciB0aGUgbGF5ZXIgb24gd2hpY2ggdXNlci1zcGVjaWZpZWQgbG9jYXRpb25zIHdpbGwgYmUgZGlzcGxheWVkXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbem9vbT17QGxpbmsgTnljTWFwTG9jYXRvci5aT09NX0xFVkVMfV0gVGhlIHpvb20gbGV2ZWwgdXNlZCB3aGVuIGxvY2F0aW5nIGNvb3JkaW5hdGVcclxuICovXG5cblxuTWFwTG9jYXRvci5PcHRpb25zO1xuLyoqXHJcbiAqIEBkZXNjIFRoZSBtYXJrZXIgaWNvbiBzdHlsZSBmb3IgdXNlciBsb2NhdGlvblxyXG4gKiBAcHVibGljXHJcbiAqIEBjb25zdCB7b2wuc3R5bGUuU3R5bGV9XHJcbiAqL1xuXG5NYXBMb2NhdG9yLkxPQ0FUSU9OX1NUWUxFID0gbmV3IF9TdHlsZS5kZWZhdWx0KHtcbiAgaW1hZ2U6IG5ldyBfSWNvbi5kZWZhdWx0KHtcbiAgICBzY2FsZTogNDggLyA1MTIsXG4gICAgaW1nU2l6ZTogWzEwMjQsIDEwMjRdLFxuICAgIHNyYzogJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQSUyRiUyRnd3dy53My5vcmclMkYyMDAwJTJGc3ZnJTIyJTIwd2lkdGglM0QlMjIxMDI0JTIyJTIwaGVpZ2h0JTNEJTIyMTAyNCUyMiUzRSUzQ2ZpbHRlciUyMGlkJTNEJTIyZmlsdGVyJTIyJTIwc3R5bGUlM0QlMjJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMlM0FzUkdCJTIyJTIweCUzRCUyMi0wLjAzNTc1MDM5OSUyMiUyMHdpZHRoJTNEJTIyMS4wNzE1MDA4JTIyJTIweSUzRCUyMi0wLjAzNjI1MzExJTIyJTIwJTIwaGVpZ2h0JTNEJTIyMS4wNzI1MDYyJTIyJTNFJTNDZmVHYXVzc2lhbkJsdXIlMjBzdGREZXZpYXRpb24lM0QlMjI2LjAwMTUyNjYlMjIlMkYlM0UlM0MlMkZmaWx0ZXIlM0UlM0NwYXRoJTIwc3R5bGUlM0QlMjJvcGFjaXR5JTNBMC4xJTNCZmlsbCUzQSUyMzAwMDAwMCUzQmZpbGwtb3BhY2l0eSUzQTElM0JzdHJva2UlM0ElMjMwMDAwMDAlM0JzdHJva2Utd2lkdGglM0ExMCUzQnN0cm9rZS1vcGFjaXR5JTNBMSUzQmZpbHRlciUzQXVybCglMjNmaWx0ZXIpJTIyJTIwZCUzRCUyMk0lMjA4NjguOTEwNzglMkMxNDEuMTA0OTIlMjBDJTIwODA2LjUzMzkyJTJDNzkuODU1Nzc0JTIwNjk1Ljg0ODA2JTJDODkuNTM5NTMyJTIwNjIxLjcwOTA1JTJDMTYyLjczMjI3JTIwNTQ3LjU3MDA1JTJDMjM1LjkyNTAxJTIwNDkyLjA4NDg2JTJDNDc2LjA1MTM5JTIwNTEwLjkxMDElMkM0OTQuNTM2MjklMjA1MjkuNzM1MzUlMkM1MTMuMDIxMTklMjA3NzMuNDczJTJDNDU3Ljc0Mzg0JTIwODQ3LjYxMiUyQzM4NC41NTExJTIwOTIxLjc1MSUyQzMxMS4zNTgzNiUyMDkzMS4yODc2NCUyQzIwMi4zNTQwNyUyMDg2OC45MTA3OCUyQzE0MS4xMDQ5MiUyMFolMjBNJTIwNjQ1LjE2MDM2JTJDMzYxLjk5OTUzJTIwYyUyMC00MS41Mjk2NyUyQy00MC43Nzg4NSUyMC0zNS4xMzkxOCUyQy0xMTMuNTg4ODElMjAxNC4xOTkxOCUyQy0xNjIuMjk3NDYlMjA0OS4zMzgzNyUyQy00OC43MDg2NCUyMDEyMy4yNzE0OSUyQy01NS4xOTcwOCUyMDE2NC44MDExNSUyQy0xNC40MTgyMyUyMDQxLjUyOTY3JTJDNDAuNzc4ODUlMjAzNS4xMzkxOCUyQzExMy41ODg4MSUyMC0xNC4xOTkxOCUyQzE2Mi4yOTc0NSUyMC00OS4zMzgzNyUyQzQ4LjcwODY0JTIwLTEyMy4yNzE0OSUyQzU1LjE5NzA5JTIwLTE2NC44MDExNSUyQzE0LjQxODI0JTIweiUyMiUyRiUzRSUzQ3BhdGglMjBzdHlsZSUzRCUyMmZpbGwlM0ElMjMwMDAlM0JzdHJva2UlM0ElMjNmZmYlM0JzdHJva2Utd2lkdGglM0EyMCUyMiUyMGQlM0QlMjJtJTIwNTEyJTJDMjUuNiUyMGMlMjAtOTUuNDI3OSUyQzAlMjAtMTcyLjglMkM3Ny4zNzIxJTIwLTE3Mi44JTJDMTcyLjglMjAwJTJDOTUuNDI3OSUyMDE0NCUyQzI4OCUyMDE3Mi44JTJDMjg4JTIwMjguOCUyQzAlMjAxNzIuOCUyQy0xOTIuNTcyMSUyMDE3Mi44JTJDLTI4OCUyMEMlMjA2ODQuOCUyQzEwMi45NzIxJTIwNjA3LjQyNzklMkMyNS42JTIwNTEyJTJDMjUuNiUyMFolMjBtJTIwMCUyQzI4OCUyMGMlMjAtNjMuNTM0NiUyQzAlMjAtMTE1LjIlMkMtNTEuNjk0MiUyMC0xMTUuMiUyQy0xMTUuMiUyMDAlMkMtNjMuNTA1OCUyMDUxLjY2NTQlMkMtMTE1LjIlMjAxMTUuMiUyQy0xMTUuMiUyMDYzLjUzNDYlMkMwJTIwMTE1LjIlMkM1MS42OTQyJTIwMTE1LjIlMkMxMTUuMiUyMDAlMkM2My41MDU4JTIwLTUxLjY2NTQlMkMxMTUuMiUyMC0xMTUuMiUyQzExNS4yJTIweiUyMiUyRiUzRSUzQyUyRnN2ZyUzRSdcbiAgfSlcbn0pO1xudmFyIF9kZWZhdWx0ID0gTWFwTG9jYXRvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7QUFNQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBOUNBO0FBOENBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVBBO0FBRkE7QUFZQTs7OztBQTdLQTtBQWdMQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQURBO0FBT0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///138\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n/**\r\n * @module nyc/MapLocator\r\n */\n\n/**\r\n * @desc An abstract class for managing map location\r\n * @public\r\n * @abstract\r\n * @class\r\n */\n\nvar MapLocator =\n/*#__PURE__*/\nfunction () {\n  function MapLocator() {\n    _classCallCheck(this, MapLocator);\n  }\n\n  _createClass(MapLocator, [{\n    key: "zoomLocation",\n\n    /**\r\n     * @desc Zoom to the provided loacation then optionally invoke a callback function\r\n     * @public\r\n     * @abstract\r\n     * @method\r\n     * @param {module:nyc/Locator~Locator.Result} data The location to which the map will be oriented\r\n     * @param {module:nyc/MapLocator~MapLocator#zoomLocationCallback=} callback The function to call after the locator has zoomed to the location\r\n     */\n    value: function zoomLocation(data, callback) {\n      throw \'Not implemented\';\n    }\n    /**\r\n     * @desc Set the location to the provided loacation without moving the map\r\n     * @public\r\n     * @abstract\r\n     * @method\r\n     * @param {module:nyc/Locator~Locator.Result} data The location\r\n     */\n\n  }, {\n    key: "setLocation",\n    value: function setLocation(data) {\n      throw \'Not implemented\';\n    }\n    /**\r\n     * @desc Get the projection of the map\r\n     * @public\r\n     * @abstract\r\n     * @method\r\n     * @returns {string} The map projection\r\n     */\n\n  }, {\n    key: "getProjection",\n    value: function getProjection() {\n      throw \'Not implemented\';\n    }\n  }]);\n\n  return MapLocator;\n}();\n/**\r\n * @desc Callback for {@link module:nyc/MapLocator~MapLocator#zoomLocation}\r\n * @public\r\n * @callback module:nyc/MapLocator~MapLocator#zoomLocationCallback\r\n */\n\n/**\r\n * @desc The default zoom level when zooming to locations\r\n * @const\r\n * @type {number}\r\n */\n\n\nMapLocator.ZOOM_LEVEL = 17;\nvar _default = MapLocator;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL01hcExvY2F0b3IuanM/ZTM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL01hcExvY2F0b3JcclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBBbiBhYnN0cmFjdCBjbGFzcyBmb3IgbWFuYWdpbmcgbWFwIGxvY2F0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzc1xyXG4gKi9cbmNsYXNzIE1hcExvY2F0b3Ige1xuICAvKipcclxuICAgKiBAZGVzYyBab29tIHRvIHRoZSBwcm92aWRlZCBsb2FjYXRpb24gdGhlbiBvcHRpb25hbGx5IGludm9rZSBhIGNhbGxiYWNrIGZ1bmN0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLlJlc3VsdH0gZGF0YSBUaGUgbG9jYXRpb24gdG8gd2hpY2ggdGhlIG1hcCB3aWxsIGJlIG9yaWVudGVkXHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL01hcExvY2F0b3J+TWFwTG9jYXRvciN6b29tTG9jYXRpb25DYWxsYmFjaz19IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjYWxsIGFmdGVyIHRoZSBsb2NhdG9yIGhhcyB6b29tZWQgdG8gdGhlIGxvY2F0aW9uXHJcbiAgICovXG4gIHpvb21Mb2NhdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIHRocm93ICdOb3QgaW1wbGVtZW50ZWQnO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFNldCB0aGUgbG9jYXRpb24gdG8gdGhlIHByb3ZpZGVkIGxvYWNhdGlvbiB3aXRob3V0IG1vdmluZyB0aGUgbWFwXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLlJlc3VsdH0gZGF0YSBUaGUgbG9jYXRpb25cclxuICAgKi9cblxuXG4gIHNldExvY2F0aW9uKGRhdGEpIHtcbiAgICB0aHJvdyAnTm90IGltcGxlbWVudGVkJztcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBHZXQgdGhlIHByb2plY3Rpb24gb2YgdGhlIG1hcFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG1hcCBwcm9qZWN0aW9uXHJcbiAgICovXG5cblxuICBnZXRQcm9qZWN0aW9uKCkge1xuICAgIHRocm93ICdOb3QgaW1wbGVtZW50ZWQnO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBAZGVzYyBDYWxsYmFjayBmb3Ige0BsaW5rIG1vZHVsZTpueWMvTWFwTG9jYXRvcn5NYXBMb2NhdG9yI3pvb21Mb2NhdGlvbn1cclxuICogQHB1YmxpY1xyXG4gKiBAY2FsbGJhY2sgbW9kdWxlOm55Yy9NYXBMb2NhdG9yfk1hcExvY2F0b3Ijem9vbUxvY2F0aW9uQ2FsbGJhY2tcclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBUaGUgZGVmYXVsdCB6b29tIGxldmVsIHdoZW4gem9vbWluZyB0byBsb2NhdGlvbnNcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG5cbk1hcExvY2F0b3IuWk9PTV9MRVZFTCA9IDE3O1xudmFyIF9kZWZhdWx0ID0gTWFwTG9jYXRvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7OztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7Ozs7QUFJQTs7Ozs7OztBQU1BOzs7Ozs7Ozs7O0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7QUFHQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///139\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Overlay = _interopRequireDefault(__webpack_require__(114));\n\nvar _ = _interopRequireDefault(__webpack_require__(40));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/FeatureTip\r\n */\n\n/**\r\n * @desc A class for providing tool tips on mouseover for vector features\r\n * @public\r\n * @class\r\n * @extends ol.Overlay\r\n * @see http://openlayers.org/en/latest/apidoc/module-ol_Overlay.html\r\n */\n\n\nvar FeatureTip =\n/*#__PURE__*/\nfunction (_Overlay$default) {\n  _inherits(FeatureTip, _Overlay$default);\n\n  /**\r\n   * @desc Create an instance of FeatureTip\r\n   * @public\r\n   * @constructor\r\n   * @param {module:nyc/ol/FeatureTip~FeatureTip.Options} options Constructor options\r\n   */\n  function FeatureTip(options) {\n    var _this;\n\n    _classCallCheck(this, FeatureTip);\n\n    var element = (0, _jquery["default"])(options.map.getTargetElement()).find(\'f-tip\').get(0);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FeatureTip).call(this, {\n      id: _["default"].nextId(\'FeatureTip\'),\n      element: element || (0, _jquery["default"])(FeatureTip.HTML).get(0),\n      stopEvent: false\n    }));\n\n    _this.setMap(options.map);\n\n    _this.map = _this.getMap();\n    _this.tip = (0, _jquery["default"])(_this.getElement());\n\n    _this.addTips(options.tips);\n\n    _this.map.on(\'pointermove\', _jquery["default"].proxy(_this.label, _assertThisInitialized(_this)));\n\n    (0, _jquery["default"])(document).mouseover(_jquery["default"].proxy(_this.out, _assertThisInitialized(_this)));\n    return _this;\n  }\n  /**\r\n   * @desc Hide the feature tip\r\n   * @public\r\n   * @method\r\n   */\n\n\n  _createClass(FeatureTip, [{\n    key: "hide",\n    value: function hide() {\n      this.tip.fadeOut();\n    }\n    /**\r\n     * @desc Adds tip definitions\r\n     * @public\r\n     * @method\r\n     * @param {Array<module:nyc/ol/FeatureTip~FeatureTip.TipDef>} tips The tip definitions to add\r\n     */\n\n  }, {\n    key: "addTips",\n    value: function addTips(tips) {\n      tips.forEach(function (def) {\n        def.layer.nycTip = def.label;\n      });\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object} event Event object\r\n     */\n\n  }, {\n    key: "out",\n    value: function out(event) {\n      if (!_jquery["default"].contains(this.map.getTargetElement(), event.target)) {\n        this.hide();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {ol.MapBrowserEvent} event OpenLayers map browser event\r\n     */\n\n  }, {\n    key: "label",\n    value: function label(event) {\n      var label = this.map.forEachFeatureAtPixel(event.pixel, function (feature, layer) {\n        return layer.getVisible() && layer.nycTip ? layer.nycTip(feature) : null;\n      });\n\n      if (label) {\n        this.tip.html(label.html);\n        this.tip.get(0).className = "f-tip ".concat(label.css || \'\');\n        this.setPosition(event.coordinate);\n        this.tip.show();\n        this.position();\n      } else {\n        this.hide();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "position",\n    value: function position() {\n      var size = this.map.getSize();\n      var position = this.map.getPixelFromCoordinate(this.getPosition());\n      var width = this.tip.width();\n      var height = this.tip.height();\n      var vert = position[1] + height > size[1] ? \'bottom\' : \'top\';\n      var horz = position[0] + width > size[0] ? \'right\' : \'left\';\n      this.setPositioning("".concat(vert, "-").concat(horz));\n    }\n  }]);\n\n  return FeatureTip;\n}(_Overlay["default"]);\n/**\r\n * @desc Object with configuration options for feature tips\r\n * @public\r\n * @typedef {Object}\r\n * @property {ol.layer.Vector} layer The layer whose features will have tips\r\n * @property {module:nyc/ol/FeatureTip~FeatureTip.LabelFunction} label A function to generate tips\r\n */\n\n\nFeatureTip.TipDef;\n/**\r\n * @desc Label function that returns a {@link module:nyc/ol/FeatureTip~FeatureTip.Label}\r\n * @public\r\n * @typedef {function(ol.Feature):module:nyc/ol/FeatureTip~FeatureTip.Label}\r\n */\n\nFeatureTip.LabelFunction;\n/**\r\n * @desc Object type to return from a feature\'s label function\r\n * @public\r\n * @typedef {Object}\r\n * @property {jQuery|Element|string} html The tip content\r\n * @property {string=} css A CSS class to apply to the tip\r\n */\n\nFeatureTip.Label;\n/**\r\n * @desc Constructor options for {@link module:nyc/ol/FeatureTip~FeatureTip}\r\n * @public\r\n * @typedef {Object}\r\n * @property {ol.Map} map The map\r\n * @property {Array<module:nyc/ol/FeatureTip~FeatureTip.TipDef>} tips The tip definitions\r\n */\n\nFeatureTip.Options;\n/**\r\n * @private\r\n * @const\r\n * @type {string}\r\n */\n\nFeatureTip.HTML = \'<div class="f-tip" role="tooltip"></div>\';\nvar _default = FeatureTip;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL0ZlYXR1cmVUaXAuanM/YzM0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qcXVlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXG52YXIgX092ZXJsYXkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJvbC9PdmVybGF5XCIpKTtcblxudmFyIF8gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLy4uXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL29sL0ZlYXR1cmVUaXBcclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBBIGNsYXNzIGZvciBwcm92aWRpbmcgdG9vbCB0aXBzIG9uIG1vdXNlb3ZlciBmb3IgdmVjdG9yIGZlYXR1cmVzXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIG9sLk92ZXJsYXlcclxuICogQHNlZSBodHRwOi8vb3BlbmxheWVycy5vcmcvZW4vbGF0ZXN0L2FwaWRvYy9tb2R1bGUtb2xfT3ZlcmxheS5odG1sXHJcbiAqL1xuY2xhc3MgRmVhdHVyZVRpcCBleHRlbmRzIF9PdmVybGF5LmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgRmVhdHVyZVRpcFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvb2wvRmVhdHVyZVRpcH5GZWF0dXJlVGlwLk9wdGlvbnN9IG9wdGlvbnMgQ29uc3RydWN0b3Igb3B0aW9uc1xyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgZWxlbWVudCA9ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKG9wdGlvbnMubWFwLmdldFRhcmdldEVsZW1lbnQoKSkuZmluZCgnZi10aXAnKS5nZXQoMCk7XG4gICAgc3VwZXIoe1xuICAgICAgaWQ6IF8uZGVmYXVsdC5uZXh0SWQoJ0ZlYXR1cmVUaXAnKSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQgfHwgKDAsIF9qcXVlcnkuZGVmYXVsdCkoRmVhdHVyZVRpcC5IVE1MKS5nZXQoMCksXG4gICAgICBzdG9wRXZlbnQ6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5zZXRNYXAob3B0aW9ucy5tYXApO1xuICAgIHRoaXMubWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICB0aGlzLnRpcCA9ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKHRoaXMuZ2V0RWxlbWVudCgpKTtcbiAgICB0aGlzLmFkZFRpcHMob3B0aW9ucy50aXBzKTtcbiAgICB0aGlzLm1hcC5vbigncG9pbnRlcm1vdmUnLCBfanF1ZXJ5LmRlZmF1bHQucHJveHkodGhpcy5sYWJlbCwgdGhpcykpO1xuICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGRvY3VtZW50KS5tb3VzZW92ZXIoX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMub3V0LCB0aGlzKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgSGlkZSB0aGUgZmVhdHVyZSB0aXBcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqL1xuXG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRpcC5mYWRlT3V0KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgQWRkcyB0aXAgZGVmaW5pdGlvbnNcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7QXJyYXk8bW9kdWxlOm55Yy9vbC9GZWF0dXJlVGlwfkZlYXR1cmVUaXAuVGlwRGVmPn0gdGlwcyBUaGUgdGlwIGRlZmluaXRpb25zIHRvIGFkZFxyXG4gICAqL1xuXG5cbiAgYWRkVGlwcyh0aXBzKSB7XG4gICAgdGlwcy5mb3JFYWNoKGRlZiA9PiB7XG4gICAgICBkZWYubGF5ZXIubnljVGlwID0gZGVmLmxhYmVsO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBFdmVudCBvYmplY3RcclxuICAgKi9cblxuXG4gIG91dChldmVudCkge1xuICAgIGlmICghX2pxdWVyeS5kZWZhdWx0LmNvbnRhaW5zKHRoaXMubWFwLmdldFRhcmdldEVsZW1lbnQoKSwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7b2wuTWFwQnJvd3NlckV2ZW50fSBldmVudCBPcGVuTGF5ZXJzIG1hcCBicm93c2VyIGV2ZW50XHJcbiAgICovXG5cblxuICBsYWJlbChldmVudCkge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5tYXAuZm9yRWFjaEZlYXR1cmVBdFBpeGVsKGV2ZW50LnBpeGVsLCAoZmVhdHVyZSwgbGF5ZXIpID0+IHtcbiAgICAgIHJldHVybiBsYXllci5nZXRWaXNpYmxlKCkgJiYgbGF5ZXIubnljVGlwID8gbGF5ZXIubnljVGlwKGZlYXR1cmUpIDogbnVsbDtcbiAgICB9KTtcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy50aXAuaHRtbChsYWJlbC5odG1sKTtcbiAgICAgIHRoaXMudGlwLmdldCgwKS5jbGFzc05hbWUgPSBgZi10aXAgJHtsYWJlbC5jc3MgfHwgJyd9YDtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24oZXZlbnQuY29vcmRpbmF0ZSk7XG4gICAgICB0aGlzLnRpcC5zaG93KCk7XG4gICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKi9cblxuXG4gIHBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLm1hcC5nZXRTaXplKCk7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm1hcC5nZXRQaXhlbEZyb21Db29yZGluYXRlKHRoaXMuZ2V0UG9zaXRpb24oKSk7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLnRpcC53aWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMudGlwLmhlaWdodCgpO1xuICAgIGNvbnN0IHZlcnQgPSBwb3NpdGlvblsxXSArIGhlaWdodCA+IHNpemVbMV0gPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIGNvbnN0IGhvcnogPSBwb3NpdGlvblswXSArIHdpZHRoID4gc2l6ZVswXSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgdGhpcy5zZXRQb3NpdGlvbmluZyhgJHt2ZXJ0fS0ke2hvcnp9YCk7XG4gIH1cblxufVxuLyoqXHJcbiAqIEBkZXNjIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgZmVhdHVyZSB0aXBzXHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtvbC5sYXllci5WZWN0b3J9IGxheWVyIFRoZSBsYXllciB3aG9zZSBmZWF0dXJlcyB3aWxsIGhhdmUgdGlwc1xyXG4gKiBAcHJvcGVydHkge21vZHVsZTpueWMvb2wvRmVhdHVyZVRpcH5GZWF0dXJlVGlwLkxhYmVsRnVuY3Rpb259IGxhYmVsIEEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGlwc1xyXG4gKi9cblxuXG5GZWF0dXJlVGlwLlRpcERlZjtcbi8qKlxyXG4gKiBAZGVzYyBMYWJlbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB7QGxpbmsgbW9kdWxlOm55Yy9vbC9GZWF0dXJlVGlwfkZlYXR1cmVUaXAuTGFiZWx9XHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge2Z1bmN0aW9uKG9sLkZlYXR1cmUpOm1vZHVsZTpueWMvb2wvRmVhdHVyZVRpcH5GZWF0dXJlVGlwLkxhYmVsfVxyXG4gKi9cblxuRmVhdHVyZVRpcC5MYWJlbEZ1bmN0aW9uO1xuLyoqXHJcbiAqIEBkZXNjIE9iamVjdCB0eXBlIHRvIHJldHVybiBmcm9tIGEgZmVhdHVyZSdzIGxhYmVsIGZ1bmN0aW9uXHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtqUXVlcnl8RWxlbWVudHxzdHJpbmd9IGh0bWwgVGhlIHRpcCBjb250ZW50XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gY3NzIEEgQ1NTIGNsYXNzIHRvIGFwcGx5IHRvIHRoZSB0aXBcclxuICovXG5cbkZlYXR1cmVUaXAuTGFiZWw7XG4vKipcclxuICogQGRlc2MgQ29uc3RydWN0b3Igb3B0aW9ucyBmb3Ige0BsaW5rIG1vZHVsZTpueWMvb2wvRmVhdHVyZVRpcH5GZWF0dXJlVGlwfVxyXG4gKiBAcHVibGljXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7b2wuTWFwfSBtYXAgVGhlIG1hcFxyXG4gKiBAcHJvcGVydHkge0FycmF5PG1vZHVsZTpueWMvb2wvRmVhdHVyZVRpcH5GZWF0dXJlVGlwLlRpcERlZj59IHRpcHMgVGhlIHRpcCBkZWZpbml0aW9uc1xyXG4gKi9cblxuRmVhdHVyZVRpcC5PcHRpb25zO1xuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxuRmVhdHVyZVRpcC5IVE1MID0gJzxkaXYgY2xhc3M9XCJmLXRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+PC9kaXY+JztcbnZhciBfZGVmYXVsdCA9IEZlYXR1cmVUaXA7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBSUE7Ozs7Ozs7OztBQU9BOzs7OztBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQVpBO0FBYUE7QUFDQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUE1RkE7QUErRkE7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///140\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Zoom = _interopRequireDefault(__webpack_require__(142));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/Zoom\r\n */\n\n/**\r\n * @desc Class for providing a set of buttons to zoom and search.\r\n * @public\r\n * @class\r\n * @extends {module:nyc/Zoom~Zoom}\r\n */\n\n\nvar Zoom =\n/*#__PURE__*/\nfunction (_Zoom$default) {\n  _inherits(Zoom, _Zoom$default);\n\n  /**\r\n   * @desc Create an instance of Zoom\r\n   * @constructor\r\n   * @param {ol.Map} map The OpenLayers map that will be controlled\r\n   */\n  function Zoom(map) {\n    var _this;\n\n    _classCallCheck(this, Zoom);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Zoom).call(this, (0, _jquery["default"])(map.getTargetElement()).find(\'.ol-overlaycontainer-stopevent\')));\n    /**\r\n     * @private\r\n     * @member {ol.Map}\r\n     */\n\n    _this.map = map;\n    /**\r\n     * @private\r\n     * @member {ol.View}\r\n     */\n\n    _this.view = map.getView();\n\n    _this.getContainer().on(\'click dblclick mouseover mousemove\', function () {\n      (0, _jquery["default"])(\'.f-tip\').hide();\n    });\n\n    return _this;\n  }\n  /**\r\n   * @desc Handle the zoom event triggered by user interaction\r\n   * @public\r\n   * @override\r\n   * @method\r\n   * @param {jQuery.Event} event The event triggered by the zoom buttons\r\n   */\n\n\n  _createClass(Zoom, [{\n    key: "zoom",\n    value: function zoom(event) {\n      this.view.animate({\n        zoom: this.view.getZoom() + (0, _jquery["default"])(event.currentTarget).data(\'zoom-incr\') * 1\n      });\n    }\n  }]);\n\n  return Zoom;\n}(_Zoom["default"]);\n\nvar _default = Zoom;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL1pvb20uanM/NGEzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qcXVlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXG52YXIgX1pvb20gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9ab29tXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL29sL1pvb21cclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBDbGFzcyBmb3IgcHJvdmlkaW5nIGEgc2V0IG9mIGJ1dHRvbnMgdG8gem9vbSBhbmQgc2VhcmNoLlxyXG4gKiBAcHVibGljXHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOm55Yy9ab29tflpvb219XHJcbiAqL1xuY2xhc3MgWm9vbSBleHRlbmRzIF9ab29tLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgWm9vbVxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7b2wuTWFwfSBtYXAgVGhlIE9wZW5MYXllcnMgbWFwIHRoYXQgd2lsbCBiZSBjb250cm9sbGVkXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgIHN1cGVyKCgwLCBfanF1ZXJ5LmRlZmF1bHQpKG1hcC5nZXRUYXJnZXRFbGVtZW50KCkpLmZpbmQoJy5vbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudCcpKTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtvbC5NYXB9XHJcbiAgICAgKi9cblxuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge29sLlZpZXd9XHJcbiAgICAgKi9cblxuICAgIHRoaXMudmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgdGhpcy5nZXRDb250YWluZXIoKS5vbignY2xpY2sgZGJsY2xpY2sgbW91c2VvdmVyIG1vdXNlbW92ZScsICgpID0+IHtcbiAgICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKCcuZi10aXAnKS5oaWRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgSGFuZGxlIHRoZSB6b29tIGV2ZW50IHRyaWdnZXJlZCBieSB1c2VyIGludGVyYWN0aW9uXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRyaWdnZXJlZCBieSB0aGUgem9vbSBidXR0b25zXHJcbiAgICovXG5cblxuICB6b29tKGV2ZW50KSB7XG4gICAgdGhpcy52aWV3LmFuaW1hdGUoe1xuICAgICAgem9vbTogdGhpcy52aWV3LmdldFpvb20oKSArICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoJ3pvb20taW5jcicpICogMVxuICAgIH0pO1xuICB9XG5cbn1cblxudmFyIF9kZWZhdWx0ID0gWm9vbTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUlBOzs7Ozs7OztBQU1BOzs7OztBQUNBOzs7OztBQUtBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBakJBO0FBaUJBO0FBQ0E7Ozs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7OztBQXJDQTtBQUNBO0FBd0NBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///141\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Container = _interopRequireDefault(__webpack_require__(69));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/Zoom\r\n */\n\n/**\r\n * @desc Abstract class for zoom and search controls\r\n * @public\r\n * @abstract\r\n * @class\r\n * @extends module:nyc/Container~Container\r\n * @fires module:nyc/Zoom~Zoom#geolocate\r\n */\n\n\nvar Zoom =\n/*#__PURE__*/\nfunction (_Container$default) {\n  _inherits(Zoom, _Container$default);\n\n  /**\r\n   * @desc  Create an instance of Zoom\r\n   * @access protected\r\n   * @constructor\r\n   * @param {jQuery|Element|string} target The target\r\n   */\n  function Zoom(target) {\n    var _this;\n\n    _classCallCheck(this, Zoom);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Zoom).call(this, (0, _jquery["default"])(Zoom.HTML)));\n    (0, _jquery["default"])(target).append(_this.getContainer());\n\n    _this.find(\'.btn-z-in, .btn-z-out\').click(_jquery["default"].proxy(_this.zoom, _assertThisInitialized(_this)));\n\n    return _this;\n  }\n  /**\r\n   * @desc Handle the zoom event triggered by user interaction\r\n   * @public\r\n   * @abstract\r\n   * @method\r\n   * @param {jQuery.Event} event The event triggered by the zoom buttons\r\n   */\n\n\n  _createClass(Zoom, [{\n    key: "zoom",\n    value: function zoom(event) {\n      throw \'Not implemented\';\n    }\n  }]);\n\n  return Zoom;\n}(_Container["default"]);\n/**\r\n * @desc The user has requested their geolocation\r\n * @event module:nyc/Zoom~Zoom#geolocate\r\n */\n\n/**\r\n * @private\r\n * @const\r\n * @type {string}\r\n */\n\n\nZoom.HTML = \'<div class="zoom">\' + \'<button class="btn-z-in btn-sq rad-all" data-zoom-incr="1" title="Zoom in">\' + \'<span class="screen-reader-only">Zoom in</span>\' + \'<span class="fas fa-plus" role="img"></span>\' + \'</button>\' + \'<button class="btn-z-out btn-sq rad-all" data-zoom-incr="-1" title="Zoom out">\' + \'<span class="screen-reader-only">Zoom out</span>\' + \'<span class="fas fa-minus" role="img"></span>\' + \'</button>\' + \'</div>\';\nvar _default = Zoom;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL1pvb20uanM/MTY0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9qcXVlcnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXG52YXIgX0NvbnRhaW5lciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vQ29udGFpbmVyXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL1pvb21cclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBBYnN0cmFjdCBjbGFzcyBmb3Igem9vbSBhbmQgc2VhcmNoIGNvbnRyb2xzXHJcbiAqIEBwdWJsaWNcclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBtb2R1bGU6bnljL0NvbnRhaW5lcn5Db250YWluZXJcclxuICogQGZpcmVzIG1vZHVsZTpueWMvWm9vbX5ab29tI2dlb2xvY2F0ZVxyXG4gKi9cbmNsYXNzIFpvb20gZXh0ZW5kcyBfQ29udGFpbmVyLmRlZmF1bHQge1xuICAvKipcclxuICAgKiBAZGVzYyAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFpvb21cclxuICAgKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGhlIHRhcmdldFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICBzdXBlcigoMCwgX2pxdWVyeS5kZWZhdWx0KShab29tLkhUTUwpKTtcbiAgICAoMCwgX2pxdWVyeS5kZWZhdWx0KSh0YXJnZXQpLmFwcGVuZCh0aGlzLmdldENvbnRhaW5lcigpKTtcbiAgICB0aGlzLmZpbmQoJy5idG4tei1pbiwgLmJ0bi16LW91dCcpLmNsaWNrKF9qcXVlcnkuZGVmYXVsdC5wcm94eSh0aGlzLnpvb20sIHRoaXMpKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBIYW5kbGUgdGhlIHpvb20gZXZlbnQgdHJpZ2dlcmVkIGJ5IHVzZXIgaW50ZXJhY3Rpb25cclxuICAgKiBAcHVibGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBldmVudCBUaGUgZXZlbnQgdHJpZ2dlcmVkIGJ5IHRoZSB6b29tIGJ1dHRvbnNcclxuICAgKi9cblxuXG4gIHpvb20oZXZlbnQpIHtcbiAgICB0aHJvdyAnTm90IGltcGxlbWVudGVkJztcbiAgfVxuXG59XG4vKipcclxuICogQGRlc2MgVGhlIHVzZXIgaGFzIHJlcXVlc3RlZCB0aGVpciBnZW9sb2NhdGlvblxyXG4gKiBAZXZlbnQgbW9kdWxlOm55Yy9ab29tflpvb20jZ2VvbG9jYXRlXHJcbiAqL1xuXG4vKipcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG5cblpvb20uSFRNTCA9ICc8ZGl2IGNsYXNzPVwiem9vbVwiPicgKyAnPGJ1dHRvbiBjbGFzcz1cImJ0bi16LWluIGJ0bi1zcSByYWQtYWxsXCIgZGF0YS16b29tLWluY3I9XCIxXCIgdGl0bGU9XCJab29tIGluXCI+JyArICc8c3BhbiBjbGFzcz1cInNjcmVlbi1yZWFkZXItb25seVwiPlpvb20gaW48L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cImZhcyBmYS1wbHVzXCIgcm9sZT1cImltZ1wiPjwvc3Bhbj4nICsgJzwvYnV0dG9uPicgKyAnPGJ1dHRvbiBjbGFzcz1cImJ0bi16LW91dCBidG4tc3EgcmFkLWFsbFwiIGRhdGEtem9vbS1pbmNyPVwiLTFcIiB0aXRsZT1cIlpvb20gb3V0XCI+JyArICc8c3BhbiBjbGFzcz1cInNjcmVlbi1yZWFkZXItb25seVwiPlpvb20gb3V0PC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJmYXMgZmEtbWludXNcIiByb2xlPVwiaW1nXCI+PC9zcGFuPicgKyAnPC9idXR0b24+JyArICc8L2Rpdj4nO1xudmFyIF9kZWZhdWx0ID0gWm9vbTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUlBOzs7Ozs7Ozs7O0FBUUE7Ozs7O0FBQ0E7Ozs7OztBQU1BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBSkE7QUFJQTtBQUNBOzs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7OztBQXZCQTtBQTBCQTs7Ozs7QUFLQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///142\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Geolocate = _interopRequireDefault(__webpack_require__(144));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/Geolocate\r\n */\n\n/**\r\n * @desc Class for providing a set of buttons to zoom and search.\r\n * @public\r\n * @class\r\n * @extends {module:nyc/Geolocate~Geolocate}\r\n * @fires module:nyc/Geolocate~Geolocate#geolocate\r\n */\n\n\nvar Geolocate =\n/*#__PURE__*/\nfunction (_Geolocate$default) {\n  _inherits(Geolocate, _Geolocate$default);\n\n  /**\r\n   * @desc Create an instance of Geolocate\r\n   * @constructor\r\n   * @param {ol.Map} map The OpenLayers map that will be controlled\r\n   */\n  function Geolocate(map) {\n    var _this;\n\n    _classCallCheck(this, Geolocate);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Geolocate).call(this, (0, _jquery["default"])(map.getTargetElement()).find(\'.ol-overlaycontainer-stopevent\')));\n\n    _this.getContainer().on(\'click dblclick mouseover mousemove\', function () {\n      (0, _jquery["default"])(\'.f-tip\').hide();\n    });\n\n    return _this;\n  }\n\n  return Geolocate;\n}(_Geolocate["default"]);\n\nvar _default = Geolocate;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL0dlb2xvY2F0ZS5qcz84MjE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbnZhciBfR2VvbG9jYXRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vR2VvbG9jYXRlXCIpKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXHJcbiAqIEBtb2R1bGUgbnljL29sL0dlb2xvY2F0ZVxyXG4gKi9cblxuLyoqXHJcbiAqIEBkZXNjIENsYXNzIGZvciBwcm92aWRpbmcgYSBzZXQgb2YgYnV0dG9ucyB0byB6b29tIGFuZCBzZWFyY2guXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqIEBleHRlbmRzIHttb2R1bGU6bnljL0dlb2xvY2F0ZX5HZW9sb2NhdGV9XHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0dlb2xvY2F0ZX5HZW9sb2NhdGUjZ2VvbG9jYXRlXHJcbiAqL1xuY2xhc3MgR2VvbG9jYXRlIGV4dGVuZHMgX0dlb2xvY2F0ZS5kZWZhdWx0IHtcbiAgLyoqXHJcbiAgICogQGRlc2MgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEdlb2xvY2F0ZVxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7b2wuTWFwfSBtYXAgVGhlIE9wZW5MYXllcnMgbWFwIHRoYXQgd2lsbCBiZSBjb250cm9sbGVkXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgIHN1cGVyKCgwLCBfanF1ZXJ5LmRlZmF1bHQpKG1hcC5nZXRUYXJnZXRFbGVtZW50KCkpLmZpbmQoJy5vbC1vdmVybGF5Y29udGFpbmVyLXN0b3BldmVudCcpKTtcbiAgICB0aGlzLmdldENvbnRhaW5lcigpLm9uKCdjbGljayBkYmxjbGljayBtb3VzZW92ZXIgbW91c2Vtb3ZlJywgKCkgPT4ge1xuICAgICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoJy5mLXRpcCcpLmhpZGUoKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbnZhciBfZGVmYXVsdCA9IEdlb2xvY2F0ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7O0FBSUE7Ozs7Ozs7OztBQU9BOzs7OztBQUNBOzs7OztBQUtBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUtBO0FBQ0E7O0FBWkE7QUFDQTtBQWNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///143\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Container = _interopRequireDefault(__webpack_require__(69));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/Geolocate\r\n */\n\n/**\r\n * @desc Abstract class for zoom and search controls\r\n * @public\r\n * @abstract\r\n * @class\r\n * @extends module:nyc/Container~Container\r\n * @fires module:nyc/Geolocate~Geolocate#geolocate\r\n */\n\n\nvar Geolocate =\n/*#__PURE__*/\nfunction (_Container$default) {\n  _inherits(Geolocate, _Container$default);\n\n  /**\r\n   * @desc  Create an instance of Geolocate\r\n   * @access protected\r\n   * @constructor\r\n   * @param {jQuery|Element|string} target The target\r\n   */\n  function Geolocate(target) {\n    var _this;\n\n    _classCallCheck(this, Geolocate);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Geolocate).call(this, (0, _jquery["default"])(Geolocate.HTML)));\n    (0, _jquery["default"])(target).append(_this.getContainer());\n\n    _this.find(\'.btn-geo\').click(_jquery["default"].proxy(_this.geolocate, _assertThisInitialized(_this)));\n\n    return _this;\n  }\n  /**\r\n   * @desc Trigger the geolocate event requeted by user interaction\r\n   * @public\r\n   * @method\r\n   */\n\n\n  _createClass(Geolocate, [{\n    key: "geolocate",\n    value: function geolocate() {\n      this.trigger(\'geolocate\');\n    }\n  }]);\n\n  return Geolocate;\n}(_Container["default"]);\n/**\r\n * @desc The user has requested their geolocation\r\n * @event module:nyc/Geolocate~Geolocate#geolocate\r\n */\n\n/**\r\n * @private\r\n * @const\r\n * @type {string}\r\n */\n\n\nGeolocate.HTML = \'<div class="geoloc">\' + \'<button class="btn-geo btn-sq rad-all" title="Current location">\' + \'<span class="screen-reader-only">Current location</span>\' + \'<span class="fas fa-crosshairs" role="img"></span>\' + \'</button>\' + \'</div>\';\nvar _default = Geolocate;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0dlb2xvY2F0ZS5qcz8yM2I2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbnZhciBfQ29udGFpbmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9Db250YWluZXJcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogQG1vZHVsZSBueWMvR2VvbG9jYXRlXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQWJzdHJhY3QgY2xhc3MgZm9yIHpvb20gYW5kIHNlYXJjaCBjb250cm9sc1xyXG4gKiBAcHVibGljXHJcbiAqIEBhYnN0cmFjdFxyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMgbW9kdWxlOm55Yy9Db250YWluZXJ+Q29udGFpbmVyXHJcbiAqIEBmaXJlcyBtb2R1bGU6bnljL0dlb2xvY2F0ZX5HZW9sb2NhdGUjZ2VvbG9jYXRlXHJcbiAqL1xuY2xhc3MgR2VvbG9jYXRlIGV4dGVuZHMgX0NvbnRhaW5lci5kZWZhdWx0IHtcbiAgLyoqXHJcbiAgICogQGRlc2MgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBHZW9sb2NhdGVcclxuICAgKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGhlIHRhcmdldFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICBzdXBlcigoMCwgX2pxdWVyeS5kZWZhdWx0KShHZW9sb2NhdGUuSFRNTCkpO1xuICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKHRhcmdldCkuYXBwZW5kKHRoaXMuZ2V0Q29udGFpbmVyKCkpO1xuICAgIHRoaXMuZmluZCgnLmJ0bi1nZW8nKS5jbGljayhfanF1ZXJ5LmRlZmF1bHQucHJveHkodGhpcy5nZW9sb2NhdGUsIHRoaXMpKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyBUcmlnZ2VyIHRoZSBnZW9sb2NhdGUgZXZlbnQgcmVxdWV0ZWQgYnkgdXNlciBpbnRlcmFjdGlvblxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICovXG5cblxuICBnZW9sb2NhdGUoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdnZW9sb2NhdGUnKTtcbiAgfVxuXG59XG4vKipcclxuICogQGRlc2MgVGhlIHVzZXIgaGFzIHJlcXVlc3RlZCB0aGVpciBnZW9sb2NhdGlvblxyXG4gKiBAZXZlbnQgbW9kdWxlOm55Yy9HZW9sb2NhdGV+R2VvbG9jYXRlI2dlb2xvY2F0ZVxyXG4gKi9cblxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBjb25zdFxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxuXG5HZW9sb2NhdGUuSFRNTCA9ICc8ZGl2IGNsYXNzPVwiZ2VvbG9jXCI+JyArICc8YnV0dG9uIGNsYXNzPVwiYnRuLWdlbyBidG4tc3EgcmFkLWFsbFwiIHRpdGxlPVwiQ3VycmVudCBsb2NhdGlvblwiPicgKyAnPHNwYW4gY2xhc3M9XCJzY3JlZW4tcmVhZGVyLW9ubHlcIj5DdXJyZW50IGxvY2F0aW9uPC9zcGFuPicgKyAnPHNwYW4gY2xhc3M9XCJmYXMgZmEtY3Jvc3NoYWlyc1wiIHJvbGU9XCJpbWdcIj48L3NwYW4+JyArICc8L2J1dHRvbj4nICsgJzwvZGl2Pic7XG52YXIgX2RlZmF1bHQgPSBHZW9sb2NhdGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7OztBQVFBOzs7OztBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUpBO0FBSUE7QUFDQTs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7O0FBckJBO0FBd0JBOzs7OztBQUtBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///144\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _GeoJSON = _interopRequireDefault(__webpack_require__(77));\n\nvar _extent = __webpack_require__(0);\n\nvar _Search = _interopRequireDefault(__webpack_require__(146));\n\nvar _Locator = _interopRequireDefault(__webpack_require__(103));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/ol/Search\r\n */\n\n/**\r\n * @desc Class for providing a set of buttons to zoom and search.\r\n * @public\r\n * @class\r\n * @extends {module:nyc/Search~Search}\r\n * @fires module:nyc/Search~Search#search\r\n * @fires module:nyc/Search~Search#disambiguated\r\n */\n\n\nvar Search =\n/*#__PURE__*/\nfunction (_Search$default) {\n  _inherits(Search, _Search$default);\n\n  /**\r\n   * @desc Create an instance of Search\r\n   * @constructor\r\n   * @param {jQuery|Element|string} target The target\r\n   */\n  function Search(target) {\n    var _this;\n\n    _classCallCheck(this, Search);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Search).call(this, target));\n    /**\r\n     * @private\r\n     * @member {ol.format.GeoJSON}\r\n     */\n\n    _this.geoJson = new _GeoJSON["default"]();\n\n    _this.getContainer().on(\'click dblclick mouseover mousemove\', function () {\n      (0, _jquery["default"])(\'.f-tip\').hide();\n    });\n\n    return _this;\n  }\n  /**\r\n   * @public\r\n   * @override\r\n   * @method\r\n   * @param {ol.Feature} feature The feature object\r\n   * @param {module:nyc/Search~Search.FeatureSearchOptions} options Describes how to convert feature\r\n   * @return {module:nyc/Locator~Locator.Result} The location\r\n   */\n\n\n  _createClass(Search, [{\n    key: "featureAsLocation",\n    value: function featureAsLocation(feature, options) {\n      var geom = feature.getGeometry();\n      var location = {\n        name: options.nameField ? feature.get(options.nameField) : feature.getName(),\n        data: feature.getProperties(),\n        type: \'geocoded\',\n        accuracy: _Locator["default"].Accuracy.HIGH\n      };\n\n      if (geom) {\n        location.coordinate = (0, _extent.getCenter)(geom.getExtent());\n        location.geometry = JSON.parse(this.geoJson.writeGeometry(geom));\n      }\n\n      return location;\n    }\n  }]);\n\n  return Search;\n}(_Search["default"]);\n\nvar _default = Search;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL29sL1NlYXJjaC5qcz9iZWJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbnZhciBfR2VvSlNPTiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIm9sL2Zvcm1hdC9HZW9KU09OXCIpKTtcblxudmFyIF9leHRlbnQgPSByZXF1aXJlKFwib2wvZXh0ZW50XCIpO1xuXG52YXIgX1NlYXJjaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL1NlYXJjaFwiKSk7XG5cbnZhciBfTG9jYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL0xvY2F0b3JcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcclxuICogQG1vZHVsZSBueWMvb2wvU2VhcmNoXHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgQ2xhc3MgZm9yIHByb3ZpZGluZyBhIHNldCBvZiBidXR0b25zIHRvIHpvb20gYW5kIHNlYXJjaC5cclxuICogQHB1YmxpY1xyXG4gKiBAY2xhc3NcclxuICogQGV4dGVuZHMge21vZHVsZTpueWMvU2VhcmNoflNlYXJjaH1cclxuICogQGZpcmVzIG1vZHVsZTpueWMvU2VhcmNoflNlYXJjaCNzZWFyY2hcclxuICogQGZpcmVzIG1vZHVsZTpueWMvU2VhcmNoflNlYXJjaCNkaXNhbWJpZ3VhdGVkXHJcbiAqL1xuY2xhc3MgU2VhcmNoIGV4dGVuZHMgX1NlYXJjaC5kZWZhdWx0IHtcbiAgLyoqXHJcbiAgICogQGRlc2MgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFNlYXJjaFxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGhlIHRhcmdldFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICBzdXBlcih0YXJnZXQpO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge29sLmZvcm1hdC5HZW9KU09OfVxyXG4gICAgICovXG5cbiAgICB0aGlzLmdlb0pzb24gPSBuZXcgX0dlb0pTT04uZGVmYXVsdCgpO1xuICAgIHRoaXMuZ2V0Q29udGFpbmVyKCkub24oJ2NsaWNrIGRibGNsaWNrIG1vdXNlb3ZlciBtb3VzZW1vdmUnLCAoKSA9PiB7XG4gICAgICAoMCwgX2pxdWVyeS5kZWZhdWx0KSgnLmYtdGlwJykuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtvbC5GZWF0dXJlfSBmZWF0dXJlIFRoZSBmZWF0dXJlIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9TZWFyY2h+U2VhcmNoLkZlYXR1cmVTZWFyY2hPcHRpb25zfSBvcHRpb25zIERlc2NyaWJlcyBob3cgdG8gY29udmVydCBmZWF0dXJlXHJcbiAgICogQHJldHVybiB7bW9kdWxlOm55Yy9Mb2NhdG9yfkxvY2F0b3IuUmVzdWx0fSBUaGUgbG9jYXRpb25cclxuICAgKi9cblxuXG4gIGZlYXR1cmVBc0xvY2F0aW9uKGZlYXR1cmUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBnZW9tID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpO1xuICAgIGNvbnN0IGxvY2F0aW9uID0ge1xuICAgICAgbmFtZTogb3B0aW9ucy5uYW1lRmllbGQgPyBmZWF0dXJlLmdldChvcHRpb25zLm5hbWVGaWVsZCkgOiBmZWF0dXJlLmdldE5hbWUoKSxcbiAgICAgIGRhdGE6IGZlYXR1cmUuZ2V0UHJvcGVydGllcygpLFxuICAgICAgdHlwZTogJ2dlb2NvZGVkJyxcbiAgICAgIGFjY3VyYWN5OiBfTG9jYXRvci5kZWZhdWx0LkFjY3VyYWN5LkhJR0hcbiAgICB9O1xuXG4gICAgaWYgKGdlb20pIHtcbiAgICAgIGxvY2F0aW9uLmNvb3JkaW5hdGUgPSAoMCwgX2V4dGVudC5nZXRDZW50ZXIpKGdlb20uZ2V0RXh0ZW50KCkpO1xuICAgICAgbG9jYXRpb24uZ2VvbWV0cnkgPSBKU09OLnBhcnNlKHRoaXMuZ2VvSnNvbi53cml0ZUdlb21ldHJ5KGdlb20pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cblxufVxuXG52YXIgX2RlZmF1bHQgPSBTZWFyY2g7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7OztBQVFBOzs7OztBQUNBOzs7OztBQUtBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBV0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUEzQ0E7QUFDQTtBQThDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///145\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nvar _Container = _interopRequireDefault(__webpack_require__(69));\n\nvar _AutoComplete = _interopRequireDefault(__webpack_require__(147));\n\nvar _Dialog = _interopRequireDefault(__webpack_require__(113));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/Search\r\n */\n\n/**\r\n * @desc Abstract class for zoom and search controls\r\n * @public\r\n * @abstract\r\n * @class\r\n * @extends module:nyc/Container~Container\r\n * @fires module:nyc/Search~Search#search\r\n * @fires module:nyc/Search~Search#disambiguated\r\n */\n\n\nvar Search =\n/*#__PURE__*/\nfunction (_Container$default) {\n  _inherits(Search, _Container$default);\n\n  /**\r\n   * @desc  Create an instance of Search\r\n   * @access protected\r\n   * @constructor\r\n   * @param {jQuery|Element|string} target The target\r\n   */\n  function Search(target) {\n    var _this;\n\n    _classCallCheck(this, Search);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Search).call(this, (0, _jquery["default"])(Search.HTML)));\n    var input;\n    target = (0, _jquery["default"])(target).get(0);\n\n    if (target.tagName === \'INPUT\') {\n      input = target;\n      target = (0, _jquery["default"])(\'<div class="map-srch"></div>\');\n      target.insertAfter(input);\n\n      _this.find(\'.srch\').addClass(\'input-group\');\n    }\n\n    (0, _jquery["default"])(target).append(_this.getContainer());\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.input = _this.find(\'input\');\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.clear = _this.find(\'.btn-x\');\n\n    if (input) {\n      _this.input.attr(\'id\', (0, _jquery["default"])(input).attr(\'id\')).attr(\'placeholder\', (0, _jquery["default"])(input).attr(\'placeholder\')).addClass((0, _jquery["default"])(input).attr(\'class\'));\n\n      (0, _jquery["default"])(input).remove();\n\n      _this.clear.remove();\n    }\n    /**\r\n     * @private\r\n     * @member {boolean}\r\n     */\n\n\n    _this.isAddrSrch = true;\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.list = _this.find(\'ul.rad-all\');\n    /**\r\n     * @private\r\n     * @member {jQuery}\r\n     */\n\n    _this.retention = _this.find(\'ul.retention\');\n    /**\r\n     * @private\r\n     * @member {AutoComplete}\r\n     */\n\n    _this.autoComplete = null;\n\n    _this.hookupEvents(_this.input);\n\n    return _this;\n  }\n  /**\r\n   * @public\r\n   * @abstract\r\n   * @method\r\n   * @param {Object} feature The feature object\r\n   * @param {module:nyc/Search~Search.FeatureSearchOptions} options Describes how to convert feature\r\n   * @return {module:nyc/Locator~Locator.Result} The location\r\n   */\n\n\n  _createClass(Search, [{\n    key: "featureAsLocation",\n    value: function featureAsLocation(feature, options) {\n      throw \'Not implemented\';\n    }\n    /**\r\n     * @desc Set or get the value of the search field\r\n     * @public\r\n     * @method\r\n     * @param {string=} val The value for the search field\r\n     * @return {string} The value of the search field\r\n     */\n\n  }, {\n    key: "val",\n    value: function val(_val) {\n      if (typeof _val === \'string\') {\n        this.input.val(_val);\n        this.clearBtn();\n      }\n\n      return this.input.val();\n    }\n    /**\r\n     * @desc Displays possible address matches\r\n     * @public\r\n     * @method\r\n     * @param {module:nyc/Locator~Locator.Ambiguous} ambiguous Possible locations resulting from a geocoder search to display to the user\r\n     */\n\n  }, {\n    key: "disambiguate",\n    value: function disambiguate(ambiguous) {\n      var _this2 = this;\n\n      var possible = ambiguous.possible;\n\n      if (possible.length) {\n        var list = this.list;\n        this.emptyList();\n        possible.forEach(function (locateResult) {\n          list.append(_this2.listItem({\n            layerName: \'addr\'\n          }, locateResult));\n        });\n        this.showList(true);\n      }\n    }\n    /**\r\n     * @desc Add searchable features\r\n     * @public\r\n     * @method\r\n     * @param {module:nyc/Search~Search.FeatureSearchOptions} options The options for creating a feature search\r\n     */\n\n  }, {\n    key: "setFeatures",\n    value: function setFeatures(options) {\n      var _this3 = this;\n\n      this.autoComplete = this.autoComplete || new _AutoComplete["default"]();\n      options.nameField = options.nameField || \'name\';\n      options.displayField = options.displayField || options.nameField;\n\n      if (options.placeholder) {\n        this.input.attr(\'placeholder\', options.placeholder);\n      }\n\n      this.sortAlphapetically(options).forEach(function (feature) {\n        var location = _this3.featureAsLocation(feature, options);\n\n        var li = _this3.listItem(options, location);\n\n        _this3.retention.append(li);\n      });\n      this.emptyList();\n    }\n    /**\r\n     * @desc Remove searchable features\r\n     * @public\r\n     * @method\r\n     * @param {string} featureTypeName The featureTypeName used when the features were set\r\n     */\n\n  }, {\n    key: "removeFeatures",\n    value: function removeFeatures(featureTypeName) {\n      this.find(\'li.\' + featureTypeName).remove();\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {module:nyc/Search~Search.FeatureSearchOptions} options Options\r\n     * @return {Array<Object>} features\r\n     */\n\n  }, {\n    key: "sortAlphapetically",\n    value: function sortAlphapetically(options) {\n      var features = [];\n      options.features.forEach(function (feature) {\n        if (feature.get) {\n          features.push(_jquery["default"].extend({}, feature));\n        } else {\n          features.push(_jquery["default"].extend({\n            get: function get(prop) {\n              return this.properties[prop];\n            }\n          }, feature));\n        }\n      });\n      features.sort(function (a, b) {\n        var nameField = options.nameField;\n\n        if (a.get(nameField) < b.get(nameField)) {\n          return -1;\n        }\n\n        if (a.get(nameField) > b.get(nameField)) {\n          return 1;\n        }\n\n        return 0;\n      });\n      return features;\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {module:nyc/Search~Search.FeatureSearchOptions} options Options\r\n     * @param {module:nyc/Locator~Locator.Result} data Location data\r\n     * @return {jQuery} list item\r\n     */\n\n  }, {\n    key: "listItem",\n    value: function listItem(options, data) {\n      var li = (0, _jquery["default"])(\'<li></li>\');\n      var displayField = options.displayField;\n      var name = "".concat(data.data[displayField] || data.name);\n      li.addClass(options.layerName);\n\n      if (options.layerName !== \'addr\') {\n        li.addClass(\'feature\');\n      }\n\n      return li.addClass(\'notranslate\').attr({\n        translate: \'no\',\n        \'data-id\': encodeURIComponent(name)\n      }).html("<a href=\\"#\\">".concat(name, "</a>")).data(\'nameField\', options.nameField).data(\'displayField\', displayField).data(\'location\', data).click(_jquery["default"].proxy(this.disambiguated, this)).keyup(_jquery["default"].proxy(this.disambiguated, this));\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "emptyList",\n    value: function emptyList() {\n      var retention = this.retention;\n      this.find(\'li\').each(function (i, item) {\n        if (retention.find("li[data-id=\\"".concat((0, _jquery["default"])(item).attr(\'data-id\'), "\\"]")).length === 0) {\n          retention.append(item);\n        }\n      });\n      this.list.empty();\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: "disambiguated",\n    value: function disambiguated(event) {\n      var li = (0, _jquery["default"])(event.currentTarget);\n      var data = li.data(\'location\');\n\n      if (data) {\n        this.val(data.name);\n        data.isFeature = li.hasClass(\'feature\');\n        this.trigger(\'disambiguated\', data);\n        li.parent().slideUp();\n        this.emptyList();\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: "listClick",\n    value: function listClick(event) {\n      event = event.originalEvent || event;\n\n      if (this.list.css(\'display\') === \'block\') {\n        var target = (0, _jquery["default"])(event.target);\n\n        if (_jquery["default"].contains(this.list.get(0), target.get(0))) {\n          if (this.autoComplete) {\n            target.trigger(\'click\');\n          }\n        } else if (this.getContainer().css(\'display\') === \'block\') {\n          this.list.slideUp();\n        }\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery} input Input element\r\n     */\n\n  }, {\n    key: "hookupEvents",\n    value: function hookupEvents(input) {\n      input.on(\'keyup change\', _jquery["default"].proxy(this.key, this));\n      input.focus(function () {\n        return input.select();\n      });\n      this.clear.click(_jquery["default"].proxy(this.clearTxt, this));\n      (0, _jquery["default"])(document).mouseup(_jquery["default"].proxy(this.listClick, this));\n      this.find(\'.btn-srch\').click(_jquery["default"].proxy(this.triggerSearch, this));\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {jQuery.Event} event Event object\r\n     */\n\n  }, {\n    key: "key",\n    value: function key(event) {\n      if (event.keyCode === 13 && this.isAddrSrch) {\n        this.triggerSearch();\n        this.list.slideUp();\n      } else {\n        this.filterList();\n      }\n\n      this.clearBtn();\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "clearTxt",\n    value: function clearTxt() {\n      this.val(\'\');\n      this.clearBtn();\n      this.input.focus();\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "clearBtn",\n    value: function clearBtn() {\n      this.clear[this.val() ? \'show\' : \'hide\']();\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "filterList",\n    value: function filterList() {\n      var typed = this.val().trim();\n\n      if (this.autoComplete && typed) {\n        this.autoComplete.filter(this.retention, this.list, typed);\n      } else {\n        this.emptyList();\n      }\n\n      this.showList(false);\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {boolean} focus Should we focus?\r\n     */\n\n  }, {\n    key: "showList",\n    value: function showList(focus) {\n      var _this4 = this;\n\n      if (this.getContainer().css(\'display\') === \'block\') {\n        this.list.slideDown(function () {\n          if (focus) {\n            _this4.list.children().first().find(\'a\').attr(\'tabindex\', 0).focus();\n          }\n        });\n      } else {\n        var msg = (0, _jquery["default"])(\'<div><strong>Possible matches:</strong></div>\');\n        msg.append(this.list);\n        this.dialog = this.dialog || new _Dialog["default"]({\n          target: (0, _jquery["default"])(\'.nyc-map\'),\n          css: \'posbl\'\n        });\n        this.list.one(\'click\', _jquery["default"].proxy(this.dialog.hide, this.dialog));\n        this.dialog.ok({\n          buttonText: [\'Cancel\'],\n          message: msg\n        });\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     */\n\n  }, {\n    key: "triggerSearch",\n    value: function triggerSearch() {\n      var input = this.val().trim();\n\n      if (input.length) {\n        this.input.blur();\n        this.trigger(\'search\', input);\n      }\n    }\n  }]);\n\n  return Search;\n}(_Container["default"]);\n/**\r\n * @desc Object type to hold data about how to search features\r\n * @public\r\n * @typedef {Object}\r\n * @property {Array<Object|ol.Feature>} features The features to be searched\r\n * @property {string} layerName The name of the layer or feature type the features are from\r\n * @property {string} [nameField="name"] The name attribute field of the feature\r\n * @property {string=} displayField The name attribute field of the feature\r\n * @property {string=} placeholder A placeholder for the search field\r\n */\n\n\nSearch.FeatureSearchOptions;\n/**\r\n * @desc The user has requested a search based on their text input\r\n * @event module:nyc/Search~Search#search\r\n * @type {string}\r\n */\n\n/**\r\n * @desc The user has chosen a location from a list of possible locations\r\n * @event module:nyc/Search~Search#disambiguated\r\n * @type {module:nyc/Locate~Locate.Result}\r\n */\n\n/**\r\n * @private\r\n * @const\r\n * @type {string}\r\n */\n\nSearch.HTML = \'<div class="srch-ctl">\' + \'<div class="srch" role="search">\' + \'<input class="rad-all" type="text" placeholder="Search for an address...">\' + \'<button class="btn btn-rnd btn-x">\' + \'<span class="screen-reader-only">Clear</span>\' + \'<span class="fas fa-times" role="img"></span>\' + \'</button>\' + \'<button class="btn btn-srch btn-primary btn-lg">Search</button>\' + \'</div>\' + \'<ul class="rad-all" role="region" label="Possible matches for your search"></ul>\' + \'<ul class="retention"></ul>\' + \'</div>\';\nvar _default = Search;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL1NlYXJjaC5qcz9jYjE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbnZhciBfQ29udGFpbmVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9Db250YWluZXJcIikpO1xuXG52YXIgX0F1dG9Db21wbGV0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vQXV0b0NvbXBsZXRlXCIpKTtcblxudmFyIF9EaWFsb2cgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL0RpYWxvZ1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9TZWFyY2hcclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBBYnN0cmFjdCBjbGFzcyBmb3Igem9vbSBhbmQgc2VhcmNoIGNvbnRyb2xzXHJcbiAqIEBwdWJsaWNcclxuICogQGFic3RyYWN0XHJcbiAqIEBjbGFzc1xyXG4gKiBAZXh0ZW5kcyBtb2R1bGU6bnljL0NvbnRhaW5lcn5Db250YWluZXJcclxuICogQGZpcmVzIG1vZHVsZTpueWMvU2VhcmNoflNlYXJjaCNzZWFyY2hcclxuICogQGZpcmVzIG1vZHVsZTpueWMvU2VhcmNoflNlYXJjaCNkaXNhbWJpZ3VhdGVkXHJcbiAqL1xuY2xhc3MgU2VhcmNoIGV4dGVuZHMgX0NvbnRhaW5lci5kZWZhdWx0IHtcbiAgLyoqXHJcbiAgICogQGRlc2MgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBTZWFyY2hcclxuICAgKiBAYWNjZXNzIHByb3RlY3RlZFxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5fEVsZW1lbnR8c3RyaW5nfSB0YXJnZXQgVGhlIHRhcmdldFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICBzdXBlcigoMCwgX2pxdWVyeS5kZWZhdWx0KShTZWFyY2guSFRNTCkpO1xuICAgIGxldCBpbnB1dDtcbiAgICB0YXJnZXQgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KSh0YXJnZXQpLmdldCgwKTtcblxuICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgaW5wdXQgPSB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KSgnPGRpdiBjbGFzcz1cIm1hcC1zcmNoXCI+PC9kaXY+Jyk7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoaW5wdXQpO1xuICAgICAgdGhpcy5maW5kKCcuc3JjaCcpLmFkZENsYXNzKCdpbnB1dC1ncm91cCcpO1xuICAgIH1cblxuICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKHRhcmdldCkuYXBwZW5kKHRoaXMuZ2V0Q29udGFpbmVyKCkpO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge2pRdWVyeX1cclxuICAgICAqL1xuXG4gICAgdGhpcy5pbnB1dCA9IHRoaXMuZmluZCgnaW5wdXQnKTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtqUXVlcnl9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuY2xlYXIgPSB0aGlzLmZpbmQoJy5idG4teCcpO1xuXG4gICAgaWYgKGlucHV0KSB7XG4gICAgICB0aGlzLmlucHV0LmF0dHIoJ2lkJywgKDAsIF9qcXVlcnkuZGVmYXVsdCkoaW5wdXQpLmF0dHIoJ2lkJykpLmF0dHIoJ3BsYWNlaG9sZGVyJywgKDAsIF9qcXVlcnkuZGVmYXVsdCkoaW5wdXQpLmF0dHIoJ3BsYWNlaG9sZGVyJykpLmFkZENsYXNzKCgwLCBfanF1ZXJ5LmRlZmF1bHQpKGlucHV0KS5hdHRyKCdjbGFzcycpKTtcbiAgICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGlucHV0KS5yZW1vdmUoKTtcbiAgICAgIHRoaXMuY2xlYXIucmVtb3ZlKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cblxuXG4gICAgdGhpcy5pc0FkZHJTcmNoID0gdHJ1ZTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAbWVtYmVyIHtqUXVlcnl9XHJcbiAgICAgKi9cblxuICAgIHRoaXMubGlzdCA9IHRoaXMuZmluZCgndWwucmFkLWFsbCcpO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge2pRdWVyeX1cclxuICAgICAqL1xuXG4gICAgdGhpcy5yZXRlbnRpb24gPSB0aGlzLmZpbmQoJ3VsLnJldGVudGlvbicpO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBtZW1iZXIge0F1dG9Db21wbGV0ZX1cclxuICAgICAqL1xuXG4gICAgdGhpcy5hdXRvQ29tcGxldGUgPSBudWxsO1xuICAgIHRoaXMuaG9va3VwRXZlbnRzKHRoaXMuaW5wdXQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgVGhlIGZlYXR1cmUgb2JqZWN0XHJcbiAgICogQHBhcmFtIHttb2R1bGU6bnljL1NlYXJjaH5TZWFyY2guRmVhdHVyZVNlYXJjaE9wdGlvbnN9IG9wdGlvbnMgRGVzY3JpYmVzIGhvdyB0byBjb252ZXJ0IGZlYXR1cmVcclxuICAgKiBAcmV0dXJuIHttb2R1bGU6bnljL0xvY2F0b3J+TG9jYXRvci5SZXN1bHR9IFRoZSBsb2NhdGlvblxyXG4gICAqL1xuXG5cbiAgZmVhdHVyZUFzTG9jYXRpb24oZmVhdHVyZSwgb3B0aW9ucykge1xuICAgIHRocm93ICdOb3QgaW1wbGVtZW50ZWQnO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFNldCBvciBnZXQgdGhlIHZhbHVlIG9mIHRoZSBzZWFyY2ggZmllbGRcclxuICAgKiBAcHVibGljXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdmFsIFRoZSB2YWx1ZSBmb3IgdGhlIHNlYXJjaCBmaWVsZFxyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBzZWFyY2ggZmllbGRcclxuICAgKi9cblxuXG4gIHZhbCh2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaW5wdXQudmFsKHZhbCk7XG4gICAgICB0aGlzLmNsZWFyQnRuKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgRGlzcGxheXMgcG9zc2libGUgYWRkcmVzcyBtYXRjaGVzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLkFtYmlndW91c30gYW1iaWd1b3VzIFBvc3NpYmxlIGxvY2F0aW9ucyByZXN1bHRpbmcgZnJvbSBhIGdlb2NvZGVyIHNlYXJjaCB0byBkaXNwbGF5IHRvIHRoZSB1c2VyXHJcbiAgICovXG5cblxuICBkaXNhbWJpZ3VhdGUoYW1iaWd1b3VzKSB7XG4gICAgY29uc3QgcG9zc2libGUgPSBhbWJpZ3VvdXMucG9zc2libGU7XG5cbiAgICBpZiAocG9zc2libGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsaXN0ID0gdGhpcy5saXN0O1xuICAgICAgdGhpcy5lbXB0eUxpc3QoKTtcbiAgICAgIHBvc3NpYmxlLmZvckVhY2gobG9jYXRlUmVzdWx0ID0+IHtcbiAgICAgICAgbGlzdC5hcHBlbmQodGhpcy5saXN0SXRlbSh7XG4gICAgICAgICAgbGF5ZXJOYW1lOiAnYWRkcidcbiAgICAgICAgfSwgbG9jYXRlUmVzdWx0KSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2hvd0xpc3QodHJ1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIEFkZCBzZWFyY2hhYmxlIGZlYXR1cmVzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvU2VhcmNoflNlYXJjaC5GZWF0dXJlU2VhcmNoT3B0aW9uc30gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBmZWF0dXJlIHNlYXJjaFxyXG4gICAqL1xuXG5cbiAgc2V0RmVhdHVyZXMob3B0aW9ucykge1xuICAgIHRoaXMuYXV0b0NvbXBsZXRlID0gdGhpcy5hdXRvQ29tcGxldGUgfHwgbmV3IF9BdXRvQ29tcGxldGUuZGVmYXVsdCgpO1xuICAgIG9wdGlvbnMubmFtZUZpZWxkID0gb3B0aW9ucy5uYW1lRmllbGQgfHwgJ25hbWUnO1xuICAgIG9wdGlvbnMuZGlzcGxheUZpZWxkID0gb3B0aW9ucy5kaXNwbGF5RmllbGQgfHwgb3B0aW9ucy5uYW1lRmllbGQ7XG5cbiAgICBpZiAob3B0aW9ucy5wbGFjZWhvbGRlcikge1xuICAgICAgdGhpcy5pbnB1dC5hdHRyKCdwbGFjZWhvbGRlcicsIG9wdGlvbnMucGxhY2Vob2xkZXIpO1xuICAgIH1cblxuICAgIHRoaXMuc29ydEFscGhhcGV0aWNhbGx5KG9wdGlvbnMpLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZmVhdHVyZUFzTG9jYXRpb24oZmVhdHVyZSwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBsaSA9IHRoaXMubGlzdEl0ZW0ob3B0aW9ucywgbG9jYXRpb24pO1xuICAgICAgdGhpcy5yZXRlbnRpb24uYXBwZW5kKGxpKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtcHR5TGlzdCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIFJlbW92ZSBzZWFyY2hhYmxlIGZlYXR1cmVzXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZVR5cGVOYW1lIFRoZSBmZWF0dXJlVHlwZU5hbWUgdXNlZCB3aGVuIHRoZSBmZWF0dXJlcyB3ZXJlIHNldFxyXG4gICAqL1xuXG5cbiAgcmVtb3ZlRmVhdHVyZXMoZmVhdHVyZVR5cGVOYW1lKSB7XG4gICAgdGhpcy5maW5kKCdsaS4nICsgZmVhdHVyZVR5cGVOYW1lKS5yZW1vdmUoKTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvU2VhcmNoflNlYXJjaC5GZWF0dXJlU2VhcmNoT3B0aW9uc30gb3B0aW9ucyBPcHRpb25zXHJcbiAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0Pn0gZmVhdHVyZXNcclxuICAgKi9cblxuXG4gIHNvcnRBbHBoYXBldGljYWxseShvcHRpb25zKSB7XG4gICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICBvcHRpb25zLmZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgICBpZiAoZmVhdHVyZS5nZXQpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaChfanF1ZXJ5LmRlZmF1bHQuZXh0ZW5kKHt9LCBmZWF0dXJlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKF9qcXVlcnkuZGVmYXVsdC5leHRlbmQoe1xuICAgICAgICAgIGdldChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgIH1cblxuICAgICAgICB9LCBmZWF0dXJlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmVhdHVyZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgbmFtZUZpZWxkID0gb3B0aW9ucy5uYW1lRmllbGQ7XG5cbiAgICAgIGlmIChhLmdldChuYW1lRmllbGQpIDwgYi5nZXQobmFtZUZpZWxkKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmdldChuYW1lRmllbGQpID4gYi5nZXQobmFtZUZpZWxkKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7bW9kdWxlOm55Yy9TZWFyY2h+U2VhcmNoLkZlYXR1cmVTZWFyY2hPcHRpb25zfSBvcHRpb25zIE9wdGlvbnNcclxuICAgKiBAcGFyYW0ge21vZHVsZTpueWMvTG9jYXRvcn5Mb2NhdG9yLlJlc3VsdH0gZGF0YSBMb2NhdGlvbiBkYXRhXHJcbiAgICogQHJldHVybiB7alF1ZXJ5fSBsaXN0IGl0ZW1cclxuICAgKi9cblxuXG4gIGxpc3RJdGVtKG9wdGlvbnMsIGRhdGEpIHtcbiAgICBjb25zdCBsaSA9ICgwLCBfanF1ZXJ5LmRlZmF1bHQpKCc8bGk+PC9saT4nKTtcbiAgICBjb25zdCBkaXNwbGF5RmllbGQgPSBvcHRpb25zLmRpc3BsYXlGaWVsZDtcbiAgICBjb25zdCBuYW1lID0gYCR7ZGF0YS5kYXRhW2Rpc3BsYXlGaWVsZF0gfHwgZGF0YS5uYW1lfWA7XG4gICAgbGkuYWRkQ2xhc3Mob3B0aW9ucy5sYXllck5hbWUpO1xuXG4gICAgaWYgKG9wdGlvbnMubGF5ZXJOYW1lICE9PSAnYWRkcicpIHtcbiAgICAgIGxpLmFkZENsYXNzKCdmZWF0dXJlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpLmFkZENsYXNzKCdub3RyYW5zbGF0ZScpLmF0dHIoe1xuICAgICAgdHJhbnNsYXRlOiAnbm8nLFxuICAgICAgJ2RhdGEtaWQnOiBlbmNvZGVVUklDb21wb25lbnQobmFtZSlcbiAgICB9KS5odG1sKGA8YSBocmVmPVwiI1wiPiR7bmFtZX08L2E+YCkuZGF0YSgnbmFtZUZpZWxkJywgb3B0aW9ucy5uYW1lRmllbGQpLmRhdGEoJ2Rpc3BsYXlGaWVsZCcsIGRpc3BsYXlGaWVsZCkuZGF0YSgnbG9jYXRpb24nLCBkYXRhKS5jbGljayhfanF1ZXJ5LmRlZmF1bHQucHJveHkodGhpcy5kaXNhbWJpZ3VhdGVkLCB0aGlzKSkua2V5dXAoX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMuZGlzYW1iaWd1YXRlZCwgdGhpcykpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqL1xuXG5cbiAgZW1wdHlMaXN0KCkge1xuICAgIGNvbnN0IHJldGVudGlvbiA9IHRoaXMucmV0ZW50aW9uO1xuICAgIHRoaXMuZmluZCgnbGknKS5lYWNoKChpLCBpdGVtKSA9PiB7XG4gICAgICBpZiAocmV0ZW50aW9uLmZpbmQoYGxpW2RhdGEtaWQ9XCIkeygwLCBfanF1ZXJ5LmRlZmF1bHQpKGl0ZW0pLmF0dHIoJ2RhdGEtaWQnKX1cIl1gKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0ZW50aW9uLmFwcGVuZChpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmxpc3QuZW1wdHkoKTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XHJcbiAgICovXG5cblxuICBkaXNhbWJpZ3VhdGVkKGV2ZW50KSB7XG4gICAgY29uc3QgbGkgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KShldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICBjb25zdCBkYXRhID0gbGkuZGF0YSgnbG9jYXRpb24nKTtcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICB0aGlzLnZhbChkYXRhLm5hbWUpO1xuICAgICAgZGF0YS5pc0ZlYXR1cmUgPSBsaS5oYXNDbGFzcygnZmVhdHVyZScpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdkaXNhbWJpZ3VhdGVkJywgZGF0YSk7XG4gICAgICBsaS5wYXJlbnQoKS5zbGlkZVVwKCk7XG4gICAgICB0aGlzLmVtcHR5TGlzdCgpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBtZXRob2RcclxuICAgKiBAcGFyYW0ge2pRdWVyeS5FdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XHJcbiAgICovXG5cblxuICBsaXN0Q2xpY2soZXZlbnQpIHtcbiAgICBldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQ7XG5cbiAgICBpZiAodGhpcy5saXN0LmNzcygnZGlzcGxheScpID09PSAnYmxvY2snKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSAoMCwgX2pxdWVyeS5kZWZhdWx0KShldmVudC50YXJnZXQpO1xuXG4gICAgICBpZiAoX2pxdWVyeS5kZWZhdWx0LmNvbnRhaW5zKHRoaXMubGlzdC5nZXQoMCksIHRhcmdldC5nZXQoMCkpKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9Db21wbGV0ZSkge1xuICAgICAgICAgIHRhcmdldC50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0Q29udGFpbmVyKCkuY3NzKCdkaXNwbGF5JykgPT09ICdibG9jaycpIHtcbiAgICAgICAgdGhpcy5saXN0LnNsaWRlVXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtqUXVlcnl9IGlucHV0IElucHV0IGVsZW1lbnRcclxuICAgKi9cblxuXG4gIGhvb2t1cEV2ZW50cyhpbnB1dCkge1xuICAgIGlucHV0Lm9uKCdrZXl1cCBjaGFuZ2UnLCBfanF1ZXJ5LmRlZmF1bHQucHJveHkodGhpcy5rZXksIHRoaXMpKTtcbiAgICBpbnB1dC5mb2N1cygoKSA9PiBpbnB1dC5zZWxlY3QoKSk7XG4gICAgdGhpcy5jbGVhci5jbGljayhfanF1ZXJ5LmRlZmF1bHQucHJveHkodGhpcy5jbGVhclR4dCwgdGhpcykpO1xuICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGRvY3VtZW50KS5tb3VzZXVwKF9qcXVlcnkuZGVmYXVsdC5wcm94eSh0aGlzLmxpc3RDbGljaywgdGhpcykpO1xuICAgIHRoaXMuZmluZCgnLmJ0bi1zcmNoJykuY2xpY2soX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMudHJpZ2dlclNlYXJjaCwgdGhpcykpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5LkV2ZW50fSBldmVudCBFdmVudCBvYmplY3RcclxuICAgKi9cblxuXG4gIGtleShldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAxMyAmJiB0aGlzLmlzQWRkclNyY2gpIHtcbiAgICAgIHRoaXMudHJpZ2dlclNlYXJjaCgpO1xuICAgICAgdGhpcy5saXN0LnNsaWRlVXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maWx0ZXJMaXN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhckJ0bigpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqL1xuXG5cbiAgY2xlYXJUeHQoKSB7XG4gICAgdGhpcy52YWwoJycpO1xuICAgIHRoaXMuY2xlYXJCdG4oKTtcbiAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICovXG5cblxuICBjbGVhckJ0bigpIHtcbiAgICB0aGlzLmNsZWFyW3RoaXMudmFsKCkgPyAnc2hvdycgOiAnaGlkZSddKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICovXG5cblxuICBmaWx0ZXJMaXN0KCkge1xuICAgIGNvbnN0IHR5cGVkID0gdGhpcy52YWwoKS50cmltKCk7XG5cbiAgICBpZiAodGhpcy5hdXRvQ29tcGxldGUgJiYgdHlwZWQpIHtcbiAgICAgIHRoaXMuYXV0b0NvbXBsZXRlLmZpbHRlcih0aGlzLnJldGVudGlvbiwgdGhpcy5saXN0LCB0eXBlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1wdHlMaXN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaG93TGlzdChmYWxzZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBmb2N1cyBTaG91bGQgd2UgZm9jdXM/XHJcbiAgICovXG5cblxuICBzaG93TGlzdChmb2N1cykge1xuICAgIGlmICh0aGlzLmdldENvbnRhaW5lcigpLmNzcygnZGlzcGxheScpID09PSAnYmxvY2snKSB7XG4gICAgICB0aGlzLmxpc3Quc2xpZGVEb3duKCgpID0+IHtcbiAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5saXN0LmNoaWxkcmVuKCkuZmlyc3QoKS5maW5kKCdhJykuYXR0cigndGFiaW5kZXgnLCAwKS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gKDAsIF9qcXVlcnkuZGVmYXVsdCkoJzxkaXY+PHN0cm9uZz5Qb3NzaWJsZSBtYXRjaGVzOjwvc3Ryb25nPjwvZGl2PicpO1xuICAgICAgbXNnLmFwcGVuZCh0aGlzLmxpc3QpO1xuICAgICAgdGhpcy5kaWFsb2cgPSB0aGlzLmRpYWxvZyB8fCBuZXcgX0RpYWxvZy5kZWZhdWx0KHtcbiAgICAgICAgdGFyZ2V0OiAoMCwgX2pxdWVyeS5kZWZhdWx0KSgnLm55Yy1tYXAnKSxcbiAgICAgICAgY3NzOiAncG9zYmwnXG4gICAgICB9KTtcbiAgICAgIHRoaXMubGlzdC5vbmUoJ2NsaWNrJywgX2pxdWVyeS5kZWZhdWx0LnByb3h5KHRoaXMuZGlhbG9nLmhpZGUsIHRoaXMuZGlhbG9nKSk7XG4gICAgICB0aGlzLmRpYWxvZy5vayh7XG4gICAgICAgIGJ1dHRvblRleHQ6IFsnQ2FuY2VsJ10sXG4gICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqL1xuXG5cbiAgdHJpZ2dlclNlYXJjaCgpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMudmFsKCkudHJpbSgpO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5pbnB1dC5ibHVyKCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3NlYXJjaCcsIGlucHV0KTtcbiAgICB9XG4gIH1cblxufVxuLyoqXHJcbiAqIEBkZXNjIE9iamVjdCB0eXBlIHRvIGhvbGQgZGF0YSBhYm91dCBob3cgdG8gc2VhcmNoIGZlYXR1cmVzXHJcbiAqIEBwdWJsaWNcclxuICogQHR5cGVkZWYge09iamVjdH1cclxuICogQHByb3BlcnR5IHtBcnJheTxPYmplY3R8b2wuRmVhdHVyZT59IGZlYXR1cmVzIFRoZSBmZWF0dXJlcyB0byBiZSBzZWFyY2hlZFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGF5ZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBsYXllciBvciBmZWF0dXJlIHR5cGUgdGhlIGZlYXR1cmVzIGFyZSBmcm9tXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZUZpZWxkPVwibmFtZVwiXSBUaGUgbmFtZSBhdHRyaWJ1dGUgZmllbGQgb2YgdGhlIGZlYXR1cmVcclxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkaXNwbGF5RmllbGQgVGhlIG5hbWUgYXR0cmlidXRlIGZpZWxkIG9mIHRoZSBmZWF0dXJlXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gcGxhY2Vob2xkZXIgQSBwbGFjZWhvbGRlciBmb3IgdGhlIHNlYXJjaCBmaWVsZFxyXG4gKi9cblxuXG5TZWFyY2guRmVhdHVyZVNlYXJjaE9wdGlvbnM7XG4vKipcclxuICogQGRlc2MgVGhlIHVzZXIgaGFzIHJlcXVlc3RlZCBhIHNlYXJjaCBiYXNlZCBvbiB0aGVpciB0ZXh0IGlucHV0XHJcbiAqIEBldmVudCBtb2R1bGU6bnljL1NlYXJjaH5TZWFyY2gjc2VhcmNoXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG4vKipcclxuICogQGRlc2MgVGhlIHVzZXIgaGFzIGNob3NlbiBhIGxvY2F0aW9uIGZyb20gYSBsaXN0IG9mIHBvc3NpYmxlIGxvY2F0aW9uc1xyXG4gKiBAZXZlbnQgbW9kdWxlOm55Yy9TZWFyY2h+U2VhcmNoI2Rpc2FtYmlndWF0ZWRcclxuICogQHR5cGUge21vZHVsZTpueWMvTG9jYXRlfkxvY2F0ZS5SZXN1bHR9XHJcbiAqL1xuXG4vKipcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0XHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG5TZWFyY2guSFRNTCA9ICc8ZGl2IGNsYXNzPVwic3JjaC1jdGxcIj4nICsgJzxkaXYgY2xhc3M9XCJzcmNoXCIgcm9sZT1cInNlYXJjaFwiPicgKyAnPGlucHV0IGNsYXNzPVwicmFkLWFsbFwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJTZWFyY2ggZm9yIGFuIGFkZHJlc3MuLi5cIj4nICsgJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLXJuZCBidG4teFwiPicgKyAnPHNwYW4gY2xhc3M9XCJzY3JlZW4tcmVhZGVyLW9ubHlcIj5DbGVhcjwvc3Bhbj4nICsgJzxzcGFuIGNsYXNzPVwiZmFzIGZhLXRpbWVzXCIgcm9sZT1cImltZ1wiPjwvc3Bhbj4nICsgJzwvYnV0dG9uPicgKyAnPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc3JjaCBidG4tcHJpbWFyeSBidG4tbGdcIj5TZWFyY2g8L2J1dHRvbj4nICsgJzwvZGl2PicgKyAnPHVsIGNsYXNzPVwicmFkLWFsbFwiIHJvbGU9XCJyZWdpb25cIiBsYWJlbD1cIlBvc3NpYmxlIG1hdGNoZXMgZm9yIHlvdXIgc2VhcmNoXCI+PC91bD4nICsgJzx1bCBjbGFzcz1cInJldGVudGlvblwiPjwvdWw+JyArICc8L2Rpdj4nO1xudmFyIF9kZWZhdWx0ID0gU2VhcmNoO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7Ozs7QUFJQTs7Ozs7Ozs7Ozs7QUFTQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUF6REE7QUF5REE7QUFDQTs7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBMVhBO0FBNlhBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///146\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports["default"] = void 0;\n\nvar _jquery = _interopRequireDefault(__webpack_require__(8));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n}\n/**\r\n * @module nyc/AutoComplete\r\n */\n\n/**\r\n * @desc A class to provide fitering functionality for autocomplete\r\n * @public\r\n * @class\r\n */\n\n\nvar AutoComplete =\n/*#__PURE__*/\nfunction () {\n  function AutoComplete() {\n    _classCallCheck(this, AutoComplete);\n  }\n\n  _createClass(AutoComplete, [{\n    key: "filter",\n\n    /**\r\n     * @desc Find matching li elements from inUl and move them to outUl\r\n     * @public\r\n     * @method\r\n     * @param {jQuery|Element|string} inUl The ul element to search\r\n     * @param {jQuery|Element|string} outUl The ul element to receive results\r\n     * @param {string} typed The text for searching\r\n     */\n    value: function filter(inUl, outUl, typed) {\n      var _this = this;\n\n      var _long = typed.length > 3;\n\n      var veryLong = typed.length > 6;\n      var filtered = {\n        exact: [],\n        possible: []\n      };\n      var matchers = this.regexp(typed);\n      var all = [];\n      var test = this.test;\n\n      _jquery["default"].merge((0, _jquery["default"])(outUl).find(\'li\'), (0, _jquery["default"])(inUl).find(\'li\')).each(function (_, li) {\n        all.push((0, _jquery["default"])(li));\n        test(matchers, (0, _jquery["default"])(li), filtered, _long, _this.log);\n      });\n\n      (0, _jquery["default"])(inUl).append(all);\n\n      if (filtered.exact.length) {\n        (0, _jquery["default"])(outUl).prepend(filtered.exact);\n      } else if (!veryLong) {\n        (0, _jquery["default"])(outUl).prepend(filtered.possible);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {Object<string,RegExp>} matchers Matchers\r\n     * @param {jQuery|string|number} item Item\r\n     * @param {Object<string,Array<JQuery|string|number>>} filtered Filtered\r\n     * @param {boolean} long If true use exact test\r\n     */\n\n  }, {\n    key: "test",\n    value: function test(matchers, item, filtered, _long2) {\n      var text = item.html();\n\n      if (_long2) {\n        if (matchers.exact.test(text)) {\n          filtered.exact.push(item);\n        }\n      }\n\n      if (matchers.possible.test(text)) {\n        filtered.possible.push(item);\n      }\n    }\n    /**\r\n     * @private\r\n     * @method\r\n     * @param {string} typed Typed string\r\n     * @return {Object<string,RegExp>} Exact and possible regexes\r\n     */\n\n  }, {\n    key: "regexp",\n    value: function regexp(typed) {\n      var possibleMatch = new String(typed.replace(/[^a-zA-Z0-9]/g, \'\'));\n      var exactMatch = new String(typed.replace(/[^a-zA-Z0-9 ]/g, \'\'));\n      var possible = \'^\';\n\n      for (var i = 0; i < possibleMatch.length; i++) {\n        possible += "(?=.*".concat(possibleMatch.charAt(i), ")|");\n      }\n\n      possible = possible.substr(0, possible.length - 1);\n      possible += \'.*$\';\n      return {\n        exact: new RegExp("(".concat(exactMatch, ")"), \'i\'),\n        possible: new RegExp(possible, \'i\')\n      };\n    }\n  }]);\n\n  return AutoComplete;\n}();\n\nvar _default = AutoComplete;\nexports["default"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL255Yy1saWIvbnljL0F1dG9Db21wbGV0ZS5qcz85ZGYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pxdWVyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxyXG4gKiBAbW9kdWxlIG55Yy9BdXRvQ29tcGxldGVcclxuICovXG5cbi8qKlxyXG4gKiBAZGVzYyBBIGNsYXNzIHRvIHByb3ZpZGUgZml0ZXJpbmcgZnVuY3Rpb25hbGl0eSBmb3IgYXV0b2NvbXBsZXRlXHJcbiAqIEBwdWJsaWNcclxuICogQGNsYXNzXHJcbiAqL1xuY2xhc3MgQXV0b0NvbXBsZXRlIHtcbiAgLyoqXHJcbiAgICogQGRlc2MgRmluZCBtYXRjaGluZyBsaSBlbGVtZW50cyBmcm9tIGluVWwgYW5kIG1vdmUgdGhlbSB0byBvdXRVbFxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtqUXVlcnl8RWxlbWVudHxzdHJpbmd9IGluVWwgVGhlIHVsIGVsZW1lbnQgdG8gc2VhcmNoXHJcbiAgICogQHBhcmFtIHtqUXVlcnl8RWxlbWVudHxzdHJpbmd9IG91dFVsIFRoZSB1bCBlbGVtZW50IHRvIHJlY2VpdmUgcmVzdWx0c1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlZCBUaGUgdGV4dCBmb3Igc2VhcmNoaW5nXHJcbiAgICovXG4gIGZpbHRlcihpblVsLCBvdXRVbCwgdHlwZWQpIHtcbiAgICBjb25zdCBsb25nID0gdHlwZWQubGVuZ3RoID4gMztcbiAgICBjb25zdCB2ZXJ5TG9uZyA9IHR5cGVkLmxlbmd0aCA+IDY7XG4gICAgY29uc3QgZmlsdGVyZWQgPSB7XG4gICAgICBleGFjdDogW10sXG4gICAgICBwb3NzaWJsZTogW11cbiAgICB9O1xuICAgIGNvbnN0IG1hdGNoZXJzID0gdGhpcy5yZWdleHAodHlwZWQpO1xuICAgIGNvbnN0IGFsbCA9IFtdO1xuICAgIGNvbnN0IHRlc3QgPSB0aGlzLnRlc3Q7XG5cbiAgICBfanF1ZXJ5LmRlZmF1bHQubWVyZ2UoKDAsIF9qcXVlcnkuZGVmYXVsdCkob3V0VWwpLmZpbmQoJ2xpJyksICgwLCBfanF1ZXJ5LmRlZmF1bHQpKGluVWwpLmZpbmQoJ2xpJykpLmVhY2goKF8sIGxpKSA9PiB7XG4gICAgICBhbGwucHVzaCgoMCwgX2pxdWVyeS5kZWZhdWx0KShsaSkpO1xuICAgICAgdGVzdChtYXRjaGVycywgKDAsIF9qcXVlcnkuZGVmYXVsdCkobGkpLCBmaWx0ZXJlZCwgbG9uZywgdGhpcy5sb2cpO1xuICAgIH0pO1xuXG4gICAgKDAsIF9qcXVlcnkuZGVmYXVsdCkoaW5VbCkuYXBwZW5kKGFsbCk7XG5cbiAgICBpZiAoZmlsdGVyZWQuZXhhY3QubGVuZ3RoKSB7XG4gICAgICAoMCwgX2pxdWVyeS5kZWZhdWx0KShvdXRVbCkucHJlcGVuZChmaWx0ZXJlZC5leGFjdCk7XG4gICAgfSBlbHNlIGlmICghdmVyeUxvbmcpIHtcbiAgICAgICgwLCBfanF1ZXJ5LmRlZmF1bHQpKG91dFVsKS5wcmVwZW5kKGZpbHRlcmVkLnBvc3NpYmxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAbWV0aG9kXHJcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLFJlZ0V4cD59IG1hdGNoZXJzIE1hdGNoZXJzXHJcbiAgICogQHBhcmFtIHtqUXVlcnl8c3RyaW5nfG51bWJlcn0gaXRlbSBJdGVtXHJcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLEFycmF5PEpRdWVyeXxzdHJpbmd8bnVtYmVyPj59IGZpbHRlcmVkIEZpbHRlcmVkXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBsb25nIElmIHRydWUgdXNlIGV4YWN0IHRlc3RcclxuICAgKi9cblxuXG4gIHRlc3QobWF0Y2hlcnMsIGl0ZW0sIGZpbHRlcmVkLCBsb25nKSB7XG4gICAgY29uc3QgdGV4dCA9IGl0ZW0uaHRtbCgpO1xuXG4gICAgaWYgKGxvbmcpIHtcbiAgICAgIGlmIChtYXRjaGVycy5leGFjdC50ZXN0KHRleHQpKSB7XG4gICAgICAgIGZpbHRlcmVkLmV4YWN0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoZXJzLnBvc3NpYmxlLnRlc3QodGV4dCkpIHtcbiAgICAgIGZpbHRlcmVkLnBvc3NpYmxlLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlZCBUeXBlZCBzdHJpbmdcclxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLFJlZ0V4cD59IEV4YWN0IGFuZCBwb3NzaWJsZSByZWdleGVzXHJcbiAgICovXG5cblxuICByZWdleHAodHlwZWQpIHtcbiAgICBjb25zdCBwb3NzaWJsZU1hdGNoID0gbmV3IFN0cmluZyh0eXBlZC5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgJycpKTtcbiAgICBjb25zdCBleGFjdE1hdGNoID0gbmV3IFN0cmluZyh0eXBlZC5yZXBsYWNlKC9bXmEtekEtWjAtOSBdL2csICcnKSk7XG4gICAgbGV0IHBvc3NpYmxlID0gJ14nO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NzaWJsZU1hdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3NzaWJsZSArPSBgKD89Lioke3Bvc3NpYmxlTWF0Y2guY2hhckF0KGkpfSl8YDtcbiAgICB9XG5cbiAgICBwb3NzaWJsZSA9IHBvc3NpYmxlLnN1YnN0cigwLCBwb3NzaWJsZS5sZW5ndGggLSAxKTtcbiAgICBwb3NzaWJsZSArPSAnLiokJztcbiAgICByZXR1cm4ge1xuICAgICAgZXhhY3Q6IG5ldyBSZWdFeHAoYCgke2V4YWN0TWF0Y2h9KWAsICdpJyksXG4gICAgICBwb3NzaWJsZTogbmV3IFJlZ0V4cChwb3NzaWJsZSwgJ2knKVxuICAgIH07XG4gIH1cblxufVxuXG52YXIgX2RlZmF1bHQgPSBBdXRvQ29tcGxldGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7OztBQUlBOzs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7QUFDQTs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7O0FBSUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///147\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/Collection.js\nvar Collection = __webpack_require__(49);\n\n// EXTERNAL MODULE: ./node_modules/ol/CollectionEventType.js\nvar CollectionEventType = __webpack_require__(27);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/Event.js\nvar Event = __webpack_require__(23);\n\n// CONCATENATED MODULE: ./node_modules/ol/MapEvent.js\n/**\n * @module ol/MapEvent\n */\n\n/**\n * @classdesc\n * Events emitted as map events are instances of this type.\n * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.\n */\n\nvar MapEvent =\n/*@__PURE__*/\nfunction (Event) {\n  function MapEvent(type, map, opt_frameState) {\n    Event.call(this, type);\n    /**\n     * The map where the event occurred.\n     * @type {import("./PluggableMap.js").default}\n     * @api\n     */\n\n    this.map = map;\n    /**\n     * The frame state at the time of the event.\n     * @type {?import("./PluggableMap.js").FrameState}\n     * @api\n     */\n\n    this.frameState = opt_frameState !== undefined ? opt_frameState : null;\n  }\n\n  if (Event) MapEvent.__proto__ = Event;\n  MapEvent.prototype = Object.create(Event && Event.prototype);\n  MapEvent.prototype.constructor = MapEvent;\n  return MapEvent;\n}(Event["a" /* default */]);\n\n/* harmony default export */ var ol_MapEvent = (MapEvent);\n// CONCATENATED MODULE: ./node_modules/ol/MapBrowserEvent.js\n/**\n * @module ol/MapBrowserEvent\n */\n\n/**\n * @classdesc\n * Events emitted as map browser events are instances of this type.\n * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.\n */\n\nvar MapBrowserEvent =\n/*@__PURE__*/\nfunction (MapEvent) {\n  function MapBrowserEvent(type, map, browserEvent, opt_dragging, opt_frameState) {\n    MapEvent.call(this, type, map, opt_frameState);\n    /**\n     * The original browser event.\n     * @const\n     * @type {Event}\n     * @api\n     */\n\n    this.originalEvent = browserEvent;\n    /**\n     * The map pixel relative to the viewport corresponding to the original browser event.\n     * @type {import("./pixel.js").Pixel}\n     * @api\n     */\n\n    this.pixel = map.getEventPixel(browserEvent);\n    /**\n     * The coordinate in view projection corresponding to the original browser event.\n     * @type {import("./coordinate.js").Coordinate}\n     * @api\n     */\n\n    this.coordinate = map.getCoordinateFromPixel(this.pixel);\n    /**\n     * Indicates if the map is currently being dragged. Only set for\n     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.\n     *\n     * @type {boolean}\n     * @api\n     */\n\n    this.dragging = opt_dragging !== undefined ? opt_dragging : false;\n  }\n\n  if (MapEvent) MapBrowserEvent.__proto__ = MapEvent;\n  MapBrowserEvent.prototype = Object.create(MapEvent && MapEvent.prototype);\n  MapBrowserEvent.prototype.constructor = MapBrowserEvent;\n  /**\n   * Prevents the default browser action.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.\n   * @override\n   * @api\n   */\n\n  MapBrowserEvent.prototype.preventDefault = function preventDefault() {\n    MapEvent.prototype.preventDefault.call(this);\n    this.originalEvent.preventDefault();\n  };\n  /**\n   * Prevents further propagation of the current event.\n   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.\n   * @override\n   * @api\n   */\n\n\n  MapBrowserEvent.prototype.stopPropagation = function stopPropagation() {\n    MapEvent.prototype.stopPropagation.call(this);\n    this.originalEvent.stopPropagation();\n  };\n\n  return MapBrowserEvent;\n}(ol_MapEvent);\n\n/* harmony default export */ var ol_MapBrowserEvent = (MapBrowserEvent);\n// EXTERNAL MODULE: ./node_modules/ol/has.js\nvar has = __webpack_require__(19);\n\n// EXTERNAL MODULE: ./node_modules/ol/MapBrowserEventType.js\nvar MapBrowserEventType = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./node_modules/ol/MapBrowserPointerEvent.js\n/**\n * @module ol/MapBrowserPointerEvent\n */\n\n\nvar MapBrowserPointerEvent =\n/*@__PURE__*/\nfunction (MapBrowserEvent) {\n  function MapBrowserPointerEvent(type, map, pointerEvent, opt_dragging, opt_frameState) {\n    MapBrowserEvent.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);\n    /**\n     * @const\n     * @type {import("./pointer/PointerEvent.js").default}\n     */\n\n    this.pointerEvent = pointerEvent;\n  }\n\n  if (MapBrowserEvent) MapBrowserPointerEvent.__proto__ = MapBrowserEvent;\n  MapBrowserPointerEvent.prototype = Object.create(MapBrowserEvent && MapBrowserEvent.prototype);\n  MapBrowserPointerEvent.prototype.constructor = MapBrowserPointerEvent;\n  return MapBrowserPointerEvent;\n}(ol_MapBrowserEvent);\n\n/* harmony default export */ var ol_MapBrowserPointerEvent = (MapBrowserPointerEvent);\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar ol_events = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/Target.js\nvar Target = __webpack_require__(44);\n\n// CONCATENATED MODULE: ./node_modules/ol/pointer/EventType.js\n/**\n * @module ol/pointer/EventType\n */\n\n/**\n * Constants for event names.\n * @enum {string}\n */\n/* harmony default export */ var EventType = ({\n  POINTERMOVE: \'pointermove\',\n  POINTERDOWN: \'pointerdown\',\n  POINTERUP: \'pointerup\',\n  POINTEROVER: \'pointerover\',\n  POINTEROUT: \'pointerout\',\n  POINTERENTER: \'pointerenter\',\n  POINTERLEAVE: \'pointerleave\',\n  POINTERCANCEL: \'pointercancel\'\n});\n// CONCATENATED MODULE: ./node_modules/ol/pointer/EventSource.js\n/**\n * @module ol/pointer/EventSource\n */\nvar EventSource_EventSource = function EventSource(dispatcher, mapping) {\n  /**\n   * @type {import("./PointerEventHandler.js").default}\n   */\n  this.dispatcher = dispatcher;\n  /**\n   * @private\n   * @const\n   * @type {!Object<string, function(Event)>}\n   */\n\n  this.mapping_ = mapping;\n};\n/**\n * List of events supported by this source.\n * @return {Array<string>} Event names\n */\n\n\nEventSource_EventSource.prototype.getEvents = function getEvents() {\n  return Object.keys(this.mapping_);\n};\n/**\n * Returns the handler that should handle a given event type.\n * @param {string} eventType The event type.\n * @return {function(Event)} Handler\n */\n\n\nEventSource_EventSource.prototype.getHandlerForEvent = function getHandlerForEvent(eventType) {\n  return this.mapping_[eventType];\n};\n\n/* harmony default export */ var pointer_EventSource = (EventSource_EventSource);\n// CONCATENATED MODULE: ./node_modules/ol/pointer/MouseSource.js\n/**\n * @module ol/pointer/MouseSource\n */\n// Based on https://github.com/Polymer/PointerEvents\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/**\n * @type {number}\n */\n\nvar POINTER_ID = 1;\n/**\n * @type {string}\n */\n\nvar POINTER_TYPE = \'mouse\';\n/**\n * Radius around touchend that swallows mouse events.\n *\n * @type {number}\n */\n\nvar DEDUP_DIST = 25;\n/**\n * Handler for `mousedown`.\n *\n * @this {MouseSource}\n * @param {MouseEvent} inEvent The in event.\n */\n\nfunction mousedown(inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    // TODO(dfreedman) workaround for some elements not sending mouseup\n    // http://crbug/149091\n    if (POINTER_ID.toString() in this.pointerMap) {\n      this.cancel(inEvent);\n    }\n\n    var e = prepareEvent(inEvent, this.dispatcher);\n    this.pointerMap[POINTER_ID.toString()] = inEvent;\n    this.dispatcher.down(e, inEvent);\n  }\n}\n/**\n * Handler for `mousemove`.\n *\n * @this {MouseSource}\n * @param {MouseEvent} inEvent The in event.\n */\n\n\nfunction mousemove(inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    var e = prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.move(e, inEvent);\n  }\n}\n/**\n * Handler for `mouseup`.\n *\n * @this {MouseSource}\n * @param {MouseEvent} inEvent The in event.\n */\n\n\nfunction mouseup(inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    var p = this.pointerMap[POINTER_ID.toString()];\n\n    if (p && p.button === inEvent.button) {\n      var e = prepareEvent(inEvent, this.dispatcher);\n      this.dispatcher.up(e, inEvent);\n      this.cleanupMouse();\n    }\n  }\n}\n/**\n * Handler for `mouseover`.\n *\n * @this {MouseSource}\n * @param {MouseEvent} inEvent The in event.\n */\n\n\nfunction mouseover(inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    var e = prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.enterOver(e, inEvent);\n  }\n}\n/**\n * Handler for `mouseout`.\n *\n * @this {MouseSource}\n * @param {MouseEvent} inEvent The in event.\n */\n\n\nfunction mouseout(inEvent) {\n  if (!this.isEventSimulatedFromTouch_(inEvent)) {\n    var e = prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.leaveOut(e, inEvent);\n  }\n}\n\nvar MouseSource =\n/*@__PURE__*/\nfunction (EventSource) {\n  function MouseSource(dispatcher) {\n    var mapping = {\n      \'mousedown\': mousedown,\n      \'mousemove\': mousemove,\n      \'mouseup\': mouseup,\n      \'mouseover\': mouseover,\n      \'mouseout\': mouseout\n    };\n    EventSource.call(this, dispatcher, mapping);\n    /**\n     * @const\n     * @type {!Object<string, Event|Object>}\n     */\n\n    this.pointerMap = dispatcher.pointerMap;\n    /**\n     * @const\n     * @type {Array<import("../pixel.js").Pixel>}\n     */\n\n    this.lastTouches = [];\n  }\n\n  if (EventSource) MouseSource.__proto__ = EventSource;\n  MouseSource.prototype = Object.create(EventSource && EventSource.prototype);\n  MouseSource.prototype.constructor = MouseSource;\n  /**\n   * Detect if a mouse event was simulated from a touch by\n   * checking if previously there was a touch event at the\n   * same position.\n   *\n   * FIXME - Known problem with the native Android browser on\n   * Samsung GT-I9100 (Android 4.1.2):\n   * In case the page is scrolled, this function does not work\n   * correctly when a canvas is used (WebGL or canvas renderer).\n   * Mouse listeners on canvas elements (for this browser), create\n   * two mouse events: One \'good\' and one \'bad\' one (on other browsers or\n   * when a div is used, there is only one event). For the \'bad\' one,\n   * clientX/clientY and also pageX/pageY are wrong when the page\n   * is scrolled. Because of that, this function can not detect if\n   * the events were simulated from a touch event. As result, a\n   * pointer event at a wrong position is dispatched, which confuses\n   * the map interactions.\n   * It is unclear, how one can get the correct position for the event\n   * or detect that the positions are invalid.\n   *\n   * @private\n   * @param {MouseEvent} inEvent The in event.\n   * @return {boolean} True, if the event was generated by a touch.\n   */\n\n  MouseSource.prototype.isEventSimulatedFromTouch_ = function isEventSimulatedFromTouch_(inEvent) {\n    var lts = this.lastTouches;\n    var x = inEvent.clientX;\n    var y = inEvent.clientY;\n\n    for (var i = 0, l = lts.length, t = void 0; i < l && (t = lts[i]); i++) {\n      // simulated mouse events will be swallowed near a primary touchend\n      var dx = Math.abs(x - t[0]);\n      var dy = Math.abs(y - t[1]);\n\n      if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Dispatches a `pointercancel` event.\n   *\n   * @param {Event} inEvent The in event.\n   */\n\n\n  MouseSource.prototype.cancel = function cancel(inEvent) {\n    var e = prepareEvent(inEvent, this.dispatcher);\n    this.dispatcher.cancel(e, inEvent);\n    this.cleanupMouse();\n  };\n  /**\n   * Remove the mouse from the list of active pointers.\n   */\n\n\n  MouseSource.prototype.cleanupMouse = function cleanupMouse() {\n    delete this.pointerMap[POINTER_ID.toString()];\n  };\n\n  return MouseSource;\n}(pointer_EventSource);\n/**\n * Creates a copy of the original event that will be used\n * for the fake pointer event.\n *\n * @param {Event} inEvent The in event.\n * @param {import("./PointerEventHandler.js").default} dispatcher Event handler.\n * @return {Object} The copied event.\n */\n\n\nfunction prepareEvent(inEvent, dispatcher) {\n  var e = dispatcher.cloneEvent(inEvent, inEvent); // forward mouse preventDefault\n\n  var pd = e.preventDefault;\n\n  e.preventDefault = function () {\n    inEvent.preventDefault();\n    pd();\n  };\n\n  e.pointerId = POINTER_ID;\n  e.isPrimary = true;\n  e.pointerType = POINTER_TYPE;\n  return e;\n}\n/* harmony default export */ var pointer_MouseSource = (MouseSource);\n// CONCATENATED MODULE: ./node_modules/ol/pointer/MsSource.js\n/**\n * @module ol/pointer/MsSource\n */\n// Based on https://github.com/Polymer/PointerEvents\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/**\n * @const\n * @type {Array<string>}\n */\n\nvar POINTER_TYPES = [\'\', \'unavailable\', \'touch\', \'pen\', \'mouse\'];\n/**\n * Handler for `msPointerDown`.\n *\n * @this {MsSource}\n * @param {MSPointerEvent} inEvent The in event.\n */\n\nfunction msPointerDown(inEvent) {\n  this.pointerMap[inEvent.pointerId.toString()] = inEvent;\n  var e = this.prepareEvent_(inEvent);\n  this.dispatcher.down(e, inEvent);\n}\n/**\n * Handler for `msPointerMove`.\n *\n * @this {MsSource}\n * @param {MSPointerEvent} inEvent The in event.\n */\n\n\nfunction msPointerMove(inEvent) {\n  var e = this.prepareEvent_(inEvent);\n  this.dispatcher.move(e, inEvent);\n}\n/**\n * Handler for `msPointerUp`.\n *\n * @this {MsSource}\n * @param {MSPointerEvent} inEvent The in event.\n */\n\n\nfunction msPointerUp(inEvent) {\n  var e = this.prepareEvent_(inEvent);\n  this.dispatcher.up(e, inEvent);\n  this.cleanup(inEvent.pointerId);\n}\n/**\n * Handler for `msPointerOut`.\n *\n * @this {MsSource}\n * @param {MSPointerEvent} inEvent The in event.\n */\n\n\nfunction msPointerOut(inEvent) {\n  var e = this.prepareEvent_(inEvent);\n  this.dispatcher.leaveOut(e, inEvent);\n}\n/**\n * Handler for `msPointerOver`.\n *\n * @this {MsSource}\n * @param {MSPointerEvent} inEvent The in event.\n */\n\n\nfunction msPointerOver(inEvent) {\n  var e = this.prepareEvent_(inEvent);\n  this.dispatcher.enterOver(e, inEvent);\n}\n/**\n * Handler for `msPointerCancel`.\n *\n * @this {MsSource}\n * @param {MSPointerEvent} inEvent The in event.\n */\n\n\nfunction msPointerCancel(inEvent) {\n  var e = this.prepareEvent_(inEvent);\n  this.dispatcher.cancel(e, inEvent);\n  this.cleanup(inEvent.pointerId);\n}\n/**\n * Handler for `msLostPointerCapture`.\n *\n * @this {MsSource}\n * @param {MSPointerEvent} inEvent The in event.\n */\n\n\nfunction msLostPointerCapture(inEvent) {\n  var e = this.dispatcher.makeEvent(\'lostpointercapture\', inEvent, inEvent);\n  this.dispatcher.dispatchEvent(e);\n}\n/**\n * Handler for `msGotPointerCapture`.\n *\n * @this {MsSource}\n * @param {MSPointerEvent} inEvent The in event.\n */\n\n\nfunction msGotPointerCapture(inEvent) {\n  var e = this.dispatcher.makeEvent(\'gotpointercapture\', inEvent, inEvent);\n  this.dispatcher.dispatchEvent(e);\n}\n\nvar MsSource =\n/*@__PURE__*/\nfunction (EventSource) {\n  function MsSource(dispatcher) {\n    var mapping = {\n      \'MSPointerDown\': msPointerDown,\n      \'MSPointerMove\': msPointerMove,\n      \'MSPointerUp\': msPointerUp,\n      \'MSPointerOut\': msPointerOut,\n      \'MSPointerOver\': msPointerOver,\n      \'MSPointerCancel\': msPointerCancel,\n      \'MSGotPointerCapture\': msGotPointerCapture,\n      \'MSLostPointerCapture\': msLostPointerCapture\n    };\n    EventSource.call(this, dispatcher, mapping);\n    /**\n     * @const\n     * @type {!Object<string, MSPointerEvent|Object>}\n     */\n\n    this.pointerMap = dispatcher.pointerMap;\n  }\n\n  if (EventSource) MsSource.__proto__ = EventSource;\n  MsSource.prototype = Object.create(EventSource && EventSource.prototype);\n  MsSource.prototype.constructor = MsSource;\n  /**\n   * Creates a copy of the original event that will be used\n   * for the fake pointer event.\n   *\n   * @private\n   * @param {MSPointerEvent} inEvent The in event.\n   * @return {Object} The copied event.\n   */\n\n  MsSource.prototype.prepareEvent_ = function prepareEvent_(inEvent) {\n    /** @type {MSPointerEvent|Object} */\n    var e = inEvent;\n\n    if (typeof inEvent.pointerType === \'number\') {\n      e = this.dispatcher.cloneEvent(inEvent, inEvent);\n      e.pointerType = POINTER_TYPES[inEvent.pointerType];\n    }\n\n    return e;\n  };\n  /**\n   * Remove this pointer from the list of active pointers.\n   * @param {number} pointerId Pointer identifier.\n   */\n\n\n  MsSource.prototype.cleanup = function cleanup(pointerId) {\n    delete this.pointerMap[pointerId.toString()];\n  };\n\n  return MsSource;\n}(pointer_EventSource);\n\n/* harmony default export */ var pointer_MsSource = (MsSource);\n// CONCATENATED MODULE: ./node_modules/ol/pointer/NativeSource.js\n/**\n * @module ol/pointer/NativeSource\n */\n// Based on https://github.com/Polymer/PointerEvents\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/**\n * Handler for `pointerdown`.\n *\n * @this {NativeSource}\n * @param {Event} inEvent The in event.\n */\n\nfunction pointerDown(inEvent) {\n  this.dispatcher.fireNativeEvent(inEvent);\n}\n/**\n * Handler for `pointermove`.\n *\n * @this {NativeSource}\n * @param {Event} inEvent The in event.\n */\n\n\nfunction pointerMove(inEvent) {\n  this.dispatcher.fireNativeEvent(inEvent);\n}\n/**\n * Handler for `pointerup`.\n *\n * @this {NativeSource}\n * @param {Event} inEvent The in event.\n */\n\n\nfunction pointerUp(inEvent) {\n  this.dispatcher.fireNativeEvent(inEvent);\n}\n/**\n * Handler for `pointerout`.\n *\n * @this {NativeSource}\n * @param {Event} inEvent The in event.\n */\n\n\nfunction pointerOut(inEvent) {\n  this.dispatcher.fireNativeEvent(inEvent);\n}\n/**\n * Handler for `pointerover`.\n *\n * @this {NativeSource}\n * @param {Event} inEvent The in event.\n */\n\n\nfunction pointerOver(inEvent) {\n  this.dispatcher.fireNativeEvent(inEvent);\n}\n/**\n * Handler for `pointercancel`.\n *\n * @this {NativeSource}\n * @param {Event} inEvent The in event.\n */\n\n\nfunction pointerCancel(inEvent) {\n  this.dispatcher.fireNativeEvent(inEvent);\n}\n/**\n * Handler for `lostpointercapture`.\n *\n * @this {NativeSource}\n * @param {Event} inEvent The in event.\n */\n\n\nfunction lostPointerCapture(inEvent) {\n  this.dispatcher.fireNativeEvent(inEvent);\n}\n/**\n * Handler for `gotpointercapture`.\n *\n * @this {NativeSource}\n * @param {Event} inEvent The in event.\n */\n\n\nfunction gotPointerCapture(inEvent) {\n  this.dispatcher.fireNativeEvent(inEvent);\n}\n\nvar NativeSource =\n/*@__PURE__*/\nfunction (EventSource) {\n  function NativeSource(dispatcher) {\n    var mapping = {\n      \'pointerdown\': pointerDown,\n      \'pointermove\': pointerMove,\n      \'pointerup\': pointerUp,\n      \'pointerout\': pointerOut,\n      \'pointerover\': pointerOver,\n      \'pointercancel\': pointerCancel,\n      \'gotpointercapture\': gotPointerCapture,\n      \'lostpointercapture\': lostPointerCapture\n    };\n    EventSource.call(this, dispatcher, mapping);\n  }\n\n  if (EventSource) NativeSource.__proto__ = EventSource;\n  NativeSource.prototype = Object.create(EventSource && EventSource.prototype);\n  NativeSource.prototype.constructor = NativeSource;\n  return NativeSource;\n}(pointer_EventSource);\n\n/* harmony default export */ var pointer_NativeSource = (NativeSource);\n// CONCATENATED MODULE: ./node_modules/ol/pointer/PointerEvent.js\n/**\n * @module ol/pointer/PointerEvent\n */\n// Based on https://github.com/Polymer/PointerEvents\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/**\n * Is the `buttons` property supported?\n * @type {boolean}\n */\n\nvar HAS_BUTTONS = false;\n\nvar PointerEvent =\n/*@__PURE__*/\nfunction (_Event) {\n  function PointerEvent(type, originalEvent, opt_eventDict) {\n    _Event.call(this, type);\n    /**\n     * @const\n     * @type {Event}\n     */\n\n\n    this.originalEvent = originalEvent;\n    var eventDict = opt_eventDict ? opt_eventDict : {};\n    /**\n     * @type {number}\n     */\n\n    this.buttons = getButtons(eventDict);\n    /**\n     * @type {number}\n     */\n\n    this.pressure = getPressure(eventDict, this.buttons); // MouseEvent related properties\n\n    /**\n     * @type {boolean}\n     */\n\n    this.bubbles = \'bubbles\' in eventDict ? eventDict[\'bubbles\'] : false;\n    /**\n     * @type {boolean}\n     */\n\n    this.cancelable = \'cancelable\' in eventDict ? eventDict[\'cancelable\'] : false;\n    /**\n     * @type {Object}\n     */\n\n    this.view = \'view\' in eventDict ? eventDict[\'view\'] : null;\n    /**\n     * @type {number}\n     */\n\n    this.detail = \'detail\' in eventDict ? eventDict[\'detail\'] : null;\n    /**\n     * @type {number}\n     */\n\n    this.screenX = \'screenX\' in eventDict ? eventDict[\'screenX\'] : 0;\n    /**\n     * @type {number}\n     */\n\n    this.screenY = \'screenY\' in eventDict ? eventDict[\'screenY\'] : 0;\n    /**\n     * @type {number}\n     */\n\n    this.clientX = \'clientX\' in eventDict ? eventDict[\'clientX\'] : 0;\n    /**\n     * @type {number}\n     */\n\n    this.clientY = \'clientY\' in eventDict ? eventDict[\'clientY\'] : 0;\n    /**\n     * @type {boolean}\n     */\n\n    this.ctrlKey = \'ctrlKey\' in eventDict ? eventDict[\'ctrlKey\'] : false;\n    /**\n     * @type {boolean}\n     */\n\n    this.altKey = \'altKey\' in eventDict ? eventDict[\'altKey\'] : false;\n    /**\n     * @type {boolean}\n     */\n\n    this.shiftKey = \'shiftKey\' in eventDict ? eventDict[\'shiftKey\'] : false;\n    /**\n     * @type {boolean}\n     */\n\n    this.metaKey = \'metaKey\' in eventDict ? eventDict[\'metaKey\'] : false;\n    /**\n     * @type {number}\n     */\n\n    this.button = \'button\' in eventDict ? eventDict[\'button\'] : 0;\n    /**\n     * @type {Node}\n     */\n\n    this.relatedTarget = \'relatedTarget\' in eventDict ? eventDict[\'relatedTarget\'] : null; // PointerEvent related properties\n\n    /**\n     * @const\n     * @type {number}\n     */\n\n    this.pointerId = \'pointerId\' in eventDict ? eventDict[\'pointerId\'] : 0;\n    /**\n     * @type {number}\n     */\n\n    this.width = \'width\' in eventDict ? eventDict[\'width\'] : 0;\n    /**\n     * @type {number}\n     */\n\n    this.height = \'height\' in eventDict ? eventDict[\'height\'] : 0;\n    /**\n     * @type {number}\n     */\n\n    this.tiltX = \'tiltX\' in eventDict ? eventDict[\'tiltX\'] : 0;\n    /**\n     * @type {number}\n     */\n\n    this.tiltY = \'tiltY\' in eventDict ? eventDict[\'tiltY\'] : 0;\n    /**\n     * @type {string}\n     */\n\n    this.pointerType = \'pointerType\' in eventDict ? eventDict[\'pointerType\'] : \'\';\n    /**\n     * @type {number}\n     */\n\n    this.hwTimestamp = \'hwTimestamp\' in eventDict ? eventDict[\'hwTimestamp\'] : 0;\n    /**\n     * @type {boolean}\n     */\n\n    this.isPrimary = \'isPrimary\' in eventDict ? eventDict[\'isPrimary\'] : false; // keep the semantics of preventDefault\n\n    if (originalEvent.preventDefault) {\n      this.preventDefault = function () {\n        originalEvent.preventDefault();\n      };\n    }\n  }\n\n  if (_Event) PointerEvent.__proto__ = _Event;\n  PointerEvent.prototype = Object.create(_Event && _Event.prototype);\n  PointerEvent.prototype.constructor = PointerEvent;\n  return PointerEvent;\n}(Event["a" /* default */]);\n/**\n * @param {Object<string, ?>} eventDict The event dictionary.\n * @return {number} Button indicator.\n */\n\n\nfunction getButtons(eventDict) {\n  // According to the w3c spec,\n  // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button\n  // MouseEvent.button == 0 can mean either no mouse button depressed, or the\n  // left mouse button depressed.\n  //\n  // As of now, the only way to distinguish between the two states of\n  // MouseEvent.button is by using the deprecated MouseEvent.which property, as\n  // this maps mouse buttons to positive integers > 0, and uses 0 to mean that\n  // no mouse button is held.\n  //\n  // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,\n  // but initMouseEvent does not expose an argument with which to set\n  // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set\n  // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations\n  // of app developers.\n  //\n  // The only way to propagate the correct state of MouseEvent.which and\n  // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0\n  // is to call initMouseEvent with a buttonArg value of -1.\n  //\n  // This is fixed with DOM Level 4\'s use of buttons\n  var buttons;\n\n  if (eventDict.buttons || HAS_BUTTONS) {\n    buttons = eventDict.buttons;\n  } else {\n    switch (eventDict.which) {\n      case 1:\n        buttons = 1;\n        break;\n\n      case 2:\n        buttons = 4;\n        break;\n\n      case 3:\n        buttons = 2;\n        break;\n\n      default:\n        buttons = 0;\n    }\n  }\n\n  return buttons;\n}\n/**\n * @param {Object<string, ?>} eventDict The event dictionary.\n * @param {number} buttons Button indicator.\n * @return {number} The pressure.\n */\n\n\nfunction getPressure(eventDict, buttons) {\n  // Spec requires that pointers without pressure specified use 0.5 for down\n  // state and 0 for up state.\n  var pressure = 0;\n\n  if (eventDict.pressure) {\n    pressure = eventDict.pressure;\n  } else {\n    pressure = buttons ? 0.5 : 0;\n  }\n\n  return pressure;\n}\n/**\n * Checks if the `buttons` property is supported.\n */\n\n\n(function () {\n  try {\n    var ev = new MouseEvent(\'click\', {\n      buttons: 1\n    });\n    HAS_BUTTONS = ev.buttons === 1;\n  } catch (e) {// pass\n  }\n})();\n\n/* harmony default export */ var pointer_PointerEvent = (PointerEvent);\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(13);\n\n// CONCATENATED MODULE: ./node_modules/ol/pointer/TouchSource.js\n/**\n * @module ol/pointer/TouchSource\n */\n// Based on https://github.com/Polymer/PointerEvents\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n/**\n * @type {number}\n */\n\nvar CLICK_COUNT_TIMEOUT = 200;\n/**\n * @type {string}\n */\n\nvar TouchSource_POINTER_TYPE = \'touch\';\n/**\n * Handler for `touchstart`, triggers `pointerover`,\n * `pointerenter` and `pointerdown` events.\n *\n * @this {TouchSource}\n * @param {TouchEvent} inEvent The in event.\n */\n\nfunction touchstart(inEvent) {\n  this.vacuumTouches_(inEvent);\n  this.setPrimaryTouch_(inEvent.changedTouches[0]);\n  this.dedupSynthMouse_(inEvent);\n  this.clickCount_++;\n  this.processTouches_(inEvent, this.overDown_);\n}\n/**\n * Handler for `touchmove`.\n *\n * @this {TouchSource}\n * @param {TouchEvent} inEvent The in event.\n */\n\n\nfunction touchmove(inEvent) {\n  this.processTouches_(inEvent, this.moveOverOut_);\n}\n/**\n * Handler for `touchend`, triggers `pointerup`,\n * `pointerout` and `pointerleave` events.\n *\n * @this {TouchSource}\n * @param {TouchEvent} inEvent The event.\n */\n\n\nfunction touchend(inEvent) {\n  this.dedupSynthMouse_(inEvent);\n  this.processTouches_(inEvent, this.upOut_);\n}\n/**\n * Handler for `touchcancel`, triggers `pointercancel`,\n * `pointerout` and `pointerleave` events.\n *\n * @this {TouchSource}\n * @param {TouchEvent} inEvent The in event.\n */\n\n\nfunction touchcancel(inEvent) {\n  this.processTouches_(inEvent, this.cancelOut_);\n}\n\nvar TouchSource_TouchSource =\n/*@__PURE__*/\nfunction (EventSource) {\n  function TouchSource(dispatcher, mouseSource) {\n    var mapping = {\n      \'touchstart\': touchstart,\n      \'touchmove\': touchmove,\n      \'touchend\': touchend,\n      \'touchcancel\': touchcancel\n    };\n    EventSource.call(this, dispatcher, mapping);\n    /**\n     * @const\n     * @type {!Object<string, Event|Object>}\n     */\n\n    this.pointerMap = dispatcher.pointerMap;\n    /**\n     * @const\n     * @type {import("./MouseSource.js").default}\n     */\n\n    this.mouseSource = mouseSource;\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.firstTouchId_ = undefined;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.clickCount_ = 0;\n    /**\n     * @private\n     * @type {?}\n     */\n\n    this.resetId_;\n    /**\n     * Mouse event timeout: This should be long enough to\n     * ignore compat mouse events made by touch.\n     * @private\n     * @type {number}\n     */\n\n    this.dedupTimeout_ = 2500;\n  }\n\n  if (EventSource) TouchSource.__proto__ = EventSource;\n  TouchSource.prototype = Object.create(EventSource && EventSource.prototype);\n  TouchSource.prototype.constructor = TouchSource;\n  /**\n   * @private\n   * @param {Touch} inTouch The in touch.\n   * @return {boolean} True, if this is the primary touch.\n   */\n\n  TouchSource.prototype.isPrimaryTouch_ = function isPrimaryTouch_(inTouch) {\n    return this.firstTouchId_ === inTouch.identifier;\n  };\n  /**\n   * Set primary touch if there are no pointers, or the only pointer is the mouse.\n   * @param {Touch} inTouch The in touch.\n   * @private\n   */\n\n\n  TouchSource.prototype.setPrimaryTouch_ = function setPrimaryTouch_(inTouch) {\n    var count = Object.keys(this.pointerMap).length;\n\n    if (count === 0 || count === 1 && POINTER_ID.toString() in this.pointerMap) {\n      this.firstTouchId_ = inTouch.identifier;\n      this.cancelResetClickCount_();\n    }\n  };\n  /**\n   * @private\n   * @param {PointerEvent} inPointer The in pointer object.\n   */\n\n\n  TouchSource.prototype.removePrimaryPointer_ = function removePrimaryPointer_(inPointer) {\n    if (inPointer.isPrimary) {\n      this.firstTouchId_ = undefined;\n      this.resetClickCount_();\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  TouchSource.prototype.resetClickCount_ = function resetClickCount_() {\n    this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), CLICK_COUNT_TIMEOUT);\n  };\n  /**\n   * @private\n   */\n\n\n  TouchSource.prototype.resetClickCountHandler_ = function resetClickCountHandler_() {\n    this.clickCount_ = 0;\n    this.resetId_ = undefined;\n  };\n  /**\n   * @private\n   */\n\n\n  TouchSource.prototype.cancelResetClickCount_ = function cancelResetClickCount_() {\n    if (this.resetId_ !== undefined) {\n      clearTimeout(this.resetId_);\n    }\n  };\n  /**\n   * @private\n   * @param {TouchEvent} browserEvent Browser event\n   * @param {Touch} inTouch Touch event\n   * @return {PointerEvent} A pointer object.\n   */\n\n\n  TouchSource.prototype.touchToPointer_ = function touchToPointer_(browserEvent, inTouch) {\n    var e = this.dispatcher.cloneEvent(browserEvent, inTouch); // Spec specifies that pointerId 1 is reserved for Mouse.\n    // Touch identifiers can start at 0.\n    // Add 2 to the touch identifier for compatibility.\n\n    e.pointerId = inTouch.identifier + 2; // TODO: check if this is necessary?\n    //e.target = findTarget(e);\n\n    e.bubbles = true;\n    e.cancelable = true;\n    e.detail = this.clickCount_;\n    e.button = 0;\n    e.buttons = 1;\n    e.width = inTouch.radiusX || 0;\n    e.height = inTouch.radiusY || 0;\n    e.pressure = inTouch.force || 0.5;\n    e.isPrimary = this.isPrimaryTouch_(inTouch);\n    e.pointerType = TouchSource_POINTER_TYPE; // make sure that the properties that are different for\n    // each `Touch` object are not copied from the BrowserEvent object\n\n    e.clientX = inTouch.clientX;\n    e.clientY = inTouch.clientY;\n    e.screenX = inTouch.screenX;\n    e.screenY = inTouch.screenY;\n    return e;\n  };\n  /**\n   * @private\n   * @param {TouchEvent} inEvent Touch event\n   * @param {function(TouchEvent, PointerEvent)} inFunction In function.\n   */\n\n\n  TouchSource.prototype.processTouches_ = function processTouches_(inEvent, inFunction) {\n    var touches = Array.prototype.slice.call(inEvent.changedTouches);\n    var count = touches.length;\n\n    function preventDefault() {\n      inEvent.preventDefault();\n    }\n\n    for (var i = 0; i < count; ++i) {\n      var pointer = this.touchToPointer_(inEvent, touches[i]); // forward touch preventDefaults\n\n      pointer.preventDefault = preventDefault;\n      inFunction.call(this, inEvent, pointer);\n    }\n  };\n  /**\n   * @private\n   * @param {TouchList} touchList The touch list.\n   * @param {number} searchId Search identifier.\n   * @return {boolean} True, if the `Touch` with the given id is in the list.\n   */\n\n\n  TouchSource.prototype.findTouch_ = function findTouch_(touchList, searchId) {\n    var l = touchList.length;\n\n    for (var i = 0; i < l; i++) {\n      var touch = touchList[i];\n\n      if (touch.identifier === searchId) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * In some instances, a touchstart can happen without a touchend. This\n   * leaves the pointermap in a broken state.\n   * Therefore, on every touchstart, we remove the touches that did not fire a\n   * touchend event.\n   * To keep state globally consistent, we fire a pointercancel for\n   * this "abandoned" touch\n   *\n   * @private\n   * @param {TouchEvent} inEvent The in event.\n   */\n\n\n  TouchSource.prototype.vacuumTouches_ = function vacuumTouches_(inEvent) {\n    var touchList = inEvent.touches; // pointerMap.getCount() should be < touchList.length here,\n    // as the touchstart has not been processed yet.\n\n    var keys = Object.keys(this.pointerMap);\n    var count = keys.length;\n\n    if (count >= touchList.length) {\n      var d = [];\n\n      for (var i = 0; i < count; ++i) {\n        var key = Number(keys[i]);\n        var value = this.pointerMap[key]; // Never remove pointerId == 1, which is mouse.\n        // Touch identifiers are 2 smaller than their pointerId, which is the\n        // index in pointermap.\n\n        if (key != POINTER_ID && !this.findTouch_(touchList, key - 2)) {\n          d.push(value.out);\n        }\n      }\n\n      for (var i$1 = 0; i$1 < d.length; ++i$1) {\n        this.cancelOut_(inEvent, d[i$1]);\n      }\n    }\n  };\n  /**\n   * @private\n   * @param {TouchEvent} browserEvent The event.\n   * @param {PointerEvent} inPointer The in pointer object.\n   */\n\n\n  TouchSource.prototype.overDown_ = function overDown_(browserEvent, inPointer) {\n    this.pointerMap[inPointer.pointerId] = {\n      target: inPointer.target,\n      out: inPointer,\n      outTarget: inPointer.target\n    };\n    this.dispatcher.over(inPointer, browserEvent);\n    this.dispatcher.enter(inPointer, browserEvent);\n    this.dispatcher.down(inPointer, browserEvent);\n  };\n  /**\n   * @private\n   * @param {TouchEvent} browserEvent The event.\n   * @param {PointerEvent} inPointer The in pointer.\n   */\n\n\n  TouchSource.prototype.moveOverOut_ = function moveOverOut_(browserEvent, inPointer) {\n    var event = inPointer;\n    var pointer = this.pointerMap[event.pointerId]; // a finger drifted off the screen, ignore it\n\n    if (!pointer) {\n      return;\n    }\n\n    var outEvent = pointer.out;\n    var outTarget = pointer.outTarget;\n    this.dispatcher.move(event, browserEvent);\n\n    if (outEvent && outTarget !== event.target) {\n      outEvent.relatedTarget = event.target;\n      /** @type {Object} */\n\n      event.relatedTarget = outTarget; // recover from retargeting by shadow\n\n      outEvent.target = outTarget;\n\n      if (event.target) {\n        this.dispatcher.leaveOut(outEvent, browserEvent);\n        this.dispatcher.enterOver(event, browserEvent);\n      } else {\n        // clean up case when finger leaves the screen\n\n        /** @type {Object} */\n        event.target = outTarget;\n        /** @type {Object} */\n\n        event.relatedTarget = null;\n        this.cancelOut_(browserEvent, event);\n      }\n    }\n\n    pointer.out = event;\n    pointer.outTarget = event.target;\n  };\n  /**\n   * @private\n   * @param {TouchEvent} browserEvent An event.\n   * @param {PointerEvent} inPointer The inPointer object.\n   */\n\n\n  TouchSource.prototype.upOut_ = function upOut_(browserEvent, inPointer) {\n    this.dispatcher.up(inPointer, browserEvent);\n    this.dispatcher.out(inPointer, browserEvent);\n    this.dispatcher.leave(inPointer, browserEvent);\n    this.cleanUpPointer_(inPointer);\n  };\n  /**\n   * @private\n   * @param {TouchEvent} browserEvent The event.\n   * @param {PointerEvent} inPointer The in pointer.\n   */\n\n\n  TouchSource.prototype.cancelOut_ = function cancelOut_(browserEvent, inPointer) {\n    this.dispatcher.cancel(inPointer, browserEvent);\n    this.dispatcher.out(inPointer, browserEvent);\n    this.dispatcher.leave(inPointer, browserEvent);\n    this.cleanUpPointer_(inPointer);\n  };\n  /**\n   * @private\n   * @param {PointerEvent} inPointer The inPointer object.\n   */\n\n\n  TouchSource.prototype.cleanUpPointer_ = function cleanUpPointer_(inPointer) {\n    delete this.pointerMap[inPointer.pointerId];\n    this.removePrimaryPointer_(inPointer);\n  };\n  /**\n   * Prevent synth mouse events from creating pointer events.\n   *\n   * @private\n   * @param {TouchEvent} inEvent The in event.\n   */\n\n\n  TouchSource.prototype.dedupSynthMouse_ = function dedupSynthMouse_(inEvent) {\n    var lts = this.mouseSource.lastTouches;\n    var t = inEvent.changedTouches[0]; // only the primary finger will synth mouse events\n\n    if (this.isPrimaryTouch_(t)) {\n      // remember x/y of last touch\n      var lt = [t.clientX, t.clientY];\n      lts.push(lt);\n      setTimeout(function () {\n        // remove touch after timeout\n        Object(array["h" /* remove */])(lts, lt);\n      }, this.dedupTimeout_);\n    }\n  };\n\n  return TouchSource;\n}(pointer_EventSource);\n\n/* harmony default export */ var pointer_TouchSource = (TouchSource_TouchSource);\n// CONCATENATED MODULE: ./node_modules/ol/pointer/PointerEventHandler.js\n/**\n * @module ol/pointer/PointerEventHandler\n */\n// Based on https://github.com/Polymer/PointerEvents\n// Copyright (c) 2013 The Polymer Authors. All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\n\n\n\n\n\n/**\n * Properties to copy when cloning an event, with default values.\n * @type {Array<Array>}\n */\n\nvar CLONE_PROPS = [// MouseEvent\n[\'bubbles\', false], [\'cancelable\', false], [\'view\', null], [\'detail\', null], [\'screenX\', 0], [\'screenY\', 0], [\'clientX\', 0], [\'clientY\', 0], [\'ctrlKey\', false], [\'altKey\', false], [\'shiftKey\', false], [\'metaKey\', false], [\'button\', 0], [\'relatedTarget\', null], // DOM Level 3\n[\'buttons\', 0], // PointerEvent\n[\'pointerId\', 0], [\'width\', 0], [\'height\', 0], [\'pressure\', 0], [\'tiltX\', 0], [\'tiltY\', 0], [\'pointerType\', \'\'], [\'hwTimestamp\', 0], [\'isPrimary\', false], // event instance\n[\'type\', \'\'], [\'target\', null], [\'currentTarget\', null], [\'which\', 0]];\n\nvar PointerEventHandler_PointerEventHandler =\n/*@__PURE__*/\nfunction (EventTarget) {\n  function PointerEventHandler(element) {\n    EventTarget.call(this);\n    /**\n     * @const\n     * @private\n     * @type {Element|HTMLDocument}\n     */\n\n    this.element_ = element;\n    /**\n     * @const\n     * @type {!Object<string, Event|Object>}\n     */\n\n    this.pointerMap = {};\n    /**\n     * @type {Object<string, function(Event)>}\n     * @private\n     */\n\n    this.eventMap_ = {};\n    /**\n     * @type {Array<import("./EventSource.js").default>}\n     * @private\n     */\n\n    this.eventSourceList_ = [];\n    this.registerSources();\n  }\n\n  if (EventTarget) PointerEventHandler.__proto__ = EventTarget;\n  PointerEventHandler.prototype = Object.create(EventTarget && EventTarget.prototype);\n  PointerEventHandler.prototype.constructor = PointerEventHandler;\n  /**\n   * Set up the event sources (mouse, touch and native pointers)\n   * that generate pointer events.\n   */\n\n  PointerEventHandler.prototype.registerSources = function registerSources() {\n    if (has["g" /* POINTER */]) {\n      this.registerSource(\'native\', new pointer_NativeSource(this));\n    } else if (has["f" /* MSPOINTER */]) {\n      this.registerSource(\'ms\', new pointer_MsSource(this));\n    } else {\n      var mouseSource = new pointer_MouseSource(this);\n      this.registerSource(\'mouse\', mouseSource);\n\n      if (has["i" /* TOUCH */]) {\n        this.registerSource(\'touch\', new pointer_TouchSource(this, mouseSource));\n      }\n    } // register events on the viewport element\n\n\n    this.register_();\n  };\n  /**\n   * Add a new event source that will generate pointer events.\n   *\n   * @param {string} name A name for the event source\n   * @param {import("./EventSource.js").default} source The source event.\n   */\n\n\n  PointerEventHandler.prototype.registerSource = function registerSource(name, source) {\n    var s = source;\n    var newEvents = s.getEvents();\n\n    if (newEvents) {\n      newEvents.forEach(function (e) {\n        var handler = s.getHandlerForEvent(e);\n\n        if (handler) {\n          this.eventMap_[e] = handler.bind(s);\n        }\n      }.bind(this));\n      this.eventSourceList_.push(s);\n    }\n  };\n  /**\n   * Set up the events for all registered event sources.\n   * @private\n   */\n\n\n  PointerEventHandler.prototype.register_ = function register_() {\n    var l = this.eventSourceList_.length;\n\n    for (var i = 0; i < l; i++) {\n      var eventSource = this.eventSourceList_[i];\n      this.addEvents_(eventSource.getEvents());\n    }\n  };\n  /**\n   * Remove all registered events.\n   * @private\n   */\n\n\n  PointerEventHandler.prototype.unregister_ = function unregister_() {\n    var l = this.eventSourceList_.length;\n\n    for (var i = 0; i < l; i++) {\n      var eventSource = this.eventSourceList_[i];\n      this.removeEvents_(eventSource.getEvents());\n    }\n  };\n  /**\n   * Calls the right handler for a new event.\n   * @private\n   * @param {Event} inEvent Browser event.\n   */\n\n\n  PointerEventHandler.prototype.eventHandler_ = function eventHandler_(inEvent) {\n    var type = inEvent.type;\n    var handler = this.eventMap_[type];\n\n    if (handler) {\n      handler(inEvent);\n    }\n  };\n  /**\n   * Setup listeners for the given events.\n   * @private\n   * @param {Array<string>} events List of events.\n   */\n\n\n  PointerEventHandler.prototype.addEvents_ = function addEvents_(events) {\n    events.forEach(function (eventName) {\n      Object(ol_events["a" /* listen */])(this.element_, eventName, this.eventHandler_, this);\n    }.bind(this));\n  };\n  /**\n   * Unregister listeners for the given events.\n   * @private\n   * @param {Array<string>} events List of events.\n   */\n\n\n  PointerEventHandler.prototype.removeEvents_ = function removeEvents_(events) {\n    events.forEach(function (e) {\n      Object(ol_events["c" /* unlisten */])(this.element_, e, this.eventHandler_, this);\n    }.bind(this));\n  };\n  /**\n   * Returns a snapshot of inEvent, with writable properties.\n   *\n   * @param {Event} event Browser event.\n   * @param {Event|Touch} inEvent An event that contains\n   *    properties to copy.\n   * @return {Object} An object containing shallow copies of\n   *    `inEvent`\'s properties.\n   */\n\n\n  PointerEventHandler.prototype.cloneEvent = function cloneEvent(event, inEvent) {\n    var eventCopy = {};\n\n    for (var i = 0, ii = CLONE_PROPS.length; i < ii; i++) {\n      var p = CLONE_PROPS[i][0];\n      eventCopy[p] = event[p] || inEvent[p] || CLONE_PROPS[i][1];\n    }\n\n    return eventCopy;\n  }; // EVENTS\n\n  /**\n   * Triggers a \'pointerdown\' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.down = function down(data, event) {\n    this.fireEvent(EventType.POINTERDOWN, data, event);\n  };\n  /**\n   * Triggers a \'pointermove\' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.move = function move(data, event) {\n    this.fireEvent(EventType.POINTERMOVE, data, event);\n  };\n  /**\n   * Triggers a \'pointerup\' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.up = function up(data, event) {\n    this.fireEvent(EventType.POINTERUP, data, event);\n  };\n  /**\n   * Triggers a \'pointerenter\' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.enter = function enter(data, event) {\n    data.bubbles = false;\n    this.fireEvent(EventType.POINTERENTER, data, event);\n  };\n  /**\n   * Triggers a \'pointerleave\' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.leave = function leave(data, event) {\n    data.bubbles = false;\n    this.fireEvent(EventType.POINTERLEAVE, data, event);\n  };\n  /**\n   * Triggers a \'pointerover\' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.over = function over(data, event) {\n    data.bubbles = true;\n    this.fireEvent(EventType.POINTEROVER, data, event);\n  };\n  /**\n   * Triggers a \'pointerout\' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.out = function out(data, event) {\n    data.bubbles = true;\n    this.fireEvent(EventType.POINTEROUT, data, event);\n  };\n  /**\n   * Triggers a \'pointercancel\' event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.cancel = function cancel(data, event) {\n    this.fireEvent(EventType.POINTERCANCEL, data, event);\n  };\n  /**\n   * Triggers a combination of \'pointerout\' and \'pointerleave\' events.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.leaveOut = function leaveOut(data, event) {\n    this.out(data, event);\n\n    if (!this.contains_(data.target, data.relatedTarget)) {\n      this.leave(data, event);\n    }\n  };\n  /**\n   * Triggers a combination of \'pointerover\' and \'pointerevents\' events.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.enterOver = function enterOver(data, event) {\n    this.over(data, event);\n\n    if (!this.contains_(data.target, data.relatedTarget)) {\n      this.enter(data, event);\n    }\n  };\n  /**\n   * @private\n   * @param {Element} container The container element.\n   * @param {Element} contained The contained element.\n   * @return {boolean} Returns true if the container element\n   *   contains the other element.\n   */\n\n\n  PointerEventHandler.prototype.contains_ = function contains_(container, contained) {\n    if (!container || !contained) {\n      return false;\n    }\n\n    return container.contains(contained);\n  }; // EVENT CREATION AND TRACKING\n\n  /**\n   * Creates a new Event of type `inType`, based on the information in\n   * `data`.\n   *\n   * @param {string} inType A string representing the type of event to create.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   * @return {PointerEvent} A PointerEvent of type `inType`.\n   */\n\n\n  PointerEventHandler.prototype.makeEvent = function makeEvent(inType, data, event) {\n    return new pointer_PointerEvent(inType, event, data);\n  };\n  /**\n   * Make and dispatch an event in one call.\n   * @param {string} inType A string representing the type of event.\n   * @param {Object} data Pointer event data.\n   * @param {Event} event The event.\n   */\n\n\n  PointerEventHandler.prototype.fireEvent = function fireEvent(inType, data, event) {\n    var e = this.makeEvent(inType, data, event);\n    this.dispatchEvent(e);\n  };\n  /**\n   * Creates a pointer event from a native pointer event\n   * and dispatches this event.\n   * @param {Event} event A platform event with a target.\n   */\n\n\n  PointerEventHandler.prototype.fireNativeEvent = function fireNativeEvent(event) {\n    var e = this.makeEvent(event.type, event, event);\n    this.dispatchEvent(e);\n  };\n  /**\n   * Wrap a native mouse event into a pointer event.\n   * This proxy method is required for the legacy IE support.\n   * @param {string} eventType The pointer event type.\n   * @param {Event} event The event.\n   * @return {PointerEvent} The wrapped event.\n   */\n\n\n  PointerEventHandler.prototype.wrapMouseEvent = function wrapMouseEvent(eventType, event) {\n    var pointerEvent = this.makeEvent(eventType, prepareEvent(event, this), event);\n    return pointerEvent;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  PointerEventHandler.prototype.disposeInternal = function disposeInternal() {\n    this.unregister_();\n    EventTarget.prototype.disposeInternal.call(this);\n  };\n\n  return PointerEventHandler;\n}(Target["a" /* default */]);\n\n/* harmony default export */ var pointer_PointerEventHandler = (PointerEventHandler_PointerEventHandler);\n// CONCATENATED MODULE: ./node_modules/ol/MapBrowserEventHandler.js\n/**\n * @module ol/MapBrowserEventHandler\n */\n\n\n\n\n\n\n\n\nvar MapBrowserEventHandler_MapBrowserEventHandler =\n/*@__PURE__*/\nfunction (EventTarget) {\n  function MapBrowserEventHandler(map, moveTolerance) {\n    EventTarget.call(this);\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import("./PluggableMap.js").default}\n     * @private\n     */\n\n    this.map_ = map;\n    /**\n     * @type {any}\n     * @private\n     */\n\n    this.clickTimeoutId_;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.dragging_ = false;\n    /**\n     * @type {!Array<import("./events.js").EventsKey>}\n     * @private\n     */\n\n    this.dragListenerKeys_ = [];\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.moveTolerance_ = moveTolerance ? moveTolerance * has["b" /* DEVICE_PIXEL_RATIO */] : has["b" /* DEVICE_PIXEL_RATIO */];\n    /**\n     * The most recent "down" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {import("./pointer/PointerEvent.js").default}\n     * @private\n     */\n\n    this.down_ = null;\n    var element = this.map_.getViewport();\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.activePointers_ = 0;\n    /**\n     * @type {!Object<number, boolean>}\n     * @private\n     */\n\n    this.trackedTouches_ = {};\n    /**\n     * Event handler which generates pointer events for\n     * the viewport element.\n     *\n     * @type {PointerEventHandler}\n     * @private\n     */\n\n    this.pointerEventHandler_ = new pointer_PointerEventHandler(element);\n    /**\n     * Event handler which generates pointer events for\n     * the document (used when dragging).\n     *\n     * @type {PointerEventHandler}\n     * @private\n     */\n\n    this.documentPointerEventHandler_ = null;\n    /**\n     * @type {?import("./events.js").EventsKey}\n     * @private\n     */\n\n    this.pointerdownListenerKey_ = Object(ol_events["a" /* listen */])(this.pointerEventHandler_, EventType.POINTERDOWN, this.handlePointerDown_, this);\n    /**\n     * @type {?import("./events.js").EventsKey}\n     * @private\n     */\n\n    this.relayedListenerKey_ = Object(ol_events["a" /* listen */])(this.pointerEventHandler_, EventType.POINTERMOVE, this.relayEvent_, this);\n  }\n\n  if (EventTarget) MapBrowserEventHandler.__proto__ = EventTarget;\n  MapBrowserEventHandler.prototype = Object.create(EventTarget && EventTarget.prototype);\n  MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;\n  /**\n   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n  MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_(pointerEvent) {\n    var newEvent = new ol_MapBrowserPointerEvent(MapBrowserEventType["a" /* default */].CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new ol_MapBrowserPointerEvent(MapBrowserEventType["a" /* default */].DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(function () {\n        this.clickTimeoutId_ = undefined;\n        var newEvent = new ol_MapBrowserPointerEvent(MapBrowserEventType["a" /* default */].SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_(pointerEvent) {\n    var event = pointerEvent;\n\n    if (event.type == MapBrowserEventType["a" /* default */].POINTERUP || event.type == MapBrowserEventType["a" /* default */].POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == MapBrowserEventType["a" /* default */].POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  };\n  /**\n   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new ol_MapBrowserPointerEvent(MapBrowserEventType["a" /* default */].POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n\n    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(ol_events["e" /* unlistenByKey */]);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n  };\n  /**\n   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n  /**\n   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new ol_MapBrowserPointerEvent(MapBrowserEventType["a" /* default */].POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    this.down_ = pointerEvent;\n\n    if (this.dragListenerKeys_.length === 0) {\n      /* Set up a pointer event handler on the `document`,\n       * which is required when the pointer is moved outside\n       * the viewport when dragging.\n       */\n      this.documentPointerEventHandler_ = new pointer_PointerEventHandler(document);\n      this.dragListenerKeys_.push(Object(ol_events["a" /* listen */])(this.documentPointerEventHandler_, MapBrowserEventType["a" /* default */].POINTERMOVE, this.handlePointerMove_, this), Object(ol_events["a" /* listen */])(this.documentPointerEventHandler_, MapBrowserEventType["a" /* default */].POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let\'s say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn\'t know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      Object(ol_events["a" /* listen */])(this.pointerEventHandler_, MapBrowserEventType["a" /* default */].POINTERCANCEL, this.handlePointerUp_, this));\n    }\n  };\n  /**\n   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a \'false\' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      var newEvent = new ol_MapBrowserPointerEvent(MapBrowserEventType["a" /* default */].POINTERDRAG, this.map_, pointerEvent, this.dragging_);\n      this.dispatchEvent(newEvent);\n    } // Some native android browser triggers mousemove events during small period\n    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n    // https://code.google.com/p/android/issues/detail?id=19827\n    // ex: Galaxy Tab P3110 + Android 4.1.1\n\n\n    pointerEvent.preventDefault();\n  };\n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserPointerEvent matches the PointerEvent type.\n   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_(pointerEvent) {\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new ol_MapBrowserPointerEvent(pointerEvent.type, this.map_, pointerEvent, dragging));\n  };\n  /**\n   * @param {import("./pointer/PointerEvent.js").default} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n\n\n  MapBrowserEventHandler.prototype.isMoving_ = function isMoving_(pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal() {\n    if (this.relayedListenerKey_) {\n      Object(ol_events["e" /* unlistenByKey */])(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n\n    if (this.pointerdownListenerKey_) {\n      Object(ol_events["e" /* unlistenByKey */])(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(ol_events["e" /* unlistenByKey */]);\n    this.dragListenerKeys_.length = 0;\n\n    if (this.documentPointerEventHandler_) {\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n\n    if (this.pointerEventHandler_) {\n      this.pointerEventHandler_.dispose();\n      this.pointerEventHandler_ = null;\n    }\n\n    EventTarget.prototype.disposeInternal.call(this);\n  };\n\n  return MapBrowserEventHandler;\n}(Target["a" /* default */]);\n\n/* harmony default export */ var ol_MapBrowserEventHandler = (MapBrowserEventHandler_MapBrowserEventHandler);\n// EXTERNAL MODULE: ./node_modules/ol/MapEventType.js\nvar MapEventType = __webpack_require__(76);\n\n// CONCATENATED MODULE: ./node_modules/ol/MapProperty.js\n/**\n * @module ol/MapProperty\n */\n\n/**\n * @enum {string}\n */\n/* harmony default export */ var MapProperty = ({\n  LAYERGROUP: \'layergroup\',\n  SIZE: \'size\',\n  TARGET: \'target\',\n  VIEW: \'view\'\n});\n// EXTERNAL MODULE: ./node_modules/ol/render/EventType.js\nvar render_EventType = __webpack_require__(38);\n\n// EXTERNAL MODULE: ./node_modules/ol/Object.js\nvar ol_Object = __webpack_require__(15);\n\n// EXTERNAL MODULE: ./node_modules/ol/ObjectEventType.js\nvar ObjectEventType = __webpack_require__(54);\n\n// EXTERNAL MODULE: ./node_modules/ol/TileState.js\nvar TileState = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar events_EventType = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(11);\n\n// EXTERNAL MODULE: ./node_modules/ol/obj.js\nvar obj = __webpack_require__(12);\n\n// CONCATENATED MODULE: ./node_modules/ol/structs/PriorityQueue.js\n/**\n * @module ol/structs/PriorityQueue\n */\n\n\n/**\n * @type {number}\n */\n\nvar DROP = Infinity;\n/**\n * @classdesc\n * Priority queue.\n *\n * The implementation is inspired from the Closure Library\'s Heap class and\n * Python\'s heapq module.\n *\n * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html\n * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.\n *\n * @template T\n */\n\nvar PriorityQueue_PriorityQueue = function PriorityQueue(priorityFunction, keyFunction) {\n  /**\n   * @type {function(T): number}\n   * @private\n   */\n  this.priorityFunction_ = priorityFunction;\n  /**\n   * @type {function(T): string}\n   * @private\n   */\n\n  this.keyFunction_ = keyFunction;\n  /**\n   * @type {Array<T>}\n   * @private\n   */\n\n  this.elements_ = [];\n  /**\n   * @type {Array<number>}\n   * @private\n   */\n\n  this.priorities_ = [];\n  /**\n   * @type {!Object<string, boolean>}\n   * @private\n   */\n\n  this.queuedElements_ = {};\n};\n/**\n * FIXME empty description for jsdoc\n */\n\n\nPriorityQueue_PriorityQueue.prototype.clear = function clear$1() {\n  this.elements_.length = 0;\n  this.priorities_.length = 0;\n  Object(obj["b" /* clear */])(this.queuedElements_);\n};\n/**\n * Remove and return the highest-priority element. O(log N).\n * @return {T} Element.\n */\n\n\nPriorityQueue_PriorityQueue.prototype.dequeue = function dequeue() {\n  var elements = this.elements_;\n  var priorities = this.priorities_;\n  var element = elements[0];\n\n  if (elements.length == 1) {\n    elements.length = 0;\n    priorities.length = 0;\n  } else {\n    elements[0] = elements.pop();\n    priorities[0] = priorities.pop();\n    this.siftUp_(0);\n  }\n\n  var elementKey = this.keyFunction_(element);\n  delete this.queuedElements_[elementKey];\n  return element;\n};\n/**\n * Enqueue an element. O(log N).\n * @param {T} element Element.\n * @return {boolean} The element was added to the queue.\n */\n\n\nPriorityQueue_PriorityQueue.prototype.enqueue = function enqueue(element) {\n  Object(asserts["a" /* assert */])(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue\n\n  var priority = this.priorityFunction_(element);\n\n  if (priority != DROP) {\n    this.elements_.push(element);\n    this.priorities_.push(priority);\n    this.queuedElements_[this.keyFunction_(element)] = true;\n    this.siftDown_(0, this.elements_.length - 1);\n    return true;\n  }\n\n  return false;\n};\n/**\n * @return {number} Count.\n */\n\n\nPriorityQueue_PriorityQueue.prototype.getCount = function getCount() {\n  return this.elements_.length;\n};\n/**\n * Gets the index of the left child of the node at the given index.\n * @param {number} index The index of the node to get the left child for.\n * @return {number} The index of the left child.\n * @private\n */\n\n\nPriorityQueue_PriorityQueue.prototype.getLeftChildIndex_ = function getLeftChildIndex_(index) {\n  return index * 2 + 1;\n};\n/**\n * Gets the index of the right child of the node at the given index.\n * @param {number} index The index of the node to get the right child for.\n * @return {number} The index of the right child.\n * @private\n */\n\n\nPriorityQueue_PriorityQueue.prototype.getRightChildIndex_ = function getRightChildIndex_(index) {\n  return index * 2 + 2;\n};\n/**\n * Gets the index of the parent of the node at the given index.\n * @param {number} index The index of the node to get the parent for.\n * @return {number} The index of the parent.\n * @private\n */\n\n\nPriorityQueue_PriorityQueue.prototype.getParentIndex_ = function getParentIndex_(index) {\n  return index - 1 >> 1;\n};\n/**\n * Make this a heap. O(N).\n * @private\n */\n\n\nPriorityQueue_PriorityQueue.prototype.heapify_ = function heapify_() {\n  var i;\n\n  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {\n    this.siftUp_(i);\n  }\n};\n/**\n * @return {boolean} Is empty.\n */\n\n\nPriorityQueue_PriorityQueue.prototype.isEmpty = function isEmpty() {\n  return this.elements_.length === 0;\n};\n/**\n * @param {string} key Key.\n * @return {boolean} Is key queued.\n */\n\n\nPriorityQueue_PriorityQueue.prototype.isKeyQueued = function isKeyQueued(key) {\n  return key in this.queuedElements_;\n};\n/**\n * @param {T} element Element.\n * @return {boolean} Is queued.\n */\n\n\nPriorityQueue_PriorityQueue.prototype.isQueued = function isQueued(element) {\n  return this.isKeyQueued(this.keyFunction_(element));\n};\n/**\n * @param {number} index The index of the node to move down.\n * @private\n */\n\n\nPriorityQueue_PriorityQueue.prototype.siftUp_ = function siftUp_(index) {\n  var elements = this.elements_;\n  var priorities = this.priorities_;\n  var count = elements.length;\n  var element = elements[index];\n  var priority = priorities[index];\n  var startIndex = index;\n\n  while (index < count >> 1) {\n    var lIndex = this.getLeftChildIndex_(index);\n    var rIndex = this.getRightChildIndex_(index);\n    var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;\n    elements[index] = elements[smallerChildIndex];\n    priorities[index] = priorities[smallerChildIndex];\n    index = smallerChildIndex;\n  }\n\n  elements[index] = element;\n  priorities[index] = priority;\n  this.siftDown_(startIndex, index);\n};\n/**\n * @param {number} startIndex The index of the root.\n * @param {number} index The index of the node to move up.\n * @private\n */\n\n\nPriorityQueue_PriorityQueue.prototype.siftDown_ = function siftDown_(startIndex, index) {\n  var elements = this.elements_;\n  var priorities = this.priorities_;\n  var element = elements[index];\n  var priority = priorities[index];\n\n  while (index > startIndex) {\n    var parentIndex = this.getParentIndex_(index);\n\n    if (priorities[parentIndex] > priority) {\n      elements[index] = elements[parentIndex];\n      priorities[index] = priorities[parentIndex];\n      index = parentIndex;\n    } else {\n      break;\n    }\n  }\n\n  elements[index] = element;\n  priorities[index] = priority;\n};\n/**\n * FIXME empty description for jsdoc\n */\n\n\nPriorityQueue_PriorityQueue.prototype.reprioritize = function reprioritize() {\n  var priorityFunction = this.priorityFunction_;\n  var elements = this.elements_;\n  var priorities = this.priorities_;\n  var index = 0;\n  var n = elements.length;\n  var element, i, priority;\n\n  for (i = 0; i < n; ++i) {\n    element = elements[i];\n    priority = priorityFunction(element);\n\n    if (priority == DROP) {\n      delete this.queuedElements_[this.keyFunction_(element)];\n    } else {\n      priorities[index] = priority;\n      elements[index++] = element;\n    }\n  }\n\n  elements.length = index;\n  priorities.length = index;\n  this.heapify_();\n};\n\n/* harmony default export */ var structs_PriorityQueue = (PriorityQueue_PriorityQueue);\n// CONCATENATED MODULE: ./node_modules/ol/TileQueue.js\n/**\n * @module ol/TileQueue\n */\n\n\n\n\n/**\n * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction\n */\n\nvar TileQueue_TileQueue =\n/*@__PURE__*/\nfunction (PriorityQueue) {\n  function TileQueue(tilePriorityFunction, tileChangeCallback) {\n    PriorityQueue.call(\n    /**\n     * @param {Array} element Element.\n     * @return {number} Priority.\n     */\n    this, function (element) {\n      return tilePriorityFunction.apply(null, element);\n    },\n    /**\n     * @param {Array} element Element.\n     * @return {string} Key.\n     */\n    function (element) {\n      return (\n        /** @type {import("./Tile.js").default} */\n        element[0].getKey()\n      );\n    });\n    /**\n     * @private\n     * @type {function(): ?}\n     */\n\n    this.tileChangeCallback_ = tileChangeCallback;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.tilesLoading_ = 0;\n    /**\n     * @private\n     * @type {!Object<string,boolean>}\n     */\n\n    this.tilesLoadingKeys_ = {};\n  }\n\n  if (PriorityQueue) TileQueue.__proto__ = PriorityQueue;\n  TileQueue.prototype = Object.create(PriorityQueue && PriorityQueue.prototype);\n  TileQueue.prototype.constructor = TileQueue;\n  /**\n   * @inheritDoc\n   */\n\n  TileQueue.prototype.enqueue = function enqueue(element) {\n    var added = PriorityQueue.prototype.enqueue.call(this, element);\n\n    if (added) {\n      var tile = element[0];\n      Object(ol_events["a" /* listen */])(tile, events_EventType["a" /* default */].CHANGE, this.handleTileChange, this);\n    }\n\n    return added;\n  };\n  /**\n   * @return {number} Number of tiles loading.\n   */\n\n\n  TileQueue.prototype.getTilesLoading = function getTilesLoading() {\n    return this.tilesLoading_;\n  };\n  /**\n   * @param {import("./events/Event.js").default} event Event.\n   * @protected\n   */\n\n\n  TileQueue.prototype.handleTileChange = function handleTileChange(event) {\n    var tile =\n    /** @type {import("./Tile.js").default} */\n    event.target;\n    var state = tile.getState();\n\n    if (state === TileState["a" /* default */].LOADED || state === TileState["a" /* default */].ERROR || state === TileState["a" /* default */].EMPTY || state === TileState["a" /* default */].ABORT) {\n      Object(ol_events["c" /* unlisten */])(tile, events_EventType["a" /* default */].CHANGE, this.handleTileChange, this);\n      var tileKey = tile.getKey();\n\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n\n      this.tileChangeCallback_();\n    }\n  };\n  /**\n   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n   * @param {number} maxNewLoads Maximum number of new tiles to load.\n   */\n\n\n  TileQueue.prototype.loadMoreTiles = function loadMoreTiles(maxTotalLoading, maxNewLoads) {\n    var newLoads = 0;\n    var abortedTiles = false;\n    var state, tile, tileKey;\n\n    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {\n      tile =\n      /** @type {import("./Tile.js").default} */\n      this.dequeue()[0];\n      tileKey = tile.getKey();\n      state = tile.getState();\n\n      if (state === TileState["a" /* default */].ABORT) {\n        abortedTiles = true;\n      } else if (state === TileState["a" /* default */].IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile.load();\n      }\n    }\n\n    if (newLoads === 0 && abortedTiles) {\n      // Do not stop the render loop when all wanted tiles were aborted due to\n      // a small, saturated tile cache.\n      this.tileChangeCallback_();\n    }\n  };\n\n  return TileQueue;\n}(structs_PriorityQueue);\n\n/* harmony default export */ var ol_TileQueue = (TileQueue_TileQueue);\n// EXTERNAL MODULE: ./node_modules/ol/View.js + 4 modules\nvar View = __webpack_require__(107);\n\n// EXTERNAL MODULE: ./node_modules/ol/ViewHint.js\nvar ViewHint = __webpack_require__(18);\n\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/functions.js\nvar functions = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/ol/layer/Base.js\nvar Base = __webpack_require__(93);\n\n// EXTERNAL MODULE: ./node_modules/ol/source/State.js\nvar State = __webpack_require__(45);\n\n// CONCATENATED MODULE: ./node_modules/ol/layer/Group.js\n/**\n * @module ol/layer/Group\n */\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map\'s `layers` collection, or `Infinity` when the layer\'s `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.\n */\n\n/**\n * @enum {string}\n * @private\n */\n\nvar Property = {\n  LAYERS: \'layers\'\n};\n/**\n * @classdesc\n * A {@link module:ol/Collection~Collection} of layers that are handled together.\n *\n * A generic `change` event is triggered when the group/Collection changes.\n *\n * @api\n */\n\nvar Group_LayerGroup =\n/*@__PURE__*/\nfunction (BaseLayer) {\n  function LayerGroup(opt_options) {\n    var options = opt_options || {};\n    var baseOptions =\n    /** @type {Options} */\n    Object(obj["a" /* assign */])({}, options);\n    delete baseOptions.layers;\n    var layers = options.layers;\n    BaseLayer.call(this, baseOptions);\n    /**\n     * @private\n     * @type {Array<import("../events.js").EventsKey>}\n     */\n\n    this.layersListenerKeys_ = [];\n    /**\n     * @private\n     * @type {Object<string, Array<import("../events.js").EventsKey>>}\n     */\n\n    this.listenerKeys_ = {};\n    Object(ol_events["a" /* listen */])(this, Object(ol_Object["b" /* getChangeEventType */])(Property.LAYERS), this.handleLayersChanged_, this);\n\n    if (layers) {\n      if (Array.isArray(layers)) {\n        layers = new Collection["a" /* default */](layers.slice(), {\n          unique: true\n        });\n      } else {\n        Object(asserts["a" /* assert */])(typeof\n        /** @type {?} */\n        layers.getArray === \'function\', 43); // Expected `layers` to be an array or a `Collection`\n      }\n    } else {\n      layers = new Collection["a" /* default */](undefined, {\n        unique: true\n      });\n    }\n\n    this.setLayers(layers);\n  }\n\n  if (BaseLayer) LayerGroup.__proto__ = BaseLayer;\n  LayerGroup.prototype = Object.create(BaseLayer && BaseLayer.prototype);\n  LayerGroup.prototype.constructor = LayerGroup;\n  /**\n   * @private\n   */\n\n  LayerGroup.prototype.handleLayerChange_ = function handleLayerChange_() {\n    this.changed();\n  };\n  /**\n   * @private\n   */\n\n\n  LayerGroup.prototype.handleLayersChanged_ = function handleLayersChanged_() {\n    this.layersListenerKeys_.forEach(ol_events["e" /* unlistenByKey */]);\n    this.layersListenerKeys_.length = 0;\n    var layers = this.getLayers();\n    this.layersListenerKeys_.push(Object(ol_events["a" /* listen */])(layers, CollectionEventType["a" /* default */].ADD, this.handleLayersAdd_, this), Object(ol_events["a" /* listen */])(layers, CollectionEventType["a" /* default */].REMOVE, this.handleLayersRemove_, this));\n\n    for (var id in this.listenerKeys_) {\n      this.listenerKeys_[id].forEach(ol_events["e" /* unlistenByKey */]);\n    }\n\n    Object(obj["b" /* clear */])(this.listenerKeys_);\n    var layersArray = layers.getArray();\n\n    for (var i = 0, ii = layersArray.length; i < ii; i++) {\n      var layer = layersArray[i];\n      this.listenerKeys_[Object(util["c" /* getUid */])(layer)] = [Object(ol_events["a" /* listen */])(layer, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.handleLayerChange_, this), Object(ol_events["a" /* listen */])(layer, events_EventType["a" /* default */].CHANGE, this.handleLayerChange_, this)];\n    }\n\n    this.changed();\n  };\n  /**\n   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.\n   * @private\n   */\n\n\n  LayerGroup.prototype.handleLayersAdd_ = function handleLayersAdd_(collectionEvent) {\n    var layer =\n    /** @type {import("./Base.js").default} */\n    collectionEvent.element;\n    this.listenerKeys_[Object(util["c" /* getUid */])(layer)] = [Object(ol_events["a" /* listen */])(layer, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.handleLayerChange_, this), Object(ol_events["a" /* listen */])(layer, events_EventType["a" /* default */].CHANGE, this.handleLayerChange_, this)];\n    this.changed();\n  };\n  /**\n   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.\n   * @private\n   */\n\n\n  LayerGroup.prototype.handleLayersRemove_ = function handleLayersRemove_(collectionEvent) {\n    var layer =\n    /** @type {import("./Base.js").default} */\n    collectionEvent.element;\n    var key = Object(util["c" /* getUid */])(layer);\n    this.listenerKeys_[key].forEach(ol_events["e" /* unlistenByKey */]);\n    delete this.listenerKeys_[key];\n    this.changed();\n  };\n  /**\n   * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n   * in this group.\n   * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of\n   *   {@link module:ol/layer/Base layers} that are part of this group.\n   * @observable\n   * @api\n   */\n\n\n  LayerGroup.prototype.getLayers = function getLayers() {\n    return (\n      /** @type {!import("../Collection.js").default<import("./Base.js").default>} */\n      this.get(Property.LAYERS)\n    );\n  };\n  /**\n   * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}\n   * in this group.\n   * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of\n   *   {@link module:ol/layer/Base layers} that are part of this group.\n   * @observable\n   * @api\n   */\n\n\n  LayerGroup.prototype.setLayers = function setLayers(layers) {\n    this.set(Property.LAYERS, layers);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LayerGroup.prototype.getLayersArray = function getLayersArray(opt_array) {\n    var array = opt_array !== undefined ? opt_array : [];\n    this.getLayers().forEach(function (layer) {\n      layer.getLayersArray(array);\n    });\n    return array;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LayerGroup.prototype.getLayerStatesArray = function getLayerStatesArray(opt_states) {\n    var states = opt_states !== undefined ? opt_states : [];\n    var pos = states.length;\n    this.getLayers().forEach(function (layer) {\n      layer.getLayerStatesArray(states);\n    });\n    var ownLayerState = this.getLayerState();\n\n    for (var i = pos, ii = states.length; i < ii; i++) {\n      var layerState = states[i];\n      layerState.opacity *= ownLayerState.opacity;\n      layerState.visible = layerState.visible && ownLayerState.visible;\n      layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);\n      layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);\n\n      if (ownLayerState.extent !== undefined) {\n        if (layerState.extent !== undefined) {\n          layerState.extent = Object(ol_extent["getIntersection"])(layerState.extent, ownLayerState.extent);\n        } else {\n          layerState.extent = ownLayerState.extent;\n        }\n      }\n    }\n\n    return states;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  LayerGroup.prototype.getSourceState = function getSourceState() {\n    return State["a" /* default */].READY;\n  };\n\n  return LayerGroup;\n}(Base["a" /* default */]);\n\n/* harmony default export */ var Group = (Group_LayerGroup);\n// EXTERNAL MODULE: ./node_modules/ol/size.js\nvar ol_size = __webpack_require__(42);\n\n// EXTERNAL MODULE: ./node_modules/ol/transform.js\nvar transform = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./node_modules/ol/PluggableMap.js\n/**\n * @module ol/PluggableMap\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import("./View.js").State} viewState The state of the current view.\n * @property {boolean} animate\n * @property {import("./transform.js").Transform} coordinateToPixelTransform\n * @property {null|import("./extent.js").Extent} extent\n * @property {import("./coordinate.js").Coordinate} focus\n * @property {number} index\n * @property {Object<string, import("./layer/Layer.js").State>} layerStates\n * @property {Array<import("./layer/Layer.js").State>} layerStatesArray\n * @property {import("./transform.js").Transform} pixelToCoordinateTransform\n * @property {Array<PostRenderFunction>} postRenderFunctions\n * @property {import("./size.js").Size} size\n * @property {!Object<string, boolean>} skippedFeatureUids\n * @property {TileQueue} tileQueue\n * @property {Object<string, Object<string, import("./TileRange.js").default>>} usedTiles\n * @property {Array<number>} viewHints\n * @property {!Object<string, Object<string, boolean>>} wantedTiles\n */\n\n/**\n * @typedef {function(PluggableMap, ?FrameState): boolean} PostRenderFunction\n */\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import("./layer/Layer.js").default): boolean} layerFilter Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels\n * inside the radius around the given position will be checked for features. This only\n * works for the canvas renderer and not for WebGL.\n */\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import("./control/Control.js").default>} [controls]\n * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]\n * @property {HTMLElement|Document} keyboardEventTarget\n * @property {Collection<import("./Overlay.js").default>} overlays\n * @property {Object<string, *>} values\n */\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control~defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction~defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles\n * will be loaded during animations. This may improve the user experience, but\n * can also make animations stutter on devices with slow memory.\n * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,\n * tiles will be loaded while interacting with the map. This may improve the\n * user experience, but can also make map panning and zooming choppy on devices\n * with slow memory.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered.\n * @property {View} [view] The map\'s view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n/**\n * @fires import("./MapBrowserEvent.js").MapBrowserEvent\n * @fires import("./MapEvent.js").MapEvent\n * @fires module:ol/render/Event~RenderEvent#postcompose\n * @fires module:ol/render/Event~RenderEvent#precompose\n * @fires module:ol/render/Event~RenderEvent#rendercomplete\n * @api\n */\n\nvar PluggableMap_PluggableMap =\n/*@__PURE__*/\nfunction (BaseObject) {\n  function PluggableMap(options) {\n    BaseObject.call(this);\n    var optionsInternal = createOptionsInternal(options);\n    /**\n     * @type {number}\n     * @private\n     */\n\n    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;\n    /**\n     * @type {boolean}\n     * @private\n     */\n\n    this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : has["b" /* DEVICE_PIXEL_RATIO */];\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n\n    this.animationDelayKey_;\n    /**\n     * @private\n     */\n\n    this.animationDelay_ = function () {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_.call(this, Date.now());\n    }.bind(this);\n    /**\n     * @private\n     * @type {import("./transform.js").Transform}\n     */\n\n\n    this.coordinateToPixelTransform_ = Object(transform["c" /* create */])();\n    /**\n     * @private\n     * @type {import("./transform.js").Transform}\n     */\n\n    this.pixelToCoordinateTransform_ = Object(transform["c" /* create */])();\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.frameIndex_ = 0;\n    /**\n     * @private\n     * @type {?FrameState}\n     */\n\n    this.frameState_ = null;\n    /**\n     * The extent at the previous \'moveend\' event.\n     * @private\n     * @type {import("./extent.js").Extent}\n     */\n\n    this.previousExtent_ = null;\n    /**\n     * @private\n     * @type {?import("./events.js").EventsKey}\n     */\n\n    this.viewPropertyListenerKey_ = null;\n    /**\n     * @private\n     * @type {?import("./events.js").EventsKey}\n     */\n\n    this.viewChangeListenerKey_ = null;\n    /**\n     * @private\n     * @type {Array<import("./events.js").EventsKey>}\n     */\n\n    this.layerGroupPropertyListenerKeys_ = null;\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    this.viewport_ = document.createElement(\'div\');\n    this.viewport_.className = \'ol-viewport\' + (has["i" /* TOUCH */] ? \' ol-touch\' : \'\');\n    this.viewport_.style.position = \'relative\';\n    this.viewport_.style.overflow = \'hidden\';\n    this.viewport_.style.width = \'100%\';\n    this.viewport_.style.height = \'100%\'; // prevent page zoom on IE >= 10 browsers\n\n    this.viewport_.style.msTouchAction = \'none\';\n    this.viewport_.style.touchAction = \'none\';\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    this.overlayContainer_ = document.createElement(\'div\');\n    this.overlayContainer_.className = \'ol-overlaycontainer\';\n    this.viewport_.appendChild(this.overlayContainer_);\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n\n    this.overlayContainerStopEvent_ = document.createElement(\'div\');\n    this.overlayContainerStopEvent_.className = \'ol-overlaycontainer-stopevent\';\n    var overlayEvents = [events_EventType["a" /* default */].CLICK, events_EventType["a" /* default */].DBLCLICK, events_EventType["a" /* default */].MOUSEDOWN, events_EventType["a" /* default */].TOUCHSTART, events_EventType["a" /* default */].MSPOINTERDOWN, MapBrowserEventType["a" /* default */].POINTERDOWN, events_EventType["a" /* default */].MOUSEWHEEL, events_EventType["a" /* default */].WHEEL];\n\n    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {\n      Object(ol_events["a" /* listen */])(this.overlayContainerStopEvent_, overlayEvents[i], Event["b" /* stopPropagation */]);\n    }\n\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n    /**\n     * @private\n     * @type {MapBrowserEventHandler}\n     */\n\n    this.mapBrowserEventHandler_ = new ol_MapBrowserEventHandler(this, options.moveTolerance);\n\n    for (var key in MapBrowserEventType["a" /* default */]) {\n      Object(ol_events["a" /* listen */])(this.mapBrowserEventHandler_, MapBrowserEventType["a" /* default */][key], this.handleMapBrowserEvent, this);\n    }\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n\n\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n    /**\n     * @private\n     * @type {Array<import("./events.js").EventsKey>}\n     */\n\n    this.keyHandlerKeys_ = null;\n    Object(ol_events["a" /* listen */])(this.viewport_, events_EventType["a" /* default */].CONTEXTMENU, this.handleBrowserEvent, this);\n    Object(ol_events["a" /* listen */])(this.viewport_, events_EventType["a" /* default */].WHEEL, this.handleBrowserEvent, this);\n    Object(ol_events["a" /* listen */])(this.viewport_, events_EventType["a" /* default */].MOUSEWHEEL, this.handleBrowserEvent, this);\n    /**\n     * @type {Collection<import("./control/Control.js").default>}\n     * @protected\n     */\n\n    this.controls = optionsInternal.controls || new Collection["a" /* default */]();\n    /**\n     * @type {Collection<import("./interaction/Interaction.js").default>}\n     * @protected\n     */\n\n    this.interactions = optionsInternal.interactions || new Collection["a" /* default */]();\n    /**\n     * @type {Collection<import("./Overlay.js").default>}\n     * @private\n     */\n\n    this.overlays_ = optionsInternal.overlays;\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object<string, import("./Overlay.js").default>}\n     */\n\n    this.overlayIdIndex_ = {};\n    /**\n     * @type {import("./renderer/Map.js").default}\n     * @private\n     */\n\n    this.renderer_ = this.createRenderer();\n    /**\n     * @type {function(Event)|undefined}\n     * @private\n     */\n\n    this.handleResize_;\n    /**\n     * @private\n     * @type {import("./coordinate.js").Coordinate}\n     */\n\n    this.focus_ = null;\n    /**\n     * @private\n     * @type {!Array<PostRenderFunction>}\n     */\n\n    this.postRenderFunctions_ = [];\n    /**\n     * @private\n     * @type {TileQueue}\n     */\n\n    this.tileQueue_ = new ol_TileQueue(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));\n    /**\n     * Uids of features to skip at rendering time.\n     * @type {Object<string, boolean>}\n     * @private\n     */\n\n    this.skippedFeatureUids_ = {};\n    Object(ol_events["a" /* listen */])(this, Object(ol_Object["b" /* getChangeEventType */])(MapProperty.LAYERGROUP), this.handleLayerGroupChanged_, this);\n    Object(ol_events["a" /* listen */])(this, Object(ol_Object["b" /* getChangeEventType */])(MapProperty.VIEW), this.handleViewChanged_, this);\n    Object(ol_events["a" /* listen */])(this, Object(ol_Object["b" /* getChangeEventType */])(MapProperty.SIZE), this.handleSizeChanged_, this);\n    Object(ol_events["a" /* listen */])(this, Object(ol_Object["b" /* getChangeEventType */])(MapProperty.TARGET), this.handleTargetChanged_, this); // setProperties will trigger the rendering of the map if the map\n    // is "defined" already.\n\n    this.setProperties(optionsInternal.values);\n    this.controls.forEach(\n    /**\n     * @param {import("./control/Control.js").default} control Control.\n     * @this {PluggableMap}\n     */\n    function (control) {\n      control.setMap(this);\n    }.bind(this));\n    Object(ol_events["a" /* listen */])(this.controls, CollectionEventType["a" /* default */].ADD,\n    /**\n     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }, this);\n    Object(ol_events["a" /* listen */])(this.controls, CollectionEventType["a" /* default */].REMOVE,\n    /**\n     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }, this);\n    this.interactions.forEach(\n    /**\n     * @param {import("./interaction/Interaction.js").default} interaction Interaction.\n     * @this {PluggableMap}\n     */\n    function (interaction) {\n      interaction.setMap(this);\n    }.bind(this));\n    Object(ol_events["a" /* listen */])(this.interactions, CollectionEventType["a" /* default */].ADD,\n    /**\n     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }, this);\n    Object(ol_events["a" /* listen */])(this.interactions, CollectionEventType["a" /* default */].REMOVE,\n    /**\n     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }, this);\n    this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n    Object(ol_events["a" /* listen */])(this.overlays_, CollectionEventType["a" /* default */].ADD,\n    /**\n     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      this.addOverlayInternal_(\n      /** @type {import("./Overlay.js").default} */\n      event.element);\n    }, this);\n    Object(ol_events["a" /* listen */])(this.overlays_, CollectionEventType["a" /* default */].REMOVE,\n    /**\n     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      var overlay =\n      /** @type {import("./Overlay.js").default} */\n      event.element;\n      var id = overlay.getId();\n\n      if (id !== undefined) {\n        delete this.overlayIdIndex_[id.toString()];\n      }\n\n      event.element.setMap(null);\n    }, this);\n  }\n\n  if (BaseObject) PluggableMap.__proto__ = BaseObject;\n  PluggableMap.prototype = Object.create(BaseObject && BaseObject.prototype);\n  PluggableMap.prototype.constructor = PluggableMap;\n  /**\n   * @abstract\n   * @return {import("./renderer/Map.js").default} The map renderer\n   */\n\n  PluggableMap.prototype.createRenderer = function createRenderer() {\n    throw new Error(\'Use a map type that has a createRenderer method\');\n  };\n  /**\n   * Add the given control to the map.\n   * @param {import("./control/Control.js").default} control Control.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addControl = function addControl(control) {\n    this.getControls().push(control);\n  };\n  /**\n   * Add the given interaction to the map.\n   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addInteraction = function addInteraction(interaction) {\n    this.getInteractions().push(interaction);\n  };\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {import("./layer/Base.js").default} layer Layer.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addLayer = function addLayer(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n  /**\n   * Add the given overlay to the map.\n   * @param {import("./Overlay.js").default} overlay Overlay.\n   * @api\n   */\n\n\n  PluggableMap.prototype.addOverlay = function addOverlay(overlay) {\n    this.getOverlays().push(overlay);\n  };\n  /**\n   * This deals with map\'s overlay collection changes.\n   * @param {import("./Overlay.js").default} overlay Overlay.\n   * @private\n   */\n\n\n  PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_(overlay) {\n    var id = overlay.getId();\n\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n\n    overlay.setMap(this);\n  };\n  /**\n   *\n   * @inheritDoc\n   */\n\n\n  PluggableMap.prototype.disposeInternal = function disposeInternal() {\n    this.mapBrowserEventHandler_.dispose();\n    Object(ol_events["c" /* unlisten */])(this.viewport_, events_EventType["a" /* default */].CONTEXTMENU, this.handleBrowserEvent, this);\n    Object(ol_events["c" /* unlisten */])(this.viewport_, events_EventType["a" /* default */].WHEEL, this.handleBrowserEvent, this);\n    Object(ol_events["c" /* unlisten */])(this.viewport_, events_EventType["a" /* default */].MOUSEWHEEL, this.handleBrowserEvent, this);\n\n    if (this.handleResize_ !== undefined) {\n      removeEventListener(events_EventType["a" /* default */].RESIZE, this.handleResize_, false);\n      this.handleResize_ = undefined;\n    }\n\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n      this.animationDelayKey_ = undefined;\n    }\n\n    this.setTarget(null);\n    BaseObject.prototype.disposeInternal.call(this);\n  };\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `opt_options`.\n   * @param {import("./pixel.js").Pixel} pixel Pixel.\n   * @param {function(this: S, import("./Feature.js").FeatureLike,\n   *     import("./layer/Layer.js").default): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature feature} or\n   *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n\n\n  PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options :\n    /** @type {AtPixelOptions} */\n    {};\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : functions["b" /* TRUE */];\n    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n  };\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {import("./pixel.js").Pixel} pixel Pixel.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or\n   * `null` if none were found.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel(pixel, opt_options) {\n    var features = null;\n    this.forEachFeatureAtPixel(pixel, function (feature) {\n      if (!features) {\n        features = [];\n      }\n\n      features.push(feature);\n    }, opt_options);\n    return features;\n  };\n  /**\n   * Detect layers that have a color value at a pixel on the viewport, and\n   * execute a callback with each matching layer. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {import("./pixel.js").Pixel} pixel Pixel.\n   * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback\n   *     Layer callback. This callback will receive two arguments: first is the\n   *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n   *     that do not currently support this argument. To stop detection, callback\n   *     functions can return a truthy value.\n   * @param {AtPixelOptions=} opt_options Configuration options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n\n\n  PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n\n    var options = opt_options ||\n    /** @type {AtPixelOptions} */\n    {};\n    var hitTolerance = options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = options.layerFilter || functions["b" /* TRUE */];\n    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n  };\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {import("./pixel.js").Pixel} pixel Pixel.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @template U\n   * @api\n   */\n\n\n  PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel(pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options :\n    /** @type {AtPixelOptions} */\n    {};\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : functions["b" /* TRUE */];\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);\n  };\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {Event} event Event.\n   * @return {import("./coordinate.js").Coordinate} Coordinate.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getEventCoordinate = function getEventCoordinate(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {Event|TouchEvent} event Event.\n   * @return {import("./pixel.js").Pixel} Pixel.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getEventPixel = function getEventPixel(event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = \'changedTouches\' in event ?\n    /** @type {TouchEvent} */\n    event.changedTouches[0] :\n    /** @type {MouseEvent} */\n    event;\n    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];\n  };\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getTarget = function getTarget() {\n    return (\n      /** @type {HTMLElement|string|undefined} */\n      this.get(MapProperty.TARGET)\n    );\n  };\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getTargetElement = function getTargetElement() {\n    var target = this.getTarget();\n\n    if (target !== undefined) {\n      return typeof target === \'string\' ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  };\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.\n   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel(pixel) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return Object(transform["a" /* apply */])(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {Collection<import("./control/Control.js").default>} Controls.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getControls = function getControls() {\n    return this.controls;\n  };\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {Collection<import("./Overlay.js").default>} Overlays.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getOverlays = function getOverlays() {\n    return this.overlays_;\n  };\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `\'2\'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {import("./Overlay.js").default} Overlay.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getOverlayById = function getOverlayById(id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  };\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getInteractions = function getInteractions() {\n    return this.interactions;\n  };\n  /**\n   * Get the layergroup associated with this map.\n   * @return {LayerGroup} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getLayerGroup = function getLayerGroup() {\n    return (\n      /** @type {LayerGroup} */\n      this.get(MapProperty.LAYERGROUP)\n    );\n  };\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!Collection<import("./layer/Base.js").default>} Layers.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getLayers = function getLayers() {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.\n   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate(coordinate) {\n    var frameState = this.frameState_;\n\n    if (!frameState) {\n      return null;\n    } else {\n      return Object(transform["a" /* apply */])(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  };\n  /**\n   * Get the map renderer.\n   * @return {import("./renderer/Map.js").default} Renderer\n   */\n\n\n  PluggableMap.prototype.getRenderer = function getRenderer() {\n    return this.renderer_;\n  };\n  /**\n   * Get the size of this map.\n   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getSize = function getSize() {\n    return (\n      /** @type {import("./size.js").Size|undefined} */\n      this.get(MapProperty.SIZE)\n    );\n  };\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {View} The view that controls this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.getView = function getView() {\n    return (\n      /** @type {View} */\n      this.get(MapProperty.VIEW)\n    );\n  };\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.getViewport = function getViewport() {\n    return this.viewport_;\n  };\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map\'s overlay container.\n   */\n\n\n  PluggableMap.prototype.getOverlayContainer = function getOverlayContainer() {\n    return this.overlayContainer_;\n  };\n  /**\n   * Get the element that serves as a container for overlays that don\'t allow\n   * event propagation. Elements added to this container won\'t let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don\'t trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map\'s overlay container that stops events.\n   */\n\n\n  PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent() {\n    return this.overlayContainerStopEvent_;\n  };\n  /**\n   * @param {import("./Tile.js").default} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n\n\n  PluggableMap.prototype.getTilePriority = function getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n    // Filter out tiles at higher zoom levels than the current zoom level, or that\n    // are outside the visible extent.\n    var frameState = this.frameState_;\n\n    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n      return DROP;\n    }\n\n    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n      return DROP;\n    } // Prioritize the highest zoom level tiles closest to the focus.\n    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n    // Within a zoom level, tiles are prioritized by the distance in pixels\n    // between the center of the tile and the focus.  The factor of 65536 means\n    // that the prioritization should behave as desired for tiles up to\n    // 65536 * Math.log(2) = 45426 pixels from the focus.\n\n\n    var deltaX = tileCenter[0] - frameState.focus[0];\n    var deltaY = tileCenter[1] - frameState.focus[1];\n    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n  };\n  /**\n   * @param {Event} browserEvent Browser event.\n   * @param {string=} opt_type Type.\n   */\n\n\n  PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent(browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new ol_MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n  /**\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n\n\n  PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent(mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n\n    this.focus_ = mapBrowserEvent.coordinate;\n    mapBrowserEvent.frameState = this.frameState_;\n    var interactionsArray = this.getInteractions().getArray();\n\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      for (var i = interactionsArray.length - 1; i >= 0; i--) {\n        var interaction = interactionsArray[i];\n\n        if (!interaction.getActive()) {\n          continue;\n        }\n\n        var cont = interaction.handleEvent(mapBrowserEvent);\n\n        if (!cont) {\n          break;\n        }\n      }\n    }\n  };\n  /**\n   * @protected\n   */\n\n\n  PluggableMap.prototype.handlePostRender = function handlePostRender() {\n    var frameState = this.frameState_; // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n\n    var tileQueue = this.tileQueue_;\n\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = this.maxTilesLoading_;\n      var maxNewLoads = maxTotalLoading;\n\n      if (frameState) {\n        var hints = frameState.viewHints;\n\n        if (hints[ViewHint["a" /* default */].ANIMATING]) {\n          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n\n        if (hints[ViewHint["a" /* default */].INTERACTING]) {\n          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n      }\n\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n\n    if (frameState && this.hasListener(render_EventType["a" /* default */].RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !getLoading(this.getLayers().getArray())) {\n      this.renderer_.dispatchRenderEvent(render_EventType["a" /* default */].RENDERCOMPLETE, frameState);\n    }\n\n    var postRenderFunctions = this.postRenderFunctions_;\n\n    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n\n    postRenderFunctions.length = 0;\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_() {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_() {\n    // target may be undefined, null, a string or an Element.\n    // If it\'s a string we convert it to an Element before proceeding.\n    // If it\'s not now an Element we remove the viewport from the DOM.\n    // If it\'s an Element we append the viewport element to it.\n    var targetElement;\n\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n\n    if (this.keyHandlerKeys_) {\n      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        Object(ol_events["e" /* unlistenByKey */])(this.keyHandlerKeys_[i]);\n      }\n\n      this.keyHandlerKeys_ = null;\n    }\n\n    if (!targetElement) {\n      this.renderer_.removeLayerRenderers();\n      Object(dom["e" /* removeNode */])(this.viewport_);\n\n      if (this.handleResize_ !== undefined) {\n        removeEventListener(events_EventType["a" /* default */].RESIZE, this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [Object(ol_events["a" /* listen */])(keyboardEventTarget, events_EventType["a" /* default */].KEYDOWN, this.handleBrowserEvent, this), Object(ol_events["a" /* listen */])(keyboardEventTarget, events_EventType["a" /* default */].KEYPRESS, this.handleBrowserEvent, this)];\n\n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        window.addEventListener(events_EventType["a" /* default */].RESIZE, this.handleResize_, false);\n      }\n    }\n\n    this.updateSize(); // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleTileChange_ = function handleTileChange_() {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_() {\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_() {\n    if (this.viewPropertyListenerKey_) {\n      Object(ol_events["e" /* unlistenByKey */])(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n\n    if (this.viewChangeListenerKey_) {\n      Object(ol_events["e" /* unlistenByKey */])(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n\n    var view = this.getView();\n\n    if (view) {\n      this.viewport_.setAttribute(\'data-view\', Object(util["c" /* getUid */])(view));\n      this.viewPropertyListenerKey_ = Object(ol_events["a" /* listen */])(view, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = Object(ol_events["a" /* listen */])(view, events_EventType["a" /* default */].CHANGE, this.handleViewPropertyChanged_, this);\n    }\n\n    this.render();\n  };\n  /**\n   * @private\n   */\n\n\n  PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(ol_events["e" /* unlistenByKey */]);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n\n    var layerGroup = this.getLayerGroup();\n\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [Object(ol_events["a" /* listen */])(layerGroup, ObjectEventType["a" /* default */].PROPERTYCHANGE, this.render, this), Object(ol_events["a" /* listen */])(layerGroup, events_EventType["a" /* default */].CHANGE, this.render, this)];\n    }\n\n    this.render();\n  };\n  /**\n   * @return {boolean} Is rendered.\n   */\n\n\n  PluggableMap.prototype.isRendered = function isRendered() {\n    return !!this.frameState_;\n  };\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n\n\n  PluggableMap.prototype.renderSync = function renderSync() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n\n    this.animationDelay_();\n  };\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n\n\n  PluggableMap.prototype.render = function render() {\n    if (this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  };\n  /**\n   * Remove the given control from the map.\n   * @param {import("./control/Control.js").default} control Control.\n   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeControl = function removeControl(control) {\n    return this.getControls().remove(control);\n  };\n  /**\n   * Remove the given interaction from the map.\n   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.\n   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeInteraction = function removeInteraction(interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n  /**\n   * Removes the given layer from the map.\n   * @param {import("./layer/Base.js").default} layer Layer.\n   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeLayer = function removeLayer(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n  /**\n   * Remove the given overlay from the map.\n   * @param {import("./Overlay.js").default} overlay Overlay.\n   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n\n\n  PluggableMap.prototype.removeOverlay = function removeOverlay(overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n\n\n  PluggableMap.prototype.renderFrame_ = function renderFrame_(time) {\n    var viewState;\n    var size = this.getSize();\n    var view = this.getView();\n    var extent = Object(ol_extent["createEmpty"])();\n    var previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n\n    var frameState = null;\n\n    if (size !== undefined && Object(ol_size["a" /* hasArea */])(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n      var layerStates = {};\n\n      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n        layerStates[Object(util["c" /* getUid */])(layerStatesArray[i].layer)] = layerStatesArray[i];\n      }\n\n      viewState = view.getState(this.pixelRatio_);\n      frameState =\n      /** @type {FrameState} */\n      {\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        extent: extent,\n        focus: this.focus_ ? this.focus_ : viewState.center,\n        index: this.frameIndex_++,\n        layerStates: layerStates,\n        layerStatesArray: layerStatesArray,\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        skippedFeatureUids: this.skippedFeatureUids_,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      };\n    }\n\n    if (frameState) {\n      frameState.extent = Object(ol_extent["getForViewAndSize"])(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n\n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ || !Object(ol_extent["isEmpty"])(this.previousExtent_) && !Object(ol_extent["equals"])(frameState.extent, this.previousExtent_);\n\n        if (moveStart) {\n          this.dispatchEvent(new ol_MapEvent(MapEventType["a" /* default */].MOVESTART, this, previousFrameState));\n          this.previousExtent_ = Object(ol_extent["createOrUpdateEmpty"])(this.previousExtent_);\n        }\n      }\n\n      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint["a" /* default */].ANIMATING] && !frameState.viewHints[ViewHint["a" /* default */].INTERACTING] && !Object(ol_extent["equals"])(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(new ol_MapEvent(MapEventType["a" /* default */].MOVEEND, this, frameState));\n        Object(ol_extent["clone"])(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new ol_MapEvent(MapEventType["a" /* default */].POSTRENDER, this, frameState));\n    setTimeout(this.handlePostRender.bind(this), 0);\n  };\n  /**\n   * Sets the layergroup of this map.\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setLayerGroup = function setLayerGroup(layerGroup) {\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  };\n  /**\n   * Set the size of this map.\n   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setSize = function setSize(size) {\n    this.set(MapProperty.SIZE, size);\n  };\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string|undefined} target The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setTarget = function setTarget(target) {\n    this.set(MapProperty.TARGET, target);\n  };\n  /**\n   * Set the view for this map.\n   * @param {View} view The view that controls this map.\n   * @observable\n   * @api\n   */\n\n\n  PluggableMap.prototype.setView = function setView(view) {\n    this.set(MapProperty.VIEW, view);\n  };\n  /**\n   * @param {import("./Feature.js").default} feature Feature.\n   */\n\n\n  PluggableMap.prototype.skipFeature = function skipFeature(feature) {\n    this.skippedFeatureUids_[Object(util["c" /* getUid */])(feature)] = true;\n    this.render();\n  };\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n\n\n  PluggableMap.prototype.updateSize = function updateSize() {\n    var targetElement = this.getTargetElement();\n\n    if (!targetElement) {\n      this.setSize(undefined);\n    } else {\n      var computedStyle = getComputedStyle(targetElement);\n      this.setSize([targetElement.offsetWidth - parseFloat(computedStyle[\'borderLeftWidth\']) - parseFloat(computedStyle[\'paddingLeft\']) - parseFloat(computedStyle[\'paddingRight\']) - parseFloat(computedStyle[\'borderRightWidth\']), targetElement.offsetHeight - parseFloat(computedStyle[\'borderTopWidth\']) - parseFloat(computedStyle[\'paddingTop\']) - parseFloat(computedStyle[\'paddingBottom\']) - parseFloat(computedStyle[\'borderBottomWidth\'])]);\n    }\n  };\n  /**\n   * @param {import("./Feature.js").default} feature Feature.\n   */\n\n\n  PluggableMap.prototype.unskipFeature = function unskipFeature(feature) {\n    delete this.skippedFeatureUids_[Object(util["c" /* getUid */])(feature)];\n    this.render();\n  };\n\n  return PluggableMap;\n}(ol_Object["a" /* default */]);\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\n\n\nfunction createOptionsInternal(options) {\n  /**\n   * @type {HTMLElement|Document}\n   */\n  var keyboardEventTarget = null;\n\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === \'string\' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n  /**\n   * @type {Object<string, *>}\n   */\n\n\n  var values = {};\n  var layerGroup = options.layers && typeof\n  /** @type {?} */\n  options.layers.getLayers === \'function\' ?\n  /** @type {LayerGroup} */\n  options.layers : new Group({\n    layers:\n    /** @type {Collection} */\n    options.layers\n  });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n  values[MapProperty.TARGET] = options.target;\n  values[MapProperty.VIEW] = options.view !== undefined ? options.view : new View["default"]();\n  var controls;\n\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection["a" /* default */](options.controls.slice());\n    } else {\n      Object(asserts["a" /* assert */])(typeof\n      /** @type {?} */\n      options.controls.getArray === \'function\', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`\n\n      controls =\n      /** @type {Collection} */\n      options.controls;\n    }\n  }\n\n  var interactions;\n\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection["a" /* default */](options.interactions.slice());\n    } else {\n      Object(asserts["a" /* assert */])(typeof\n      /** @type {?} */\n      options.interactions.getArray === \'function\', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`\n\n      interactions =\n      /** @type {Collection} */\n      options.interactions;\n    }\n  }\n\n  var overlays;\n\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection["a" /* default */](options.overlays.slice());\n    } else {\n      Object(asserts["a" /* assert */])(typeof\n      /** @type {?} */\n      options.overlays.getArray === \'function\', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`\n\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection["a" /* default */]();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n}\n\n/* harmony default export */ var ol_PluggableMap = __webpack_exports__["default"] = (PluggableMap_PluggableMap);\n/**\n * @param  {Array<import("./layer/Base.js").default>} layers Layers.\n * @return {boolean} Layers have sources that are still loading.\n */\n\nfunction getLoading(layers) {\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var layer = layers[i];\n\n    if (typeof\n    /** @type {?} */\n    layer.getLayers === \'function\') {\n      return getLoading(\n      /** @type {LayerGroup} */\n      layer.getLayers().getArray());\n    } else {\n      var source =\n      /** @type {import("./layer/Layer.js").default} */\n      layer.getSource();\n\n      if (source && source.loading) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9NYXBFdmVudC5qcz8zNjE2Iiwid2VicGFjazovLy8uLi8uLi9zcmMvb2wvTWFwQnJvd3NlckV2ZW50LmpzPzZkNjUiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9vbC9NYXBCcm93c2VyUG9pbnRlckV2ZW50LmpzPzEwMTUiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9wb2ludGVyL0V2ZW50VHlwZS5qcz9kMDMxIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvcG9pbnRlci9FdmVudFNvdXJjZS5qcz9lYzgxIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvcG9pbnRlci9Nb3VzZVNvdXJjZS5qcz82ZTc2Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvcG9pbnRlci9Nc1NvdXJjZS5qcz8yZWI2Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvcG9pbnRlci9OYXRpdmVTb3VyY2UuanM/ZmY2NyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzPzM5MzciLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9wb2ludGVyL1RvdWNoU291cmNlLmpzPzdlZDciLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9wb2ludGVyL1BvaW50ZXJFdmVudEhhbmRsZXIuanM/OTcxOSIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL01hcEJyb3dzZXJFdmVudEhhbmRsZXIuanM/OTdkNyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL01hcFByb3BlcnR5LmpzPzk1ODYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanM/NmIxMiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL1RpbGVRdWV1ZS5qcz9kOGE2Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvbGF5ZXIvR3JvdXAuanM/YzI1NiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL29sL1BsdWdnYWJsZU1hcC5qcz81NjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9NYXBFdmVudFxuICovXG5pbXBvcnQgRXZlbnQgZnJvbSAnLi9ldmVudHMvRXZlbnQuanMnO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGFzIG1hcCBldmVudHMgYXJlIGluc3RhbmNlcyBvZiB0aGlzIHR5cGUuXG4gKiBTZWUge0BsaW5rIG1vZHVsZTpvbC9QbHVnZ2FibGVNYXB+UGx1Z2dhYmxlTWFwfSBmb3Igd2hpY2ggZXZlbnRzIHRyaWdnZXIgYSBtYXAgZXZlbnQuXG4gKi9cbmNsYXNzIE1hcEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGU9fSBvcHRfZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG1hcCwgb3B0X2ZyYW1lU3RhdGUpIHtcblxuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcCB3aGVyZSB0aGUgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYW1lIHN0YXRlIGF0IHRoZSB0aW1lIG9mIHRoZSBldmVudC5cbiAgICAgKiBAdHlwZSB7P2ltcG9ydChcIi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZSA9IG9wdF9mcmFtZVN0YXRlICE9PSB1bmRlZmluZWQgPyBvcHRfZnJhbWVTdGF0ZSA6IG51bGw7XG5cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEV2ZW50O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJFdmVudFxuICovXG5pbXBvcnQgTWFwRXZlbnQgZnJvbSAnLi9NYXBFdmVudC5qcyc7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogRXZlbnRzIGVtaXR0ZWQgYXMgbWFwIGJyb3dzZXIgZXZlbnRzIGFyZSBpbnN0YW5jZXMgb2YgdGhpcyB0eXBlLlxuICogU2VlIHtAbGluayBtb2R1bGU6b2wvUGx1Z2dhYmxlTWFwflBsdWdnYWJsZU1hcH0gZm9yIHdoaWNoIGV2ZW50cyB0cmlnZ2VyIGEgbWFwIGJyb3dzZXIgZXZlbnQuXG4gKi9cbmNsYXNzIE1hcEJyb3dzZXJFdmVudCBleHRlbmRzIE1hcEV2ZW50IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBicm93c2VyRXZlbnQgQnJvd3NlciBldmVudC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2RyYWdnaW5nIElzIHRoZSBtYXAgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQ/XG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGU9fSBvcHRfZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG1hcCwgYnJvd3NlckV2ZW50LCBvcHRfZHJhZ2dpbmcsIG9wdF9mcmFtZVN0YXRlKSB7XG5cbiAgICBzdXBlcih0eXBlLCBtYXAsIG9wdF9mcmFtZVN0YXRlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW5hbCBicm93c2VyIGV2ZW50LlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtFdmVudH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gYnJvd3NlckV2ZW50O1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hcCBwaXhlbCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5waXhlbCA9IG1hcC5nZXRFdmVudFBpeGVsKGJyb3dzZXJFdmVudCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBpbiB2aWV3IHByb2plY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgb3JpZ2luYWwgYnJvd3NlciBldmVudC5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICogQGFwaVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZSA9IG1hcC5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHRoaXMucGl4ZWwpO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBtYXAgaXMgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQuIE9ubHkgc2V0IGZvclxuICAgICAqIGBQT0lOVEVSRFJBR2AgYW5kIGBQT0lOVEVSTU9WRWAgZXZlbnRzLiBEZWZhdWx0IGlzIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAYXBpXG4gICAgICovXG4gICAgdGhpcy5kcmFnZ2luZyA9IG9wdF9kcmFnZ2luZyAhPT0gdW5kZWZpbmVkID8gb3B0X2RyYWdnaW5nIDogZmFsc2U7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBicm93c2VyIGFjdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5wcmV2ZW50RGVmYXVsdC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIHByZXZlbnREZWZhdWx0KCkge1xuICAgIHN1cGVyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgZnVydGhlciBwcm9wYWdhdGlvbiBvZiB0aGUgY3VycmVudCBldmVudC5cbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5zdG9wUHJvcGFnYXRpb24uXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgc3VwZXIuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTWFwQnJvd3NlckV2ZW50O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL01hcEJyb3dzZXJQb2ludGVyRXZlbnRcbiAqL1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudCBmcm9tICcuL01hcEJyb3dzZXJFdmVudC5qcyc7XG5cbmNsYXNzIE1hcEJyb3dzZXJQb2ludGVyRXZlbnQgZXh0ZW5kcyBNYXBCcm93c2VyRXZlbnQge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlciBldmVudC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2RyYWdnaW5nIElzIHRoZSBtYXAgY3VycmVudGx5IGJlaW5nIGRyYWdnZWQ/XG4gICAqIEBwYXJhbSB7P2ltcG9ydChcIi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGU9fSBvcHRfZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG1hcCwgcG9pbnRlckV2ZW50LCBvcHRfZHJhZ2dpbmcsIG9wdF9mcmFtZVN0YXRlKSB7XG5cbiAgICBzdXBlcih0eXBlLCBtYXAsIHBvaW50ZXJFdmVudC5vcmlnaW5hbEV2ZW50LCBvcHRfZHJhZ2dpbmcsIG9wdF9mcmFtZVN0YXRlKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyRXZlbnQgPSBwb2ludGVyRXZlbnQ7XG5cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9FdmVudFR5cGVcbiAqL1xuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgZXZlbnQgbmFtZXMuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBPSU5URVJNT1ZFOiAncG9pbnRlcm1vdmUnLFxuICBQT0lOVEVSRE9XTjogJ3BvaW50ZXJkb3duJyxcbiAgUE9JTlRFUlVQOiAncG9pbnRlcnVwJyxcbiAgUE9JTlRFUk9WRVI6ICdwb2ludGVyb3ZlcicsXG4gIFBPSU5URVJPVVQ6ICdwb2ludGVyb3V0JyxcbiAgUE9JTlRFUkVOVEVSOiAncG9pbnRlcmVudGVyJyxcbiAgUE9JTlRFUkxFQVZFOiAncG9pbnRlcmxlYXZlJyxcbiAgUE9JTlRFUkNBTkNFTDogJ3BvaW50ZXJjYW5jZWwnXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvRXZlbnRTb3VyY2VcbiAqL1xuXG5jbGFzcyBFdmVudFNvdXJjZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzXCIpLmRlZmF1bHR9IGRpc3BhdGNoZXIgRXZlbnQgaGFuZGxlci5cbiAgICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgZnVuY3Rpb24oRXZlbnQpPn0gbWFwcGluZyBFdmVudCBtYXBwaW5nLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGlzcGF0Y2hlciwgbWFwcGluZykge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vUG9pbnRlckV2ZW50SGFuZGxlci5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgZnVuY3Rpb24oRXZlbnQpPn1cbiAgICAgKi9cbiAgICB0aGlzLm1hcHBpbmdfID0gbWFwcGluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGV2ZW50cyBzdXBwb3J0ZWQgYnkgdGhpcyBzb3VyY2UuXG4gICAqIEByZXR1cm4ge0FycmF5PHN0cmluZz59IEV2ZW50IG5hbWVzXG4gICAqL1xuICBnZXRFdmVudHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwcGluZ18pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhhbmRsZXIgdGhhdCBzaG91bGQgaGFuZGxlIGEgZ2l2ZW4gZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb24oRXZlbnQpfSBIYW5kbGVyXG4gICAqL1xuICBnZXRIYW5kbGVyRm9yRXZlbnQoZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwcGluZ19bZXZlbnRUeXBlXTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50U291cmNlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvTW91c2VTb3VyY2VcbiAqL1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9Qb2ludGVyRXZlbnRzXG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBUaGUgUG9seW1lciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL0V2ZW50U291cmNlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBQT0lOVEVSX0lEID0gMTtcblxuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBQT0lOVEVSX1RZUEUgPSAnbW91c2UnO1xuXG5cbi8qKlxuICogUmFkaXVzIGFyb3VuZCB0b3VjaGVuZCB0aGF0IHN3YWxsb3dzIG1vdXNlIGV2ZW50cy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBERURVUF9ESVNUID0gMjU7XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1vdXNlZG93bmAuXG4gKlxuICogQHRoaXMge01vdXNlU291cmNlfVxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbW91c2Vkb3duKGluRXZlbnQpIHtcbiAgaWYgKCF0aGlzLmlzRXZlbnRTaW11bGF0ZWRGcm9tVG91Y2hfKGluRXZlbnQpKSB7XG4gICAgLy8gVE9ETyhkZnJlZWRtYW4pIHdvcmthcm91bmQgZm9yIHNvbWUgZWxlbWVudHMgbm90IHNlbmRpbmcgbW91c2V1cFxuICAgIC8vIGh0dHA6Ly9jcmJ1Zy8xNDkwOTFcbiAgICBpZiAoUE9JTlRFUl9JRC50b1N0cmluZygpIGluIHRoaXMucG9pbnRlck1hcCkge1xuICAgICAgdGhpcy5jYW5jZWwoaW5FdmVudCk7XG4gICAgfVxuICAgIGNvbnN0IGUgPSBwcmVwYXJlRXZlbnQoaW5FdmVudCwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICB0aGlzLnBvaW50ZXJNYXBbUE9JTlRFUl9JRC50b1N0cmluZygpXSA9IGluRXZlbnQ7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmRvd24oZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2Vtb3ZlYC5cbiAqXG4gKiBAdGhpcyB7TW91c2VTb3VyY2V9XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtb3VzZW1vdmUoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICBjb25zdCBlID0gcHJlcGFyZUV2ZW50KGluRXZlbnQsIHRoaXMuZGlzcGF0Y2hlcik7XG4gICAgdGhpcy5kaXNwYXRjaGVyLm1vdmUoZSwgaW5FdmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2V1cGAuXG4gKlxuICogQHRoaXMge01vdXNlU291cmNlfVxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbW91c2V1cChpbkV2ZW50KSB7XG4gIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoXyhpbkV2ZW50KSkge1xuICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50ZXJNYXBbUE9JTlRFUl9JRC50b1N0cmluZygpXTtcblxuICAgIGlmIChwICYmIHAuYnV0dG9uID09PSBpbkV2ZW50LmJ1dHRvbikge1xuICAgICAgY29uc3QgZSA9IHByZXBhcmVFdmVudChpbkV2ZW50LCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgdGhpcy5kaXNwYXRjaGVyLnVwKGUsIGluRXZlbnQpO1xuICAgICAgdGhpcy5jbGVhbnVwTW91c2UoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbW91c2VvdmVyYC5cbiAqXG4gKiBAdGhpcyB7TW91c2VTb3VyY2V9XG4gKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtb3VzZW92ZXIoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICBjb25zdCBlID0gcHJlcGFyZUV2ZW50KGluRXZlbnQsIHRoaXMuZGlzcGF0Y2hlcik7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmVudGVyT3ZlcihlLCBpbkV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtb3VzZW91dGAuXG4gKlxuICogQHRoaXMge01vdXNlU291cmNlfVxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbW91c2VvdXQoaW5FdmVudCkge1xuICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkpIHtcbiAgICBjb25zdCBlID0gcHJlcGFyZUV2ZW50KGluRXZlbnQsIHRoaXMuZGlzcGF0Y2hlcik7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmxlYXZlT3V0KGUsIGluRXZlbnQpO1xuICB9XG59XG5cblxuY2xhc3MgTW91c2VTb3VyY2UgZXh0ZW5kcyBFdmVudFNvdXJjZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzXCIpLmRlZmF1bHR9IGRpc3BhdGNoZXIgRXZlbnQgaGFuZGxlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRpc3BhdGNoZXIpIHtcbiAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgJ21vdXNlZG93bic6IG1vdXNlZG93bixcbiAgICAgICdtb3VzZW1vdmUnOiBtb3VzZW1vdmUsXG4gICAgICAnbW91c2V1cCc6IG1vdXNldXAsXG4gICAgICAnbW91c2VvdmVyJzogbW91c2VvdmVyLFxuICAgICAgJ21vdXNlb3V0JzogbW91c2VvdXRcbiAgICB9O1xuICAgIHN1cGVyKGRpc3BhdGNoZXIsIG1hcHBpbmcpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBFdmVudHxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlck1hcCA9IGRpc3BhdGNoZXIucG9pbnRlck1hcDtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbD59XG4gICAgICovXG4gICAgdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBhIG1vdXNlIGV2ZW50IHdhcyBzaW11bGF0ZWQgZnJvbSBhIHRvdWNoIGJ5XG4gICAqIGNoZWNraW5nIGlmIHByZXZpb3VzbHkgdGhlcmUgd2FzIGEgdG91Y2ggZXZlbnQgYXQgdGhlXG4gICAqIHNhbWUgcG9zaXRpb24uXG4gICAqXG4gICAqIEZJWE1FIC0gS25vd24gcHJvYmxlbSB3aXRoIHRoZSBuYXRpdmUgQW5kcm9pZCBicm93c2VyIG9uXG4gICAqIFNhbXN1bmcgR1QtSTkxMDAgKEFuZHJvaWQgNC4xLjIpOlxuICAgKiBJbiBjYXNlIHRoZSBwYWdlIGlzIHNjcm9sbGVkLCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHdvcmtcbiAgICogY29ycmVjdGx5IHdoZW4gYSBjYW52YXMgaXMgdXNlZCAoV2ViR0wgb3IgY2FudmFzIHJlbmRlcmVyKS5cbiAgICogTW91c2UgbGlzdGVuZXJzIG9uIGNhbnZhcyBlbGVtZW50cyAoZm9yIHRoaXMgYnJvd3NlciksIGNyZWF0ZVxuICAgKiB0d28gbW91c2UgZXZlbnRzOiBPbmUgJ2dvb2QnIGFuZCBvbmUgJ2JhZCcgb25lIChvbiBvdGhlciBicm93c2VycyBvclxuICAgKiB3aGVuIGEgZGl2IGlzIHVzZWQsIHRoZXJlIGlzIG9ubHkgb25lIGV2ZW50KS4gRm9yIHRoZSAnYmFkJyBvbmUsXG4gICAqIGNsaWVudFgvY2xpZW50WSBhbmQgYWxzbyBwYWdlWC9wYWdlWSBhcmUgd3Jvbmcgd2hlbiB0aGUgcGFnZVxuICAgKiBpcyBzY3JvbGxlZC4gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIGZ1bmN0aW9uIGNhbiBub3QgZGV0ZWN0IGlmXG4gICAqIHRoZSBldmVudHMgd2VyZSBzaW11bGF0ZWQgZnJvbSBhIHRvdWNoIGV2ZW50LiBBcyByZXN1bHQsIGFcbiAgICogcG9pbnRlciBldmVudCBhdCBhIHdyb25nIHBvc2l0aW9uIGlzIGRpc3BhdGNoZWQsIHdoaWNoIGNvbmZ1c2VzXG4gICAqIHRoZSBtYXAgaW50ZXJhY3Rpb25zLlxuICAgKiBJdCBpcyB1bmNsZWFyLCBob3cgb25lIGNhbiBnZXQgdGhlIGNvcnJlY3QgcG9zaXRpb24gZm9yIHRoZSBldmVudFxuICAgKiBvciBkZXRlY3QgdGhhdCB0aGUgcG9zaXRpb25zIGFyZSBpbnZhbGlkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlLCBpZiB0aGUgZXZlbnQgd2FzIGdlbmVyYXRlZCBieSBhIHRvdWNoLlxuICAgKi9cbiAgaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaF8oaW5FdmVudCkge1xuICAgIGNvbnN0IGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgY29uc3QgeCA9IGluRXZlbnQuY2xpZW50WDtcbiAgICBjb25zdCB5ID0gaW5FdmVudC5jbGllbnRZO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbHRzLmxlbmd0aCwgdDsgaSA8IGwgJiYgKHQgPSBsdHNbaV0pOyBpKyspIHtcbiAgICAgIC8vIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgd2lsbCBiZSBzd2FsbG93ZWQgbmVhciBhIHByaW1hcnkgdG91Y2hlbmRcbiAgICAgIGNvbnN0IGR4ID0gTWF0aC5hYnMoeCAtIHRbMF0pO1xuICAgICAgY29uc3QgZHkgPSBNYXRoLmFicyh5IC0gdFsxXSk7XG4gICAgICBpZiAoZHggPD0gREVEVVBfRElTVCAmJiBkeSA8PSBERURVUF9ESVNUKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIGBwb2ludGVyY2FuY2VsYCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gICAqL1xuICBjYW5jZWwoaW5FdmVudCkge1xuICAgIGNvbnN0IGUgPSBwcmVwYXJlRXZlbnQoaW5FdmVudCwgdGhpcy5kaXNwYXRjaGVyKTtcbiAgICB0aGlzLmRpc3BhdGNoZXIuY2FuY2VsKGUsIGluRXZlbnQpO1xuICAgIHRoaXMuY2xlYW51cE1vdXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBtb3VzZSBmcm9tIHRoZSBsaXN0IG9mIGFjdGl2ZSBwb2ludGVycy5cbiAgICovXG4gIGNsZWFudXBNb3VzZSgpIHtcbiAgICBkZWxldGUgdGhpcy5wb2ludGVyTWFwW1BPSU5URVJfSUQudG9TdHJpbmcoKV07XG4gIH1cbn1cblxuXG4vKipcbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IHdpbGwgYmUgdXNlZFxuICogZm9yIHRoZSBmYWtlIHBvaW50ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4vUG9pbnRlckV2ZW50SGFuZGxlci5qc1wiKS5kZWZhdWx0fSBkaXNwYXRjaGVyIEV2ZW50IGhhbmRsZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb3BpZWQgZXZlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlRXZlbnQoaW5FdmVudCwgZGlzcGF0Y2hlcikge1xuICBjb25zdCBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQsIGluRXZlbnQpO1xuXG4gIC8vIGZvcndhcmQgbW91c2UgcHJldmVudERlZmF1bHRcbiAgY29uc3QgcGQgPSBlLnByZXZlbnREZWZhdWx0O1xuICBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHBkKCk7XG4gIH07XG5cbiAgZS5wb2ludGVySWQgPSBQT0lOVEVSX0lEO1xuICBlLmlzUHJpbWFyeSA9IHRydWU7XG4gIGUucG9pbnRlclR5cGUgPSBQT0lOVEVSX1RZUEU7XG5cbiAgcmV0dXJuIGU7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgTW91c2VTb3VyY2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Nc1NvdXJjZVxuICovXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9Qb2ludGVyRXZlbnRzXG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBUaGUgUG9seW1lciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL0V2ZW50U291cmNlLmpzJztcblxuXG4vKipcbiAqIEBjb25zdFxuICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gKi9cbmNvbnN0IFBPSU5URVJfVFlQRVMgPSBbXG4gICcnLFxuICAndW5hdmFpbGFibGUnLFxuICAndG91Y2gnLFxuICAncGVuJyxcbiAgJ21vdXNlJ1xuXTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyRG93bmAuXG4gKlxuICogQHRoaXMge01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlckRvd24oaW5FdmVudCkge1xuICB0aGlzLnBvaW50ZXJNYXBbaW5FdmVudC5wb2ludGVySWQudG9TdHJpbmcoKV0gPSBpbkV2ZW50O1xuICBjb25zdCBlID0gdGhpcy5wcmVwYXJlRXZlbnRfKGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIuZG93bihlLCBpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyTW92ZWAuXG4gKlxuICogQHRoaXMge01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlck1vdmUoaW5FdmVudCkge1xuICBjb25zdCBlID0gdGhpcy5wcmVwYXJlRXZlbnRfKGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIubW92ZShlLCBpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyVXBgLlxuICpcbiAqIEB0aGlzIHtNc1NvdXJjZX1cbiAqIEBwYXJhbSB7TVNQb2ludGVyRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBtc1BvaW50ZXJVcChpbkV2ZW50KSB7XG4gIGNvbnN0IGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci51cChlLCBpbkV2ZW50KTtcbiAgdGhpcy5jbGVhbnVwKGluRXZlbnQucG9pbnRlcklkKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgbXNQb2ludGVyT3V0YC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNQb2ludGVyT3V0KGluRXZlbnQpIHtcbiAgY29uc3QgZSA9IHRoaXMucHJlcGFyZUV2ZW50XyhpbkV2ZW50KTtcbiAgdGhpcy5kaXNwYXRjaGVyLmxlYXZlT3V0KGUsIGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc1BvaW50ZXJPdmVyYC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNQb2ludGVyT3ZlcihpbkV2ZW50KSB7XG4gIGNvbnN0IGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5lbnRlck92ZXIoZSwgaW5FdmVudCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zUG9pbnRlckNhbmNlbGAuXG4gKlxuICogQHRoaXMge01zU291cmNlfVxuICogQHBhcmFtIHtNU1BvaW50ZXJFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIG1zUG9pbnRlckNhbmNlbChpbkV2ZW50KSB7XG4gIGNvbnN0IGUgPSB0aGlzLnByZXBhcmVFdmVudF8oaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5jYW5jZWwoZSwgaW5FdmVudCk7XG4gIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYG1zTG9zdFBvaW50ZXJDYXB0dXJlYC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNMb3N0UG9pbnRlckNhcHR1cmUoaW5FdmVudCkge1xuICBjb25zdCBlID0gdGhpcy5kaXNwYXRjaGVyLm1ha2VFdmVudCgnbG9zdHBvaW50ZXJjYXB0dXJlJywgaW5FdmVudCwgaW5FdmVudCk7XG4gIHRoaXMuZGlzcGF0Y2hlci5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBtc0dvdFBvaW50ZXJDYXB0dXJlYC5cbiAqXG4gKiBAdGhpcyB7TXNTb3VyY2V9XG4gKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbXNHb3RQb2ludGVyQ2FwdHVyZShpbkV2ZW50KSB7XG4gIGNvbnN0IGUgPSB0aGlzLmRpc3BhdGNoZXIubWFrZUV2ZW50KCdnb3Rwb2ludGVyY2FwdHVyZScsIGluRXZlbnQsIGluRXZlbnQpO1xuICB0aGlzLmRpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuY2xhc3MgTXNTb3VyY2UgZXh0ZW5kcyBFdmVudFNvdXJjZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzXCIpLmRlZmF1bHR9IGRpc3BhdGNoZXIgRXZlbnQgaGFuZGxlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRpc3BhdGNoZXIpIHtcbiAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgJ01TUG9pbnRlckRvd24nOiBtc1BvaW50ZXJEb3duLFxuICAgICAgJ01TUG9pbnRlck1vdmUnOiBtc1BvaW50ZXJNb3ZlLFxuICAgICAgJ01TUG9pbnRlclVwJzogbXNQb2ludGVyVXAsXG4gICAgICAnTVNQb2ludGVyT3V0JzogbXNQb2ludGVyT3V0LFxuICAgICAgJ01TUG9pbnRlck92ZXInOiBtc1BvaW50ZXJPdmVyLFxuICAgICAgJ01TUG9pbnRlckNhbmNlbCc6IG1zUG9pbnRlckNhbmNlbCxcbiAgICAgICdNU0dvdFBvaW50ZXJDYXB0dXJlJzogbXNHb3RQb2ludGVyQ2FwdHVyZSxcbiAgICAgICdNU0xvc3RQb2ludGVyQ2FwdHVyZSc6IG1zTG9zdFBvaW50ZXJDYXB0dXJlXG4gICAgfTtcbiAgICBzdXBlcihkaXNwYXRjaGVyLCBtYXBwaW5nKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgTVNQb2ludGVyRXZlbnR8T2JqZWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJNYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJNYXA7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgd2lsbCBiZSB1c2VkXG4gICAqIGZvciB0aGUgZmFrZSBwb2ludGVyIGV2ZW50LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge01TUG9pbnRlckV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29waWVkIGV2ZW50LlxuICAgKi9cbiAgcHJlcGFyZUV2ZW50XyhpbkV2ZW50KSB7XG4gICAgLyoqIEB0eXBlIHtNU1BvaW50ZXJFdmVudHxPYmplY3R9ICovXG4gICAgbGV0IGUgPSBpbkV2ZW50O1xuICAgIGlmICh0eXBlb2YgaW5FdmVudC5wb2ludGVyVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGUgPSB0aGlzLmRpc3BhdGNoZXIuY2xvbmVFdmVudChpbkV2ZW50LCBpbkV2ZW50KTtcbiAgICAgIGUucG9pbnRlclR5cGUgPSBQT0lOVEVSX1RZUEVTW2luRXZlbnQucG9pbnRlclR5cGVdO1xuICAgIH1cblxuICAgIHJldHVybiBlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGlzIHBvaW50ZXIgZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgcG9pbnRlcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludGVySWQgUG9pbnRlciBpZGVudGlmaWVyLlxuICAgKi9cbiAgY2xlYW51cChwb2ludGVySWQpIHtcbiAgICBkZWxldGUgdGhpcy5wb2ludGVyTWFwW3BvaW50ZXJJZC50b1N0cmluZygpXTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1zU291cmNlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3BvaW50ZXIvTmF0aXZlU291cmNlXG4gKi9cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnLi9FdmVudFNvdXJjZS5qcyc7XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHBvaW50ZXJkb3duYC5cbiAqXG4gKiBAdGhpcyB7TmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJEb3duKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcm1vdmVgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlck1vdmUoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBwb2ludGVydXBgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlclVwKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcm91dGAuXG4gKlxuICogQHRoaXMge05hdGl2ZVNvdXJjZX1cbiAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiBwb2ludGVyT3V0KGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgcG9pbnRlcm92ZXJgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gcG9pbnRlck92ZXIoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBwb2ludGVyY2FuY2VsYC5cbiAqXG4gKiBAdGhpcyB7TmF0aXZlU291cmNlfVxuICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHBvaW50ZXJDYW5jZWwoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGBsb3N0cG9pbnRlcmNhcHR1cmVgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gbG9zdFBvaW50ZXJDYXB0dXJlKGluRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaGVyLmZpcmVOYXRpdmVFdmVudChpbkV2ZW50KTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgZ290cG9pbnRlcmNhcHR1cmVgLlxuICpcbiAqIEB0aGlzIHtOYXRpdmVTb3VyY2V9XG4gKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ290UG9pbnRlckNhcHR1cmUoaW5FdmVudCkge1xuICB0aGlzLmRpc3BhdGNoZXIuZmlyZU5hdGl2ZUV2ZW50KGluRXZlbnQpO1xufVxuXG5jbGFzcyBOYXRpdmVTb3VyY2UgZXh0ZW5kcyBFdmVudFNvdXJjZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzXCIpLmRlZmF1bHR9IGRpc3BhdGNoZXIgRXZlbnQgaGFuZGxlci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGRpc3BhdGNoZXIpIHtcbiAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgJ3BvaW50ZXJkb3duJzogcG9pbnRlckRvd24sXG4gICAgICAncG9pbnRlcm1vdmUnOiBwb2ludGVyTW92ZSxcbiAgICAgICdwb2ludGVydXAnOiBwb2ludGVyVXAsXG4gICAgICAncG9pbnRlcm91dCc6IHBvaW50ZXJPdXQsXG4gICAgICAncG9pbnRlcm92ZXInOiBwb2ludGVyT3ZlcixcbiAgICAgICdwb2ludGVyY2FuY2VsJzogcG9pbnRlckNhbmNlbCxcbiAgICAgICdnb3Rwb2ludGVyY2FwdHVyZSc6IGdvdFBvaW50ZXJDYXB0dXJlLFxuICAgICAgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6IGxvc3RQb2ludGVyQ2FwdHVyZVxuICAgIH07XG4gICAgc3VwZXIoZGlzcGF0Y2hlciwgbWFwcGluZyk7XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBOYXRpdmVTb3VyY2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Qb2ludGVyRXZlbnRcbiAqL1xuXG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9Qb2ludGVyRXZlbnRzXG5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBUaGUgUG9seW1lciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuLy8gbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuLy8gbWV0OlxuLy9cbi8vICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbi8vIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbi8vICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuLy8gY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lclxuLy8gaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuLy8gZGlzdHJpYnV0aW9uLlxuLy8gKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4vLyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuLy8gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbi8vXG4vLyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4vLyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1Jcbi8vIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4vLyBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbi8vIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuLy8gREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4vLyBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4vLyAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0Vcbi8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cbmltcG9ydCBfRXZlbnQgZnJvbSAnLi4vZXZlbnRzL0V2ZW50LmpzJztcblxuXG4vKipcbiAqIElzIHRoZSBgYnV0dG9uc2AgcHJvcGVydHkgc3VwcG9ydGVkP1xuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbmxldCBIQVNfQlVUVE9OUyA9IGZhbHNlO1xuXG5cbmNsYXNzIFBvaW50ZXJFdmVudCBleHRlbmRzIF9FdmVudCB7XG5cbiAgLyoqXG4gICAqIEEgY2xhc3MgZm9yIHBvaW50ZXIgZXZlbnRzLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIGlzIHVzZWQgYXMgYW4gYWJzdHJhY3Rpb24gZm9yIG1vdXNlIGV2ZW50cyxcbiAgICogdG91Y2ggZXZlbnRzIGFuZCBldmVuIG5hdGl2ZSBwb2ludGVyIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtIHtFdmVudH0gb3JpZ2luYWxFdmVudCBUaGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgPz49fSBvcHRfZXZlbnREaWN0IEFuIG9wdGlvbmFsIGRpY3Rpb25hcnkgb2ZcbiAgICogICAgaW5pdGlhbCBldmVudCBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3JpZ2luYWxFdmVudCwgb3B0X2V2ZW50RGljdCkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge0V2ZW50fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG5cbiAgICBjb25zdCBldmVudERpY3QgPSBvcHRfZXZlbnREaWN0ID8gb3B0X2V2ZW50RGljdCA6IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbnMgPSBnZXRCdXR0b25zKGV2ZW50RGljdCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucHJlc3N1cmUgPSBnZXRQcmVzc3VyZShldmVudERpY3QsIHRoaXMuYnV0dG9ucyk7XG5cbiAgICAvLyBNb3VzZUV2ZW50IHJlbGF0ZWQgcHJvcGVydGllc1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5idWJibGVzID0gJ2J1YmJsZXMnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnYnViYmxlcyddIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNhbmNlbGFibGUgPSAnY2FuY2VsYWJsZScgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydjYW5jZWxhYmxlJ10gOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy52aWV3ID0gJ3ZpZXcnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsndmlldyddIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZXRhaWwgPSAnZGV0YWlsJyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2RldGFpbCddIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zY3JlZW5YID0gJ3NjcmVlblgnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnc2NyZWVuWCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zY3JlZW5ZID0gJ3NjcmVlblknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnc2NyZWVuWSddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRYID0gJ2NsaWVudFgnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnY2xpZW50WCddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRZID0gJ2NsaWVudFknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnY2xpZW50WSddIDogMDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuY3RybEtleSA9ICdjdHJsS2V5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2N0cmxLZXknXSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hbHRLZXkgPSAnYWx0S2V5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2FsdEtleSddIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNoaWZ0S2V5ID0gJ3NoaWZ0S2V5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ3NoaWZ0S2V5J10gOiBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubWV0YUtleSA9ICdtZXRhS2V5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ21ldGFLZXknXSA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbiA9ICdidXR0b24nIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnYnV0dG9uJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge05vZGV9XG4gICAgICovXG4gICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gJ3JlbGF0ZWRUYXJnZXQnIGluIGV2ZW50RGljdCA/XG4gICAgICBldmVudERpY3RbJ3JlbGF0ZWRUYXJnZXQnXSA6IG51bGw7XG5cbiAgICAvLyBQb2ludGVyRXZlbnQgcmVsYXRlZCBwcm9wZXJ0aWVzXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlcklkID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0Wydwb2ludGVySWQnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMud2lkdGggPSAnd2lkdGgnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsnd2lkdGgnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gJ2hlaWdodCcgaW4gZXZlbnREaWN0ID8gZXZlbnREaWN0WydoZWlnaHQnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsdFggPSAndGlsdFgnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsndGlsdFgnXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudGlsdFkgPSAndGlsdFknIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsndGlsdFknXSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucG9pbnRlclR5cGUgPSAncG9pbnRlclR5cGUnIGluIGV2ZW50RGljdCA/IGV2ZW50RGljdFsncG9pbnRlclR5cGUnXSA6ICcnO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmh3VGltZXN0YW1wID0gJ2h3VGltZXN0YW1wJyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2h3VGltZXN0YW1wJ10gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc1ByaW1hcnkgPSAnaXNQcmltYXJ5JyBpbiBldmVudERpY3QgPyBldmVudERpY3RbJ2lzUHJpbWFyeSddIDogZmFsc2U7XG5cbiAgICAvLyBrZWVwIHRoZSBzZW1hbnRpY3Mgb2YgcHJldmVudERlZmF1bHRcbiAgICBpZiAob3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsID8+fSBldmVudERpY3QgVGhlIGV2ZW50IGRpY3Rpb25hcnkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEJ1dHRvbiBpbmRpY2F0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldEJ1dHRvbnMoZXZlbnREaWN0KSB7XG4gIC8vIEFjY29yZGluZyB0byB0aGUgdzNjIHNwZWMsXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLU1vdXNlRXZlbnQtYnV0dG9uXG4gIC8vIE1vdXNlRXZlbnQuYnV0dG9uID09IDAgY2FuIG1lYW4gZWl0aGVyIG5vIG1vdXNlIGJ1dHRvbiBkZXByZXNzZWQsIG9yIHRoZVxuICAvLyBsZWZ0IG1vdXNlIGJ1dHRvbiBkZXByZXNzZWQuXG4gIC8vXG4gIC8vIEFzIG9mIG5vdywgdGhlIG9ubHkgd2F5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIHR3byBzdGF0ZXMgb2ZcbiAgLy8gTW91c2VFdmVudC5idXR0b24gaXMgYnkgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgTW91c2VFdmVudC53aGljaCBwcm9wZXJ0eSwgYXNcbiAgLy8gdGhpcyBtYXBzIG1vdXNlIGJ1dHRvbnMgdG8gcG9zaXRpdmUgaW50ZWdlcnMgPiAwLCBhbmQgdXNlcyAwIHRvIG1lYW4gdGhhdFxuICAvLyBubyBtb3VzZSBidXR0b24gaXMgaGVsZC5cbiAgLy9cbiAgLy8gTW91c2VFdmVudC53aGljaCBpcyBkZXJpdmVkIGZyb20gTW91c2VFdmVudC5idXR0b24gYXQgTW91c2VFdmVudCBjcmVhdGlvbixcbiAgLy8gYnV0IGluaXRNb3VzZUV2ZW50IGRvZXMgbm90IGV4cG9zZSBhbiBhcmd1bWVudCB3aXRoIHdoaWNoIHRvIHNldFxuICAvLyBNb3VzZUV2ZW50LndoaWNoLiBDYWxsaW5nIGluaXRNb3VzZUV2ZW50IHdpdGggYSBidXR0b25Bcmcgb2YgMCB3aWxsIHNldFxuICAvLyBNb3VzZUV2ZW50LmJ1dHRvbiA9PSAwIGFuZCBNb3VzZUV2ZW50LndoaWNoID09IDEsIGJyZWFraW5nIHRoZSBleHBlY3RhdGlvbnNcbiAgLy8gb2YgYXBwIGRldmVsb3BlcnMuXG4gIC8vXG4gIC8vIFRoZSBvbmx5IHdheSB0byBwcm9wYWdhdGUgdGhlIGNvcnJlY3Qgc3RhdGUgb2YgTW91c2VFdmVudC53aGljaCBhbmRcbiAgLy8gTW91c2VFdmVudC5idXR0b24gdG8gYSBuZXcgTW91c2VFdmVudC5idXR0b24gPT0gMCBhbmQgTW91c2VFdmVudC53aGljaCA9PSAwXG4gIC8vIGlzIHRvIGNhbGwgaW5pdE1vdXNlRXZlbnQgd2l0aCBhIGJ1dHRvbkFyZyB2YWx1ZSBvZiAtMS5cbiAgLy9cbiAgLy8gVGhpcyBpcyBmaXhlZCB3aXRoIERPTSBMZXZlbCA0J3MgdXNlIG9mIGJ1dHRvbnNcbiAgbGV0IGJ1dHRvbnM7XG4gIGlmIChldmVudERpY3QuYnV0dG9ucyB8fCBIQVNfQlVUVE9OUykge1xuICAgIGJ1dHRvbnMgPSBldmVudERpY3QuYnV0dG9ucztcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKGV2ZW50RGljdC53aGljaCkge1xuICAgICAgY2FzZSAxOiBidXR0b25zID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IGJ1dHRvbnMgPSA0OyBicmVhaztcbiAgICAgIGNhc2UgMzogYnV0dG9ucyA9IDI7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogYnV0dG9ucyA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBidXR0b25zO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCA/Pn0gZXZlbnREaWN0IFRoZSBldmVudCBkaWN0aW9uYXJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1dHRvbnMgQnV0dG9uIGluZGljYXRvci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHByZXNzdXJlLlxuICovXG5mdW5jdGlvbiBnZXRQcmVzc3VyZShldmVudERpY3QsIGJ1dHRvbnMpIHtcbiAgLy8gU3BlYyByZXF1aXJlcyB0aGF0IHBvaW50ZXJzIHdpdGhvdXQgcHJlc3N1cmUgc3BlY2lmaWVkIHVzZSAwLjUgZm9yIGRvd25cbiAgLy8gc3RhdGUgYW5kIDAgZm9yIHVwIHN0YXRlLlxuICBsZXQgcHJlc3N1cmUgPSAwO1xuICBpZiAoZXZlbnREaWN0LnByZXNzdXJlKSB7XG4gICAgcHJlc3N1cmUgPSBldmVudERpY3QucHJlc3N1cmU7XG4gIH0gZWxzZSB7XG4gICAgcHJlc3N1cmUgPSBidXR0b25zID8gMC41IDogMDtcbiAgfVxuICByZXR1cm4gcHJlc3N1cmU7XG59XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGBidXR0b25zYCBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQuXG4gKi9cbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBldiA9IG5ldyBNb3VzZUV2ZW50KCdjbGljaycsIHtidXR0b25zOiAxfSk7XG4gICAgSEFTX0JVVFRPTlMgPSBldi5idXR0b25zID09PSAxO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gcGFzc1xuICB9XG59KSgpO1xuXG5leHBvcnQgZGVmYXVsdCBQb2ludGVyRXZlbnQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Ub3VjaFNvdXJjZVxuICovXG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL1BvaW50ZXJFdmVudHNcblxuLy8gQ29weXJpZ2h0IChjKSAyMDEzIFRoZSBQb2x5bWVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cblxuaW1wb3J0IHtyZW1vdmV9IGZyb20gJy4uL2FycmF5LmpzJztcbmltcG9ydCBFdmVudFNvdXJjZSBmcm9tICcuL0V2ZW50U291cmNlLmpzJztcbmltcG9ydCB7UE9JTlRFUl9JRH0gZnJvbSAnLi9Nb3VzZVNvdXJjZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBDTElDS19DT1VOVF9USU1FT1VUID0gMjAwO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFBPSU5URVJfVFlQRSA9ICd0b3VjaCc7XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHRvdWNoc3RhcnRgLCB0cmlnZ2VycyBgcG9pbnRlcm92ZXJgLFxuICogYHBvaW50ZXJlbnRlcmAgYW5kIGBwb2ludGVyZG93bmAgZXZlbnRzLlxuICpcbiAqIEB0aGlzIHtUb3VjaFNvdXJjZX1cbiAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIHRvdWNoc3RhcnQoaW5FdmVudCkge1xuICB0aGlzLnZhY3V1bVRvdWNoZXNfKGluRXZlbnQpO1xuICB0aGlzLnNldFByaW1hcnlUb3VjaF8oaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gIHRoaXMuZGVkdXBTeW50aE1vdXNlXyhpbkV2ZW50KTtcbiAgdGhpcy5jbGlja0NvdW50XysrO1xuICB0aGlzLnByb2Nlc3NUb3VjaGVzXyhpbkV2ZW50LCB0aGlzLm92ZXJEb3duXyk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYHRvdWNobW92ZWAuXG4gKlxuICogQHRoaXMge1RvdWNoU291cmNlfVxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBpbiBldmVudC5cbiAqL1xuZnVuY3Rpb24gdG91Y2htb3ZlKGluRXZlbnQpIHtcbiAgdGhpcy5wcm9jZXNzVG91Y2hlc18oaW5FdmVudCwgdGhpcy5tb3ZlT3Zlck91dF8pO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIGB0b3VjaGVuZGAsIHRyaWdnZXJzIGBwb2ludGVydXBgLFxuICogYHBvaW50ZXJvdXRgIGFuZCBgcG9pbnRlcmxlYXZlYCBldmVudHMuXG4gKlxuICogQHRoaXMge1RvdWNoU291cmNlfVxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBpbkV2ZW50IFRoZSBldmVudC5cbiAqL1xuZnVuY3Rpb24gdG91Y2hlbmQoaW5FdmVudCkge1xuICB0aGlzLmRlZHVwU3ludGhNb3VzZV8oaW5FdmVudCk7XG4gIHRoaXMucHJvY2Vzc1RvdWNoZXNfKGluRXZlbnQsIHRoaXMudXBPdXRfKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBgdG91Y2hjYW5jZWxgLCB0cmlnZ2VycyBgcG9pbnRlcmNhbmNlbGAsXG4gKiBgcG9pbnRlcm91dGAgYW5kIGBwb2ludGVybGVhdmVgIGV2ZW50cy5cbiAqXG4gKiBAdGhpcyB7VG91Y2hTb3VyY2V9XG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICovXG5mdW5jdGlvbiB0b3VjaGNhbmNlbChpbkV2ZW50KSB7XG4gIHRoaXMucHJvY2Vzc1RvdWNoZXNfKGluRXZlbnQsIHRoaXMuY2FuY2VsT3V0Xyk7XG59XG5cblxuY2xhc3MgVG91Y2hTb3VyY2UgZXh0ZW5kcyBFdmVudFNvdXJjZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzXCIpLmRlZmF1bHR9IGRpc3BhdGNoZXIgVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Nb3VzZVNvdXJjZS5qc1wiKS5kZWZhdWx0fSBtb3VzZVNvdXJjZSBNb3VzZSBzb3VyY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkaXNwYXRjaGVyLCBtb3VzZVNvdXJjZSkge1xuICAgIGNvbnN0IG1hcHBpbmcgPSB7XG4gICAgICAndG91Y2hzdGFydCc6IHRvdWNoc3RhcnQsXG4gICAgICAndG91Y2htb3ZlJzogdG91Y2htb3ZlLFxuICAgICAgJ3RvdWNoZW5kJzogdG91Y2hlbmQsXG4gICAgICAndG91Y2hjYW5jZWwnOiB0b3VjaGNhbmNlbFxuICAgIH07XG4gICAgc3VwZXIoZGlzcGF0Y2hlciwgbWFwcGluZyk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEV2ZW50fE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyTWFwID0gZGlzcGF0Y2hlci5wb2ludGVyTWFwO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vTW91c2VTb3VyY2UuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1vdXNlU291cmNlID0gbW91c2VTb3VyY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZmlyc3RUb3VjaElkXyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWNrQ291bnRfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez99XG4gICAgICovXG4gICAgdGhpcy5yZXNldElkXztcblxuICAgIC8qKlxuICAgICAqIE1vdXNlIGV2ZW50IHRpbWVvdXQ6IFRoaXMgc2hvdWxkIGJlIGxvbmcgZW5vdWdoIHRvXG4gICAgICogaWdub3JlIGNvbXBhdCBtb3VzZSBldmVudHMgbWFkZSBieSB0b3VjaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kZWR1cFRpbWVvdXRfID0gMjUwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNofSBpblRvdWNoIFRoZSBpbiB0b3VjaC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSwgaWYgdGhpcyBpcyB0aGUgcHJpbWFyeSB0b3VjaC5cbiAgICovXG4gIGlzUHJpbWFyeVRvdWNoXyhpblRvdWNoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RUb3VjaElkXyA9PT0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBwcmltYXJ5IHRvdWNoIGlmIHRoZXJlIGFyZSBubyBwb2ludGVycywgb3IgdGhlIG9ubHkgcG9pbnRlciBpcyB0aGUgbW91c2UuXG4gICAqIEBwYXJhbSB7VG91Y2h9IGluVG91Y2ggVGhlIGluIHRvdWNoLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0UHJpbWFyeVRvdWNoXyhpblRvdWNoKSB7XG4gICAgY29uc3QgY291bnQgPSBPYmplY3Qua2V5cyh0aGlzLnBvaW50ZXJNYXApLmxlbmd0aDtcbiAgICBpZiAoY291bnQgPT09IDAgfHwgKGNvdW50ID09PSAxICYmIFBPSU5URVJfSUQudG9TdHJpbmcoKSBpbiB0aGlzLnBvaW50ZXJNYXApKSB7XG4gICAgICB0aGlzLmZpcnN0VG91Y2hJZF8gPSBpblRvdWNoLmlkZW50aWZpZXI7XG4gICAgICB0aGlzLmNhbmNlbFJlc2V0Q2xpY2tDb3VudF8oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGluUG9pbnRlciBUaGUgaW4gcG9pbnRlciBvYmplY3QuXG4gICAqL1xuICByZW1vdmVQcmltYXJ5UG9pbnRlcl8oaW5Qb2ludGVyKSB7XG4gICAgaWYgKGluUG9pbnRlci5pc1ByaW1hcnkpIHtcbiAgICAgIHRoaXMuZmlyc3RUb3VjaElkXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVzZXRDbGlja0NvdW50XygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXRDbGlja0NvdW50XygpIHtcbiAgICB0aGlzLnJlc2V0SWRfID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMucmVzZXRDbGlja0NvdW50SGFuZGxlcl8uYmluZCh0aGlzKSxcbiAgICAgIENMSUNLX0NPVU5UX1RJTUVPVVQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXNldENsaWNrQ291bnRIYW5kbGVyXygpIHtcbiAgICB0aGlzLmNsaWNrQ291bnRfID0gMDtcbiAgICB0aGlzLnJlc2V0SWRfID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5jZWxSZXNldENsaWNrQ291bnRfKCkge1xuICAgIGlmICh0aGlzLnJlc2V0SWRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0SWRfKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgQnJvd3NlciBldmVudFxuICAgKiBAcGFyYW0ge1RvdWNofSBpblRvdWNoIFRvdWNoIGV2ZW50XG4gICAqIEByZXR1cm4ge1BvaW50ZXJFdmVudH0gQSBwb2ludGVyIG9iamVjdC5cbiAgICovXG4gIHRvdWNoVG9Qb2ludGVyXyhicm93c2VyRXZlbnQsIGluVG91Y2gpIHtcbiAgICBjb25zdCBlID0gdGhpcy5kaXNwYXRjaGVyLmNsb25lRXZlbnQoYnJvd3NlckV2ZW50LCBpblRvdWNoKTtcbiAgICAvLyBTcGVjIHNwZWNpZmllcyB0aGF0IHBvaW50ZXJJZCAxIGlzIHJlc2VydmVkIGZvciBNb3VzZS5cbiAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBjYW4gc3RhcnQgYXQgMC5cbiAgICAvLyBBZGQgMiB0byB0aGUgdG91Y2ggaWRlbnRpZmllciBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICBlLnBvaW50ZXJJZCA9IGluVG91Y2guaWRlbnRpZmllciArIDI7XG4gICAgLy8gVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBuZWNlc3Nhcnk/XG4gICAgLy9lLnRhcmdldCA9IGZpbmRUYXJnZXQoZSk7XG4gICAgZS5idWJibGVzID0gdHJ1ZTtcbiAgICBlLmNhbmNlbGFibGUgPSB0cnVlO1xuICAgIGUuZGV0YWlsID0gdGhpcy5jbGlja0NvdW50XztcbiAgICBlLmJ1dHRvbiA9IDA7XG4gICAgZS5idXR0b25zID0gMTtcbiAgICBlLndpZHRoID0gaW5Ub3VjaC5yYWRpdXNYIHx8IDA7XG4gICAgZS5oZWlnaHQgPSBpblRvdWNoLnJhZGl1c1kgfHwgMDtcbiAgICBlLnByZXNzdXJlID0gaW5Ub3VjaC5mb3JjZSB8fCAwLjU7XG4gICAgZS5pc1ByaW1hcnkgPSB0aGlzLmlzUHJpbWFyeVRvdWNoXyhpblRvdWNoKTtcbiAgICBlLnBvaW50ZXJUeXBlID0gUE9JTlRFUl9UWVBFO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIHByb3BlcnRpZXMgdGhhdCBhcmUgZGlmZmVyZW50IGZvclxuICAgIC8vIGVhY2ggYFRvdWNoYCBvYmplY3QgYXJlIG5vdCBjb3BpZWQgZnJvbSB0aGUgQnJvd3NlckV2ZW50IG9iamVjdFxuICAgIGUuY2xpZW50WCA9IGluVG91Y2guY2xpZW50WDtcbiAgICBlLmNsaWVudFkgPSBpblRvdWNoLmNsaWVudFk7XG4gICAgZS5zY3JlZW5YID0gaW5Ub3VjaC5zY3JlZW5YO1xuICAgIGUuc2NyZWVuWSA9IGluVG91Y2guc2NyZWVuWTtcblxuICAgIHJldHVybiBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUb3VjaCBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRvdWNoRXZlbnQsIFBvaW50ZXJFdmVudCl9IGluRnVuY3Rpb24gSW4gZnVuY3Rpb24uXG4gICAqL1xuICBwcm9jZXNzVG91Y2hlc18oaW5FdmVudCwgaW5GdW5jdGlvbikge1xuICAgIGNvbnN0IHRvdWNoZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbkV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcbiAgICBjb25zdCBjb3VudCA9IHRvdWNoZXMubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLnRvdWNoVG9Qb2ludGVyXyhpbkV2ZW50LCB0b3VjaGVzW2ldKTtcbiAgICAgIC8vIGZvcndhcmQgdG91Y2ggcHJldmVudERlZmF1bHRzXG4gICAgICBwb2ludGVyLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XG4gICAgICBpbkZ1bmN0aW9uLmNhbGwodGhpcywgaW5FdmVudCwgcG9pbnRlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hMaXN0fSB0b3VjaExpc3QgVGhlIHRvdWNoIGxpc3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWFyY2hJZCBTZWFyY2ggaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSwgaWYgdGhlIGBUb3VjaGAgd2l0aCB0aGUgZ2l2ZW4gaWQgaXMgaW4gdGhlIGxpc3QuXG4gICAqL1xuICBmaW5kVG91Y2hfKHRvdWNoTGlzdCwgc2VhcmNoSWQpIHtcbiAgICBjb25zdCBsID0gdG91Y2hMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgdG91Y2ggPSB0b3VjaExpc3RbaV07XG4gICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gc2VhcmNoSWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbiBzb21lIGluc3RhbmNlcywgYSB0b3VjaHN0YXJ0IGNhbiBoYXBwZW4gd2l0aG91dCBhIHRvdWNoZW5kLiBUaGlzXG4gICAqIGxlYXZlcyB0aGUgcG9pbnRlcm1hcCBpbiBhIGJyb2tlbiBzdGF0ZS5cbiAgICogVGhlcmVmb3JlLCBvbiBldmVyeSB0b3VjaHN0YXJ0LCB3ZSByZW1vdmUgdGhlIHRvdWNoZXMgdGhhdCBkaWQgbm90IGZpcmUgYVxuICAgKiB0b3VjaGVuZCBldmVudC5cbiAgICogVG8ga2VlcCBzdGF0ZSBnbG9iYWxseSBjb25zaXN0ZW50LCB3ZSBmaXJlIGEgcG9pbnRlcmNhbmNlbCBmb3JcbiAgICogdGhpcyBcImFiYW5kb25lZFwiIHRvdWNoXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gaW5FdmVudCBUaGUgaW4gZXZlbnQuXG4gICAqL1xuICB2YWN1dW1Ub3VjaGVzXyhpbkV2ZW50KSB7XG4gICAgY29uc3QgdG91Y2hMaXN0ID0gaW5FdmVudC50b3VjaGVzO1xuICAgIC8vIHBvaW50ZXJNYXAuZ2V0Q291bnQoKSBzaG91bGQgYmUgPCB0b3VjaExpc3QubGVuZ3RoIGhlcmUsXG4gICAgLy8gYXMgdGhlIHRvdWNoc3RhcnQgaGFzIG5vdCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucG9pbnRlck1hcCk7XG4gICAgY29uc3QgY291bnQgPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoY291bnQgPj0gdG91Y2hMaXN0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IE51bWJlcihrZXlzW2ldKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnBvaW50ZXJNYXBba2V5XTtcbiAgICAgICAgLy8gTmV2ZXIgcmVtb3ZlIHBvaW50ZXJJZCA9PSAxLCB3aGljaCBpcyBtb3VzZS5cbiAgICAgICAgLy8gVG91Y2ggaWRlbnRpZmllcnMgYXJlIDIgc21hbGxlciB0aGFuIHRoZWlyIHBvaW50ZXJJZCwgd2hpY2ggaXMgdGhlXG4gICAgICAgIC8vIGluZGV4IGluIHBvaW50ZXJtYXAuXG4gICAgICAgIGlmIChrZXkgIT0gUE9JTlRFUl9JRCAmJiAhdGhpcy5maW5kVG91Y2hfKHRvdWNoTGlzdCwga2V5IC0gMikpIHtcbiAgICAgICAgICBkLnB1c2godmFsdWUub3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsT3V0XyhpbkV2ZW50LCBkW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpbiBwb2ludGVyIG9iamVjdC5cbiAgICovXG4gIG92ZXJEb3duXyhicm93c2VyRXZlbnQsIGluUG9pbnRlcikge1xuICAgIHRoaXMucG9pbnRlck1hcFtpblBvaW50ZXIucG9pbnRlcklkXSA9IHtcbiAgICAgIHRhcmdldDogaW5Qb2ludGVyLnRhcmdldCxcbiAgICAgIG91dDogaW5Qb2ludGVyLFxuICAgICAgb3V0VGFyZ2V0OiBpblBvaW50ZXIudGFyZ2V0XG4gICAgfTtcbiAgICB0aGlzLmRpc3BhdGNoZXIub3ZlcihpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaGVyLmVudGVyKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIuZG93bihpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpbiBwb2ludGVyLlxuICAgKi9cbiAgbW92ZU92ZXJPdXRfKGJyb3dzZXJFdmVudCwgaW5Qb2ludGVyKSB7XG4gICAgY29uc3QgZXZlbnQgPSBpblBvaW50ZXI7XG4gICAgY29uc3QgcG9pbnRlciA9IHRoaXMucG9pbnRlck1hcFtldmVudC5wb2ludGVySWRdO1xuICAgIC8vIGEgZmluZ2VyIGRyaWZ0ZWQgb2ZmIHRoZSBzY3JlZW4sIGlnbm9yZSBpdFxuICAgIGlmICghcG9pbnRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvdXRFdmVudCA9IHBvaW50ZXIub3V0O1xuICAgIGNvbnN0IG91dFRhcmdldCA9IHBvaW50ZXIub3V0VGFyZ2V0O1xuICAgIHRoaXMuZGlzcGF0Y2hlci5tb3ZlKGV2ZW50LCBicm93c2VyRXZlbnQpO1xuICAgIGlmIChvdXRFdmVudCAmJiBvdXRUYXJnZXQgIT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgb3V0RXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqLyAoZXZlbnQpLnJlbGF0ZWRUYXJnZXQgPSBvdXRUYXJnZXQ7XG4gICAgICAvLyByZWNvdmVyIGZyb20gcmV0YXJnZXRpbmcgYnkgc2hhZG93XG4gICAgICBvdXRFdmVudC50YXJnZXQgPSBvdXRUYXJnZXQ7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hlci5sZWF2ZU91dChvdXRFdmVudCwgYnJvd3NlckV2ZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLmVudGVyT3ZlcihldmVudCwgYnJvd3NlckV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNsZWFuIHVwIGNhc2Ugd2hlbiBmaW5nZXIgbGVhdmVzIHRoZSBzY3JlZW5cbiAgICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovIChldmVudCkudGFyZ2V0ID0gb3V0VGFyZ2V0O1xuICAgICAgICAvKiogQHR5cGUge09iamVjdH0gKi8gKGV2ZW50KS5yZWxhdGVkVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW5jZWxPdXRfKGJyb3dzZXJFdmVudCwgZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyLm91dCA9IGV2ZW50O1xuICAgIHBvaW50ZXIub3V0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gYnJvd3NlckV2ZW50IEFuIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpblBvaW50ZXIgb2JqZWN0LlxuICAgKi9cbiAgdXBPdXRfKGJyb3dzZXJFdmVudCwgaW5Qb2ludGVyKSB7XG4gICAgdGhpcy5kaXNwYXRjaGVyLnVwKGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIub3V0KGluUG9pbnRlciwgYnJvd3NlckV2ZW50KTtcbiAgICB0aGlzLmRpc3BhdGNoZXIubGVhdmUoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuY2xlYW5VcFBvaW50ZXJfKGluUG9pbnRlcik7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBicm93c2VyRXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpbiBwb2ludGVyLlxuICAgKi9cbiAgY2FuY2VsT3V0Xyhicm93c2VyRXZlbnQsIGluUG9pbnRlcikge1xuICAgIHRoaXMuZGlzcGF0Y2hlci5jYW5jZWwoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5vdXQoaW5Qb2ludGVyLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hlci5sZWF2ZShpblBvaW50ZXIsIGJyb3dzZXJFdmVudCk7XG4gICAgdGhpcy5jbGVhblVwUG9pbnRlcl8oaW5Qb2ludGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gaW5Qb2ludGVyIFRoZSBpblBvaW50ZXIgb2JqZWN0LlxuICAgKi9cbiAgY2xlYW5VcFBvaW50ZXJfKGluUG9pbnRlcikge1xuICAgIGRlbGV0ZSB0aGlzLnBvaW50ZXJNYXBbaW5Qb2ludGVyLnBvaW50ZXJJZF07XG4gICAgdGhpcy5yZW1vdmVQcmltYXJ5UG9pbnRlcl8oaW5Qb2ludGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50IHN5bnRoIG1vdXNlIGV2ZW50cyBmcm9tIGNyZWF0aW5nIHBvaW50ZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGluRXZlbnQgVGhlIGluIGV2ZW50LlxuICAgKi9cbiAgZGVkdXBTeW50aE1vdXNlXyhpbkV2ZW50KSB7XG4gICAgY29uc3QgbHRzID0gdGhpcy5tb3VzZVNvdXJjZS5sYXN0VG91Y2hlcztcbiAgICBjb25zdCB0ID0gaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAvLyBvbmx5IHRoZSBwcmltYXJ5IGZpbmdlciB3aWxsIHN5bnRoIG1vdXNlIGV2ZW50c1xuICAgIGlmICh0aGlzLmlzUHJpbWFyeVRvdWNoXyh0KSkge1xuICAgICAgLy8gcmVtZW1iZXIgeC95IG9mIGxhc3QgdG91Y2hcbiAgICAgIGNvbnN0IGx0ID0gW3QuY2xpZW50WCwgdC5jbGllbnRZXTtcbiAgICAgIGx0cy5wdXNoKGx0KTtcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRvdWNoIGFmdGVyIHRpbWVvdXRcbiAgICAgICAgcmVtb3ZlKGx0cywgbHQpO1xuICAgICAgfSwgdGhpcy5kZWR1cFRpbWVvdXRfKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVG91Y2hTb3VyY2U7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvcG9pbnRlci9Qb2ludGVyRXZlbnRIYW5kbGVyXG4gKi9cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvUG9pbnRlckV2ZW50c1xuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMgVGhlIFBvbHltZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbi8vIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbi8vIG1ldDpcbi8vXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4vLyBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4vLyAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbi8vIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXJcbi8vIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbi8vIGRpc3RyaWJ1dGlvbi5cbi8vICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuLy8gY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb21cbi8vIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4vL1xuLy8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuLy8gXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4vLyBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuLy8gT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4vLyBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4vLyBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbi8vIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuLy8gVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuLy8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4vLyBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4uL2V2ZW50cy5qcyc7XG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQge1BPSU5URVIsIE1TUE9JTlRFUiwgVE9VQ0h9IGZyb20gJy4uL2hhcy5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgTW91c2VTb3VyY2UsIHtwcmVwYXJlRXZlbnQgYXMgcHJlcGFyZU1vdXNlRXZlbnR9IGZyb20gJy4vTW91c2VTb3VyY2UuanMnO1xuaW1wb3J0IE1zU291cmNlIGZyb20gJy4vTXNTb3VyY2UuanMnO1xuaW1wb3J0IE5hdGl2ZVNvdXJjZSBmcm9tICcuL05hdGl2ZVNvdXJjZS5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50IGZyb20gJy4vUG9pbnRlckV2ZW50LmpzJztcbmltcG9ydCBUb3VjaFNvdXJjZSBmcm9tICcuL1RvdWNoU291cmNlLmpzJztcblxuXG4vKipcbiAqIFByb3BlcnRpZXMgdG8gY29weSB3aGVuIGNsb25pbmcgYW4gZXZlbnQsIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBAdHlwZSB7QXJyYXk8QXJyYXk+fVxuICovXG5jb25zdCBDTE9ORV9QUk9QUyA9IFtcbiAgLy8gTW91c2VFdmVudFxuICBbJ2J1YmJsZXMnLCBmYWxzZV0sXG4gIFsnY2FuY2VsYWJsZScsIGZhbHNlXSxcbiAgWyd2aWV3JywgbnVsbF0sXG4gIFsnZGV0YWlsJywgbnVsbF0sXG4gIFsnc2NyZWVuWCcsIDBdLFxuICBbJ3NjcmVlblknLCAwXSxcbiAgWydjbGllbnRYJywgMF0sXG4gIFsnY2xpZW50WScsIDBdLFxuICBbJ2N0cmxLZXknLCBmYWxzZV0sXG4gIFsnYWx0S2V5JywgZmFsc2VdLFxuICBbJ3NoaWZ0S2V5JywgZmFsc2VdLFxuICBbJ21ldGFLZXknLCBmYWxzZV0sXG4gIFsnYnV0dG9uJywgMF0sXG4gIFsncmVsYXRlZFRhcmdldCcsIG51bGxdLFxuICAvLyBET00gTGV2ZWwgM1xuICBbJ2J1dHRvbnMnLCAwXSxcbiAgLy8gUG9pbnRlckV2ZW50XG4gIFsncG9pbnRlcklkJywgMF0sXG4gIFsnd2lkdGgnLCAwXSxcbiAgWydoZWlnaHQnLCAwXSxcbiAgWydwcmVzc3VyZScsIDBdLFxuICBbJ3RpbHRYJywgMF0sXG4gIFsndGlsdFknLCAwXSxcbiAgWydwb2ludGVyVHlwZScsICcnXSxcbiAgWydod1RpbWVzdGFtcCcsIDBdLFxuICBbJ2lzUHJpbWFyeScsIGZhbHNlXSxcbiAgLy8gZXZlbnQgaW5zdGFuY2VcbiAgWyd0eXBlJywgJyddLFxuICBbJ3RhcmdldCcsIG51bGxdLFxuICBbJ2N1cnJlbnRUYXJnZXQnLCBudWxsXSxcbiAgWyd3aGljaCcsIDBdXG5dO1xuXG5cbmNsYXNzIFBvaW50ZXJFdmVudEhhbmRsZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudHxIVE1MRG9jdW1lbnR9IGVsZW1lbnQgVmlld3BvcnQgZWxlbWVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7RWxlbWVudHxIVE1MRG9jdW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50XyA9IGVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIEV2ZW50fE9iamVjdD59XG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyTWFwID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgZnVuY3Rpb24oRXZlbnQpPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRNYXBfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi9FdmVudFNvdXJjZS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZXZlbnRTb3VyY2VMaXN0XyA9IFtdO1xuXG4gICAgdGhpcy5yZWdpc3RlclNvdXJjZXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIGV2ZW50IHNvdXJjZXMgKG1vdXNlLCB0b3VjaCBhbmQgbmF0aXZlIHBvaW50ZXJzKVxuICAgKiB0aGF0IGdlbmVyYXRlIHBvaW50ZXIgZXZlbnRzLlxuICAgKi9cbiAgcmVnaXN0ZXJTb3VyY2VzKCkge1xuICAgIGlmIChQT0lOVEVSKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyU291cmNlKCduYXRpdmUnLCBuZXcgTmF0aXZlU291cmNlKHRoaXMpKTtcbiAgICB9IGVsc2UgaWYgKE1TUE9JTlRFUikge1xuICAgICAgdGhpcy5yZWdpc3RlclNvdXJjZSgnbXMnLCBuZXcgTXNTb3VyY2UodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtb3VzZVNvdXJjZSA9IG5ldyBNb3VzZVNvdXJjZSh0aGlzKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJTb3VyY2UoJ21vdXNlJywgbW91c2VTb3VyY2UpO1xuXG4gICAgICBpZiAoVE9VQ0gpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclNvdXJjZSgndG91Y2gnLCBuZXcgVG91Y2hTb3VyY2UodGhpcywgbW91c2VTb3VyY2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWdpc3RlciBldmVudHMgb24gdGhlIHZpZXdwb3J0IGVsZW1lbnRcbiAgICB0aGlzLnJlZ2lzdGVyXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBldmVudCBzb3VyY2UgdGhhdCB3aWxsIGdlbmVyYXRlIHBvaW50ZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIG5hbWUgZm9yIHRoZSBldmVudCBzb3VyY2VcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0V2ZW50U291cmNlLmpzXCIpLmRlZmF1bHR9IHNvdXJjZSBUaGUgc291cmNlIGV2ZW50LlxuICAgKi9cbiAgcmVnaXN0ZXJTb3VyY2UobmFtZSwgc291cmNlKSB7XG4gICAgY29uc3QgcyA9IHNvdXJjZTtcbiAgICBjb25zdCBuZXdFdmVudHMgPSBzLmdldEV2ZW50cygpO1xuXG4gICAgaWYgKG5ld0V2ZW50cykge1xuICAgICAgbmV3RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcy5nZXRIYW5kbGVyRm9yRXZlbnQoZSk7XG5cbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmV2ZW50TWFwX1tlXSA9IGhhbmRsZXIuYmluZChzKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2VMaXN0Xy5wdXNoKHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIGV2ZW50cyBmb3IgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgc291cmNlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVyXygpIHtcbiAgICBjb25zdCBsID0gdGhpcy5ldmVudFNvdXJjZUxpc3RfLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSB0aGlzLmV2ZW50U291cmNlTGlzdF9baV07XG4gICAgICB0aGlzLmFkZEV2ZW50c18oZXZlbnRTb3VyY2UuZ2V0RXZlbnRzKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIHJlZ2lzdGVyZWQgZXZlbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdW5yZWdpc3Rlcl8oKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuZXZlbnRTb3VyY2VMaXN0Xy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGV2ZW50U291cmNlID0gdGhpcy5ldmVudFNvdXJjZUxpc3RfW2ldO1xuICAgICAgdGhpcy5yZW1vdmVFdmVudHNfKGV2ZW50U291cmNlLmdldEV2ZW50cygpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIHJpZ2h0IGhhbmRsZXIgZm9yIGEgbmV3IGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAqL1xuICBldmVudEhhbmRsZXJfKGluRXZlbnQpIHtcbiAgICBjb25zdCB0eXBlID0gaW5FdmVudC50eXBlO1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmV2ZW50TWFwX1t0eXBlXTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihpbkV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV2ZW50cyBMaXN0IG9mIGV2ZW50cy5cbiAgICovXG4gIGFkZEV2ZW50c18oZXZlbnRzKSB7XG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICBsaXN0ZW4odGhpcy5lbGVtZW50XywgZXZlbnROYW1lLCB0aGlzLmV2ZW50SGFuZGxlcl8sIHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBldmVudHMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzIExpc3Qgb2YgZXZlbnRzLlxuICAgKi9cbiAgcmVtb3ZlRXZlbnRzXyhldmVudHMpIHtcbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICB1bmxpc3Rlbih0aGlzLmVsZW1lbnRfLCBlLCB0aGlzLmV2ZW50SGFuZGxlcl8sIHRoaXMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGluRXZlbnQsIHdpdGggd3JpdGFibGUgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgQnJvd3NlciBldmVudC5cbiAgICogQHBhcmFtIHtFdmVudHxUb3VjaH0gaW5FdmVudCBBbiBldmVudCB0aGF0IGNvbnRhaW5zXG4gICAqICAgIHByb3BlcnRpZXMgdG8gY29weS5cbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBzaGFsbG93IGNvcGllcyBvZlxuICAgKiAgICBgaW5FdmVudGAncyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgY2xvbmVFdmVudChldmVudCwgaW5FdmVudCkge1xuICAgIGNvbnN0IGV2ZW50Q29weSA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IENMT05FX1BST1BTLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHAgPSBDTE9ORV9QUk9QU1tpXVswXTtcbiAgICAgIGV2ZW50Q29weVtwXSA9IGV2ZW50W3BdIHx8IGluRXZlbnRbcF0gfHwgQ0xPTkVfUFJPUFNbaV1bMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50Q29weTtcbiAgfVxuXG4gIC8vIEVWRU5UU1xuXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJkb3duJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBkb3duKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSRE9XTiwgZGF0YSwgZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJtb3ZlJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBtb3ZlKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5maXJlRXZlbnQoUG9pbnRlckV2ZW50VHlwZS5QT0lOVEVSTU9WRSwgZGF0YSwgZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJ1cCcgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgdXAoZGF0YSwgZXZlbnQpIHtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJVUCwgZGF0YSwgZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJlbnRlcicgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgZW50ZXIoZGF0YSwgZXZlbnQpIHtcbiAgICBkYXRhLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJFTlRFUiwgZGF0YSwgZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJsZWF2ZScgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgbGVhdmUoZGF0YSwgZXZlbnQpIHtcbiAgICBkYXRhLmJ1YmJsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJMRUFWRSwgZGF0YSwgZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgJ3BvaW50ZXJvdmVyJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBvdmVyKGRhdGEsIGV2ZW50KSB7XG4gICAgZGF0YS5idWJibGVzID0gdHJ1ZTtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJPVkVSLCBkYXRhLCBldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYSAncG9pbnRlcm91dCcgZXZlbnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgb3V0KGRhdGEsIGV2ZW50KSB7XG4gICAgZGF0YS5idWJibGVzID0gdHJ1ZTtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJPVVQsIGRhdGEsIGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhICdwb2ludGVyY2FuY2VsJyBldmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqL1xuICBjYW5jZWwoZGF0YSwgZXZlbnQpIHtcbiAgICB0aGlzLmZpcmVFdmVudChQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJDQU5DRUwsIGRhdGEsIGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIGNvbWJpbmF0aW9uIG9mICdwb2ludGVyb3V0JyBhbmQgJ3BvaW50ZXJsZWF2ZScgZXZlbnRzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIGxlYXZlT3V0KGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5vdXQoZGF0YSwgZXZlbnQpO1xuICAgIGlmICghdGhpcy5jb250YWluc18oZGF0YS50YXJnZXQsIGRhdGEucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHRoaXMubGVhdmUoZGF0YSwgZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIGNvbWJpbmF0aW9uIG9mICdwb2ludGVyb3ZlcicgYW5kICdwb2ludGVyZXZlbnRzJyBldmVudHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFBvaW50ZXIgZXZlbnQgZGF0YS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKi9cbiAgZW50ZXJPdmVyKGRhdGEsIGV2ZW50KSB7XG4gICAgdGhpcy5vdmVyKGRhdGEsIGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuY29udGFpbnNfKGRhdGEudGFyZ2V0LCBkYXRhLnJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICB0aGlzLmVudGVyKGRhdGEsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgVGhlIGNvbnRhaW5lciBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lZCBUaGUgY29udGFpbmVkIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICogICBjb250YWlucyB0aGUgb3RoZXIgZWxlbWVudC5cbiAgICovXG4gIGNvbnRhaW5zXyhjb250YWluZXIsIGNvbnRhaW5lZCkge1xuICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lci5jb250YWlucyhjb250YWluZWQpO1xuICB9XG5cbiAgLy8gRVZFTlQgQ1JFQVRJT04gQU5EIFRSQUNLSU5HXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEV2ZW50IG9mIHR5cGUgYGluVHlwZWAsIGJhc2VkIG9uIHRoZSBpbmZvcm1hdGlvbiBpblxuICAgKiBgZGF0YWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpblR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGV2ZW50IHRvIGNyZWF0ZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgUG9pbnRlciBldmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQuXG4gICAqIEByZXR1cm4ge1BvaW50ZXJFdmVudH0gQSBQb2ludGVyRXZlbnQgb2YgdHlwZSBgaW5UeXBlYC5cbiAgICovXG4gIG1ha2VFdmVudChpblR5cGUsIGRhdGEsIGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludGVyRXZlbnQoaW5UeXBlLCBldmVudCwgZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhbmQgZGlzcGF0Y2ggYW4gZXZlbnQgaW4gb25lIGNhbGwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpblR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBQb2ludGVyIGV2ZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudC5cbiAgICovXG4gIGZpcmVFdmVudChpblR5cGUsIGRhdGEsIGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IHRoaXMubWFrZUV2ZW50KGluVHlwZSwgZGF0YSwgZXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcG9pbnRlciBldmVudCBmcm9tIGEgbmF0aXZlIHBvaW50ZXIgZXZlbnRcbiAgICogYW5kIGRpc3BhdGNoZXMgdGhpcyBldmVudC5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgQSBwbGF0Zm9ybSBldmVudCB3aXRoIGEgdGFyZ2V0LlxuICAgKi9cbiAgZmlyZU5hdGl2ZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IHRoaXMubWFrZUV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50LCBldmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXAgYSBuYXRpdmUgbW91c2UgZXZlbnQgaW50byBhIHBvaW50ZXIgZXZlbnQuXG4gICAqIFRoaXMgcHJveHkgbWV0aG9kIGlzIHJlcXVpcmVkIGZvciB0aGUgbGVnYWN5IElFIHN1cHBvcnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgVGhlIHBvaW50ZXIgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtQb2ludGVyRXZlbnR9IFRoZSB3cmFwcGVkIGV2ZW50LlxuICAgKi9cbiAgd3JhcE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBldmVudCkge1xuICAgIGNvbnN0IHBvaW50ZXJFdmVudCA9IHRoaXMubWFrZUV2ZW50KFxuICAgICAgZXZlbnRUeXBlLCBwcmVwYXJlTW91c2VFdmVudChldmVudCwgdGhpcyksIGV2ZW50KTtcbiAgICByZXR1cm4gcG9pbnRlckV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyXygpO1xuICAgIHN1cGVyLmRpc3Bvc2VJbnRlcm5hbCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvaW50ZXJFdmVudEhhbmRsZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwQnJvd3NlckV2ZW50SGFuZGxlclxuICovXG5pbXBvcnQge0RFVklDRV9QSVhFTF9SQVRJT30gZnJvbSAnLi9oYXMuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBCcm93c2VyUG9pbnRlckV2ZW50IGZyb20gJy4vTWFwQnJvd3NlclBvaW50ZXJFdmVudC5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW5CeUtleX0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4vZXZlbnRzL1RhcmdldC5qcyc7XG5pbXBvcnQgUG9pbnRlckV2ZW50VHlwZSBmcm9tICcuL3BvaW50ZXIvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBQb2ludGVyRXZlbnRIYW5kbGVyIGZyb20gJy4vcG9pbnRlci9Qb2ludGVyRXZlbnRIYW5kbGVyLmpzJztcblxuY2xhc3MgTWFwQnJvd3NlckV2ZW50SGFuZGxlciBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgVGhlIG1hcCB3aXRoIHRoZSB2aWV3cG9ydCB0byBsaXN0ZW4gdG8gZXZlbnRzIG9uLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG1vdmVUb2xlcmFuY2UgVGhlIG1pbmltYWwgZGlzdGFuY2UgdGhlIHBvaW50ZXIgbXVzdCB0cmF2ZWwgdG8gdHJpZ2dlciBhIG1vdmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtYXAsIG1vdmVUb2xlcmFuY2UpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2Ugd2lsbCBsaXN0ZW4gdG8gdGhlIHJlYWwgZXZlbnRzIG9uLlxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXBfID0gbWFwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2xpY2tUaW1lb3V0SWRfO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRyYWdnaW5nXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubW92ZVRvbGVyYW5jZV8gPSBtb3ZlVG9sZXJhbmNlID9cbiAgICAgIG1vdmVUb2xlcmFuY2UgKiBERVZJQ0VfUElYRUxfUkFUSU8gOiBERVZJQ0VfUElYRUxfUkFUSU87XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCByZWNlbnQgXCJkb3duXCIgdHlwZSBldmVudCAob3IgbnVsbCBpZiBub25lIGhhdmUgb2NjdXJyZWQpLlxuICAgICAqIFNldCBvbiBwb2ludGVyZG93bi5cbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kb3duXyA9IG51bGw7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5tYXBfLmdldFZpZXdwb3J0KCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVQb2ludGVyc18gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8bnVtYmVyLCBib29sZWFuPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHJhY2tlZFRvdWNoZXNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyIHdoaWNoIGdlbmVyYXRlcyBwb2ludGVyIGV2ZW50cyBmb3JcbiAgICAgKiB0aGUgdmlld3BvcnQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtQb2ludGVyRXZlbnRIYW5kbGVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXyA9IG5ldyBQb2ludGVyRXZlbnRIYW5kbGVyKGVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlciB3aGljaCBnZW5lcmF0ZXMgcG9pbnRlciBldmVudHMgZm9yXG4gICAgICogdGhlIGRvY3VtZW50ICh1c2VkIHdoZW4gZHJhZ2dpbmcpLlxuICAgICAqXG4gICAgICogQHR5cGUge1BvaW50ZXJFdmVudEhhbmRsZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfID0gbGlzdGVuKHRoaXMucG9pbnRlckV2ZW50SGFuZGxlcl8sXG4gICAgICBQb2ludGVyRXZlbnRUeXBlLlBPSU5URVJET1dOLFxuICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93bl8sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8gPSBsaXN0ZW4odGhpcy5wb2ludGVyRXZlbnRIYW5kbGVyXyxcbiAgICAgIFBvaW50ZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUsXG4gICAgICB0aGlzLnJlbGF5RXZlbnRfLCB0aGlzKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtdWxhdGVDbGlja18ocG9pbnRlckV2ZW50KSB7XG4gICAgbGV0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLkNMSUNLLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICBpZiAodGhpcy5jbGlja1RpbWVvdXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZG91YmxlLWNsaWNrXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbGlja1RpbWVvdXRJZF8pO1xuICAgICAgdGhpcy5jbGlja1RpbWVvdXRJZF8gPSB1bmRlZmluZWQ7XG4gICAgICBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLkRCTENMSUNLLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjbGlja1xuICAgICAgdGhpcy5jbGlja1RpbWVvdXRJZF8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsaWNrVGltZW91dElkXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbmV3RXZlbnQgPSBuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlNJTkdMRUNMSUNLLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG4gICAgICB9LmJpbmQodGhpcyksIDI1MCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9uIGhvdyBtYW55IHBvaW50ZXJzIGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVBY3RpdmVQb2ludGVyc18ocG9pbnRlckV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBwb2ludGVyRXZlbnQ7XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PSBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCB8fFxuICAgICAgICBldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkNBTkNFTCkge1xuICAgICAgZGVsZXRlIHRoaXMudHJhY2tlZFRvdWNoZXNfW2V2ZW50LnBvaW50ZXJJZF07XG4gICAgfSBlbHNlIGlmIChldmVudC50eXBlID09IE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04pIHtcbiAgICAgIHRoaXMudHJhY2tlZFRvdWNoZXNfW2V2ZW50LnBvaW50ZXJJZF0gPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVBvaW50ZXJzXyA9IE9iamVjdC5rZXlzKHRoaXMudHJhY2tlZFRvdWNoZXNfKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlUG9pbnRlclVwXyhwb2ludGVyRXZlbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVBvaW50ZXJzXyhwb2ludGVyRXZlbnQpO1xuICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICBNYXBCcm93c2VyRXZlbnRUeXBlLlBPSU5URVJVUCwgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cbiAgICAvLyBXZSBlbXVsYXRlIGNsaWNrIGV2ZW50cyBvbiBsZWZ0IG1vdXNlIGJ1dHRvbiBjbGljaywgdG91Y2ggY29udGFjdCwgYW5kIHBlblxuICAgIC8vIGNvbnRhY3QuIGlzTW91c2VBY3Rpb25CdXR0b24gcmV0dXJucyB0cnVlIGluIHRoZXNlIGNhc2VzIChldnQuYnV0dG9uIGlzIHNldFxuICAgIC8vIHRvIDApLlxuICAgIC8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzXG4gICAgLy8gV2Ugb25seSBmaXJlIGNsaWNrLCBzaW5nbGVjbGljaywgYW5kIGRvdWJsZWNsaWNrIGlmIG5vYm9keSBoYXMgY2FsbGVkXG4gICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgb3IgZXZlbnQucHJldmVudERlZmF1bHQoKS5cbiAgICBpZiAoIW5ld0V2ZW50LnByb3BhZ2F0aW9uU3RvcHBlZCAmJiAhdGhpcy5kcmFnZ2luZ18gJiYgdGhpcy5pc01vdXNlQWN0aW9uQnV0dG9uXyhwb2ludGVyRXZlbnQpKSB7XG4gICAgICB0aGlzLmVtdWxhdGVDbGlja18odGhpcy5kb3duXyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZlUG9pbnRlcnNfID09PSAwKSB7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLmRyYWdnaW5nXyA9IGZhbHNlO1xuICAgICAgdGhpcy5kb3duXyA9IG51bGw7XG4gICAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgbGVmdCBtb3VzZSBidXR0b24gd2FzIHByZXNzZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01vdXNlQWN0aW9uQnV0dG9uXyhwb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gcG9pbnRlckV2ZW50LmJ1dHRvbiA9PT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb2ludGVyRG93bl8ocG9pbnRlckV2ZW50KSB7XG4gICAgdGhpcy51cGRhdGVBY3RpdmVQb2ludGVyc18ocG9pbnRlckV2ZW50KTtcbiAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBNYXBCcm93c2VyUG9pbnRlckV2ZW50KFxuICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSRE9XTiwgdGhpcy5tYXBfLCBwb2ludGVyRXZlbnQpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cbiAgICB0aGlzLmRvd25fID0gcG9pbnRlckV2ZW50O1xuXG4gICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyS2V5c18ubGVuZ3RoID09PSAwKSB7XG4gICAgICAvKiBTZXQgdXAgYSBwb2ludGVyIGV2ZW50IGhhbmRsZXIgb24gdGhlIGBkb2N1bWVudGAsXG4gICAgICAgKiB3aGljaCBpcyByZXF1aXJlZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmVkIG91dHNpZGVcbiAgICAgICAqIHRoZSB2aWV3cG9ydCB3aGVuIGRyYWdnaW5nLlxuICAgICAgICovXG4gICAgICB0aGlzLmRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl8gPVxuICAgICAgICAgIG5ldyBQb2ludGVyRXZlbnRIYW5kbGVyKGRvY3VtZW50KTtcblxuICAgICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5wdXNoKFxuICAgICAgICBsaXN0ZW4odGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfLFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUk1PVkUsXG4gICAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZV8sIHRoaXMpLFxuICAgICAgICBsaXN0ZW4odGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfLFxuICAgICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUlVQLFxuICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwXywgdGhpcyksXG4gICAgICAgIC8qIE5vdGUgdGhhdCB0aGUgbGlzdGVuZXIgZm9yIGBwb2ludGVyY2FuY2VsIGlzIHNldCB1cCBvblxuICAgICAgICAgKiBgcG9pbnRlckV2ZW50SGFuZGxlcl9gIGFuZCBub3QgYGRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl9gIGxpa2VcbiAgICAgICAgICogdGhlIGBwb2ludGVydXBgIGFuZCBgcG9pbnRlcm1vdmVgIGxpc3RlbmVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGUgZm9sbG93aW5nOiBgVG91Y2hTb3VyY2UudmFjdXVtVG91Y2hlc18oKWBcbiAgICAgICAgICogaXNzdWVzIGBwb2ludGVyY2FuY2VsYCBldmVudHMsIHdoZW4gdGhlcmUgd2FzIG5vIGB0b3VjaGVuZGAgZm9yIGFcbiAgICAgICAgICogYHRvdWNoc3RhcnRgLiBOb3csIGxldCdzIHNheSBhIGZpcnN0IGB0b3VjaHN0YXJ0YCBpcyByZWdpc3RlcmVkIG9uXG4gICAgICAgICAqIGBwb2ludGVyRXZlbnRIYW5kbGVyX2AuIFRoZSBgZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyX2AgaXMgc2V0IHVwLlxuICAgICAgICAgKiBCdXQgYGRvY3VtZW50UG9pbnRlckV2ZW50SGFuZGxlcl9gIGRvZXNuJ3Qga25vdyBhYm91dCB0aGUgZmlyc3RcbiAgICAgICAgICogYHRvdWNoc3RhcnRgLiBJZiB0aGVyZSBpcyBubyBgdG91Y2hlbmRgIGZvciB0aGUgYHRvdWNoc3RhcnRgLCB3ZSBjYW5cbiAgICAgICAgICogb25seSByZWNlaXZlIGEgYHRvdWNoY2FuY2VsYCBmcm9tIGBwb2ludGVyRXZlbnRIYW5kbGVyX2AsIGJlY2F1c2UgaXQgaXNcbiAgICAgICAgICogb25seSByZWdpc3RlcmVkIHRoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdGVuKHRoaXMucG9pbnRlckV2ZW50SGFuZGxlcl8sXG4gICAgICAgICAgTWFwQnJvd3NlckV2ZW50VHlwZS5QT0lOVEVSQ0FOQ0VMLFxuICAgICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwXywgdGhpcylcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9wb2ludGVyL1BvaW50ZXJFdmVudC5qc1wiKS5kZWZhdWx0fSBwb2ludGVyRXZlbnQgUG9pbnRlclxuICAgKiBldmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVBvaW50ZXJNb3ZlXyhwb2ludGVyRXZlbnQpIHtcbiAgICAvLyBCZXR3ZWVuIHBvaW50ZXJkb3duIGFuZCBwb2ludGVydXAsIHBvaW50ZXJtb3ZlIGV2ZW50cyBhcmUgdHJpZ2dlcmVkLlxuICAgIC8vIFRvIGF2b2lkIGEgJ2ZhbHNlJyB0b3VjaG1vdmUgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZCwgd2UgdGVzdCBpZiB0aGUgcG9pbnRlclxuICAgIC8vIG1vdmVkIGEgc2lnbmlmaWNhbnQgZGlzdGFuY2UuXG4gICAgaWYgKHRoaXMuaXNNb3ZpbmdfKHBvaW50ZXJFdmVudCkpIHtcbiAgICAgIHRoaXMuZHJhZ2dpbmdfID0gdHJ1ZTtcbiAgICAgIGNvbnN0IG5ld0V2ZW50ID0gbmV3IE1hcEJyb3dzZXJQb2ludGVyRXZlbnQoXG4gICAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRSQUcsIHRoaXMubWFwXywgcG9pbnRlckV2ZW50LFxuICAgICAgICB0aGlzLmRyYWdnaW5nXyk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuICAgIH1cblxuICAgIC8vIFNvbWUgbmF0aXZlIGFuZHJvaWQgYnJvd3NlciB0cmlnZ2VycyBtb3VzZW1vdmUgZXZlbnRzIGR1cmluZyBzbWFsbCBwZXJpb2RcbiAgICAvLyBvZiB0aW1lLiBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvYW5kcm9pZC9pc3N1ZXMvZGV0YWlsP2lkPTU0OTEgb3JcbiAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2FuZHJvaWQvaXNzdWVzL2RldGFpbD9pZD0xOTgyN1xuICAgIC8vIGV4OiBHYWxheHkgVGFiIFAzMTEwICsgQW5kcm9pZCA0LjEuMVxuICAgIHBvaW50ZXJFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXAgYW5kIHJlbGF5IGEgcG9pbnRlciBldmVudC4gIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHRoYXQgdGhlIHR5cGVcbiAgICogc3RyaW5nIGZvciB0aGUgTWFwQnJvd3NlclBvaW50ZXJFdmVudCBtYXRjaGVzIHRoZSBQb2ludGVyRXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BvaW50ZXIvUG9pbnRlckV2ZW50LmpzXCIpLmRlZmF1bHR9IHBvaW50ZXJFdmVudCBQb2ludGVyXG4gICAqIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVsYXlFdmVudF8ocG9pbnRlckV2ZW50KSB7XG4gICAgY29uc3QgZHJhZ2dpbmcgPSAhISh0aGlzLmRvd25fICYmIHRoaXMuaXNNb3ZpbmdfKHBvaW50ZXJFdmVudCkpO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwQnJvd3NlclBvaW50ZXJFdmVudChcbiAgICAgIHBvaW50ZXJFdmVudC50eXBlLCB0aGlzLm1hcF8sIHBvaW50ZXJFdmVudCwgZHJhZ2dpbmcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcG9pbnRlci9Qb2ludGVyRXZlbnQuanNcIikuZGVmYXVsdH0gcG9pbnRlckV2ZW50IFBvaW50ZXJcbiAgICogZXZlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIG1vdmluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTW92aW5nXyhwb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2luZ18gfHxcbiAgICAgICAgTWF0aC5hYnMocG9pbnRlckV2ZW50LmNsaWVudFggLSB0aGlzLmRvd25fLmNsaWVudFgpID4gdGhpcy5tb3ZlVG9sZXJhbmNlXyB8fFxuICAgICAgICBNYXRoLmFicyhwb2ludGVyRXZlbnQuY2xpZW50WSAtIHRoaXMuZG93bl8uY2xpZW50WSkgPiB0aGlzLm1vdmVUb2xlcmFuY2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBkaXNwb3NlSW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXMucmVsYXllZExpc3RlbmVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnJlbGF5ZWRMaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy5yZWxheWVkTGlzdGVuZXJLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMucG9pbnRlcmRvd25MaXN0ZW5lcktleV8pIHtcbiAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5wb2ludGVyZG93bkxpc3RlbmVyS2V5Xyk7XG4gICAgICB0aGlzLnBvaW50ZXJkb3duTGlzdGVuZXJLZXlfID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdMaXN0ZW5lcktleXNfLmZvckVhY2godW5saXN0ZW5CeUtleSk7XG4gICAgdGhpcy5kcmFnTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXykge1xuICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXJFdmVudEhhbmRsZXJfLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyRXZlbnRIYW5kbGVyXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfKSB7XG4gICAgICB0aGlzLnBvaW50ZXJFdmVudEhhbmRsZXJfLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMucG9pbnRlckV2ZW50SGFuZGxlcl8gPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE1hcEJyb3dzZXJFdmVudEhhbmRsZXI7XG4iLCIvKipcbiAqIEBtb2R1bGUgb2wvTWFwUHJvcGVydHlcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgTEFZRVJHUk9VUDogJ2xheWVyZ3JvdXAnLFxuICBTSVpFOiAnc2l6ZScsXG4gIFRBUkdFVDogJ3RhcmdldCcsXG4gIFZJRVc6ICd2aWV3J1xufTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWVcbiAqL1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uL2Fzc2VydHMuanMnO1xuaW1wb3J0IHtjbGVhcn0gZnJvbSAnLi4vb2JqLmpzJztcblxuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBEUk9QID0gSW5maW5pdHk7XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBQcmlvcml0eSBxdWV1ZS5cbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gaXMgaW5zcGlyZWQgZnJvbSB0aGUgQ2xvc3VyZSBMaWJyYXJ5J3MgSGVhcCBjbGFzcyBhbmRcbiAqIFB5dGhvbidzIGhlYXBxIG1vZHVsZS5cbiAqXG4gKiBTZWUgaHR0cDovL2Nsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9zdm4vZG9jcy9jbG9zdXJlX2dvb2dfc3RydWN0c19oZWFwLmpzLnNvdXJjZS5odG1sXG4gKiBhbmQgaHR0cDovL2hnLnB5dGhvbi5vcmcvY3B5dGhvbi9maWxlLzIuNy9MaWIvaGVhcHEucHkuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6IG51bWJlcn0gcHJpb3JpdHlGdW5jdGlvbiBQcmlvcml0eSBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihUKTogc3RyaW5nfSBrZXlGdW5jdGlvbiBLZXkgZnVuY3Rpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcmlvcml0eUZ1bmN0aW9uLCBrZXlGdW5jdGlvbikge1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFQpOiBudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnByaW9yaXR5RnVuY3Rpb25fID0gcHJpb3JpdHlGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihUKTogc3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5rZXlGdW5jdGlvbl8gPSBrZXlGdW5jdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxUPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudHNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucHJpb3JpdGllc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnF1ZXVlZEVsZW1lbnRzXyA9IHt9O1xuXG4gIH1cblxuICAvKipcbiAgICogRklYTUUgZW1wdHkgZGVzY3JpcHRpb24gZm9yIGpzZG9jXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzXy5sZW5ndGggPSAwO1xuICAgIHRoaXMucHJpb3JpdGllc18ubGVuZ3RoID0gMDtcbiAgICBjbGVhcih0aGlzLnF1ZXVlZEVsZW1lbnRzXyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgaGlnaGVzdC1wcmlvcml0eSBlbGVtZW50LiBPKGxvZyBOKS5cbiAgICogQHJldHVybiB7VH0gRWxlbWVudC5cbiAgICovXG4gIGRlcXVldWUoKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbMF07XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICBlbGVtZW50cy5sZW5ndGggPSAwO1xuICAgICAgcHJpb3JpdGllcy5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50c1swXSA9IGVsZW1lbnRzLnBvcCgpO1xuICAgICAgcHJpb3JpdGllc1swXSA9IHByaW9yaXRpZXMucG9wKCk7XG4gICAgICB0aGlzLnNpZnRVcF8oMCk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRLZXkgPSB0aGlzLmtleUZ1bmN0aW9uXyhlbGVtZW50KTtcbiAgICBkZWxldGUgdGhpcy5xdWV1ZWRFbGVtZW50c19bZWxlbWVudEtleV07XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGFuIGVsZW1lbnQuIE8obG9nIE4pLlxuICAgKiBAcGFyYW0ge1R9IGVsZW1lbnQgRWxlbWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVsZW1lbnQgd2FzIGFkZGVkIHRvIHRoZSBxdWV1ZS5cbiAgICovXG4gIGVucXVldWUoZWxlbWVudCkge1xuICAgIGFzc2VydCghKHRoaXMua2V5RnVuY3Rpb25fKGVsZW1lbnQpIGluIHRoaXMucXVldWVkRWxlbWVudHNfKSxcbiAgICAgIDMxKTsgLy8gVHJpZWQgdG8gZW5xdWV1ZSBhbiBgZWxlbWVudGAgdGhhdCB3YXMgYWxyZWFkeSBhZGRlZCB0byB0aGUgcXVldWVcbiAgICBjb25zdCBwcmlvcml0eSA9IHRoaXMucHJpb3JpdHlGdW5jdGlvbl8oZWxlbWVudCk7XG4gICAgaWYgKHByaW9yaXR5ICE9IERST1ApIHtcbiAgICAgIHRoaXMuZWxlbWVudHNfLnB1c2goZWxlbWVudCk7XG4gICAgICB0aGlzLnByaW9yaXRpZXNfLnB1c2gocHJpb3JpdHkpO1xuICAgICAgdGhpcy5xdWV1ZWRFbGVtZW50c19bdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCldID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2lmdERvd25fKDAsIHRoaXMuZWxlbWVudHNfLmxlbmd0aCAtIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQ291bnQuXG4gICAqL1xuICBnZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50c18ubGVuZ3RoO1xuICB9XG5cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIGxlZnQgY2hpbGQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgbGVmdCBjaGlsZCBmb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBsZWZ0IGNoaWxkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGVmdENoaWxkSW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ICogMiArIDE7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIGdldCB0aGUgcmlnaHQgY2hpbGQgZm9yLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgcmlnaHQgY2hpbGQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRSaWdodENoaWxkSW5kZXhfKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ICogMiArIDI7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBvZiB0aGUgcGFyZW50IG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBnZXQgdGhlIHBhcmVudCBmb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBwYXJlbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXJlbnRJbmRleF8oaW5kZXgpIHtcbiAgICByZXR1cm4gKGluZGV4IC0gMSkgPj4gMTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBhIGhlYXAuIE8oTikuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoZWFwaWZ5XygpIHtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAodGhpcy5lbGVtZW50c18ubGVuZ3RoID4+IDEpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMuc2lmdFVwXyhpKTtcbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBlbXB0eS5cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHNfLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBrZXkgcXVldWVkLlxuICAgKi9cbiAgaXNLZXlRdWV1ZWQoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiB0aGlzLnF1ZXVlZEVsZW1lbnRzXztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VH0gZWxlbWVudCBFbGVtZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBJcyBxdWV1ZWQuXG4gICAqL1xuICBpc1F1ZXVlZChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNLZXlRdWV1ZWQodGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCkpO1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBtb3ZlIGRvd24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaWZ0VXBfKGluZGV4KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzXztcbiAgICBjb25zdCBwcmlvcml0aWVzID0gdGhpcy5wcmlvcml0aWVzXztcbiAgICBjb25zdCBjb3VudCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gcHJpb3JpdGllc1tpbmRleF07XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuXG4gICAgd2hpbGUgKGluZGV4IDwgKGNvdW50ID4+IDEpKSB7XG4gICAgICBjb25zdCBsSW5kZXggPSB0aGlzLmdldExlZnRDaGlsZEluZGV4XyhpbmRleCk7XG4gICAgICBjb25zdCBySW5kZXggPSB0aGlzLmdldFJpZ2h0Q2hpbGRJbmRleF8oaW5kZXgpO1xuXG4gICAgICBjb25zdCBzbWFsbGVyQ2hpbGRJbmRleCA9IHJJbmRleCA8IGNvdW50ICYmXG4gICAgICAgICAgcHJpb3JpdGllc1tySW5kZXhdIDwgcHJpb3JpdGllc1tsSW5kZXhdID9cbiAgICAgICAgckluZGV4IDogbEluZGV4O1xuXG4gICAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50c1tzbWFsbGVyQ2hpbGRJbmRleF07XG4gICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXRpZXNbc21hbGxlckNoaWxkSW5kZXhdO1xuICAgICAgaW5kZXggPSBzbWFsbGVyQ2hpbGRJbmRleDtcbiAgICB9XG5cbiAgICBlbGVtZW50c1tpbmRleF0gPSBlbGVtZW50O1xuICAgIHByaW9yaXRpZXNbaW5kZXhdID0gcHJpb3JpdHk7XG4gICAgdGhpcy5zaWZ0RG93bl8oc3RhcnRJbmRleCwgaW5kZXgpO1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggVGhlIGluZGV4IG9mIHRoZSByb290LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIG1vdmUgdXAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzaWZ0RG93bl8oc3RhcnRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHNfO1xuICAgIGNvbnN0IHByaW9yaXRpZXMgPSB0aGlzLnByaW9yaXRpZXNfO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF07XG4gICAgY29uc3QgcHJpb3JpdHkgPSBwcmlvcml0aWVzW2luZGV4XTtcblxuICAgIHdoaWxlIChpbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgIGNvbnN0IHBhcmVudEluZGV4ID0gdGhpcy5nZXRQYXJlbnRJbmRleF8oaW5kZXgpO1xuICAgICAgaWYgKHByaW9yaXRpZXNbcGFyZW50SW5kZXhdID4gcHJpb3JpdHkpIHtcbiAgICAgICAgZWxlbWVudHNbaW5kZXhdID0gZWxlbWVudHNbcGFyZW50SW5kZXhdO1xuICAgICAgICBwcmlvcml0aWVzW2luZGV4XSA9IHByaW9yaXRpZXNbcGFyZW50SW5kZXhdO1xuICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRzW2luZGV4XSA9IGVsZW1lbnQ7XG4gICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEZJWE1FIGVtcHR5IGRlc2NyaXB0aW9uIGZvciBqc2RvY1xuICAgKi9cbiAgcmVwcmlvcml0aXplKCkge1xuICAgIGNvbnN0IHByaW9yaXR5RnVuY3Rpb24gPSB0aGlzLnByaW9yaXR5RnVuY3Rpb25fO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50c187XG4gICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMucHJpb3JpdGllc187XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBjb25zdCBuID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGxldCBlbGVtZW50LCBpLCBwcmlvcml0eTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBwcmlvcml0eSA9IHByaW9yaXR5RnVuY3Rpb24oZWxlbWVudCk7XG4gICAgICBpZiAocHJpb3JpdHkgPT0gRFJPUCkge1xuICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZWRFbGVtZW50c19bdGhpcy5rZXlGdW5jdGlvbl8oZWxlbWVudCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJpb3JpdGllc1tpbmRleF0gPSBwcmlvcml0eTtcbiAgICAgICAgZWxlbWVudHNbaW5kZXgrK10gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50cy5sZW5ndGggPSBpbmRleDtcbiAgICBwcmlvcml0aWVzLmxlbmd0aCA9IGluZGV4O1xuICAgIHRoaXMuaGVhcGlmeV8oKTtcbiAgfVxuXG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUHJpb3JpdHlRdWV1ZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9UaWxlUXVldWVcbiAqL1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuL1RpbGVTdGF0ZS5qcyc7XG5pbXBvcnQge2xpc3RlbiwgdW5saXN0ZW59IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4vc3RydWN0cy9Qcmlvcml0eVF1ZXVlLmpzJztcblxuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdCwgc3RyaW5nLCBpbXBvcnQoXCIuL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZSwgbnVtYmVyKTogbnVtYmVyfSBQcmlvcml0eUZ1bmN0aW9uXG4gKi9cblxuXG5jbGFzcyBUaWxlUXVldWUgZXh0ZW5kcyBQcmlvcml0eVF1ZXVlIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtQcmlvcml0eUZ1bmN0aW9ufSB0aWxlUHJpb3JpdHlGdW5jdGlvbiBUaWxlIHByaW9yaXR5IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6ID99IHRpbGVDaGFuZ2VDYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgb24gZWFjaCB0aWxlIGNoYW5nZSBldmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpbGVQcmlvcml0eUZ1bmN0aW9uLCB0aWxlQ2hhbmdlQ2FsbGJhY2spIHtcblxuICAgIHN1cGVyKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50IEVsZW1lbnQuXG4gICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFByaW9yaXR5LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aWxlUHJpb3JpdHlGdW5jdGlvbi5hcHBseShudWxsLCBlbGVtZW50KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGVsZW1lbnQgRWxlbWVudC5cbiAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gS2V5LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGVsZW1lbnRbMF0pLmdldEtleSgpKTtcbiAgICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oKTogP31cbiAgICAgKi9cbiAgICB0aGlzLnRpbGVDaGFuZ2VDYWxsYmFja18gPSB0aWxlQ2hhbmdlQ2FsbGJhY2s7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aWxlc0xvYWRpbmdfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMudGlsZXNMb2FkaW5nS2V5c18gPSB7fTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBlbnF1ZXVlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBhZGRlZCA9IHN1cGVyLmVucXVldWUoZWxlbWVudCk7XG4gICAgaWYgKGFkZGVkKSB7XG4gICAgICBjb25zdCB0aWxlID0gZWxlbWVudFswXTtcbiAgICAgIGxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgdGlsZXMgbG9hZGluZy5cbiAgICovXG4gIGdldFRpbGVzTG9hZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlc0xvYWRpbmdfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVRpbGVDaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCB0aWxlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LnRhcmdldCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aWxlLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlID09PSBUaWxlU3RhdGUuTE9BREVEIHx8IHN0YXRlID09PSBUaWxlU3RhdGUuRVJST1IgfHxcbiAgICAgICAgc3RhdGUgPT09IFRpbGVTdGF0ZS5FTVBUWSB8fCBzdGF0ZSA9PT0gVGlsZVN0YXRlLkFCT1JUKSB7XG4gICAgICB1bmxpc3Rlbih0aWxlLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZVRpbGVDaGFuZ2UsIHRoaXMpO1xuICAgICAgY29uc3QgdGlsZUtleSA9IHRpbGUuZ2V0S2V5KCk7XG4gICAgICBpZiAodGlsZUtleSBpbiB0aGlzLnRpbGVzTG9hZGluZ0tleXNfKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRpbGVzTG9hZGluZ0tleXNfW3RpbGVLZXldO1xuICAgICAgICAtLXRoaXMudGlsZXNMb2FkaW5nXztcbiAgICAgIH1cbiAgICAgIHRoaXMudGlsZUNoYW5nZUNhbGxiYWNrXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4VG90YWxMb2FkaW5nIE1heGltdW0gbnVtYmVyIHRpbGVzIHRvIGxvYWQgc2ltdWx0YW5lb3VzbHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhOZXdMb2FkcyBNYXhpbXVtIG51bWJlciBvZiBuZXcgdGlsZXMgdG8gbG9hZC5cbiAgICovXG4gIGxvYWRNb3JlVGlsZXMobWF4VG90YWxMb2FkaW5nLCBtYXhOZXdMb2Fkcykge1xuICAgIGxldCBuZXdMb2FkcyA9IDA7XG4gICAgbGV0IGFib3J0ZWRUaWxlcyA9IGZhbHNlO1xuICAgIGxldCBzdGF0ZSwgdGlsZSwgdGlsZUtleTtcbiAgICB3aGlsZSAodGhpcy50aWxlc0xvYWRpbmdfIDwgbWF4VG90YWxMb2FkaW5nICYmIG5ld0xvYWRzIDwgbWF4TmV3TG9hZHMgJiZcbiAgICAgICAgICAgdGhpcy5nZXRDb3VudCgpID4gMCkge1xuICAgICAgdGlsZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9UaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmRlcXVldWUoKVswXSk7XG4gICAgICB0aWxlS2V5ID0gdGlsZS5nZXRLZXkoKTtcbiAgICAgIHN0YXRlID0gdGlsZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKHN0YXRlID09PSBUaWxlU3RhdGUuQUJPUlQpIHtcbiAgICAgICAgYWJvcnRlZFRpbGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRpbGVTdGF0ZS5JRExFICYmICEodGlsZUtleSBpbiB0aGlzLnRpbGVzTG9hZGluZ0tleXNfKSkge1xuICAgICAgICB0aGlzLnRpbGVzTG9hZGluZ0tleXNfW3RpbGVLZXldID0gdHJ1ZTtcbiAgICAgICAgKyt0aGlzLnRpbGVzTG9hZGluZ187XG4gICAgICAgICsrbmV3TG9hZHM7XG4gICAgICAgIHRpbGUubG9hZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3TG9hZHMgPT09IDAgJiYgYWJvcnRlZFRpbGVzKSB7XG4gICAgICAvLyBEbyBub3Qgc3RvcCB0aGUgcmVuZGVyIGxvb3Agd2hlbiBhbGwgd2FudGVkIHRpbGVzIHdlcmUgYWJvcnRlZCBkdWUgdG9cbiAgICAgIC8vIGEgc21hbGwsIHNhdHVyYXRlZCB0aWxlIGNhY2hlLlxuICAgICAgdGhpcy50aWxlQ2hhbmdlQ2FsbGJhY2tfKCk7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgVGlsZVF1ZXVlO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2xheWVyL0dyb3VwXG4gKi9cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4uL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IENvbGxlY3Rpb25FdmVudFR5cGUgZnJvbSAnLi4vQ29sbGVjdGlvbkV2ZW50VHlwZS5qcyc7XG5pbXBvcnQge2dldENoYW5nZUV2ZW50VHlwZX0gZnJvbSAnLi4vT2JqZWN0LmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi4vT2JqZWN0RXZlbnRUeXBlLmpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi9hc3NlcnRzLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0SW50ZXJzZWN0aW9ufSBmcm9tICcuLi9leHRlbnQuanMnO1xuaW1wb3J0IEJhc2VMYXllciBmcm9tICcuL0Jhc2UuanMnO1xuaW1wb3J0IHthc3NpZ24sIGNsZWFyfSBmcm9tICcuLi9vYmouanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4uL3NvdXJjZS9TdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29wYWNpdHk9MV0gT3BhY2l0eSAoMCwgMSkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2aXNpYmxlPXRydWVdIFZpc2liaWxpdHkuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V4dGVudC5qc1wiKS5FeHRlbnR9IFtleHRlbnRdIFRoZSBib3VuZGluZyBleHRlbnQgZm9yIGxheWVyIHJlbmRlcmluZy4gIFRoZSBsYXllciB3aWxsIG5vdCBiZVxuICogcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGlzIGV4dGVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbekluZGV4XSBUaGUgei1pbmRleCBmb3IgbGF5ZXIgcmVuZGVyaW5nLiAgQXQgcmVuZGVyaW5nIHRpbWUsIHRoZSBsYXllcnNcbiAqIHdpbGwgYmUgb3JkZXJlZCwgZmlyc3QgYnkgWi1pbmRleCBhbmQgdGhlbiBieSBwb3NpdGlvbi4gV2hlbiBgdW5kZWZpbmVkYCwgYSBgekluZGV4YCBvZiAwIGlzIGFzc3VtZWRcbiAqIGZvciBsYXllcnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIG1hcCdzIGBsYXllcnNgIGNvbGxlY3Rpb24sIG9yIGBJbmZpbml0eWAgd2hlbiB0aGUgbGF5ZXIncyBgc2V0TWFwKClgXG4gKiBtZXRob2Qgd2FzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21pblJlc29sdXRpb25dIFRoZSBtaW5pbXVtIHJlc29sdXRpb24gKGluY2x1c2l2ZSkgYXQgd2hpY2ggdGhpcyBsYXllciB3aWxsIGJlXG4gKiB2aXNpYmxlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhSZXNvbHV0aW9uXSBUaGUgbWF4aW11bSByZXNvbHV0aW9uIChleGNsdXNpdmUpIGJlbG93IHdoaWNoIHRoaXMgbGF5ZXIgd2lsbFxuICogYmUgdmlzaWJsZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fGltcG9ydChcIi4uL0NvbGxlY3Rpb24uanNcIikuZGVmYXVsdDxpbXBvcnQoXCIuL0Jhc2UuanNcIikuZGVmYXVsdD59IFtsYXllcnNdIENoaWxkIGxheWVycy5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFByb3BlcnR5ID0ge1xuICBMQVlFUlM6ICdsYXllcnMnXG59O1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQSB7QGxpbmsgbW9kdWxlOm9sL0NvbGxlY3Rpb25+Q29sbGVjdGlvbn0gb2YgbGF5ZXJzIHRoYXQgYXJlIGhhbmRsZWQgdG9nZXRoZXIuXG4gKlxuICogQSBnZW5lcmljIGBjaGFuZ2VgIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBncm91cC9Db2xsZWN0aW9uIGNoYW5nZXMuXG4gKlxuICogQGFwaVxuICovXG5jbGFzcyBMYXllckdyb3VwIGV4dGVuZHMgQmFzZUxheWVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIExheWVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGJhc2VPcHRpb25zID0gLyoqIEB0eXBlIHtPcHRpb25zfSAqLyAoYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgZGVsZXRlIGJhc2VPcHRpb25zLmxheWVycztcblxuICAgIGxldCBsYXllcnMgPSBvcHRpb25zLmxheWVycztcblxuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4uL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT4+fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJLZXlzXyA9IHt9O1xuXG4gICAgbGlzdGVuKHRoaXMsXG4gICAgICBnZXRDaGFuZ2VFdmVudFR5cGUoUHJvcGVydHkuTEFZRVJTKSxcbiAgICAgIHRoaXMuaGFuZGxlTGF5ZXJzQ2hhbmdlZF8sIHRoaXMpO1xuXG4gICAgaWYgKGxheWVycykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGF5ZXJzKSkge1xuICAgICAgICBsYXllcnMgPSBuZXcgQ29sbGVjdGlvbihsYXllcnMuc2xpY2UoKSwge3VuaXF1ZTogdHJ1ZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiAvKiogQHR5cGUgez99ICovIChsYXllcnMpLmdldEFycmF5ID09PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIDQzKTsgLy8gRXhwZWN0ZWQgYGxheWVyc2AgdG8gYmUgYW4gYXJyYXkgb3IgYSBgQ29sbGVjdGlvbmBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXJzID0gbmV3IENvbGxlY3Rpb24odW5kZWZpbmVkLCB7dW5pcXVlOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRMYXllcnMobGF5ZXJzKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVMYXllckNoYW5nZV8oKSB7XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc0NoYW5nZWRfKCkge1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMubGF5ZXJzTGlzdGVuZXJLZXlzXy5sZW5ndGggPSAwO1xuXG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5nZXRMYXllcnMoKTtcbiAgICB0aGlzLmxheWVyc0xpc3RlbmVyS2V5c18ucHVzaChcbiAgICAgIGxpc3RlbihsYXllcnMsIENvbGxlY3Rpb25FdmVudFR5cGUuQURELCB0aGlzLmhhbmRsZUxheWVyc0FkZF8sIHRoaXMpLFxuICAgICAgbGlzdGVuKGxheWVycywgQ29sbGVjdGlvbkV2ZW50VHlwZS5SRU1PVkUsIHRoaXMuaGFuZGxlTGF5ZXJzUmVtb3ZlXywgdGhpcylcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmxpc3RlbmVyS2V5c18pIHtcbiAgICAgIHRoaXMubGlzdGVuZXJLZXlzX1tpZF0uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICB9XG4gICAgY2xlYXIodGhpcy5saXN0ZW5lcktleXNfKTtcblxuICAgIGNvbnN0IGxheWVyc0FycmF5ID0gbGF5ZXJzLmdldEFycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNBcnJheVtpXTtcbiAgICAgIHRoaXMubGlzdGVuZXJLZXlzX1tnZXRVaWQobGF5ZXIpXSA9IFtcbiAgICAgICAgbGlzdGVuKGxheWVyLCBPYmplY3RFdmVudFR5cGUuUFJPUEVSVFlDSEFOR0UsIHRoaXMuaGFuZGxlTGF5ZXJDaGFuZ2VfLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKGxheWVyLCBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZUxheWVyQ2hhbmdlXywgdGhpcylcbiAgICAgIF07XG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc0FkZF8oY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0fSAqLyAoY29sbGVjdGlvbkV2ZW50LmVsZW1lbnQpO1xuICAgIHRoaXMubGlzdGVuZXJLZXlzX1tnZXRVaWQobGF5ZXIpXSA9IFtcbiAgICAgIGxpc3RlbihsYXllciwgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLCB0aGlzLmhhbmRsZUxheWVyQ2hhbmdlXywgdGhpcyksXG4gICAgICBsaXN0ZW4obGF5ZXIsIEV2ZW50VHlwZS5DSEFOR0UsIHRoaXMuaGFuZGxlTGF5ZXJDaGFuZ2VfLCB0aGlzKVxuICAgIF07XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gY29sbGVjdGlvbkV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyc1JlbW92ZV8oY29sbGVjdGlvbkV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0fSAqLyAoY29sbGVjdGlvbkV2ZW50LmVsZW1lbnQpO1xuICAgIGNvbnN0IGtleSA9IGdldFVpZChsYXllcik7XG4gICAgdGhpcy5saXN0ZW5lcktleXNfW2tleV0uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICBkZWxldGUgdGhpcy5saXN0ZW5lcktleXNfW2tleV07XG4gICAgdGhpcy5jaGFuZ2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcmV0dXJuIHshaW1wb3J0KFwiLi4vQ29sbGVjdGlvbi5qc1wiKS5kZWZhdWx0PGltcG9ydChcIi4vQmFzZS5qc1wiKS5kZWZhdWx0Pn0gQ29sbGVjdGlvbiBvZlxuICAgKiAgIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvQmFzZSBsYXllcnN9IHRoYXQgYXJlIHBhcnQgb2YgdGhpcyBncm91cC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGF5ZXJzKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fSAqLyAodGhpcy5nZXQoUHJvcGVydHkuTEFZRVJTKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9uIGNvbGxlY3Rpb259IG9mIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXJ+TGF5ZXIgbGF5ZXJzfVxuICAgKiBpbiB0aGlzIGdyb3VwLlxuICAgKiBAcGFyYW0geyFpbXBvcnQoXCIuLi9Db2xsZWN0aW9uLmpzXCIpLmRlZmF1bHQ8aW1wb3J0KFwiLi9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBsYXllcnMgQ29sbGVjdGlvbiBvZlxuICAgKiAgIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvQmFzZSBsYXllcnN9IHRoYXQgYXJlIHBhcnQgb2YgdGhpcyBncm91cC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgc2V0TGF5ZXJzKGxheWVycykge1xuICAgIHRoaXMuc2V0KFByb3BlcnR5LkxBWUVSUywgbGF5ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0TGF5ZXJzQXJyYXkob3B0X2FycmF5KSB7XG4gICAgY29uc3QgYXJyYXkgPSBvcHRfYXJyYXkgIT09IHVuZGVmaW5lZCA/IG9wdF9hcnJheSA6IFtdO1xuICAgIHRoaXMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgbGF5ZXIuZ2V0TGF5ZXJzQXJyYXkoYXJyYXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0TGF5ZXJTdGF0ZXNBcnJheShvcHRfc3RhdGVzKSB7XG4gICAgY29uc3Qgc3RhdGVzID0gb3B0X3N0YXRlcyAhPT0gdW5kZWZpbmVkID8gb3B0X3N0YXRlcyA6IFtdO1xuXG4gICAgY29uc3QgcG9zID0gc3RhdGVzLmxlbmd0aDtcblxuICAgIHRoaXMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgbGF5ZXIuZ2V0TGF5ZXJTdGF0ZXNBcnJheShzdGF0ZXMpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb3duTGF5ZXJTdGF0ZSA9IHRoaXMuZ2V0TGF5ZXJTdGF0ZSgpO1xuICAgIGZvciAobGV0IGkgPSBwb3MsIGlpID0gc3RhdGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IGxheWVyU3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICBsYXllclN0YXRlLm9wYWNpdHkgKj0gb3duTGF5ZXJTdGF0ZS5vcGFjaXR5O1xuICAgICAgbGF5ZXJTdGF0ZS52aXNpYmxlID0gbGF5ZXJTdGF0ZS52aXNpYmxlICYmIG93bkxheWVyU3RhdGUudmlzaWJsZTtcbiAgICAgIGxheWVyU3RhdGUubWF4UmVzb2x1dGlvbiA9IE1hdGgubWluKFxuICAgICAgICBsYXllclN0YXRlLm1heFJlc29sdXRpb24sIG93bkxheWVyU3RhdGUubWF4UmVzb2x1dGlvbik7XG4gICAgICBsYXllclN0YXRlLm1pblJlc29sdXRpb24gPSBNYXRoLm1heChcbiAgICAgICAgbGF5ZXJTdGF0ZS5taW5SZXNvbHV0aW9uLCBvd25MYXllclN0YXRlLm1pblJlc29sdXRpb24pO1xuICAgICAgaWYgKG93bkxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGxheWVyU3RhdGUuZXh0ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXllclN0YXRlLmV4dGVudCA9IGdldEludGVyc2VjdGlvbihsYXllclN0YXRlLmV4dGVudCwgb3duTGF5ZXJTdGF0ZS5leHRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxheWVyU3RhdGUuZXh0ZW50ID0gb3duTGF5ZXJTdGF0ZS5leHRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRTb3VyY2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gU291cmNlU3RhdGUuUkVBRFk7XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBMYXllckdyb3VwO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL1BsdWdnYWJsZU1hcFxuICovXG5pbXBvcnQge2dldFVpZH0gZnJvbSAnLi91dGlsLmpzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgQ29sbGVjdGlvbkV2ZW50VHlwZSBmcm9tICcuL0NvbGxlY3Rpb25FdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudCBmcm9tICcuL01hcEJyb3dzZXJFdmVudC5qcyc7XG5pbXBvcnQgTWFwQnJvd3NlckV2ZW50SGFuZGxlciBmcm9tICcuL01hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMnO1xuaW1wb3J0IE1hcEJyb3dzZXJFdmVudFR5cGUgZnJvbSAnLi9NYXBCcm93c2VyRXZlbnRUeXBlLmpzJztcbmltcG9ydCBNYXBFdmVudCBmcm9tICcuL01hcEV2ZW50LmpzJztcbmltcG9ydCBNYXBFdmVudFR5cGUgZnJvbSAnLi9NYXBFdmVudFR5cGUuanMnO1xuaW1wb3J0IE1hcFByb3BlcnR5IGZyb20gJy4vTWFwUHJvcGVydHkuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50VHlwZSBmcm9tICcuL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IEJhc2VPYmplY3QsIHtnZXRDaGFuZ2VFdmVudFR5cGV9IGZyb20gJy4vT2JqZWN0LmpzJztcbmltcG9ydCBPYmplY3RFdmVudFR5cGUgZnJvbSAnLi9PYmplY3RFdmVudFR5cGUuanMnO1xuaW1wb3J0IFRpbGVRdWV1ZSBmcm9tICcuL1RpbGVRdWV1ZS5qcyc7XG5pbXBvcnQgVmlldyBmcm9tICcuL1ZpZXcuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4vVmlld0hpbnQuanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge3JlbW92ZU5vZGV9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5LCB1bmxpc3Rlbn0gZnJvbSAnLi9ldmVudHMuanMnO1xuaW1wb3J0IHtzdG9wUHJvcGFnYXRpb259IGZyb20gJy4vZXZlbnRzL0V2ZW50LmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Y3JlYXRlRW1wdHksIGNsb25lLCBjcmVhdGVPclVwZGF0ZUVtcHR5LCBlcXVhbHMsIGdldEZvclZpZXdBbmRTaXplLCBpc0VtcHR5fSBmcm9tICcuL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4vZnVuY3Rpb25zLmpzJztcbmltcG9ydCB7REVWSUNFX1BJWEVMX1JBVElPLCBUT1VDSH0gZnJvbSAnLi9oYXMuanMnO1xuaW1wb3J0IExheWVyR3JvdXAgZnJvbSAnLi9sYXllci9Hcm91cC5qcyc7XG5pbXBvcnQge2hhc0FyZWF9IGZyb20gJy4vc2l6ZS5qcyc7XG5pbXBvcnQge0RST1B9IGZyb20gJy4vc3RydWN0cy9Qcmlvcml0eVF1ZXVlLmpzJztcbmltcG9ydCB7Y3JlYXRlIGFzIGNyZWF0ZVRyYW5zZm9ybSwgYXBwbHkgYXMgYXBwbHlUcmFuc2Zvcm19IGZyb20gJy4vdHJhbnNmb3JtLmpzJztcblxuXG4vKipcbiAqIFN0YXRlIG9mIHRoZSBjdXJyZW50IGZyYW1lLiBPbmx5IGBwaXhlbFJhdGlvYCwgYHRpbWVgIGFuZCBgdmlld1N0YXRlYCBzaG91bGRcbiAqIGJlIHVzZWQgaW4gYXBwbGljYXRpb25zLlxuICogQHR5cGVkZWYge09iamVjdH0gRnJhbWVTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpeGVsUmF0aW8gVGhlIHBpeGVsIHJhdGlvIG9mIHRoZSBmcmFtZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIFRoZSB0aW1lIHdoZW4gcmVuZGVyaW5nIG9mIHRoZSBmcmFtZSB3YXMgcmVxdWVzdGVkLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1ZpZXcuanNcIikuU3RhdGV9IHZpZXdTdGF0ZSBUaGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgdmlldy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYW5pbWF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19IGNvb3JkaW5hdGVUb1BpeGVsVHJhbnNmb3JtXG4gKiBAcHJvcGVydHkge251bGx8aW1wb3J0KFwiLi9leHRlbnQuanNcIikuRXh0ZW50fSBleHRlbnRcbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGZvY3VzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZT59IGxheWVyU3RhdGVzXG4gKiBAcHJvcGVydHkge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuU3RhdGU+fSBsYXllclN0YXRlc0FycmF5XG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm1cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UG9zdFJlbmRlckZ1bmN0aW9uPn0gcG9zdFJlbmRlckZ1bmN0aW9uc1xuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZX0gc2l6ZVxuICogQHByb3BlcnR5IHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59IHNraXBwZWRGZWF0dXJlVWlkc1xuICogQHByb3BlcnR5IHtUaWxlUXVldWV9IHRpbGVRdWV1ZVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCBpbXBvcnQoXCIuL1RpbGVSYW5nZS5qc1wiKS5kZWZhdWx0Pj59IHVzZWRUaWxlc1xuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSB2aWV3SGludHNcbiAqIEBwcm9wZXJ0eSB7IU9iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsIGJvb2xlYW4+Pn0gd2FudGVkVGlsZXNcbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKFBsdWdnYWJsZU1hcCwgP0ZyYW1lU3RhdGUpOiBib29sZWFufSBQb3N0UmVuZGVyRnVuY3Rpb25cbiAqL1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQXRQaXhlbE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7dW5kZWZpbmVkfGZ1bmN0aW9uKGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICogZnVuY3Rpb24uIFRoZSBmaWx0ZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIG9uZSBhcmd1bWVudCwgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyIGxheWVyLWNhbmRpZGF0ZX0gYW5kIGl0IHNob3VsZCByZXR1cm4gYSBib29sZWFuIHZhbHVlLlxuICogT25seSBsYXllcnMgd2hpY2ggYXJlIHZpc2libGUgYW5kIGZvciB3aGljaCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgXG4gKiB3aWxsIGJlIHRlc3RlZCBmb3IgZmVhdHVyZXMuIEJ5IGRlZmF1bHQsIGFsbCB2aXNpYmxlIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGl0VG9sZXJhbmNlPTBdIEhpdC1kZXRlY3Rpb24gdG9sZXJhbmNlIGluIHBpeGVscy4gUGl4ZWxzXG4gKiBpbnNpZGUgdGhlIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgZmVhdHVyZXMuIFRoaXMgb25seVxuICogd29ya3MgZm9yIHRoZSBjYW52YXMgcmVuZGVyZXIgYW5kIG5vdCBmb3IgV2ViR0wuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcE9wdGlvbnNJbnRlcm5hbFxuICogQHByb3BlcnR5IHtDb2xsZWN0aW9uPGltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHQ+fSBbY29udHJvbHNdXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn0gW2ludGVyYWN0aW9uc11cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9IGtleWJvYXJkRXZlbnRUYXJnZXRcbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59IG92ZXJsYXlzXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsICo+fSB2YWx1ZXNcbiAqL1xuXG5cbi8qKlxuICogT2JqZWN0IGxpdGVyYWwgd2l0aCBjb25maWcgb3B0aW9ucyBmb3IgdGhlIG1hcC5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gW2NvbnRyb2xzXVxuICogQ29udHJvbHMgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2NvbnRyb2x+ZGVmYXVsdHN9IGlzIHVzZWQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsUmF0aW89d2luZG93LmRldmljZVBpeGVsUmF0aW9dIFRoZSByYXRpbyBiZXR3ZWVuXG4gKiBwaHlzaWNhbCBwaXhlbHMgYW5kIGRldmljZS1pbmRlcGVuZGVudCBwaXhlbHMgKGRpcHMpIG9uIHRoZSBkZXZpY2UuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0PnxBcnJheTxpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHQ+fSBbaW50ZXJhY3Rpb25zXVxuICogSW50ZXJhY3Rpb25zIHRoYXQgYXJlIGluaXRpYWxseSBhZGRlZCB0byB0aGUgbWFwLiBJZiBub3Qgc3BlY2lmaWVkLFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbn5kZWZhdWx0c30gaXMgdXNlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR8c3RyaW5nfSBba2V5Ym9hcmRFdmVudFRhcmdldF0gVGhlIGVsZW1lbnQgdG9cbiAqIGxpc3RlbiB0byBrZXlib2FyZCBldmVudHMgb24uIFRoaXMgZGV0ZXJtaW5lcyB3aGVuIHRoZSBgS2V5Ym9hcmRQYW5gIGFuZFxuICogYEtleWJvYXJkWm9vbWAgaW50ZXJhY3Rpb25zIHRyaWdnZXIuIEZvciBleGFtcGxlLCBpZiB0aGlzIG9wdGlvbiBpcyBzZXQgdG9cbiAqIGBkb2N1bWVudGAgdGhlIGtleWJvYXJkIGludGVyYWN0aW9ucyB3aWxsIGFsd2F5cyB0cmlnZ2VyLiBJZiB0aGlzIG9wdGlvbiBpc1xuICogbm90IHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgdGhlIGxpYnJhcnkgbGlzdGVucyB0byBrZXlib2FyZCBldmVudHMgb24gaXMgdGhlXG4gKiBtYXAgdGFyZ2V0IChpLmUuIHRoZSB1c2VyLXByb3ZpZGVkIGRpdiBmb3IgdGhlIG1hcCkuIElmIHRoaXMgaXMgbm90XG4gKiBgZG9jdW1lbnRgLCB0aGUgdGFyZ2V0IGVsZW1lbnQgbmVlZHMgdG8gYmUgZm9jdXNlZCBmb3Iga2V5IGV2ZW50cyB0byBiZVxuICogZW1pdHRlZCwgcmVxdWlyaW5nIHRoYXQgdGhlIHRhcmdldCBlbGVtZW50IGhhcyBhIGB0YWJpbmRleGAgYXR0cmlidXRlLlxuICogQHByb3BlcnR5IHtBcnJheTxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdD58TGF5ZXJHcm91cH0gW2xheWVyc11cbiAqIExheWVycy4gSWYgdGhpcyBpcyBub3QgZGVmaW5lZCwgYSBtYXAgd2l0aCBubyBsYXllcnMgd2lsbCBiZSByZW5kZXJlZC4gTm90ZVxuICogdGhhdCBsYXllcnMgYXJlIHJlbmRlcmVkIGluIHRoZSBvcmRlciBzdXBwbGllZCwgc28gaWYgeW91IHdhbnQsIGZvciBleGFtcGxlLFxuICogYSB2ZWN0b3IgbGF5ZXIgdG8gYXBwZWFyIG9uIHRvcCBvZiBhIHRpbGUgbGF5ZXIsIGl0IG11c3QgY29tZSBhZnRlciB0aGUgdGlsZVxuICogbGF5ZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFRpbGVzTG9hZGluZz0xNl0gTWF4aW11bSBudW1iZXIgdGlsZXMgdG8gbG9hZFxuICogc2ltdWx0YW5lb3VzbHkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkVGlsZXNXaGlsZUFuaW1hdGluZz1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aWxlc1xuICogd2lsbCBiZSBsb2FkZWQgZHVyaW5nIGFuaW1hdGlvbnMuIFRoaXMgbWF5IGltcHJvdmUgdGhlIHVzZXIgZXhwZXJpZW5jZSwgYnV0XG4gKiBjYW4gYWxzbyBtYWtlIGFuaW1hdGlvbnMgc3R1dHRlciBvbiBkZXZpY2VzIHdpdGggc2xvdyBtZW1vcnkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb2FkVGlsZXNXaGlsZUludGVyYWN0aW5nPWZhbHNlXSBXaGVuIHNldCB0byBgdHJ1ZWAsXG4gKiB0aWxlcyB3aWxsIGJlIGxvYWRlZCB3aGlsZSBpbnRlcmFjdGluZyB3aXRoIHRoZSBtYXAuIFRoaXMgbWF5IGltcHJvdmUgdGhlXG4gKiB1c2VyIGV4cGVyaWVuY2UsIGJ1dCBjYW4gYWxzbyBtYWtlIG1hcCBwYW5uaW5nIGFuZCB6b29taW5nIGNob3BweSBvbiBkZXZpY2VzXG4gKiB3aXRoIHNsb3cgbWVtb3J5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttb3ZlVG9sZXJhbmNlPTFdIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGluIHBpeGVscyB0aGVcbiAqIGN1cnNvciBtdXN0IG1vdmUgdG8gYmUgZGV0ZWN0ZWQgYXMgYSBtYXAgbW92ZSBldmVudCBpbnN0ZWFkIG9mIGEgY2xpY2suXG4gKiBJbmNyZWFzaW5nIHRoaXMgdmFsdWUgY2FuIG1ha2UgaXQgZWFzaWVyIHRvIGNsaWNrIG9uIHRoZSBtYXAuXG4gKiBAcHJvcGVydHkge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHQ+fEFycmF5PGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gW292ZXJsYXlzXVxuICogT3ZlcmxheXMgaW5pdGlhbGx5IGFkZGVkIHRvIHRoZSBtYXAuIEJ5IGRlZmF1bHQsIG5vIG92ZXJsYXlzIGFyZSBhZGRlZC5cbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR8c3RyaW5nfSBbdGFyZ2V0XSBUaGUgY29udGFpbmVyIGZvciB0aGUgbWFwLCBlaXRoZXIgdGhlXG4gKiBlbGVtZW50IGl0c2VsZiBvciB0aGUgYGlkYCBvZiB0aGUgZWxlbWVudC4gSWYgbm90IHNwZWNpZmllZCBhdCBjb25zdHJ1Y3Rpb25cbiAqIHRpbWUsIHtAbGluayBtb2R1bGU6b2wvTWFwfk1hcCNzZXRUYXJnZXR9IG11c3QgYmUgY2FsbGVkIGZvciB0aGUgbWFwIHRvIGJlXG4gKiByZW5kZXJlZC5cbiAqIEBwcm9wZXJ0eSB7Vmlld30gW3ZpZXddIFRoZSBtYXAncyB2aWV3LiAgTm8gbGF5ZXIgc291cmNlcyB3aWxsIGJlXG4gKiBmZXRjaGVkIHVubGVzcyB0aGlzIGlzIHNwZWNpZmllZCBhdCBjb25zdHJ1Y3Rpb24gdGltZSBvciB0aHJvdWdoXG4gKiB7QGxpbmsgbW9kdWxlOm9sL01hcH5NYXAjc2V0Vmlld30uXG4gKi9cblxuXG4vKipcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL01hcEJyb3dzZXJFdmVudC5qc1wiKS5NYXBCcm93c2VyRXZlbnRcbiAqIEBmaXJlcyBpbXBvcnQoXCIuL01hcEV2ZW50LmpzXCIpLk1hcEV2ZW50XG4gKiBAZmlyZXMgbW9kdWxlOm9sL3JlbmRlci9FdmVudH5SZW5kZXJFdmVudCNwb3N0Y29tcG9zZVxuICogQGZpcmVzIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcHJlY29tcG9zZVxuICogQGZpcmVzIG1vZHVsZTpvbC9yZW5kZXIvRXZlbnR+UmVuZGVyRXZlbnQjcmVuZGVyY29tcGxldGVcbiAqIEBhcGlcbiAqL1xuY2xhc3MgUGx1Z2dhYmxlTWFwIGV4dGVuZHMgQmFzZU9iamVjdCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TWFwT3B0aW9uc30gb3B0aW9ucyBNYXAgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICBjb25zdCBvcHRpb25zSW50ZXJuYWwgPSBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5tYXhUaWxlc0xvYWRpbmdfID0gb3B0aW9ucy5tYXhUaWxlc0xvYWRpbmcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWF4VGlsZXNMb2FkaW5nIDogMTY7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZFRpbGVzV2hpbGVBbmltYXRpbmdfID1cbiAgICAgICAgb3B0aW9ucy5sb2FkVGlsZXNXaGlsZUFuaW1hdGluZyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICBvcHRpb25zLmxvYWRUaWxlc1doaWxlQW5pbWF0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9hZFRpbGVzV2hpbGVJbnRlcmFjdGluZ18gPVxuICAgICAgICBvcHRpb25zLmxvYWRUaWxlc1doaWxlSW50ZXJhY3RpbmcgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgb3B0aW9ucy5sb2FkVGlsZXNXaGlsZUludGVyYWN0aW5nIDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbFJhdGlvXyA9IG9wdGlvbnMucGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxSYXRpbyA6IERFVklDRV9QSVhFTF9SQVRJTztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5hbmltYXRpb25EZWxheUtleV87XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkRlbGF5S2V5XyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVuZGVyRnJhbWVfLmNhbGwodGhpcywgRGF0ZS5ub3coKSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRoaXMuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm1fID0gY3JlYXRlVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuL3RyYW5zZm9ybS5qc1wiKS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgdGhpcy5waXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmZyYW1lSW5kZXhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9GcmFtZVN0YXRlfVxuICAgICAqL1xuICAgIHRoaXMuZnJhbWVTdGF0ZV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBhdCB0aGUgcHJldmlvdXMgJ21vdmVlbmQnIGV2ZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vZXh0ZW50LmpzXCIpLkV4dGVudH1cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHs/aW1wb3J0KFwiLi9ldmVudHMuanNcIikuRXZlbnRzS2V5fVxuICAgICAqL1xuICAgIHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgez9pbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXl9XG4gICAgICovXG4gICAgdGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PGltcG9ydChcIi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLnZpZXdwb3J0XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMudmlld3BvcnRfLmNsYXNzTmFtZSA9ICdvbC12aWV3cG9ydCcgKyAoVE9VQ0ggPyAnIG9sLXRvdWNoJyA6ICcnKTtcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgdGhpcy52aWV3cG9ydF8uc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgLy8gcHJldmVudCBwYWdlIHpvb20gb24gSUUgPj0gMTAgYnJvd3NlcnNcbiAgICB0aGlzLnZpZXdwb3J0Xy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xuICAgIHRoaXMudmlld3BvcnRfLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lcl8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJfLmNsYXNzTmFtZSA9ICdvbC1vdmVybGF5Y29udGFpbmVyJztcbiAgICB0aGlzLnZpZXdwb3J0Xy5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXlDb250YWluZXJfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlDb250YWluZXJTdG9wRXZlbnRfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xy5jbGFzc05hbWUgPSAnb2wtb3ZlcmxheWNvbnRhaW5lci1zdG9wZXZlbnQnO1xuICAgIGNvbnN0IG92ZXJsYXlFdmVudHMgPSBbXG4gICAgICBFdmVudFR5cGUuQ0xJQ0ssXG4gICAgICBFdmVudFR5cGUuREJMQ0xJQ0ssXG4gICAgICBFdmVudFR5cGUuTU9VU0VET1dOLFxuICAgICAgRXZlbnRUeXBlLlRPVUNIU1RBUlQsXG4gICAgICBFdmVudFR5cGUuTVNQT0lOVEVSRE9XTixcbiAgICAgIE1hcEJyb3dzZXJFdmVudFR5cGUuUE9JTlRFUkRPV04sXG4gICAgICBFdmVudFR5cGUuTU9VU0VXSEVFTCxcbiAgICAgIEV2ZW50VHlwZS5XSEVFTFxuICAgIF07XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3ZlcmxheUV2ZW50cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBsaXN0ZW4odGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xywgb3ZlcmxheUV2ZW50c1tpXSwgc3RvcFByb3BhZ2F0aW9uKTtcbiAgICB9XG4gICAgdGhpcy52aWV3cG9ydF8uYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5Q29udGFpbmVyU3RvcEV2ZW50Xyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtNYXBCcm93c2VyRXZlbnRIYW5kbGVyfVxuICAgICAqL1xuICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8gPSBuZXcgTWFwQnJvd3NlckV2ZW50SGFuZGxlcih0aGlzLCBvcHRpb25zLm1vdmVUb2xlcmFuY2UpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIE1hcEJyb3dzZXJFdmVudFR5cGUpIHtcbiAgICAgIGxpc3Rlbih0aGlzLm1hcEJyb3dzZXJFdmVudEhhbmRsZXJfLCBNYXBCcm93c2VyRXZlbnRUeXBlW2tleV0sXG4gICAgICAgIHRoaXMuaGFuZGxlTWFwQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudHxEb2N1bWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmtleWJvYXJkRXZlbnRUYXJnZXRfID0gb3B0aW9uc0ludGVybmFsLmtleWJvYXJkRXZlbnRUYXJnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuL2V2ZW50cy5qc1wiKS5FdmVudHNLZXk+fVxuICAgICAqL1xuICAgIHRoaXMua2V5SGFuZGxlcktleXNfID0gbnVsbDtcblxuICAgIGxpc3Rlbih0aGlzLnZpZXdwb3J0XywgRXZlbnRUeXBlLkNPTlRFWFRNRU5VLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcyk7XG4gICAgbGlzdGVuKHRoaXMudmlld3BvcnRfLCBFdmVudFR5cGUuV0hFRUwsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcy52aWV3cG9ydF8sIEV2ZW50VHlwZS5NT1VTRVdIRUVMLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5jb250cm9scyA9IG9wdGlvbnNJbnRlcm5hbC5jb250cm9scyB8fCBuZXcgQ29sbGVjdGlvbigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbGxlY3Rpb248aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5pbnRlcmFjdGlvbnMgPSBvcHRpb25zSW50ZXJuYWwuaW50ZXJhY3Rpb25zIHx8IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlzXyA9IG9wdGlvbnNJbnRlcm5hbC5vdmVybGF5cztcblxuICAgIC8qKlxuICAgICAqIEEgbG9va3VwIG9mIG92ZXJsYXlzIGJ5IGlkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJsYXlJZEluZGV4XyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vcmVuZGVyZXIvTWFwLmpzXCIpLmRlZmF1bHR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyXyA9IHRoaXMuY3JlYXRlUmVuZGVyZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihFdmVudCl8dW5kZWZpbmVkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5oYW5kbGVSZXNpemVfO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9XG4gICAgICovXG4gICAgdGhpcy5mb2N1c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUFycmF5PFBvc3RSZW5kZXJGdW5jdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5wb3N0UmVuZGVyRnVuY3Rpb25zXyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VGlsZVF1ZXVlfVxuICAgICAqL1xuICAgIHRoaXMudGlsZVF1ZXVlXyA9IG5ldyBUaWxlUXVldWUoXG4gICAgICB0aGlzLmdldFRpbGVQcmlvcml0eS5iaW5kKHRoaXMpLFxuICAgICAgdGhpcy5oYW5kbGVUaWxlQ2hhbmdlXy5iaW5kKHRoaXMpKTtcblxuICAgIC8qKlxuICAgICAqIFVpZHMgb2YgZmVhdHVyZXMgdG8gc2tpcCBhdCByZW5kZXJpbmcgdGltZS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNraXBwZWRGZWF0dXJlVWlkc18gPSB7fTtcblxuICAgIGxpc3RlbihcbiAgICAgIHRoaXMsIGdldENoYW5nZUV2ZW50VHlwZShNYXBQcm9wZXJ0eS5MQVlFUkdST1VQKSxcbiAgICAgIHRoaXMuaGFuZGxlTGF5ZXJHcm91cENoYW5nZWRfLCB0aGlzKTtcbiAgICBsaXN0ZW4odGhpcywgZ2V0Q2hhbmdlRXZlbnRUeXBlKE1hcFByb3BlcnR5LlZJRVcpLFxuICAgICAgdGhpcy5oYW5kbGVWaWV3Q2hhbmdlZF8sIHRoaXMpO1xuICAgIGxpc3Rlbih0aGlzLCBnZXRDaGFuZ2VFdmVudFR5cGUoTWFwUHJvcGVydHkuU0laRSksXG4gICAgICB0aGlzLmhhbmRsZVNpemVDaGFuZ2VkXywgdGhpcyk7XG4gICAgbGlzdGVuKHRoaXMsIGdldENoYW5nZUV2ZW50VHlwZShNYXBQcm9wZXJ0eS5UQVJHRVQpLFxuICAgICAgdGhpcy5oYW5kbGVUYXJnZXRDaGFuZ2VkXywgdGhpcyk7XG5cbiAgICAvLyBzZXRQcm9wZXJ0aWVzIHdpbGwgdHJpZ2dlciB0aGUgcmVuZGVyaW5nIG9mIHRoZSBtYXAgaWYgdGhlIG1hcFxuICAgIC8vIGlzIFwiZGVmaW5lZFwiIGFscmVhZHkuXG4gICAgdGhpcy5zZXRQcm9wZXJ0aWVzKG9wdGlvbnNJbnRlcm5hbC52YWx1ZXMpO1xuXG4gICAgdGhpcy5jb250cm9scy5mb3JFYWNoKFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR9IGNvbnRyb2wgQ29udHJvbC5cbiAgICAgICAqIEB0aGlzIHtQbHVnZ2FibGVNYXB9XG4gICAgICAgKi9cbiAgICAgIChmdW5jdGlvbihjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuc2V0TWFwKHRoaXMpO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICBsaXN0ZW4odGhpcy5jb250cm9scywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcCh0aGlzKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgbGlzdGVuKHRoaXMuY29udHJvbHMsIENvbGxlY3Rpb25FdmVudFR5cGUuUkVNT1ZFLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vQ29sbGVjdGlvbi5qc1wiKS5Db2xsZWN0aW9uRXZlbnR9IGV2ZW50IENvbGxlY3Rpb25FdmVudC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuaW50ZXJhY3Rpb25zLmZvckVhY2goXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9pbnRlcmFjdGlvbi9JbnRlcmFjdGlvbi5qc1wiKS5kZWZhdWx0fSBpbnRlcmFjdGlvbiBJbnRlcmFjdGlvbi5cbiAgICAgICAqIEB0aGlzIHtQbHVnZ2FibGVNYXB9XG4gICAgICAgKi9cbiAgICAgIChmdW5jdGlvbihpbnRlcmFjdGlvbikge1xuICAgICAgICBpbnRlcmFjdGlvbi5zZXRNYXAodGhpcyk7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgIGxpc3Rlbih0aGlzLmludGVyYWN0aW9ucywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcCh0aGlzKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgbGlzdGVuKHRoaXMuaW50ZXJhY3Rpb25zLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmVsZW1lbnQuc2V0TWFwKG51bGwpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLm92ZXJsYXlzXy5mb3JFYWNoKHRoaXMuYWRkT3ZlcmxheUludGVybmFsXy5iaW5kKHRoaXMpKTtcblxuICAgIGxpc3Rlbih0aGlzLm92ZXJsYXlzXywgQ29sbGVjdGlvbkV2ZW50VHlwZS5BREQsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25FdmVudH0gZXZlbnQgQ29sbGVjdGlvbkV2ZW50LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmFkZE92ZXJsYXlJbnRlcm5hbF8oLyoqIEB0eXBlIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdH0gKi8gKGV2ZW50LmVsZW1lbnQpKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgbGlzdGVuKHRoaXMub3ZlcmxheXNfLCBDb2xsZWN0aW9uRXZlbnRUeXBlLlJFTU9WRSxcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbkV2ZW50fSBldmVudCBDb2xsZWN0aW9uRXZlbnQuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXkgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSAqLyAoZXZlbnQuZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGlkID0gb3ZlcmxheS5nZXRJZCgpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLm92ZXJsYXlJZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5lbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcmVuZGVyZXIvTWFwLmpzXCIpLmRlZmF1bHR9IFRoZSBtYXAgcmVuZGVyZXJcbiAgICovXG4gIGNyZWF0ZVJlbmRlcmVyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVXNlIGEgbWFwIHR5cGUgdGhhdCBoYXMgYSBjcmVhdGVSZW5kZXJlciBtZXRob2QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIGNvbnRyb2wgdG8gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0fSBjb250cm9sIENvbnRyb2wuXG4gICAqIEBhcGlcbiAgICovXG4gIGFkZENvbnRyb2woY29udHJvbCkge1xuICAgIHRoaXMuZ2V0Q29udHJvbHMoKS5wdXNoKGNvbnRyb2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gaW50ZXJhY3Rpb24gdG8gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR9IGludGVyYWN0aW9uIEludGVyYWN0aW9uIHRvIGFkZC5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRkSW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24pIHtcbiAgICB0aGlzLmdldEludGVyYWN0aW9ucygpLnB1c2goaW50ZXJhY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGxheWVyIHRvIHRoZSB0b3Agb2YgdGhpcyBtYXAuIElmIHlvdSB3YW50IHRvIGFkZCBhIGxheWVyXG4gICAqIGVsc2V3aGVyZSBpbiB0aGUgc3RhY2ssIHVzZSBgZ2V0TGF5ZXJzKClgIGFuZCB0aGUgbWV0aG9kcyBhdmFpbGFibGUgb25cbiAgICoge0BsaW5rIG1vZHVsZTpvbC9Db2xsZWN0aW9ufkNvbGxlY3Rpb259LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICBsYXllcnMucHVzaChsYXllcik7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBvdmVybGF5IHRvIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9PdmVybGF5LmpzXCIpLmRlZmF1bHR9IG92ZXJsYXkgT3ZlcmxheS5cbiAgICogQGFwaVxuICAgKi9cbiAgYWRkT3ZlcmxheShvdmVybGF5KSB7XG4gICAgdGhpcy5nZXRPdmVybGF5cygpLnB1c2gob3ZlcmxheSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBkZWFscyB3aXRoIG1hcCdzIG92ZXJsYXkgY29sbGVjdGlvbiBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBvdmVybGF5IE92ZXJsYXkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhZGRPdmVybGF5SW50ZXJuYWxfKG92ZXJsYXkpIHtcbiAgICBjb25zdCBpZCA9IG92ZXJsYXkuZ2V0SWQoKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vdmVybGF5SWRJbmRleF9baWQudG9TdHJpbmcoKV0gPSBvdmVybGF5O1xuICAgIH1cbiAgICBvdmVybGF5LnNldE1hcCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMubWFwQnJvd3NlckV2ZW50SGFuZGxlcl8uZGlzcG9zZSgpO1xuICAgIHVubGlzdGVuKHRoaXMudmlld3BvcnRfLCBFdmVudFR5cGUuQ09OVEVYVE1FTlUsIHRoaXMuaGFuZGxlQnJvd3NlckV2ZW50LCB0aGlzKTtcbiAgICB1bmxpc3Rlbih0aGlzLnZpZXdwb3J0XywgRXZlbnRUeXBlLldIRUVMLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcyk7XG4gICAgdW5saXN0ZW4odGhpcy52aWV3cG9ydF8sIEV2ZW50VHlwZS5NT1VTRVdIRUVMLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcyk7XG4gICAgaWYgKHRoaXMuaGFuZGxlUmVzaXplXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKEV2ZW50VHlwZS5SRVNJWkUsIHRoaXMuaGFuZGxlUmVzaXplXywgZmFsc2UpO1xuICAgICAgdGhpcy5oYW5kbGVSZXNpemVfID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmltYXRpb25EZWxheUtleV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLnNldFRhcmdldChudWxsKTtcbiAgICBzdXBlci5kaXNwb3NlSW50ZXJuYWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQsIGFuZCBleGVjdXRlIGFcbiAgICogY2FsbGJhY2sgd2l0aCBlYWNoIGludGVyc2VjdGluZyBmZWF0dXJlLiBMYXllcnMgaW5jbHVkZWQgaW4gdGhlIGRldGVjdGlvbiBjYW5cbiAgICogYmUgY29uZmlndXJlZCB0aHJvdWdoIHRoZSBgbGF5ZXJGaWx0ZXJgIG9wdGlvbiBpbiBgb3B0X29wdGlvbnNgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFMsIGltcG9ydChcIi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSxcbiAgICogICAgIGltcG9ydChcIi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IFR9IGNhbGxiYWNrIEZlYXR1cmUgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGJlXG4gICAqICAgICBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgb25lXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL0ZlYXR1cmUgZmVhdHVyZX0gb3JcbiAgICogICAgIHtAbGluayBtb2R1bGU6b2wvcmVuZGVyL0ZlYXR1cmUgcmVuZGVyIGZlYXR1cmV9IGF0IHRoZSBwaXhlbCwgdGhlIHNlY29uZCBpc1xuICAgKiAgICAgdGhlIHtAbGluayBtb2R1bGU6b2wvbGF5ZXIvTGF5ZXIgbGF5ZXJ9IG9mIHRoZSBmZWF0dXJlIGFuZCB3aWxsIGJlIG51bGwgZm9yXG4gICAqICAgICB1bm1hbmFnZWQgbGF5ZXJzLiBUbyBzdG9wIGRldGVjdGlvbiwgY2FsbGJhY2sgZnVuY3Rpb25zIGNhbiByZXR1cm4gYVxuICAgKiAgICAgdHJ1dGh5IHZhbHVlLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdCwgaS5lLiB0aGUgcmV0dXJuIHZhbHVlIG9mIGxhc3RcbiAgICogY2FsbGJhY2sgZXhlY3V0aW9uLCBvciB0aGUgZmlyc3QgdHJ1dGh5IGNhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFMsVFxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIGNhbGxiYWNrLCBvcHRfb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5mcmFtZVN0YXRlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb29yZGluYXRlID0gdGhpcy5nZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKTtcbiAgICBvcHRfb3B0aW9ucyA9IG9wdF9vcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRfb3B0aW9ucyA6XG4gICAgICAvKiogQHR5cGUge0F0UGl4ZWxPcHRpb25zfSAqLyAoe30pO1xuICAgIGNvbnN0IGhpdFRvbGVyYW5jZSA9IG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAqIHRoaXMuZnJhbWVTdGF0ZV8ucGl4ZWxSYXRpbyA6IDA7XG4gICAgY29uc3QgbGF5ZXJGaWx0ZXIgPSBvcHRfb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9vcHRpb25zLmxheWVyRmlsdGVyIDogVFJVRTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcl8uZm9yRWFjaEZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLCB0aGlzLmZyYW1lU3RhdGVfLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCBudWxsLFxuICAgICAgbGF5ZXJGaWx0ZXIsIG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgYSBwaXhlbCBvbiB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7QXRQaXhlbE9wdGlvbnM9fSBvcHRfb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtBcnJheTxpbXBvcnQoXCIuL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2U+fSBUaGUgZGV0ZWN0ZWQgZmVhdHVyZXMgb3JcbiAgICogYG51bGxgIGlmIG5vbmUgd2VyZSBmb3VuZC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RmVhdHVyZXNBdFBpeGVsKHBpeGVsLCBvcHRfb3B0aW9ucykge1xuICAgIGxldCBmZWF0dXJlcyA9IG51bGw7XG4gICAgdGhpcy5mb3JFYWNoRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgIGlmICghZmVhdHVyZXMpIHtcbiAgICAgICAgZmVhdHVyZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgfSwgb3B0X29wdGlvbnMpO1xuICAgIHJldHVybiBmZWF0dXJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgbGF5ZXJzIHRoYXQgaGF2ZSBhIGNvbG9yIHZhbHVlIGF0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LCBhbmRcbiAgICogZXhlY3V0ZSBhIGNhbGxiYWNrIHdpdGggZWFjaCBtYXRjaGluZyBsYXllci4gTGF5ZXJzIGluY2x1ZGVkIGluIHRoZVxuICAgKiBkZXRlY3Rpb24gY2FuIGJlIGNvbmZpZ3VyZWQgdGhyb3VnaCBgb3B0X2xheWVyRmlsdGVyYC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBwaXhlbCBQaXhlbC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQsIChVaW50OENsYW1wZWRBcnJheXxVaW50OEFycmF5KSk6IFR9IGNhbGxiYWNrXG4gICAqICAgICBMYXllciBjYWxsYmFjay4gVGhpcyBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdHdvIGFyZ3VtZW50czogZmlyc3QgaXMgdGhlXG4gICAqICAgICB7QGxpbmsgbW9kdWxlOm9sL2xheWVyL0xheWVyIGxheWVyfSwgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIGFycmF5IHJlcHJlc2VudGluZ1xuICAgKiAgICAgW1IsIEcsIEIsIEFdIHBpeGVsIHZhbHVlcyAoMCAtIDI1NSkgYW5kIHdpbGwgYmUgYG51bGxgIGZvciBsYXllciB0eXBlc1xuICAgKiAgICAgdGhhdCBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgdGhpcyBhcmd1bWVudC4gVG8gc3RvcCBkZXRlY3Rpb24sIGNhbGxiYWNrXG4gICAqICAgICBmdW5jdGlvbnMgY2FuIHJldHVybiBhIHRydXRoeSB2YWx1ZS5cbiAgICogQHBhcmFtIHtBdFBpeGVsT3B0aW9ucz19IG9wdF9vcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICogQHJldHVybiB7VHx1bmRlZmluZWR9IENhbGxiYWNrIHJlc3VsdCwgaS5lLiB0aGUgcmV0dXJuIHZhbHVlIG9mIGxhc3RcbiAgICogY2FsbGJhY2sgZXhlY3V0aW9uLCBvciB0aGUgZmlyc3QgdHJ1dGh5IGNhbGxiYWNrIHJldHVybiB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIFMsVFxuICAgKiBAYXBpXG4gICAqL1xuICBmb3JFYWNoTGF5ZXJBdFBpeGVsKHBpeGVsLCBjYWxsYmFjaywgb3B0X29wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuZnJhbWVTdGF0ZV8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IC8qKiBAdHlwZSB7QXRQaXhlbE9wdGlvbnN9ICovICh7fSk7XG4gICAgY29uc3QgaGl0VG9sZXJhbmNlID0gb3B0aW9ucy5oaXRUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRfb3B0aW9ucy5oaXRUb2xlcmFuY2UgKiB0aGlzLmZyYW1lU3RhdGVfLnBpeGVsUmF0aW8gOiAwO1xuICAgIGNvbnN0IGxheWVyRmlsdGVyID0gb3B0aW9ucy5sYXllckZpbHRlciB8fCBUUlVFO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXy5mb3JFYWNoTGF5ZXJBdFBpeGVsKFxuICAgICAgcGl4ZWwsIHRoaXMuZnJhbWVTdGF0ZV8sIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIG51bGwsIGxheWVyRmlsdGVyLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgZmVhdHVyZXMgaW50ZXJzZWN0IGEgcGl4ZWwgb24gdGhlIHZpZXdwb3J0LiBMYXllcnMgaW5jbHVkZWQgaW4gdGhlXG4gICAqIGRldGVjdGlvbiBjYW4gYmUgY29uZmlndXJlZCB0aHJvdWdoIGBvcHRfbGF5ZXJGaWx0ZXJgLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsLlxuICAgKiBAcGFyYW0ge0F0UGl4ZWxPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSXMgdGhlcmUgYSBmZWF0dXJlIGF0IHRoZSBnaXZlbiBwaXhlbD9cbiAgICogQHRlbXBsYXRlIFVcbiAgICogQGFwaVxuICAgKi9cbiAgaGFzRmVhdHVyZUF0UGl4ZWwocGl4ZWwsIG9wdF9vcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmZyYW1lU3RhdGVfKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvb3JkaW5hdGUgPSB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwocGl4ZWwpO1xuICAgIG9wdF9vcHRpb25zID0gb3B0X29wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdF9vcHRpb25zIDpcbiAgICAgIC8qKiBAdHlwZSB7QXRQaXhlbE9wdGlvbnN9ICovICh7fSk7XG4gICAgY29uc3QgbGF5ZXJGaWx0ZXIgPSBvcHRfb3B0aW9ucy5sYXllckZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0X29wdGlvbnMubGF5ZXJGaWx0ZXIgOiBUUlVFO1xuICAgIGNvbnN0IGhpdFRvbGVyYW5jZSA9IG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdF9vcHRpb25zLmhpdFRvbGVyYW5jZSAqIHRoaXMuZnJhbWVTdGF0ZV8ucGl4ZWxSYXRpbyA6IDA7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXJfLmhhc0ZlYXR1cmVBdENvb3JkaW5hdGUoXG4gICAgICBjb29yZGluYXRlLCB0aGlzLmZyYW1lU3RhdGVfLCBoaXRUb2xlcmFuY2UsIGxheWVyRmlsdGVyLCBudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb29yZGluYXRlIGluIHZpZXcgcHJvamVjdGlvbiBmb3IgYSBicm93c2VyIGV2ZW50LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IENvb3JkaW5hdGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEV2ZW50Q29vcmRpbmF0ZShldmVudCkge1xuICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGVGcm9tUGl4ZWwodGhpcy5nZXRFdmVudFBpeGVsKGV2ZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWFwIHBpeGVsIHBvc2l0aW9uIGZvciBhIGJyb3dzZXIgZXZlbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge0V2ZW50fFRvdWNoRXZlbnR9IGV2ZW50IEV2ZW50LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL3BpeGVsLmpzXCIpLlBpeGVsfSBQaXhlbC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0RXZlbnRQaXhlbChldmVudCkge1xuICAgIGNvbnN0IHZpZXdwb3J0UG9zaXRpb24gPSB0aGlzLnZpZXdwb3J0Xy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBldmVudFBvc2l0aW9uID0gJ2NoYW5nZWRUb3VjaGVzJyBpbiBldmVudCA/XG4gICAgICAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovIChldmVudCkuY2hhbmdlZFRvdWNoZXNbMF0gOlxuICAgICAgLyoqIEB0eXBlIHtNb3VzZUV2ZW50fSAqLyAoZXZlbnQpO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIGV2ZW50UG9zaXRpb24uY2xpZW50WCAtIHZpZXdwb3J0UG9zaXRpb24ubGVmdCxcbiAgICAgIGV2ZW50UG9zaXRpb24uY2xpZW50WSAtIHZpZXdwb3J0UG9zaXRpb24udG9wXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhcmdldCBpbiB3aGljaCB0aGlzIG1hcCBpcyByZW5kZXJlZC5cbiAgICogTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB3aGF0IGlzIGVudGVyZWQgYXMgYW4gb3B0aW9uIG9yIGluIHNldFRhcmdldDpcbiAgICogaWYgdGhhdCB3YXMgYW4gZWxlbWVudCwgaXQgcmV0dXJucyBhbiBlbGVtZW50OyBpZiBhIHN0cmluZywgaXQgcmV0dXJucyB0aGF0LlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxzdHJpbmd8dW5kZWZpbmVkfSBUaGUgRWxlbWVudCBvciBpZCBvZiB0aGUgRWxlbWVudCB0aGF0IHRoZVxuICAgKiAgICAgbWFwIGlzIHJlbmRlcmVkIGluLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR8c3RyaW5nfHVuZGVmaW5lZH0gKi8gKHRoaXMuZ2V0KE1hcFByb3BlcnR5LlRBUkdFVCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgRE9NIGVsZW1lbnQgaW50byB3aGljaCB0aGlzIG1hcCBpcyByZW5kZXJlZC4gSW4gY29udHJhc3QgdG9cbiAgICogYGdldFRhcmdldGAgdGhpcyBtZXRob2QgYWx3YXlzIHJldHVybiBhbiBgRWxlbWVudGAsIG9yIGBudWxsYCBpZiB0aGVcbiAgICogbWFwIGhhcyBubyB0YXJnZXQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgZWxlbWVudCB0aGF0IHRoZSBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFRhcmdldEVsZW1lbnQoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXQoKTtcbiAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCkgOiB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvb3JkaW5hdGUgZm9yIGEgZ2l2ZW4gcGl4ZWwuICBUaGlzIHJldHVybnMgYSBjb29yZGluYXRlIGluIHRoZVxuICAgKiBtYXAgdmlldyBwcm9qZWN0aW9uLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IHBpeGVsIFBpeGVsIHBvc2l0aW9uIGluIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBUaGUgY29vcmRpbmF0ZSBmb3IgdGhlIHBpeGVsIHBvc2l0aW9uLlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRDb29yZGluYXRlRnJvbVBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0sIHBpeGVsLnNsaWNlKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCBjb250cm9scy4gTW9kaWZ5aW5nIHRoaXMgY29sbGVjdGlvbiBjaGFuZ2VzIHRoZSBjb250cm9sc1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICogQHJldHVybiB7Q29sbGVjdGlvbjxpbXBvcnQoXCIuL2NvbnRyb2wvQ29udHJvbC5qc1wiKS5kZWZhdWx0Pn0gQ29udHJvbHMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbnRyb2xzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWFwIG92ZXJsYXlzLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIG92ZXJsYXlzXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgbWFwLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0Pn0gT3ZlcmxheXMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE92ZXJsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLm92ZXJsYXlzXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gb3ZlcmxheSBieSBpdHMgaWRlbnRpZmllciAodGhlIHZhbHVlIHJldHVybmVkIGJ5IG92ZXJsYXkuZ2V0SWQoKSkuXG4gICAqIE5vdGUgdGhhdCB0aGUgaW5kZXggdHJlYXRzIHN0cmluZyBhbmQgbnVtZXJpYyBpZGVudGlmaWVycyBhcyB0aGUgc2FtZS4gU29cbiAgICogYG1hcC5nZXRPdmVybGF5QnlJZCgyKWAgd2lsbCByZXR1cm4gYW4gb3ZlcmxheSB3aXRoIGlkIGAnMidgIG9yIGAyYC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpZCBPdmVybGF5IGlkZW50aWZpZXIuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vT3ZlcmxheS5qc1wiKS5kZWZhdWx0fSBPdmVybGF5LlxuICAgKiBAYXBpXG4gICAqL1xuICBnZXRPdmVybGF5QnlJZChpZCkge1xuICAgIGNvbnN0IG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlJZEluZGV4X1tpZC50b1N0cmluZygpXTtcbiAgICByZXR1cm4gb3ZlcmxheSAhPT0gdW5kZWZpbmVkID8gb3ZlcmxheSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXAgaW50ZXJhY3Rpb25zLiBNb2RpZnlpbmcgdGhpcyBjb2xsZWN0aW9uIGNoYW5nZXMgdGhlIGludGVyYWN0aW9uc1xuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhlIG1hcC5cbiAgICpcbiAgICogSW50ZXJhY3Rpb25zIGFyZSB1c2VkIGZvciBlLmcuIHBhbiwgem9vbSBhbmQgcm90YXRlLlxuICAgKiBAcmV0dXJuIHtDb2xsZWN0aW9uPGltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdD59IEludGVyYWN0aW9ucy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0SW50ZXJhY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmludGVyYWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxheWVyZ3JvdXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFwLlxuICAgKiBAcmV0dXJuIHtMYXllckdyb3VwfSBBIGxheWVyIGdyb3VwIGNvbnRhaW5pbmcgdGhlIGxheWVycyBpbiB0aGlzIG1hcC5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0TGF5ZXJHcm91cCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtMYXllckdyb3VwfSAqLyAodGhpcy5nZXQoTWFwUHJvcGVydHkuTEFZRVJHUk9VUCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbGxlY3Rpb24gb2YgbGF5ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcC5cbiAgICogQHJldHVybiB7IUNvbGxlY3Rpb248aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHQ+fSBMYXllcnMuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldExheWVycygpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcGl4ZWwgZm9yIGEgY29vcmRpbmF0ZS4gIFRoaXMgdGFrZXMgYSBjb29yZGluYXRlIGluIHRoZSBtYXAgdmlld1xuICAgKiBwcm9qZWN0aW9uIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBpeGVsLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfSBjb29yZGluYXRlIEEgbWFwIGNvb3JkaW5hdGUuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vcGl4ZWwuanNcIikuUGl4ZWx9IEEgcGl4ZWwgcG9zaXRpb24gaW4gdGhlIG1hcCB2aWV3cG9ydC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShjb29yZGluYXRlKSB7XG4gICAgY29uc3QgZnJhbWVTdGF0ZSA9IHRoaXMuZnJhbWVTdGF0ZV87XG4gICAgaWYgKCFmcmFtZVN0YXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFwcGx5VHJhbnNmb3JtKGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0sIGNvb3JkaW5hdGUuc2xpY2UoMCwgMikpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1hcCByZW5kZXJlci5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9yZW5kZXJlci9NYXAuanNcIikuZGVmYXVsdH0gUmVuZGVyZXJcbiAgICovXG4gIGdldFJlbmRlcmVyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpemUgb2YgdGhpcyBtYXAuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vc2l6ZS5qc1wiKS5TaXplfHVuZGVmaW5lZH0gVGhlIHNpemUgaW4gcGl4ZWxzIG9mIHRoZSBtYXAgaW4gdGhlIERPTS5cbiAgICogQG9ic2VydmFibGVcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLyoqIEB0eXBlIHtpbXBvcnQoXCIuL3NpemUuanNcIikuU2l6ZXx1bmRlZmluZWR9ICovICh0aGlzLmdldChNYXBQcm9wZXJ0eS5TSVpFKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlldyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYXAuIEEgdmlldyBtYW5hZ2VzIHByb3BlcnRpZXMgc3VjaCBhc1xuICAgKiBjZW50ZXIgYW5kIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge1ZpZXd9IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldFZpZXcoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKiBAdHlwZSB7Vmlld30gKi8gKHRoaXMuZ2V0KE1hcFByb3BlcnR5LlZJRVcpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IHRoYXQgc2VydmVzIGFzIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBWaWV3cG9ydC5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0Vmlld3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld3BvcnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZWxlbWVudCB0aGF0IHNlcnZlcyBhcyB0aGUgY29udGFpbmVyIGZvciBvdmVybGF5cy4gIEVsZW1lbnRzIGFkZGVkIHRvXG4gICAqIHRoaXMgY29udGFpbmVyIHdpbGwgbGV0IG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBldmVudHMgdGhyb3VnaCB0byB0aGUgbWFwLFxuICAgKiBzbyBjbGlja3MgYW5kIGdlc3R1cmVzIG9uIGFuIG92ZXJsYXkgd2lsbCB0cmlnZ2VyIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH1cbiAgICogZXZlbnRzLlxuICAgKiBAcmV0dXJuIHshSFRNTEVsZW1lbnR9IFRoZSBtYXAncyBvdmVybGF5IGNvbnRhaW5lci5cbiAgICovXG4gIGdldE92ZXJsYXlDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheUNvbnRhaW5lcl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbGVtZW50IHRoYXQgc2VydmVzIGFzIGEgY29udGFpbmVyIGZvciBvdmVybGF5cyB0aGF0IGRvbid0IGFsbG93XG4gICAqIGV2ZW50IHByb3BhZ2F0aW9uLiBFbGVtZW50cyBhZGRlZCB0byB0aGlzIGNvbnRhaW5lciB3b24ndCBsZXQgbW91c2Vkb3duIGFuZFxuICAgKiB0b3VjaHN0YXJ0IGV2ZW50cyB0aHJvdWdoIHRvIHRoZSBtYXAsIHNvIGNsaWNrcyBhbmQgZ2VzdHVyZXMgb24gYW4gb3ZlcmxheVxuICAgKiBkb24ndCB0cmlnZ2VyIGFueSB7QGxpbmsgbW9kdWxlOm9sL01hcEJyb3dzZXJFdmVudH5NYXBCcm93c2VyRXZlbnR9LlxuICAgKiBAcmV0dXJuIHshSFRNTEVsZW1lbnR9IFRoZSBtYXAncyBvdmVybGF5IGNvbnRhaW5lciB0aGF0IHN0b3BzIGV2ZW50cy5cbiAgICovXG4gIGdldE92ZXJsYXlDb250YWluZXJTdG9wRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3ZlcmxheUNvbnRhaW5lclN0b3BFdmVudF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL1RpbGUuanNcIikuZGVmYXVsdH0gdGlsZSBUaWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGlsZVNvdXJjZUtleSBUaWxlIHNvdXJjZSBrZXkuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IHRpbGVDZW50ZXIgVGlsZSBjZW50ZXIuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aWxlUmVzb2x1dGlvbiBUaWxlIHJlc29sdXRpb24uXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGlsZSBwcmlvcml0eS5cbiAgICovXG4gIGdldFRpbGVQcmlvcml0eSh0aWxlLCB0aWxlU291cmNlS2V5LCB0aWxlQ2VudGVyLCB0aWxlUmVzb2x1dGlvbikge1xuICAgIC8vIEZpbHRlciBvdXQgdGlsZXMgYXQgaGlnaGVyIHpvb20gbGV2ZWxzIHRoYW4gdGhlIGN1cnJlbnQgem9vbSBsZXZlbCwgb3IgdGhhdFxuICAgIC8vIGFyZSBvdXRzaWRlIHRoZSB2aXNpYmxlIGV4dGVudC5cbiAgICBjb25zdCBmcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICBpZiAoIWZyYW1lU3RhdGUgfHwgISh0aWxlU291cmNlS2V5IGluIGZyYW1lU3RhdGUud2FudGVkVGlsZXMpKSB7XG4gICAgICByZXR1cm4gRFJPUDtcbiAgICB9XG4gICAgaWYgKCFmcmFtZVN0YXRlLndhbnRlZFRpbGVzW3RpbGVTb3VyY2VLZXldW3RpbGUuZ2V0S2V5KCldKSB7XG4gICAgICByZXR1cm4gRFJPUDtcbiAgICB9XG4gICAgLy8gUHJpb3JpdGl6ZSB0aGUgaGlnaGVzdCB6b29tIGxldmVsIHRpbGVzIGNsb3Nlc3QgdG8gdGhlIGZvY3VzLlxuICAgIC8vIFRpbGVzIGF0IGhpZ2hlciB6b29tIGxldmVscyBhcmUgcHJpb3JpdGl6ZWQgdXNpbmcgTWF0aC5sb2codGlsZVJlc29sdXRpb24pLlxuICAgIC8vIFdpdGhpbiBhIHpvb20gbGV2ZWwsIHRpbGVzIGFyZSBwcmlvcml0aXplZCBieSB0aGUgZGlzdGFuY2UgaW4gcGl4ZWxzXG4gICAgLy8gYmV0d2VlbiB0aGUgY2VudGVyIG9mIHRoZSB0aWxlIGFuZCB0aGUgZm9jdXMuICBUaGUgZmFjdG9yIG9mIDY1NTM2IG1lYW5zXG4gICAgLy8gdGhhdCB0aGUgcHJpb3JpdGl6YXRpb24gc2hvdWxkIGJlaGF2ZSBhcyBkZXNpcmVkIGZvciB0aWxlcyB1cCB0b1xuICAgIC8vIDY1NTM2ICogTWF0aC5sb2coMikgPSA0NTQyNiBwaXhlbHMgZnJvbSB0aGUgZm9jdXMuXG4gICAgY29uc3QgZGVsdGFYID0gdGlsZUNlbnRlclswXSAtIGZyYW1lU3RhdGUuZm9jdXNbMF07XG4gICAgY29uc3QgZGVsdGFZID0gdGlsZUNlbnRlclsxXSAtIGZyYW1lU3RhdGUuZm9jdXNbMV07XG4gICAgcmV0dXJuIDY1NTM2ICogTWF0aC5sb2codGlsZVJlc29sdXRpb24pICtcbiAgICAgICAgTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSkgLyB0aWxlUmVzb2x1dGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBicm93c2VyRXZlbnQgQnJvd3NlciBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfdHlwZSBUeXBlLlxuICAgKi9cbiAgaGFuZGxlQnJvd3NlckV2ZW50KGJyb3dzZXJFdmVudCwgb3B0X3R5cGUpIHtcbiAgICBjb25zdCB0eXBlID0gb3B0X3R5cGUgfHwgYnJvd3NlckV2ZW50LnR5cGU7XG4gICAgY29uc3QgbWFwQnJvd3NlckV2ZW50ID0gbmV3IE1hcEJyb3dzZXJFdmVudCh0eXBlLCB0aGlzLCBicm93c2VyRXZlbnQpO1xuICAgIHRoaXMuaGFuZGxlTWFwQnJvd3NlckV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNYXBCcm93c2VyRXZlbnR9IG1hcEJyb3dzZXJFdmVudCBUaGUgZXZlbnQgdG8gaGFuZGxlLlxuICAgKi9cbiAgaGFuZGxlTWFwQnJvd3NlckV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghdGhpcy5mcmFtZVN0YXRlXykge1xuICAgICAgLy8gV2l0aCBubyB2aWV3IGRlZmluZWQsIHdlIGNhbm5vdCB0cmFuc2xhdGUgcGl4ZWxzIGludG8gZ2VvZ3JhcGhpY2FsXG4gICAgICAvLyBjb29yZGluYXRlcyBzbyBpbnRlcmFjdGlvbnMgY2Fubm90IGJlIHVzZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZm9jdXNfID0gbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGU7XG4gICAgbWFwQnJvd3NlckV2ZW50LmZyYW1lU3RhdGUgPSB0aGlzLmZyYW1lU3RhdGVfO1xuICAgIGNvbnN0IGludGVyYWN0aW9uc0FycmF5ID0gdGhpcy5nZXRJbnRlcmFjdGlvbnMoKS5nZXRBcnJheSgpO1xuICAgIGlmICh0aGlzLmRpc3BhdGNoRXZlbnQobWFwQnJvd3NlckV2ZW50KSAhPT0gZmFsc2UpIHtcbiAgICAgIGZvciAobGV0IGkgPSBpbnRlcmFjdGlvbnNBcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbnRlcmFjdGlvbiA9IGludGVyYWN0aW9uc0FycmF5W2ldO1xuICAgICAgICBpZiAoIWludGVyYWN0aW9uLmdldEFjdGl2ZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udCA9IGludGVyYWN0aW9uLmhhbmRsZUV2ZW50KG1hcEJyb3dzZXJFdmVudCk7XG4gICAgICAgIGlmICghY29udCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGhhbmRsZVBvc3RSZW5kZXIoKSB7XG5cbiAgICBjb25zdCBmcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcblxuICAgIC8vIE1hbmFnZSB0aGUgdGlsZSBxdWV1ZVxuICAgIC8vIEltYWdlIGxvYWRzIGFyZSBleHBlbnNpdmUgYW5kIGEgbGltaXRlZCByZXNvdXJjZSwgc28gdHJ5IHRvIHVzZSB0aGVtXG4gICAgLy8gZWZmaWNpZW50bHk6XG4gICAgLy8gKiBXaGVuIHRoZSB2aWV3IGlzIHN0YXRpYyB3ZSBhbGxvdyBhIGxhcmdlIG51bWJlciBvZiBwYXJhbGxlbCB0aWxlIGxvYWRzXG4gICAgLy8gICB0byBjb21wbGV0ZSB0aGUgZnJhbWUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgICAvLyAqIFdoZW4gYW5pbWF0aW5nIG9yIGludGVyYWN0aW5nLCBpbWFnZSBsb2FkcyBjYW4gY2F1c2UgamFua3MsIHNvIHdlIHJlZHVjZVxuICAgIC8vICAgdGhlIG1heGltdW0gbnVtYmVyIG9mIGxvYWRzIHBlciBmcmFtZSBhbmQgbGltaXQgdGhlIG51bWJlciBvZiBwYXJhbGxlbFxuICAgIC8vICAgdGlsZSBsb2FkcyB0byByZW1haW4gcmVhY3RpdmUgdG8gdmlldyBjaGFuZ2VzIGFuZCB0byByZWR1Y2UgdGhlIGNoYW5jZSBvZlxuICAgIC8vICAgbG9hZGluZyB0aWxlcyB0aGF0IHdpbGwgcXVpY2tseSBkaXNhcHBlYXIgZnJvbSB2aWV3LlxuICAgIGNvbnN0IHRpbGVRdWV1ZSA9IHRoaXMudGlsZVF1ZXVlXztcbiAgICBpZiAoIXRpbGVRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgIGxldCBtYXhUb3RhbExvYWRpbmcgPSB0aGlzLm1heFRpbGVzTG9hZGluZ187XG4gICAgICBsZXQgbWF4TmV3TG9hZHMgPSBtYXhUb3RhbExvYWRpbmc7XG4gICAgICBpZiAoZnJhbWVTdGF0ZSkge1xuICAgICAgICBjb25zdCBoaW50cyA9IGZyYW1lU3RhdGUudmlld0hpbnRzO1xuICAgICAgICBpZiAoaGludHNbVmlld0hpbnQuQU5JTUFUSU5HXSkge1xuICAgICAgICAgIG1heFRvdGFsTG9hZGluZyA9IHRoaXMubG9hZFRpbGVzV2hpbGVBbmltYXRpbmdfID8gOCA6IDA7XG4gICAgICAgICAgbWF4TmV3TG9hZHMgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaW50c1tWaWV3SGludC5JTlRFUkFDVElOR10pIHtcbiAgICAgICAgICBtYXhUb3RhbExvYWRpbmcgPSB0aGlzLmxvYWRUaWxlc1doaWxlSW50ZXJhY3RpbmdfID8gOCA6IDA7XG4gICAgICAgICAgbWF4TmV3TG9hZHMgPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGlsZVF1ZXVlLmdldFRpbGVzTG9hZGluZygpIDwgbWF4VG90YWxMb2FkaW5nKSB7XG4gICAgICAgIHRpbGVRdWV1ZS5yZXByaW9yaXRpemUoKTsgLy8gRklYTUUgb25seSBjYWxsIGlmIHZpZXcgaGFzIGNoYW5nZWRcbiAgICAgICAgdGlsZVF1ZXVlLmxvYWRNb3JlVGlsZXMobWF4VG90YWxMb2FkaW5nLCBtYXhOZXdMb2Fkcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFtZVN0YXRlICYmIHRoaXMuaGFzTGlzdGVuZXIoUmVuZGVyRXZlbnRUeXBlLlJFTkRFUkNPTVBMRVRFKSAmJiAhZnJhbWVTdGF0ZS5hbmltYXRlICYmXG4gICAgICAgICF0aGlzLnRpbGVRdWV1ZV8uZ2V0VGlsZXNMb2FkaW5nKCkgJiYgIWdldExvYWRpbmcodGhpcy5nZXRMYXllcnMoKS5nZXRBcnJheSgpKSkge1xuICAgICAgdGhpcy5yZW5kZXJlcl8uZGlzcGF0Y2hSZW5kZXJFdmVudChSZW5kZXJFdmVudFR5cGUuUkVOREVSQ09NUExFVEUsIGZyYW1lU3RhdGUpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvc3RSZW5kZXJGdW5jdGlvbnMgPSB0aGlzLnBvc3RSZW5kZXJGdW5jdGlvbnNfO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc3RSZW5kZXJGdW5jdGlvbnMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgcG9zdFJlbmRlckZ1bmN0aW9uc1tpXSh0aGlzLCBmcmFtZVN0YXRlKTtcbiAgICB9XG4gICAgcG9zdFJlbmRlckZ1bmN0aW9ucy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTaXplQ2hhbmdlZF8oKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVGFyZ2V0Q2hhbmdlZF8oKSB7XG4gICAgLy8gdGFyZ2V0IG1heSBiZSB1bmRlZmluZWQsIG51bGwsIGEgc3RyaW5nIG9yIGFuIEVsZW1lbnQuXG4gICAgLy8gSWYgaXQncyBhIHN0cmluZyB3ZSBjb252ZXJ0IGl0IHRvIGFuIEVsZW1lbnQgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgLy8gSWYgaXQncyBub3Qgbm93IGFuIEVsZW1lbnQgd2UgcmVtb3ZlIHRoZSB2aWV3cG9ydCBmcm9tIHRoZSBET00uXG4gICAgLy8gSWYgaXQncyBhbiBFbGVtZW50IHdlIGFwcGVuZCB0aGUgdmlld3BvcnQgZWxlbWVudCB0byBpdC5cblxuICAgIGxldCB0YXJnZXRFbGVtZW50O1xuICAgIGlmICh0aGlzLmdldFRhcmdldCgpKSB7XG4gICAgICB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRUYXJnZXRFbGVtZW50KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2V5SGFuZGxlcktleXNfKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLmtleUhhbmRsZXJLZXlzXy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIHVubGlzdGVuQnlLZXkodGhpcy5rZXlIYW5kbGVyS2V5c19baV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXlIYW5kbGVyS2V5c18gPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgdGhpcy5yZW5kZXJlcl8ucmVtb3ZlTGF5ZXJSZW5kZXJlcnMoKTtcbiAgICAgIHJlbW92ZU5vZGUodGhpcy52aWV3cG9ydF8pO1xuICAgICAgaWYgKHRoaXMuaGFuZGxlUmVzaXplXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLlJFU0laRSwgdGhpcy5oYW5kbGVSZXNpemVfLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplXyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnZpZXdwb3J0Xyk7XG5cbiAgICAgIGNvbnN0IGtleWJvYXJkRXZlbnRUYXJnZXQgPSAhdGhpcy5rZXlib2FyZEV2ZW50VGFyZ2V0XyA/XG4gICAgICAgIHRhcmdldEVsZW1lbnQgOiB0aGlzLmtleWJvYXJkRXZlbnRUYXJnZXRfO1xuICAgICAgdGhpcy5rZXlIYW5kbGVyS2V5c18gPSBbXG4gICAgICAgIGxpc3RlbihrZXlib2FyZEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUuS0VZRE9XTiwgdGhpcy5oYW5kbGVCcm93c2VyRXZlbnQsIHRoaXMpLFxuICAgICAgICBsaXN0ZW4oa2V5Ym9hcmRFdmVudFRhcmdldCwgRXZlbnRUeXBlLktFWVBSRVNTLCB0aGlzLmhhbmRsZUJyb3dzZXJFdmVudCwgdGhpcylcbiAgICAgIF07XG5cbiAgICAgIGlmICghdGhpcy5oYW5kbGVSZXNpemVfKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplXyA9IHRoaXMudXBkYXRlU2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihFdmVudFR5cGUuUkVTSVpFLCB0aGlzLmhhbmRsZVJlc2l6ZV8sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICAvLyB1cGRhdGVTaXplIGNhbGxzIHNldFNpemUsIHNvIG5vIG5lZWQgdG8gY2FsbCB0aGlzLnJlbmRlclxuICAgIC8vIG91cnNlbHZlcyBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVUaWxlQ2hhbmdlXygpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVWaWV3UHJvcGVydHlDaGFuZ2VkXygpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVWaWV3Q2hhbmdlZF8oKSB7XG4gICAgaWYgKHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfKSB7XG4gICAgICB1bmxpc3RlbkJ5S2V5KHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfKTtcbiAgICAgIHRoaXMudmlld1Byb3BlcnR5TGlzdGVuZXJLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5Xykge1xuICAgICAgdW5saXN0ZW5CeUtleSh0aGlzLnZpZXdDaGFuZ2VMaXN0ZW5lcktleV8pO1xuICAgICAgdGhpcy52aWV3Q2hhbmdlTGlzdGVuZXJLZXlfID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIGlmICh2aWV3KSB7XG4gICAgICB0aGlzLnZpZXdwb3J0Xy5zZXRBdHRyaWJ1dGUoJ2RhdGEtdmlldycsIGdldFVpZCh2aWV3KSk7XG4gICAgICB0aGlzLnZpZXdQcm9wZXJ0eUxpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgICAgdmlldywgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgICB0aGlzLmhhbmRsZVZpZXdQcm9wZXJ0eUNoYW5nZWRfLCB0aGlzKTtcbiAgICAgIHRoaXMudmlld0NoYW5nZUxpc3RlbmVyS2V5XyA9IGxpc3RlbihcbiAgICAgICAgdmlldywgRXZlbnRUeXBlLkNIQU5HRSxcbiAgICAgICAgdGhpcy5oYW5kbGVWaWV3UHJvcGVydHlDaGFuZ2VkXywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUxheWVyR3JvdXBDaGFuZ2VkXygpIHtcbiAgICBpZiAodGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfKSB7XG4gICAgICB0aGlzLmxheWVyR3JvdXBQcm9wZXJ0eUxpc3RlbmVyS2V5c18uZm9yRWFjaCh1bmxpc3RlbkJ5S2V5KTtcbiAgICAgIHRoaXMubGF5ZXJHcm91cFByb3BlcnR5TGlzdGVuZXJLZXlzXyA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxheWVyR3JvdXAgPSB0aGlzLmdldExheWVyR3JvdXAoKTtcbiAgICBpZiAobGF5ZXJHcm91cCkge1xuICAgICAgdGhpcy5sYXllckdyb3VwUHJvcGVydHlMaXN0ZW5lcktleXNfID0gW1xuICAgICAgICBsaXN0ZW4oXG4gICAgICAgICAgbGF5ZXJHcm91cCwgT2JqZWN0RXZlbnRUeXBlLlBST1BFUlRZQ0hBTkdFLFxuICAgICAgICAgIHRoaXMucmVuZGVyLCB0aGlzKSxcbiAgICAgICAgbGlzdGVuKFxuICAgICAgICAgIGxheWVyR3JvdXAsIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICAgICAgdGhpcy5yZW5kZXIsIHRoaXMpXG4gICAgICBdO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHJlbmRlcmVkLlxuICAgKi9cbiAgaXNSZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmZyYW1lU3RhdGVfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFuIGltbWVkaWF0ZSByZW5kZXIgaW4gYSBzeW5jaHJvbm91cyBtYW5uZXIuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbmRlclN5bmMoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGVsYXlLZXlfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkRlbGF5S2V5Xyk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uRGVsYXlfKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCBhIG1hcCByZW5kZXJpbmcgKGF0IHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25EZWxheUtleV8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5hbmltYXRpb25EZWxheUtleV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25EZWxheV8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGdpdmVuIGNvbnRyb2wgZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vY29udHJvbC9Db250cm9sLmpzXCIpLmRlZmF1bHR9IGNvbnRyb2wgQ29udHJvbC5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi9jb250cm9sL0NvbnRyb2wuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGNvbnRyb2wgKG9yIHVuZGVmaW5lZFxuICAgKiAgICAgaWYgdGhlIGNvbnRyb2wgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZUNvbnRyb2woY29udHJvbCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnRyb2xzKCkucmVtb3ZlKGNvbnRyb2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW50ZXJhY3Rpb24gZnJvbSB0aGUgbWFwLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanNcIikuZGVmYXVsdH0gaW50ZXJhY3Rpb24gSW50ZXJhY3Rpb24gdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2ludGVyYWN0aW9uL0ludGVyYWN0aW9uLmpzXCIpLmRlZmF1bHR8dW5kZWZpbmVkfSBUaGUgcmVtb3ZlZCBpbnRlcmFjdGlvbiAob3JcbiAgICogICAgIHVuZGVmaW5lZCBpZiB0aGUgaW50ZXJhY3Rpb24gd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZUludGVyYWN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJhY3Rpb25zKCkucmVtb3ZlKGludGVyYWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBsYXllciBmcm9tIHRoZSBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9sYXllci9CYXNlLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL2xheWVyL0Jhc2UuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIGxheWVyIChvciB1bmRlZmluZWQgaWYgdGhlXG4gICAqICAgICBsYXllciB3YXMgbm90IGZvdW5kKS5cbiAgICogQGFwaVxuICAgKi9cbiAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICBjb25zdCBsYXllcnMgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllcnMoKTtcbiAgICByZXR1cm4gbGF5ZXJzLnJlbW92ZShsYXllcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBnaXZlbiBvdmVybGF5IGZyb20gdGhlIG1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdH0gb3ZlcmxheSBPdmVybGF5LlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL092ZXJsYXkuanNcIikuZGVmYXVsdHx1bmRlZmluZWR9IFRoZSByZW1vdmVkIG92ZXJsYXkgKG9yIHVuZGVmaW5lZFxuICAgKiAgICAgaWYgdGhlIG92ZXJsYXkgd2FzIG5vdCBmb3VuZCkuXG4gICAqIEBhcGlcbiAgICovXG4gIHJlbW92ZU92ZXJsYXkob3ZlcmxheSkge1xuICAgIHJldHVybiB0aGlzLmdldE92ZXJsYXlzKCkucmVtb3ZlKG92ZXJsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIFRpbWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW5kZXJGcmFtZV8odGltZSkge1xuICAgIGxldCB2aWV3U3RhdGU7XG5cbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgY29uc3QgdmlldyA9IHRoaXMuZ2V0VmlldygpO1xuICAgIGNvbnN0IGV4dGVudCA9IGNyZWF0ZUVtcHR5KCk7XG4gICAgY29uc3QgcHJldmlvdXNGcmFtZVN0YXRlID0gdGhpcy5mcmFtZVN0YXRlXztcbiAgICAvKiogQHR5cGUgez9GcmFtZVN0YXRlfSAqL1xuICAgIGxldCBmcmFtZVN0YXRlID0gbnVsbDtcbiAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGhhc0FyZWEoc2l6ZSkgJiYgdmlldyAmJiB2aWV3LmlzRGVmKCkpIHtcbiAgICAgIGNvbnN0IHZpZXdIaW50cyA9IHZpZXcuZ2V0SGludHModGhpcy5mcmFtZVN0YXRlXyA/IHRoaXMuZnJhbWVTdGF0ZV8udmlld0hpbnRzIDogdW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IGxheWVyU3RhdGVzQXJyYXkgPSB0aGlzLmdldExheWVyR3JvdXAoKS5nZXRMYXllclN0YXRlc0FycmF5KCk7XG4gICAgICBjb25zdCBsYXllclN0YXRlcyA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJTdGF0ZXNBcnJheS5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGxheWVyU3RhdGVzW2dldFVpZChsYXllclN0YXRlc0FycmF5W2ldLmxheWVyKV0gPSBsYXllclN0YXRlc0FycmF5W2ldO1xuICAgICAgfVxuICAgICAgdmlld1N0YXRlID0gdmlldy5nZXRTdGF0ZSh0aGlzLnBpeGVsUmF0aW9fKTtcbiAgICAgIGZyYW1lU3RhdGUgPSAvKiogQHR5cGUge0ZyYW1lU3RhdGV9ICovICh7XG4gICAgICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgICAgICBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybTogdGhpcy5jb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybV8sXG4gICAgICAgIGV4dGVudDogZXh0ZW50LFxuICAgICAgICBmb2N1czogdGhpcy5mb2N1c18gPyB0aGlzLmZvY3VzXyA6IHZpZXdTdGF0ZS5jZW50ZXIsXG4gICAgICAgIGluZGV4OiB0aGlzLmZyYW1lSW5kZXhfKyssXG4gICAgICAgIGxheWVyU3RhdGVzOiBsYXllclN0YXRlcyxcbiAgICAgICAgbGF5ZXJTdGF0ZXNBcnJheTogbGF5ZXJTdGF0ZXNBcnJheSxcbiAgICAgICAgcGl4ZWxSYXRpbzogdGhpcy5waXhlbFJhdGlvXyxcbiAgICAgICAgcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm06IHRoaXMucGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm1fLFxuICAgICAgICBwb3N0UmVuZGVyRnVuY3Rpb25zOiBbXSxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgc2tpcHBlZEZlYXR1cmVVaWRzOiB0aGlzLnNraXBwZWRGZWF0dXJlVWlkc18sXG4gICAgICAgIHRpbGVRdWV1ZTogdGhpcy50aWxlUXVldWVfLFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB1c2VkVGlsZXM6IHt9LFxuICAgICAgICB2aWV3U3RhdGU6IHZpZXdTdGF0ZSxcbiAgICAgICAgdmlld0hpbnRzOiB2aWV3SGludHMsXG4gICAgICAgIHdhbnRlZFRpbGVzOiB7fVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGZyYW1lU3RhdGUpIHtcbiAgICAgIGZyYW1lU3RhdGUuZXh0ZW50ID0gZ2V0Rm9yVmlld0FuZFNpemUodmlld1N0YXRlLmNlbnRlcixcbiAgICAgICAgdmlld1N0YXRlLnJlc29sdXRpb24sIHZpZXdTdGF0ZS5yb3RhdGlvbiwgZnJhbWVTdGF0ZS5zaXplLCBleHRlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWVTdGF0ZV8gPSBmcmFtZVN0YXRlO1xuICAgIHRoaXMucmVuZGVyZXJfLnJlbmRlckZyYW1lKGZyYW1lU3RhdGUpO1xuXG4gICAgaWYgKGZyYW1lU3RhdGUpIHtcbiAgICAgIGlmIChmcmFtZVN0YXRlLmFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucG9zdFJlbmRlckZ1bmN0aW9uc18sIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucyk7XG5cbiAgICAgIGlmIChwcmV2aW91c0ZyYW1lU3RhdGUpIHtcbiAgICAgICAgY29uc3QgbW92ZVN0YXJ0ID0gIXRoaXMucHJldmlvdXNFeHRlbnRfIHx8XG4gICAgICAgICAgICAgICAgICAgICghaXNFbXB0eSh0aGlzLnByZXZpb3VzRXh0ZW50XykgJiZcbiAgICAgICAgICAgICAgICAgICAgIWVxdWFscyhmcmFtZVN0YXRlLmV4dGVudCwgdGhpcy5wcmV2aW91c0V4dGVudF8pKTtcbiAgICAgICAgaWYgKG1vdmVTdGFydCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRVNUQVJULCB0aGlzLCBwcmV2aW91c0ZyYW1lU3RhdGUpKTtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzRXh0ZW50XyA9IGNyZWF0ZU9yVXBkYXRlRW1wdHkodGhpcy5wcmV2aW91c0V4dGVudF8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGUgPSB0aGlzLnByZXZpb3VzRXh0ZW50XyAmJlxuICAgICAgICAgICFmcmFtZVN0YXRlLnZpZXdIaW50c1tWaWV3SGludC5BTklNQVRJTkddICYmXG4gICAgICAgICAgIWZyYW1lU3RhdGUudmlld0hpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXSAmJlxuICAgICAgICAgICFlcXVhbHMoZnJhbWVTdGF0ZS5leHRlbnQsIHRoaXMucHJldmlvdXNFeHRlbnRfKTtcblxuICAgICAgaWYgKGlkbGUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBNYXBFdmVudChNYXBFdmVudFR5cGUuTU9WRUVORCwgdGhpcywgZnJhbWVTdGF0ZSkpO1xuICAgICAgICBjbG9uZShmcmFtZVN0YXRlLmV4dGVudCwgdGhpcy5wcmV2aW91c0V4dGVudF8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgTWFwRXZlbnQoTWFwRXZlbnRUeXBlLlBPU1RSRU5ERVIsIHRoaXMsIGZyYW1lU3RhdGUpKTtcblxuICAgIHNldFRpbWVvdXQodGhpcy5oYW5kbGVQb3N0UmVuZGVyLmJpbmQodGhpcyksIDApO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbGF5ZXJncm91cCBvZiB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHtMYXllckdyb3VwfSBsYXllckdyb3VwIEEgbGF5ZXIgZ3JvdXAgY29udGFpbmluZyB0aGUgbGF5ZXJzIGluIHRoaXMgbWFwLlxuICAgKiBAb2JzZXJ2YWJsZVxuICAgKiBAYXBpXG4gICAqL1xuICBzZXRMYXllckdyb3VwKGxheWVyR3JvdXApIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5MQVlFUkdST1VQLCBsYXllckdyb3VwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNpemUgb2YgdGhpcyBtYXAuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9zaXplLmpzXCIpLlNpemV8dW5kZWZpbmVkfSBzaXplIFRoZSBzaXplIGluIHBpeGVscyBvZiB0aGUgbWFwIGluIHRoZSBET00uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFNpemUoc2l6ZSkge1xuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlNJWkUsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgdG8gcmVuZGVyIHRoaXMgbWFwIGludG8uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8c3RyaW5nfHVuZGVmaW5lZH0gdGFyZ2V0IFRoZSBFbGVtZW50IG9yIGlkIG9mIHRoZSBFbGVtZW50XG4gICAqICAgICB0aGF0IHRoZSBtYXAgaXMgcmVuZGVyZWQgaW4uXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFRhcmdldCh0YXJnZXQpIHtcbiAgICB0aGlzLnNldChNYXBQcm9wZXJ0eS5UQVJHRVQsIHRhcmdldCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2aWV3IGZvciB0aGlzIG1hcC5cbiAgICogQHBhcmFtIHtWaWV3fSB2aWV3IFRoZSB2aWV3IHRoYXQgY29udHJvbHMgdGhpcyBtYXAuXG4gICAqIEBvYnNlcnZhYmxlXG4gICAqIEBhcGlcbiAgICovXG4gIHNldFZpZXcodmlldykge1xuICAgIHRoaXMuc2V0KE1hcFByb3BlcnR5LlZJRVcsIHZpZXcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIHNraXBGZWF0dXJlKGZlYXR1cmUpIHtcbiAgICB0aGlzLnNraXBwZWRGZWF0dXJlVWlkc19bZ2V0VWlkKGZlYXR1cmUpXSA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZSBhIHJlY2FsY3VsYXRpb24gb2YgdGhlIG1hcCB2aWV3cG9ydCBzaXplLiAgVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW5cbiAgICogdGhpcmQtcGFydHkgY29kZSBjaGFuZ2VzIHRoZSBzaXplIG9mIHRoZSBtYXAgdmlld3BvcnQuXG4gICAqIEBhcGlcbiAgICovXG4gIHVwZGF0ZVNpemUoKSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuXG4gICAgaWYgKCF0YXJnZXRFbGVtZW50KSB7XG4gICAgICB0aGlzLnNldFNpemUodW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0RWxlbWVudCk7XG4gICAgICB0aGlzLnNldFNpemUoW1xuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldFdpZHRoIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsnYm9yZGVyTGVmdFdpZHRoJ10pIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ0xlZnQnXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydwYWRkaW5nUmlnaHQnXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJSaWdodFdpZHRoJ10pLFxuICAgICAgICB0YXJnZXRFbGVtZW50Lm9mZnNldEhlaWdodCAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ2JvcmRlclRvcFdpZHRoJ10pIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZVsncGFkZGluZ1RvcCddKSAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGVbJ3BhZGRpbmdCb3R0b20nXSkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlWydib3JkZXJCb3R0b21XaWR0aCddKVxuICAgICAgXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9GZWF0dXJlLmpzXCIpLmRlZmF1bHR9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICovXG4gIHVuc2tpcEZlYXR1cmUoZmVhdHVyZSkge1xuICAgIGRlbGV0ZSB0aGlzLnNraXBwZWRGZWF0dXJlVWlkc19bZ2V0VWlkKGZlYXR1cmUpXTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge01hcE9wdGlvbnN9IG9wdGlvbnMgTWFwIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtNYXBPcHRpb25zSW50ZXJuYWx9IEludGVybmFsIG1hcCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zSW50ZXJuYWwob3B0aW9ucykge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR8RG9jdW1lbnR9XG4gICAqL1xuICBsZXQga2V5Ym9hcmRFdmVudFRhcmdldCA9IG51bGw7XG4gIGlmIChvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGtleWJvYXJkRXZlbnRUYXJnZXQgPSB0eXBlb2Ygb3B0aW9ucy5rZXlib2FyZEV2ZW50VGFyZ2V0ID09PSAnc3RyaW5nJyA/XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmtleWJvYXJkRXZlbnRUYXJnZXQpIDpcbiAgICAgIG9wdGlvbnMua2V5Ym9hcmRFdmVudFRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKj59XG4gICAqL1xuICBjb25zdCB2YWx1ZXMgPSB7fTtcblxuICBjb25zdCBsYXllckdyb3VwID0gb3B0aW9ucy5sYXllcnMgJiYgdHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMubGF5ZXJzKS5nZXRMYXllcnMgPT09ICdmdW5jdGlvbicgP1xuICAgIC8qKiBAdHlwZSB7TGF5ZXJHcm91cH0gKi8gKG9wdGlvbnMubGF5ZXJzKSA6IG5ldyBMYXllckdyb3VwKHtsYXllcnM6IC8qKiBAdHlwZSB7Q29sbGVjdGlvbn0gKi8gKG9wdGlvbnMubGF5ZXJzKX0pO1xuICB2YWx1ZXNbTWFwUHJvcGVydHkuTEFZRVJHUk9VUF0gPSBsYXllckdyb3VwO1xuXG4gIHZhbHVlc1tNYXBQcm9wZXJ0eS5UQVJHRVRdID0gb3B0aW9ucy50YXJnZXQ7XG5cbiAgdmFsdWVzW01hcFByb3BlcnR5LlZJRVddID0gb3B0aW9ucy52aWV3ICE9PSB1bmRlZmluZWQgP1xuICAgIG9wdGlvbnMudmlldyA6IG5ldyBWaWV3KCk7XG5cbiAgbGV0IGNvbnRyb2xzO1xuICBpZiAob3B0aW9ucy5jb250cm9scyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5jb250cm9scykpIHtcbiAgICAgIGNvbnRyb2xzID0gbmV3IENvbGxlY3Rpb24ob3B0aW9ucy5jb250cm9scy5zbGljZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiAvKiogQHR5cGUgez99ICovIChvcHRpb25zLmNvbnRyb2xzKS5nZXRBcnJheSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgNDcpOyAvLyBFeHBlY3RlZCBgY29udHJvbHNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbmBcbiAgICAgIGNvbnRyb2xzID0gLyoqIEB0eXBlIHtDb2xsZWN0aW9ufSAqLyAob3B0aW9ucy5jb250cm9scyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGludGVyYWN0aW9ucztcbiAgaWYgKG9wdGlvbnMuaW50ZXJhY3Rpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyYWN0aW9ucykpIHtcbiAgICAgIGludGVyYWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9uKG9wdGlvbnMuaW50ZXJhY3Rpb25zLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKG9wdGlvbnMuaW50ZXJhY3Rpb25zKS5nZXRBcnJheSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgNDgpOyAvLyBFeHBlY3RlZCBgaW50ZXJhY3Rpb25zYCB0byBiZSBhbiBhcnJheSBvciBhbiBgaW1wb3J0KFwiLi9Db2xsZWN0aW9uLmpzXCIpLkNvbGxlY3Rpb25gXG4gICAgICBpbnRlcmFjdGlvbnMgPSAvKiogQHR5cGUge0NvbGxlY3Rpb259ICovIChvcHRpb25zLmludGVyYWN0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgbGV0IG92ZXJsYXlzO1xuICBpZiAob3B0aW9ucy5vdmVybGF5cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5vdmVybGF5cykpIHtcbiAgICAgIG92ZXJsYXlzID0gbmV3IENvbGxlY3Rpb24ob3B0aW9ucy5vdmVybGF5cy5zbGljZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHR5cGVvZiAvKiogQHR5cGUgez99ICovIChvcHRpb25zLm92ZXJsYXlzKS5nZXRBcnJheSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgNDkpOyAvLyBFeHBlY3RlZCBgb3ZlcmxheXNgIHRvIGJlIGFuIGFycmF5IG9yIGFuIGBpbXBvcnQoXCIuL0NvbGxlY3Rpb24uanNcIikuQ29sbGVjdGlvbmBcbiAgICAgIG92ZXJsYXlzID0gb3B0aW9ucy5vdmVybGF5cztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3ZlcmxheXMgPSBuZXcgQ29sbGVjdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250cm9sczogY29udHJvbHMsXG4gICAgaW50ZXJhY3Rpb25zOiBpbnRlcmFjdGlvbnMsXG4gICAga2V5Ym9hcmRFdmVudFRhcmdldDoga2V5Ym9hcmRFdmVudFRhcmdldCxcbiAgICBvdmVybGF5czogb3ZlcmxheXMsXG4gICAgdmFsdWVzOiB2YWx1ZXNcbiAgfTtcblxufVxuZXhwb3J0IGRlZmF1bHQgUGx1Z2dhYmxlTWFwO1xuXG4vKipcbiAqIEBwYXJhbSAge0FycmF5PGltcG9ydChcIi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0Pn0gbGF5ZXJzIExheWVycy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IExheWVycyBoYXZlIHNvdXJjZXMgdGhhdCBhcmUgc3RpbGwgbG9hZGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9hZGluZyhsYXllcnMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBsYXllciA9IGxheWVyc1tpXTtcbiAgICBpZiAodHlwZW9mIC8qKiBAdHlwZSB7P30gKi8gKGxheWVyKS5nZXRMYXllcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBnZXRMb2FkaW5nKC8qKiBAdHlwZSB7TGF5ZXJHcm91cH0gKi8gKGxheWVyKS5nZXRMYXllcnMoKS5nZXRBcnJheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9ICovIChcbiAgICAgICAgbGF5ZXIpLmdldFNvdXJjZSgpO1xuICAgICAgaWYgKHNvdXJjZSAmJiBzb3VyY2UubG9hZGluZykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0FBR0E7Ozs7Ozs7QUFPQTtBQUFBO0FBQUE7QUFPQTtBQUVBOzs7Ozs7O0FBT0E7Ozs7Ozs7QUFPQTs7Ozs7QUFFQTs7QUF6QkE7QUFDQTtBQTRCQTs7QUN2Q0E7OztBQUdBOzs7Ozs7O0FBT0E7QUFBQTtBQUFBO0FBU0E7QUFFQTs7Ozs7Ozs7QUFRQTs7Ozs7OztBQU9BOzs7Ozs7O0FBT0E7Ozs7Ozs7OztBQVNBOzs7OztBQUVBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW5FQTtBQUNBO0FBcUVBOzs7Ozs7OztBQ2hGQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQVNBO0FBRUE7Ozs7OztBQU1BOzs7OztBQUVBOztBQW5CQTtBQUNBO0FBc0JBOzs7Ozs7OztBQzVCQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTs7QUNSQTs7O0FBSUE7QUFRQTs7O0FBR0E7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUVBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FDNUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOzs7OztBQU1BOzs7OztBQU1BOzs7Ozs7O0FBUUE7Ozs7Ozs7O0FBUUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQXBGQTs7Ozs7Ozs7Ozs7QUErRkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7O0FDdFBBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBOzs7Ozs7QUFPQTs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTs7Ozs7O0FBTUE7Ozs7O0FBQ0E7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFuREE7QUFDQTtBQXFEQTs7QUNqTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTs7Ozs7QUFDQTs7QUFqQkE7QUFDQTtBQW9CQTs7QUN6SUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFhQTtBQUNBOzs7Ozs7O0FBTUE7QUFFQTs7Ozs7QUFLQTs7Ozs7QUFLQTtBQUNBOzs7OztBQU1BOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBO0FBQ0E7Ozs7OztBQVFBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBOztBQTVKQTs7Ozs7OztBQXFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFNQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7QUFRQTs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcFJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBO0FBQ0E7QUFDQTs7Ozs7QUFNQTs7Ozs7QUFLQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7O0FBUUE7Ozs7O0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTs7OztBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFuVUE7QUFDQTtBQW9VQTs7QUN2YUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFPQTtBQUVBO0FBZUE7QUFFQTtBQVVBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFLQTtBQUNBOzs7Ozs7O0FBT0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFFQTs7Ozs7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFVQTtBQUNBO0FBMlVBOztBQ2phQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQU1BO0FBRUE7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7O0FBU0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7O0FBU0E7Ozs7OztBQU1BOzs7Ozs7QUFRQTs7Ozs7QUFJQTs7Ozs7OztBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBR0E7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBSUE7QUFDQTs7Ozs7Ozs7QUFPQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUdBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBdFRBO0FBQ0E7QUF3VEE7Ozs7O0FDcFVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1BBOzs7QUFHQTtBQUNBOzs7OztBQU1BOzs7Ozs7Ozs7Ozs7OztBQWVBO0FBUUE7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7QUFFQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUdBOzs7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQ3pSQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBUUE7QUFBQTtBQUFBO0FBTUE7QUFFQTs7Ozs7QUFBQTtBQU1BO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7OztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUE5R0E7QUFDQTtBQWdIQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSEE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQTtBQURBOzs7Ozs7Ozs7O0FBYUE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUdBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQXZMQTtBQUNBO0FBeUxBOzs7Ozs7OztBQzlPQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0hBO0FBQUE7QUFBQTtBQUtBO0FBRUE7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFRQTs7Ozs7O0FBUUE7Ozs7OztBQU9BOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7OztBQU9BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFTQTtBQUVBO0FBR0E7QUFFQTtBQUVBOzs7QUFLQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFJQTs7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFHQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUdBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUdBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUVBOzs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBOzs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVlBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbnJDQTs7Ozs7OztBQTByQ0E7Ozs7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUdBOzs7Ozs7QUFLQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUFBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///148\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external \"jQuery\"\nvar external_jQuery_ = __webpack_require__(8);\nvar external_jQuery_default = /*#__PURE__*/__webpack_require__.n(external_jQuery_);\n\n// CONCATENATED MODULE: ./src/js/Conf.js\nvar COOKIE = 'geocoding-sheet';\nvar config = {\n  nyc: true,\n  url: '',\n  id: '',\n  key: '',\n  template: '',\n  requestedFields: []\n};\nvar Conf_conf = {\n  set: function set(key, val) {\n    config[key] = val;\n    Conf_conf.saveToCookie(document);\n  },\n  get: function get(key) {\n    if (key) return config[key];\n    return config;\n  },\n  valid: function valid() {\n    var result = false;\n\n    if (config.nyc) {\n      result = config.url.trim() !== '' && config.id.trim() !== '' && config.key.trim() !== '' && config.template.trim() !== '';\n    } else {\n      result = config.template.trim() !== '';\n    }\n\n    return result;\n  },\n  getSaved: function getSaved(doc) {\n    var it = \"\".concat(COOKIE, \"=\");\n    var cookies = doc.cookie.split(';');\n    cookies.forEach(function (cookie) {\n      cookie = cookie.trim();\n\n      if (cookie.indexOf(it) === 0) {\n        var savedConf = JSON.parse(cookie.substr(it.length, cookie.length));\n        Object.keys(savedConf).forEach(function (key) {\n          config[key] = savedConf[key];\n        });\n      }\n    });\n    return config;\n  },\n  saveToCookie: function saveToCookie(doc) {\n    if (Conf_conf.valid()) {\n      var today = new Date();\n      var expire = new Date();\n      expire.setDate(today.getDate() + 365);\n      doc.cookie = \"\".concat(COOKIE, \"=\").concat(JSON.stringify(config), \"; expires=\").concat(expire.toGMTString());\n    }\n  }\n};\n/* harmony default export */ var Conf = (Conf_conf);\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/EventHandling.js\nvar EventHandling = __webpack_require__(64);\nvar EventHandling_default = /*#__PURE__*/__webpack_require__.n(EventHandling);\n\n// EXTERNAL MODULE: external \"(window.proj4 || {defs: function(){}})\"\nvar external_window_proj4_defs_function_ = __webpack_require__(85);\nvar external_window_proj4_defs_function_default = /*#__PURE__*/__webpack_require__.n(external_window_proj4_defs_function_);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/ol/format/CsvAddr.js\nvar CsvAddr = __webpack_require__(115);\nvar CsvAddr_default = /*#__PURE__*/__webpack_require__.n(CsvAddr);\n\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/Geoclient.js\nvar Geoclient = __webpack_require__(78);\nvar Geoclient_default = /*#__PURE__*/__webpack_require__.n(Geoclient);\n\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/CensusGeocoder.js\nvar CensusGeocoder = __webpack_require__(89);\nvar CensusGeocoder_default = /*#__PURE__*/__webpack_require__.n(CensusGeocoder);\n\n// CONCATENATED MODULE: ./src/js/Format.js\n\n\n\nvar format = new CsvAddr_default.a({});\n/* harmony default export */ var Format = ({\n  getFormat: function getFormat(conf) {\n    format.locationTemplate = conf.template;\n\n    if (conf.nyc) {\n      var url = \"\".concat(conf.url, \"/search.json?app_id=\").concat(conf.id, \"&app_key=\").concat(conf.key);\n      format.geocoder = new Geoclient_default.a({\n        url: url\n      });\n    } else {\n      format.geocoder = new CensusGeocoder_default.a();\n    }\n\n    return format;\n  }\n});\n// EXTERNAL MODULE: ./node_modules/ol/Feature.js\nvar Feature = __webpack_require__(59);\n\n// CONCATENATED MODULE: ./src/js/SheetGeocoder.js\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\nvar SheetGeocoder_SheetGeocoder =\n/*#__PURE__*/\nfunction (_EventHandling) {\n  _inherits(SheetGeocoder, _EventHandling);\n\n  function SheetGeocoder(options) {\n    var _this;\n\n    _classCallCheck(this, SheetGeocoder);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SheetGeocoder).call(this));\n    _this.source = options.source;\n    _this.projection = options.projection;\n\n    _this.clear();\n\n    return _this;\n  }\n\n  _createClass(SheetGeocoder, [{\n    key: \"conf\",\n    value: function conf(_conf) {\n      this.format = Format.getFormat(_conf);\n      this.requestedFields = _conf.requestedFields;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.source) this.source.clear();\n      this.geocodeAll = false;\n      this.countDown = 0;\n      this.geocodedBounds = null;\n    }\n  }, {\n    key: \"doGeocode\",\n    value: function doGeocode(featureSource, feature) {\n      if (feature) {\n        var oldInput = feature.get('_input');\n        var newInput = this.format.replace(this.format.locationTemplate, featureSource);\n        return oldInput.trim() !== newInput.trim();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(all) {\n      this.geocodeAll = all === true;\n      google.script.run.withSuccessHandler($.proxy(this.gotData, this)).getData();\n    }\n  }, {\n    key: \"gotData\",\n    value: function gotData(data) {\n      var _this2 = this;\n\n      var columns = data[0];\n      var source = this.source;\n\n      if (this.geocodeAll) {\n        this.countDown = data.length - 1;\n        this.source.clear();\n        this.geocodedBounds = null;\n        this.trigger('batch-start', data);\n      }\n\n      data.forEach(function (row, i) {\n        if (i > 0) {\n          var featureSource = {\n            _row_num: i + 1,\n            _columns: columns,\n            _cells: row\n          };\n          var feature = source.getFeatureById(i + 1);\n          columns.forEach(function (col, c) {\n            featureSource[col] = row[c];\n          });\n\n          if (_this2.doGeocode(featureSource, feature)) {\n            if (feature) {\n              source.removeFeature(feature);\n            }\n\n            feature = new Feature[\"default\"](featureSource);\n            feature.setId(i + 1);\n            feature.set('_interactive', !_this2.geocodeAll);\n            source.addFeature(feature);\n            feature.once('change', $.proxy(_this2.geocoded, _this2));\n\n            _this2.format.setGeometry(feature, featureSource);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"geocoded\",\n    value: function geocoded(event) {\n      var feature = event.target;\n      var geom = feature.getGeometry();\n      var id = feature.getId();\n      var data = {\n        projected: this.projection,\n        row: feature.get('_row_num'),\n        columns: feature.get('_columns'),\n        cells: feature.get('_cells'),\n        geocodeResp: feature.get('_geocodeResp'),\n        name: feature.get('_geocodeResp').name,\n        requestedFields: this.requestedFields,\n        interactive: feature.get('_interactive')\n      };\n      if (this.geocodeAll) this.countDown--;\n\n      if (geom) {\n        var ext = geom.getExtent();\n        var coords = geom.getCoordinates();\n        var ll = external_window_proj4_defs_function_default()('EPSG:3857', 'EPSG:4326', coords);\n        data.lng = ll[0];\n        data.lat = ll[1];\n        this.projected(data, coords);\n        this.geocodedBounds = this.geocodedBounds ? Object(extent[\"extend\"])(this.geocodedBounds, ext) : ext;\n        this.trigger('geocoded', {\n          feature: feature,\n          data: data\n        });\n      } else {\n        this.trigger('ambiguous', {\n          feature: feature,\n          data: data\n        });\n      }\n\n      if (this.geocodeAll && this.countDown === 0) {\n        this.geocodeAll = false;\n        this.trigger('batch-end');\n      }\n\n      google.script.run.withSuccessHandler($.proxy(this.updateFeature, this)).geocoded(data);\n    }\n  }, {\n    key: \"projected\",\n    value: function projected(data, coords) {\n      if (this.projection) {\n        var xy = external_window_proj4_defs_function_default()('EPSG:3857', this.projection, coords);\n        data.x = xy[0];\n        data.y = xy[1];\n      }\n    }\n  }, {\n    key: \"updateFeature\",\n    value: function updateFeature(data) {\n      var feature = this.source.getFeatureById(data.row);\n\n      if (feature) {\n        var columns = data.columns;\n\n        for (var i = 0; i < columns.length; i++) {\n          feature.set(columns[i], data.cells[i]);\n        }\n      }\n    }\n  }]);\n\n  return SheetGeocoder;\n}(EventHandling_default.a);\n\n/* harmony default export */ var js_SheetGeocoder = (SheetGeocoder_SheetGeocoder);\n// EXTERNAL MODULE: ./node_modules/ol/source/Vector.js + 4 modules\nvar Vector = __webpack_require__(83);\n\n// EXTERNAL MODULE: ./node_modules/ol/layer/Vector.js + 1 modules\nvar layer_Vector = __webpack_require__(84);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/Style.js\nvar Style = __webpack_require__(72);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/Circle.js + 1 modules\nvar Circle = __webpack_require__(82);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/Stroke.js\nvar Stroke = __webpack_require__(68);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/Fill.js\nvar Fill = __webpack_require__(58);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/TextPlacement.js\nvar TextPlacement = __webpack_require__(92);\n\n// CONCATENATED MODULE: ./node_modules/ol/style/Text.js\n/**\n * @module ol/style/Text\n */\n\n\n/**\n * The default fill color to use if no fill was set at construction time; a\n * blackish `#333`.\n *\n * @const {string}\n */\n\nvar DEFAULT_FILL_COLOR = '#333';\n/**\n * @typedef {Object} Options\n * @property {string} [font] Font style as CSS 'font' value, see:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is '10px sans-serif'\n * @property {number} [maxAngle] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.\n * The expected value is in radians, and the default is 45 (`Math.PI / 4`).\n * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.\n * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.\n * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed\n * the width of the polygon at the label position or the length of the path that it follows.\n * @property {import(\"./TextPlacement.js\").default|string} [placement] Text placement.\n * @property {number} [scale] Scale.\n * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {string} [text] Text content.\n * @property {string} [textAlign] Text alignment. Possible values: 'left', 'right', 'center', 'end' or 'start'.\n * Default is 'center' for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a\n * placement where `maxAngle` is not exceeded.\n * @property {string} [textBaseline='middle'] Text base line. Possible values: 'bottom', 'top', 'middle', 'alphabetic',\n * 'hanging', 'ideographic'.\n * @property {import(\"./Fill.js\").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {import(\"./Fill.js\").default} [backgroundFill] Fill style for the text background when `placement` is\n * `'point'`. Default is no fill.\n * @property {import(\"./Stroke.js\").default} [backgroundStroke] Stroke style for the text background  when `placement`\n * is `'point'`. Default is no stroke.\n * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of\n * values in the array is `[top, right, bottom, left]`.\n */\n\n/**\n * @classdesc\n * Set text style for vector features.\n * @api\n */\n\nvar Text_Text = function Text(opt_options) {\n  var options = opt_options || {};\n  /**\n  * @private\n  * @type {string|undefined}\n  */\n\n  this.font_ = options.font;\n  /**\n  * @private\n  * @type {number|undefined}\n  */\n\n  this.rotation_ = options.rotation;\n  /**\n  * @private\n  * @type {boolean|undefined}\n  */\n\n  this.rotateWithView_ = options.rotateWithView;\n  /**\n  * @private\n  * @type {number|undefined}\n  */\n\n  this.scale_ = options.scale;\n  /**\n  * @private\n  * @type {string|undefined}\n  */\n\n  this.text_ = options.text;\n  /**\n  * @private\n  * @type {string|undefined}\n  */\n\n  this.textAlign_ = options.textAlign;\n  /**\n  * @private\n  * @type {string|undefined}\n  */\n\n  this.textBaseline_ = options.textBaseline;\n  /**\n  * @private\n  * @type {import(\"./Fill.js\").default}\n  */\n\n  this.fill_ = options.fill !== undefined ? options.fill : new Fill[\"a\" /* default */]({\n    color: DEFAULT_FILL_COLOR\n  });\n  /**\n  * @private\n  * @type {number}\n  */\n\n  this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;\n  /**\n  * @private\n  * @type {import(\"./TextPlacement.js\").default|string}\n  */\n\n  this.placement_ = options.placement !== undefined ? options.placement : TextPlacement[\"a\" /* default */].POINT;\n  /**\n  * @private\n  * @type {boolean}\n  */\n\n  this.overflow_ = !!options.overflow;\n  /**\n  * @private\n  * @type {import(\"./Stroke.js\").default}\n  */\n\n  this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n  /**\n  * @private\n  * @type {number}\n  */\n\n  this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;\n  /**\n  * @private\n  * @type {number}\n  */\n\n  this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;\n  /**\n  * @private\n  * @type {import(\"./Fill.js\").default}\n  */\n\n  this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;\n  /**\n  * @private\n  * @type {import(\"./Stroke.js\").default}\n  */\n\n  this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;\n  /**\n  * @private\n  * @type {Array<number>}\n  */\n\n  this.padding_ = options.padding === undefined ? null : options.padding;\n};\n/**\n* Clones the style.\n* @return {Text} The cloned style.\n* @api\n*/\n\n\nText_Text.prototype.clone = function clone() {\n  return new Text_Text({\n    font: this.getFont(),\n    placement: this.getPlacement(),\n    maxAngle: this.getMaxAngle(),\n    overflow: this.getOverflow(),\n    rotation: this.getRotation(),\n    rotateWithView: this.getRotateWithView(),\n    scale: this.getScale(),\n    text: this.getText(),\n    textAlign: this.getTextAlign(),\n    textBaseline: this.getTextBaseline(),\n    fill: this.getFill() ? this.getFill().clone() : undefined,\n    stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n    offsetX: this.getOffsetX(),\n    offsetY: this.getOffsetY(),\n    backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,\n    backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined\n  });\n};\n/**\n* Get the `overflow` configuration.\n* @return {boolean} Let text overflow the length of the path they follow.\n* @api\n*/\n\n\nText_Text.prototype.getOverflow = function getOverflow() {\n  return this.overflow_;\n};\n/**\n* Get the font name.\n* @return {string|undefined} Font.\n* @api\n*/\n\n\nText_Text.prototype.getFont = function getFont() {\n  return this.font_;\n};\n/**\n* Get the maximum angle between adjacent characters.\n* @return {number} Angle in radians.\n* @api\n*/\n\n\nText_Text.prototype.getMaxAngle = function getMaxAngle() {\n  return this.maxAngle_;\n};\n/**\n* Get the label placement.\n* @return {import(\"./TextPlacement.js\").default|string} Text placement.\n* @api\n*/\n\n\nText_Text.prototype.getPlacement = function getPlacement() {\n  return this.placement_;\n};\n/**\n* Get the x-offset for the text.\n* @return {number} Horizontal text offset.\n* @api\n*/\n\n\nText_Text.prototype.getOffsetX = function getOffsetX() {\n  return this.offsetX_;\n};\n/**\n* Get the y-offset for the text.\n* @return {number} Vertical text offset.\n* @api\n*/\n\n\nText_Text.prototype.getOffsetY = function getOffsetY() {\n  return this.offsetY_;\n};\n/**\n* Get the fill style for the text.\n* @return {import(\"./Fill.js\").default} Fill style.\n* @api\n*/\n\n\nText_Text.prototype.getFill = function getFill() {\n  return this.fill_;\n};\n/**\n* Determine whether the text rotates with the map.\n* @return {boolean|undefined} Rotate with map.\n* @api\n*/\n\n\nText_Text.prototype.getRotateWithView = function getRotateWithView() {\n  return this.rotateWithView_;\n};\n/**\n* Get the text rotation.\n* @return {number|undefined} Rotation.\n* @api\n*/\n\n\nText_Text.prototype.getRotation = function getRotation() {\n  return this.rotation_;\n};\n/**\n* Get the text scale.\n* @return {number|undefined} Scale.\n* @api\n*/\n\n\nText_Text.prototype.getScale = function getScale() {\n  return this.scale_;\n};\n/**\n* Get the stroke style for the text.\n* @return {import(\"./Stroke.js\").default} Stroke style.\n* @api\n*/\n\n\nText_Text.prototype.getStroke = function getStroke() {\n  return this.stroke_;\n};\n/**\n* Get the text to be rendered.\n* @return {string|undefined} Text.\n* @api\n*/\n\n\nText_Text.prototype.getText = function getText() {\n  return this.text_;\n};\n/**\n* Get the text alignment.\n* @return {string|undefined} Text align.\n* @api\n*/\n\n\nText_Text.prototype.getTextAlign = function getTextAlign() {\n  return this.textAlign_;\n};\n/**\n* Get the text baseline.\n* @return {string|undefined} Text baseline.\n* @api\n*/\n\n\nText_Text.prototype.getTextBaseline = function getTextBaseline() {\n  return this.textBaseline_;\n};\n/**\n* Get the background fill style for the text.\n* @return {import(\"./Fill.js\").default} Fill style.\n* @api\n*/\n\n\nText_Text.prototype.getBackgroundFill = function getBackgroundFill() {\n  return this.backgroundFill_;\n};\n/**\n* Get the background stroke style for the text.\n* @return {import(\"./Stroke.js\").default} Stroke style.\n* @api\n*/\n\n\nText_Text.prototype.getBackgroundStroke = function getBackgroundStroke() {\n  return this.backgroundStroke_;\n};\n/**\n* Get the padding for the text.\n* @return {Array<number>} Padding.\n* @api\n*/\n\n\nText_Text.prototype.getPadding = function getPadding() {\n  return this.padding_;\n};\n/**\n* Set the `overflow` property.\n*\n* @param {boolean} overflow Let text overflow the path that it follows.\n* @api\n*/\n\n\nText_Text.prototype.setOverflow = function setOverflow(overflow) {\n  this.overflow_ = overflow;\n};\n/**\n* Set the font.\n*\n* @param {string|undefined} font Font.\n* @api\n*/\n\n\nText_Text.prototype.setFont = function setFont(font) {\n  this.font_ = font;\n};\n/**\n* Set the maximum angle between adjacent characters.\n*\n* @param {number} maxAngle Angle in radians.\n* @api\n*/\n\n\nText_Text.prototype.setMaxAngle = function setMaxAngle(maxAngle) {\n  this.maxAngle_ = maxAngle;\n};\n/**\n* Set the x offset.\n*\n* @param {number} offsetX Horizontal text offset.\n* @api\n*/\n\n\nText_Text.prototype.setOffsetX = function setOffsetX(offsetX) {\n  this.offsetX_ = offsetX;\n};\n/**\n* Set the y offset.\n*\n* @param {number} offsetY Vertical text offset.\n* @api\n*/\n\n\nText_Text.prototype.setOffsetY = function setOffsetY(offsetY) {\n  this.offsetY_ = offsetY;\n};\n/**\n* Set the text placement.\n*\n* @param {import(\"./TextPlacement.js\").default|string} placement Placement.\n* @api\n*/\n\n\nText_Text.prototype.setPlacement = function setPlacement(placement) {\n  this.placement_ = placement;\n};\n/**\n* Set the fill.\n*\n* @param {import(\"./Fill.js\").default} fill Fill style.\n* @api\n*/\n\n\nText_Text.prototype.setFill = function setFill(fill) {\n  this.fill_ = fill;\n};\n/**\n* Set the rotation.\n*\n* @param {number|undefined} rotation Rotation.\n* @api\n*/\n\n\nText_Text.prototype.setRotation = function setRotation(rotation) {\n  this.rotation_ = rotation;\n};\n/**\n* Set the scale.\n*\n* @param {number|undefined} scale Scale.\n* @api\n*/\n\n\nText_Text.prototype.setScale = function setScale(scale) {\n  this.scale_ = scale;\n};\n/**\n* Set the stroke.\n*\n* @param {import(\"./Stroke.js\").default} stroke Stroke style.\n* @api\n*/\n\n\nText_Text.prototype.setStroke = function setStroke(stroke) {\n  this.stroke_ = stroke;\n};\n/**\n* Set the text.\n*\n* @param {string|undefined} text Text.\n* @api\n*/\n\n\nText_Text.prototype.setText = function setText(text) {\n  this.text_ = text;\n};\n/**\n* Set the text alignment.\n*\n* @param {string|undefined} textAlign Text align.\n* @api\n*/\n\n\nText_Text.prototype.setTextAlign = function setTextAlign(textAlign) {\n  this.textAlign_ = textAlign;\n};\n/**\n* Set the text baseline.\n*\n* @param {string|undefined} textBaseline Text baseline.\n* @api\n*/\n\n\nText_Text.prototype.setTextBaseline = function setTextBaseline(textBaseline) {\n  this.textBaseline_ = textBaseline;\n};\n/**\n* Set the background fill.\n*\n* @param {import(\"./Fill.js\").default} fill Fill style.\n* @api\n*/\n\n\nText_Text.prototype.setBackgroundFill = function setBackgroundFill(fill) {\n  this.backgroundFill_ = fill;\n};\n/**\n* Set the background stroke.\n*\n* @param {import(\"./Stroke.js\").default} stroke Stroke style.\n* @api\n*/\n\n\nText_Text.prototype.setBackgroundStroke = function setBackgroundStroke(stroke) {\n  this.backgroundStroke_ = stroke;\n};\n/**\n* Set the padding (`[top, right, bottom, left]`).\n*\n* @param {!Array<number>} padding Padding.\n* @api\n*/\n\n\nText_Text.prototype.setPadding = function setPadding(padding) {\n  this.padding_ = padding;\n};\n\n/* harmony default export */ var style_Text = (Text_Text);\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/ol/index.js\nvar ol = __webpack_require__(104);\nvar ol_default = /*#__PURE__*/__webpack_require__.n(ol);\n\n// CONCATENATED MODULE: ./src/js/layer.js\n\n\n\n\n\n\n\n\n\nvar layer_style = function style(feature, resolution) {\n  var zoom = ol_default.a.TILE_GRID.getZForResolution(resolution);\n  var text = \"\".concat(feature.getId());\n  var fontSize = text.length > 2 ? zoom * .8 : zoom * 1.2;\n  var fontWeight = text.length <= 2 ? 'bold' : '';\n  return new Style[\"default\"]({\n    image: new Circle[\"a\" /* default */]({\n      radius: 10,\n      stroke: new Stroke[\"a\" /* default */]({\n        color: '#000',\n        width: 2\n      }),\n      fill: new Fill[\"a\" /* default */]({\n        color: 'rgba(255,255,255,.5)'\n      })\n    }),\n    text: new style_Text({\n      text: text,\n      font: \"\".concat(fontWeight, \" \").concat(fontSize.toFixed(0), \"px sans-serif\").trim(),\n      fill: new Fill[\"a\" /* default */]({\n        color: '#000'\n      })\n    })\n  });\n};\n\nvar layer_layer = new layer_Vector[\"default\"]({\n  source: new Vector[\"default\"](),\n  style: layer_style\n});\n/* harmony default export */ var js_layer = (layer_layer);\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/ol/Basemap.js\nvar Basemap = __webpack_require__(116);\nvar Basemap_default = /*#__PURE__*/__webpack_require__.n(Basemap);\n\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/ol/LocationMgr.js\nvar LocationMgr = __webpack_require__(110);\nvar LocationMgr_default = /*#__PURE__*/__webpack_require__.n(LocationMgr);\n\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/ol/Popup.js\nvar Popup = __webpack_require__(117);\nvar Popup_default = /*#__PURE__*/__webpack_require__.n(Popup);\n\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/Tabs.js\nvar Tabs = __webpack_require__(118);\nvar Tabs_default = /*#__PURE__*/__webpack_require__.n(Tabs);\n\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/Choice.js\nvar Choice = __webpack_require__(102);\nvar Choice_default = /*#__PURE__*/__webpack_require__.n(Choice);\n\n// EXTERNAL MODULE: ./node_modules/ol/source/XYZ.js + 12 modules\nvar XYZ = __webpack_require__(106);\n\n// CONCATENATED MODULE: ./node_modules/ol/source/OSM.js\n/**\n * @module ol/source/OSM\n */\n\n/**\n * The attribution containing a link to the OpenStreetMap Copyright and License\n * page.\n * @const\n * @type {string}\n * @api\n */\n\nvar ATTRIBUTION = '&#169; ' + '<a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> ' + 'contributors.';\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [cacheSize=2048] Cache size.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to\n * access pixel data with the Canvas renderer.  See\n * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {number} [maxZoom=19] Max zoom.\n * @property {boolean} [opaque=true] Whether the layer is opaque.\n * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.\n * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source for the OpenStreetMap tile server.\n * @api\n */\n\nvar OSM =\n/*@__PURE__*/\nfunction (XYZ) {\n  function OSM(opt_options) {\n    var options = opt_options || {};\n    var attributions;\n\n    if (options.attributions !== undefined) {\n      attributions = options.attributions;\n    } else {\n      attributions = [ATTRIBUTION];\n    }\n\n    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n    var url = options.url !== undefined ? options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n    XYZ.call(this, {\n      attributions: attributions,\n      cacheSize: options.cacheSize,\n      crossOrigin: crossOrigin,\n      opaque: options.opaque !== undefined ? options.opaque : true,\n      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileLoadFunction: options.tileLoadFunction,\n      url: url,\n      wrapX: options.wrapX,\n      attributionsCollapsible: false\n    });\n  }\n\n  if (XYZ) OSM.__proto__ = XYZ;\n  OSM.prototype = Object.create(XYZ && XYZ.prototype);\n  OSM.prototype.constructor = OSM;\n  return OSM;\n}(XYZ[\"default\"]);\n\n/* harmony default export */ var source_OSM = (OSM);\n// EXTERNAL MODULE: ./node_modules/ol/format/GeoJSON.js + 8 modules\nvar GeoJSON = __webpack_require__(77);\n\n// EXTERNAL MODULE: ./node_modules/ol/layer/Tile.js + 1 modules\nvar Tile = __webpack_require__(108);\n\n// EXTERNAL MODULE: ./node_modules/nyc-lib/nyc/LocalStorage.js\nvar LocalStorage = __webpack_require__(105);\nvar LocalStorage_default = /*#__PURE__*/__webpack_require__.n(LocalStorage);\n\n// CONCATENATED MODULE: ./src/js/App.js\nfunction App_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction App_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction App_createClass(Constructor, protoProps, staticProps) { if (protoProps) App_defineProperties(Constructor.prototype, protoProps); if (staticProps) App_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar App_App =\n/*#__PURE__*/\nfunction () {\n  function App() {\n    App_classCallCheck(this, App);\n\n    var conf = Conf.getSaved(document);\n    external_jQuery_default()('body').html(HTML);\n    this.geoclient = new Geoclient_default.a({\n      url: this.geoclientUrl()\n    });\n    this.census = new CensusGeocoder_default.a();\n    this.map = new Basemap_default.a({\n      target: 'map'\n    });\n    this.base = this.map.getBaseLayers().base;\n    this.label = this.map.getBaseLayers().labels.base;\n    this.osm = new Tile[\"default\"]({\n      source: new source_OSM(),\n      visible: false\n    });\n    this.map.addLayer(this.osm);\n    this.map.addLayer(js_layer);\n    this.popup = new Popup_default.a({\n      map: this.map\n    });\n    this.sheetGeocoder = new js_SheetGeocoder({\n      source: js_layer.getSource()\n    });\n    this.locationMgrCensus = new LocationMgr_default.a({\n      map: this.map,\n      geocoder: this.census\n    });\n    this.locationMgrGeoclient = new LocationMgr_default.a({\n      map: this.map,\n      geocoder: this.geoclient\n    });\n    this.searchCtrls = external_jQuery_default()('.srch-ctl');\n    external_jQuery_default()(external_jQuery_default()('.zoom').get(0)).hide();\n    this.geoApi = new Choice_default.a({\n      target: '#geo-api',\n      radio: true,\n      choices: API_CHOICES\n    });\n    this.onInterval = new Choice_default.a({\n      target: '#on-interv',\n      choices: [{\n        name: 'on-interv',\n        label: 'Geocode on interval',\n        values: [1]\n      }]\n    });\n    var choices = [];\n    POSSIBLE_FIELDS.forEach(function (field) {\n      choices.push({\n        name: field,\n        label: field,\n        values: [field]\n      });\n    });\n    this.geoFields = new Choice_default.a({\n      target: '#geo-fields',\n      choices: choices\n    });\n    external_jQuery_default()('#geo-fields label').each(function (i, label) {\n      label.title = label.innerHTML;\n    });\n    this.tabs = new Tabs_default.a({\n      target: '#tabs',\n      tabs: [{\n        tab: '#tab-conf',\n        title: 'Configuration',\n        active: true\n      }, {\n        tab: '#tab-map',\n        title: 'Map'\n      }]\n    });\n    this.setConfigValues(conf);\n    this.hookup();\n  }\n\n  App_createClass(App, [{\n    key: \"setConfigValues\",\n    value: function setConfigValues(conf) {\n      var fields = [];\n      conf.requestedFields.forEach(function (f) {\n        fields.push({\n          name: f,\n          label: f,\n          values: [f]\n        });\n      });\n      this.geoFields.val(fields);\n      Object.keys(conf).forEach(function (key) {\n        external_jQuery_default()(\"#\".concat(key)).val(conf[key]);\n      });\n      this.geoApi.val(conf.nyc ? [API_CHOICES[0]] : [API_CHOICES[1]]);\n    }\n  }, {\n    key: \"hookup\",\n    value: function hookup() {\n      var me = this;\n      me.geoFields.on('change', this.update, this);\n      me.geoApi.on('change', this.update, this);\n      external_jQuery_default()('#geocode').click(function () {\n        me.sheetGeocoder.getData(true);\n      });\n      external_jQuery_default()('#reset').click(function () {\n        me.sheetGeocoder.clear();\n      });\n      external_jQuery_default()('#review').change(external_jQuery_default.a.proxy(this.review, this));\n      external_jQuery_default()('.pop .btn-x').click(function () {\n        external_jQuery_default()('#review').trigger('change');\n      });\n      this.sheetGeocoder.on('geocoded', function (event) {\n        external_jQuery_default()(\"#review option[value=\\\"\".concat(event.feature.getId(), \"\\\"]\")).remove();\n      });\n      external_jQuery_default()('#download').click(external_jQuery_default.a.proxy(this.download, this));\n      external_jQuery_default()('#tab-conf input').keyup(external_jQuery_default.a.proxy(this.update, this));\n      external_jQuery_default()(window).resize(external_jQuery_default.a.proxy(this.setMapSize, this));\n      this.tabs.on('change', this.setMapSize, this);\n      this.locationMgrCensus.on('geocoded', this.showPopup, this);\n      this.locationMgrGeoclient.on('geocoded', this.showPopup, this);\n      this.sheetGeocoder.on('batch-end', this.zoom, this);\n      this.sheetGeocoder.on('geocoded', this.syncFeature, this);\n      this.sheetGeocoder.on('ambiguous', this.ambiguous, this);\n      this.onInterval.on('change', this.update, this);\n      this.update();\n\n      if (Conf.valid()) {\n        this.tabs.open('#tab-map');\n      }\n    }\n  }, {\n    key: \"ambiguous\",\n    value: function ambiguous(event) {\n      var feature = event.feature;\n      var data = event.data;\n\n      if (data.geocodeResp && data.geocodeResp.possible) {\n        var id = feature.getId();\n        var result = data.geocodeResp;\n        var opt = external_jQuery_default()(\"#review option[value=\\\"\".concat(id, \"\\\"]\"));\n        var row = id + 1;\n        var optHtml = \"(\".concat(row, \") \").concat(result.input);\n\n        if (!opt.length) {\n          external_jQuery_default()('#review').append(external_jQuery_default()('<option></option>').data('feature', feature).html(optHtml).attr('title', \"Row \".concat(row)).val(id));\n        } else {\n          opt.html(optHtml);\n        }\n\n        this.reviewMsg();\n      }\n    }\n  }, {\n    key: \"syncFeature\",\n    value: function syncFeature(event) {\n      external_jQuery_default()(\"#review option[value=\\\"\".concat(event.feature.getId(), \"\\\"]\")).remove();\n      this.reviewMsg();\n    }\n  }, {\n    key: \"reviewMsg\",\n    value: function reviewMsg() {\n      external_jQuery_default()(external_jQuery_default()('#review option').get(0)).html(\"Review \".concat(external_jQuery_default()('#review option').length - 1, \" Failures\"));\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom() {\n      var map = this.map;\n      map.getView().fit(this.sheetGeocoder.geocodedBounds, {\n        size: map.getSize(),\n        duration: 500\n      });\n    }\n  }, {\n    key: \"review\",\n    value: function review() {\n      var id = external_jQuery_default()('#review').val();\n      var feature = external_jQuery_default()(\"#review option[value=\\\"\".concat(id, \"\\\"]\")).data('feature');\n\n      if (feature) {\n        var input = feature.get('_input');\n        var locationMgr = Conf.get('nyc') ? this.locationMgrGeoclient : this.locationMgrCensus;\n        locationMgr.search.input.val(input).data('last-search', input);\n        locationMgr.search.trigger('search', input);\n      }\n    }\n  }, {\n    key: \"download\",\n    value: function download() {\n      var download = [];\n      var features = js_layer.getSource().getFeatures();\n      features.forEach(function (f) {\n        var props = f.getProperties();\n        props.SHEET_ROW_NUM = props._row_num + 1;\n        delete props.X;\n        delete props.Y;\n        delete props.LNG;\n        delete props.LAT;\n        delete props._input;\n        delete props._geocodeResp;\n        delete props._row_num;\n        delete props._columns;\n        delete props._cells;\n        delete props._source;\n        var feature = new Feature[\"default\"](props);\n        feature.setGeometry(feature.getGeometry());\n        download.push(feature);\n      });\n      var options = {\n        dataProjection: 'EPSG:4326',\n        featureProjection: 'EPSG:3857'\n      };\n      new LocalStorage_default.a().saveGeoJson('geocoded.json', new GeoJSON[\"default\"]().writeFeatures(download, options));\n    }\n  }, {\n    key: \"correctSheet\",\n    value: function correctSheet(feature, data) {\n      var geocoder = this.sheetGeocoder;\n      feature.set('_interactive', true);\n      feature.once('change', external_jQuery_default.a.proxy(geocoder.geocoded, geocoder));\n      geocoder.format.setGeocode(feature, data);\n    }\n  }, {\n    key: \"setMapSize\",\n    value: function setMapSize() {\n      var div = external_jQuery_default()('#map');\n      var map = this.map;\n\n      if (map) {\n        map.setSize([div.width(), div.height()]);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var nyc = this.geoApi.val()[0].values[0] === 'nyc';\n      Conf.set('nyc', nyc);\n      Conf.set('url', external_jQuery_default()('#url').val());\n      Conf.set('id', external_jQuery_default()('#id').val());\n      Conf.set('key', external_jQuery_default()('#key').val());\n      Conf.set('template', external_jQuery_default()('#template').val());\n      Conf.set('requestedFields', this.requestedFields());\n      external_jQuery_default()('.gc')[nyc ? 'show' : 'hide']();\n      this.setup();\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this = this;\n\n      var nyc = Conf.get('nyc');\n      this.base.setVisible(nyc);\n      this.label.setVisible(nyc);\n      this.osm.setVisible(!nyc);\n      external_jQuery_default()(this.searchCtrls.get(0))[nyc ? 'hide' : 'show']();\n      external_jQuery_default()(this.searchCtrls.get(1))[nyc ? 'show' : 'hide']();\n\n      if (Conf.valid()) {\n        this.sheetGeocoder.clear();\n        this.sheetGeocoder.projection = nyc ? 'EPSG:2263' : '';\n        this.sheetGeocoder.conf(Conf.get());\n        this.geoclient.url = this.geoclientUrl();\n\n        if (this.onInterval.val().length) {\n          this.tabs.open('#tab-map');\n          this.interval = setInterval(function () {\n            _this.sheetGeocoder.getData(false);\n          }, 5000);\n        } else {\n          clearInterval(this.interval);\n        }\n      }\n    }\n  }, {\n    key: \"geoclientUrl\",\n    value: function geoclientUrl() {\n      return \"\".concat(Conf.get('url'), \"/search.json?app_id=\").concat(Conf.get('id'), \"&app_key=\").concat(Conf.get('key'), \"&input=\");\n    }\n  }, {\n    key: \"showPopup\",\n    value: function showPopup(data) {\n      var me = this;\n      var id = external_jQuery_default()('#review').val();\n      var feature = external_jQuery_default()(\"#review option[value=\\\"\".concat(id, \"\\\"]\")).data('feature');\n\n      if (feature) {\n        var locationMgr = Conf.get('nyc') ? this.locationMgrGeoclient : this.locationMgrCensus;\n        var failedAddr = feature.get('_geocodeResp').input;\n        var lastSearch = locationMgr.search.input.data('last-search');\n\n        if (lastSearch.trim() === failedAddr.trim()) {\n          var btn = external_jQuery_default()('<button class=\"update btn rad-all\"></button>').click(function () {\n            me.correctSheet(feature, data);\n            me.popup.hide();\n          }).html(\"Update row \".concat(id * 1));\n          me.popup.show({\n            coordinate: data.coordinate,\n            html: external_jQuery_default()(\"<div><h3>\".concat(data.name, \"</h3><div>\")).append(btn)\n          });\n        }\n      }\n    }\n  }, {\n    key: \"requestedFields\",\n    value: function requestedFields() {\n      var fields = [];\n\n      if (Conf.get('nyc')) {\n        this.geoFields.val().forEach(function (choice) {\n          fields.push(choice.values[0]);\n        });\n      }\n\n      return fields;\n    }\n  }]);\n\n  return App;\n}();\n\nvar POSSIBLE_FIELDS = ['assemblyDistrict', 'atomicPolygon', 'bbl', 'bblBoroughCode', 'bblBoroughCodeIn', 'bblTaxBlock', 'bblTaxBlockIn', 'bblTaxLot', 'bblTaxLotIn', 'bikeLane', 'bikeLane2', 'bikeTrafficDirection', 'blockfaceId', 'boardOfElectionsPreferredLgc', 'boePreferredStreetName', 'boePreferredstreetCode', 'boroughCode1In', 'buildingIdentificationNumber', 'buildingIdentificationNumberIn', 'businessImprovementDistrict', 'censusBlock2000', 'censusBlock2010', 'censusTract1990', 'censusTract2000', 'censusTract2010', 'cityCouncilDistrict', 'civilCourtDistrict', 'coincidentSegmentCount', 'communityDistrict', 'communityDistrictBoroughCode', 'communityDistrictNumber', 'communitySchoolDistrict', 'condominiumBillingBbl', 'congressionalDistrict', 'cooperativeIdNumber', 'cornerCode', 'crossStreetNamesFlagIn', 'dcpCommercialStudyArea', 'dcpPreferredLgc', 'dcpPreferredLgcForStreet1', 'dcpPreferredLgcForStreet2', 'dcpPreferredLgcForStreet3', 'dcpZoningMap', 'dotStreetLightContractorArea', 'dynamicBlock', 'electionDistrict', 'fireBattalion', 'fireCompanyNumber', 'fireCompanyType', 'fireDivision', 'firstBoroughName', 'firstStreetCode', 'firstStreetNameNormalized', 'fromActualSegmentNodeId', 'fromLgc1', 'fromLionNodeId', 'fromNode', 'fromPreferredLgcsFirstSetOf5', 'fromXCoordinate', 'fromYCoordinate', 'generatedRecordFlag', 'genericId', 'geosupportFunctionCode', 'geosupportReturnCode', 'geosupportReturnCode2', 'gi5DigitStreetCode1', 'gi5DigitStreetCode2', 'gi5DigitStreetCode3', 'gi5DigitStreetCode4', 'giBoroughCode1', 'giBoroughCode2', 'giBoroughCode3', 'giBoroughCode4', 'giBuildingIdentificationNumber1', 'giBuildingIdentificationNumber2', 'giBuildingIdentificationNumber3', 'giBuildingIdentificationNumber4', 'giDcpPreferredLgc1', 'giDcpPreferredLgc2', 'giDcpPreferredLgc3', 'giDcpPreferredLgc4', 'giHighHouseNumber1', 'giHighHouseNumber2', 'giHighHouseNumber3', 'giHighHouseNumber4', 'giLowHouseNumber1', 'giLowHouseNumber2', 'giLowHouseNumber3', 'giLowHouseNumber4', 'giSideOfStreetIndicator1', 'giSideOfStreetIndicator2', 'giSideOfStreetIndicator3', 'giSideOfStreetIndicator4', 'giStreetCode1', 'giStreetCode2', 'giStreetCode3', 'giStreetCode4', 'giStreetName1', 'giStreetName2', 'giStreetName3', 'giStreetName4', 'healthArea', 'healthCenterDistrict', 'highBblOfThisBuildingsCondominiumUnits', 'highCrossStreetB5SC1', 'highCrossStreetB5SC2', 'highCrossStreetCode1', 'highCrossStreetName1', 'highHouseNumberOfBlockfaceSortFormat', 'houseNumber', 'houseNumberIn', 'houseNumberSortFormat', 'hurricaneEvacuationZone', 'instructionalRegion', 'interimAssistanceEligibilityIndicator', 'internalLabelXCoordinate', 'internalLabelYCoordinate', 'intersectingStreet1', 'intersectingStreet2', 'latitude', 'latitudeInternalLabel', 'latitudeOfFromIntersection', 'latitudeOfToIntersection', 'leftSegment1990CensusTract', 'leftSegment2000CensusBlock', 'leftSegment2000CensusTract', 'leftSegment2010CensusBlock', 'leftSegment2010CensusTract', 'leftSegmentAssemblyDistrict', 'leftSegmentBlockfaceId', 'leftSegmentBoroughCode', 'leftSegmentCommunityDistrict', 'leftSegmentCommunityDistrictBoroughCode', 'leftSegmentCommunityDistrictNumber', 'leftSegmentCommunitySchoolDistrict', 'leftSegmentDynamicBlock', 'leftSegmentElectionDistrict', 'leftSegmentFireBattalion', 'leftSegmentFireCompanyNumber', 'leftSegmentFireCompanyType', 'leftSegmentFireDivision', 'leftSegmentHealthArea', 'leftSegmentHealthCenterDistrict', 'leftSegmentHighHouseNumber', 'leftSegmentInterimAssistanceEligibilityIndicator', 'leftSegmentLowHouseNumber', 'leftSegmentNta', 'leftSegmentNtaName', 'leftSegmentPolicePatrolBorough', 'leftSegmentPolicePatrolBoroughCommand', 'leftSegmentPolicePrecinct', 'leftSegmentPoliceSector', 'leftSegmentPumaCode', 'leftSegmentZipCode', 'legacyId', 'legacySegmentId', 'lengthOfSegmentInFeet', 'lgc1', 'lionBoroughCode', 'lionBoroughCodeForVanityAddress', 'lionFaceCode', 'lionFaceCodeForVanityAddress', 'lionKey', 'lionKeyForVanityAddress', 'lionNodeNumber', 'lionSequenceNumber', 'lionSequenceNumberForVanityAddress', 'listOf4Lgcs', 'listOfPairsOfLevelCodes', 'longitude', 'longitudeInternalLabel', 'longitudeOfFromIntersection', 'longitudeOfToIntersection', 'lowBblOfThisBuildingsCondominiumUnits', 'lowCrossStreetB5SC1', 'lowCrossStreetCode1', 'lowCrossStreetName1', 'lowHouseNumberOfBlockfaceSortFormat', 'lowHouseNumberOfDefiningAddressRange', 'modeSwitchIn', 'nta', 'ntaName', 'numberOfCrossStreetB5SCsHighAddressEnd', 'numberOfCrossStreetB5SCsLowAddressEnd', 'numberOfCrossStreetsHighAddressEnd', 'numberOfCrossStreetsLowAddressEnd', 'numberOfEntriesInListOfGeographicIdentifiers', 'numberOfExistingStructuresOnLot', 'numberOfIntersectingStreets', 'numberOfParkingLanesOnStreet', 'numberOfParkingLanesOnTheStreet', 'numberOfStreetCodesAndNamesInList', 'numberOfStreetFrontagesOfLot', 'numberOfTotalLanesOnStreet', 'numberOfTotalLanesOnTheStreet', 'numberOfTravelLanesOnStreet', 'numberOfTravelLanesOnTheStreet', 'physicalId', 'policePatrolBoroughCommand', 'policePrecinct', 'policeSector', 'pumaCode', 'returnCode1a', 'returnCode1e', 'rightSegment1990CensusTract', 'rightSegment2000CensusBlock', 'rightSegment2000CensusTract', 'rightSegment2010CensusBlock', 'rightSegment2010CensusTract', 'rightSegmentAssemblyDistrict', 'rightSegmentBlockfaceId', 'rightSegmentBoroughCode', 'rightSegmentCommunityDistrict', 'rightSegmentCommunityDistrictBoroughCode', 'rightSegmentCommunityDistrictNumber', 'rightSegmentCommunitySchoolDistrict', 'rightSegmentDynamicBlock', 'rightSegmentElectionDistrict', 'rightSegmentFireBattalion', 'rightSegmentFireCompanyNumber', 'rightSegmentFireCompanyType', 'rightSegmentFireDivision', 'rightSegmentHealthArea', 'rightSegmentHealthCenterDistrict', 'rightSegmentHighHouseNumber', 'rightSegmentInterimAssistanceEligibilityIndicator', 'rightSegmentLowHouseNumber', 'rightSegmentNta', 'rightSegmentNtaName', 'rightSegmentPolicePatrolBorough', 'rightSegmentPolicePatrolBoroughCommand', 'rightSegmentPolicePrecinct', 'rightSegmentPoliceSector', 'rightSegmentPumaCode', 'rightSegmentZipCode', 'roadwayType', 'rpadBuildingClassificationCode', 'rpadSelfCheckCodeForBbl', 'sanbornBoroughCode', 'sanbornBoroughCode1', 'sanbornBoroughCode2', 'sanbornPageNumber', 'sanbornPageNumber1', 'sanbornPageNumber2', 'sanbornVolumeNumber', 'sanbornVolumeNumber1', 'sanbornVolumeNumber2', 'sanbornVolumeNumberSuffix', 'sanbornVolumeNumberSuffix1', 'sanbornVolumeNumberSuffix2', 'sanitationBulkPickupSchedule', 'sanitationCollectionSchedulingSectionAndSubsection', 'sanitationDistrict', 'sanitationRecyclingCollectionSchedule', 'sanitationRegularCollectionSchedule', 'sanitationSection', 'sanitationSnowPriorityCode', 'secondStreetCode', 'secondStreetNameNormalized', 'segmentAzimuth', 'segmentIdentifier', 'segmentLengthInFeet', 'segmentOrientation', 'segmentTypeCode', 'sideOfStreetIndicator', 'sideOfStreetOfVanityAddress', 'speedLimit', 'splitLowHouseNumber', 'stateSenatorialDistrict', 'streetCode1', 'streetCode2', 'streetCode6', 'streetCode7', 'streetName1', 'streetName1In', 'streetName2', 'streetName2In', 'streetName3In', 'streetName6', 'streetName7', 'streetStatus', 'streetWidth', 'streetWidthMaximum', 'strollingKey', 'strollingKeyBoroughCode', 'strollingKeyHighHouseNumber', 'strollingKeyOnStreetCode', 'strollingKeySideOfStreetIndicator', 'taxMapNumberSectionAndVolume', 'thirdStreetCode', 'thirdStreetNameNormalized', 'toActualSegmentNodeId', 'toLgc1', 'toLionNodeId', 'toNode', 'toPreferredLgcsFirstSetOf5', 'toXCoordinate', 'toYCoordinate', 'trafficDirection', 'underlyingStreetCode', 'uspsPreferredCityName', 'workAreaFormatIndicatorIn', 'xCoordActualSegmentHighAddressEnd', 'xCoordActualSegmentLowAddressEnd', 'xCoordinate', 'xCoordinateHighAddressEnd', 'xCoordinateLowAddressEnd', 'xCoordinateOfCenterofCurvature', 'yCoordActualSegmentHighAddressEnd', 'yCoordActualSegmentLowAddressEnd', 'yCoordinate', 'yCoordinateHighAddressEnd', 'yCoordinateLowAddressEnd', 'yCoordinateOfCenterofCurvature', 'zipCode'];\nvar API_CHOICES = [{\n  name: 'geo-api',\n  label: 'NYC Geoclient',\n  values: ['nyc'],\n  checked: true\n}, {\n  name: 'geo-api',\n  label: 'Census',\n  values: ['census']\n}];\nvar HTML = \"<div id=\\\"tabs\\\">\\n  <div id=\\\"tab-conf\\\">\\n    <label class=\\\"conf\\\" for=\\\"url\\\">Geocoder</label>\\n    <div id=\\\"geo-api\\\"></div>\\n    <label class=\\\"conf\\\" for=\\\"template\\\">Geocode-able location definition</label>\\n    <input id=\\\"template\\\" class=\\\"rad-all\\\" type=\\\"text\\\" placeholder=\\\"Eg. &#36;{AddrCol}, &#36;{CityCol}, &#36;{ZipCol}\\\">\\n    <div id=\\\"on-interv\\\"></div>\\n    <label class=\\\"conf gc\\\" for=\\\"url\\\">Geoclient endpoint</label>\\n    <input id=\\\"url\\\" class=\\\"rad-all gc\\\" type=\\\"text\\\" placeholder=\\\"Eg. https://maps.nyc.gov/geoclient/v1\\\">\\n    <label class=\\\"conf gc\\\" for=\\\"id\\\">Geoclient App ID</label>\\n    <input id=\\\"id\\\" class=\\\"rad-all gc\\\" type=\\\"text\\\">\\n    <label class=\\\"conf gc\\\" for=\\\"key\\\">Geoclient App Key</label>\\n    <input id=\\\"key\\\" class=\\\"rad-all gc\\\" type=\\\"text\\\">\\n    <label class=\\\"conf gc\\\" for=\\\"geo-fields\\\">Possible Geocoded values to append (if available)</label>\\n    <div id=\\\"geo-fields\\\" class=\\\"gc\\\"></div>\\n  </div>\\n  <div id=\\\"tab-map\\\">\\n    <button id=\\\"geocode\\\" class=\\\"btn btn-sq rad-all\\\" title=\\\"Geocode sheet\\\">\\n      <span class=\\\"screen-reader-only\\\">Geocode sheet</span>\\n    </button>\\n    <select id=\\\"review\\\" class=\\\"btn rad-all\\\">\\n      <option value=\\\"-1\\\">Review 0 Failures</option>\\n    </select>\\n    <button id=\\\"reset\\\" class=\\\"btn btn-sq rad-all\\\" title=\\\"Reset map\\\">\\n        <span class=\\\"screen-reader-only\\\">Reset map</span>\\n    </button>\\n    <div id=\\\"map\\\" class=\\\"rad-all\\\"></div>\\n    <button id=\\\"download\\\" class=\\\"btn btn-sq rad-all\\\" title=\\\"Download GeoJSON\\\">\\n      <span class=\\\"screen-reader-only\\\">Download GeoJSON</span>\\n    </button>\\n  </div>  \\n</div>\";\nApp_App.POSSIBLE_FIELDS = POSSIBLE_FIELDS;\n/* harmony default export */ var js_App = (App_App);\n// CONCATENATED MODULE: ./src/js/index.js\n\nwindow.app = new js_App();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0NvbmYuanM/NTJkZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvRm9ybWF0LmpzPzFmZDciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL1NoZWV0R2VvY29kZXIuanM/OTQ2NyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL1RleHQuanM/NDM5ZiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbGF5ZXIuanM/MzZmOSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3NvdXJjZS9PU00uanM/Yjg1YiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvQXBwLmpzP2ZhYjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2luZGV4LmpzPzdiYTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQ09PS0lFID0gJ2dlb2NvZGluZy1zaGVldCdcblxuY29uc3QgY29uZmlnID0ge1xuICBueWM6IHRydWUsXG4gIHVybDogJycsXG4gIGlkOiAnJyxcbiAga2V5OiAnJyxcbiAgdGVtcGxhdGU6ICcnLFxuICByZXF1ZXN0ZWRGaWVsZHM6IFtdXG59XG5cbmNvbnN0IGNvbmYgPSB7XG4gIHNldChrZXksIHZhbCkge1xuICAgIGNvbmZpZ1trZXldID0gdmFsXG4gICAgY29uZi5zYXZlVG9Db29raWUoZG9jdW1lbnQpXG4gIH0sXG4gIGdldChrZXkpIHtcbiAgICBpZiAoa2V5KSByZXR1cm4gY29uZmlnW2tleV1cbiAgICByZXR1cm4gY29uZmlnXG4gIH0sXG4gIHZhbGlkKCkge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZVxuICAgIGlmIChjb25maWcubnljKSB7XG4gICAgICByZXN1bHQgPSBjb25maWcudXJsLnRyaW0oKSAhPT0gJycgJiYgXG4gICAgICBjb25maWcuaWQudHJpbSgpICE9PSAnJyAmJiBcbiAgICAgIGNvbmZpZy5rZXkudHJpbSgpICE9PSAnJyAmJiBcbiAgICAgIGNvbmZpZy50ZW1wbGF0ZS50cmltKCkgIT09ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGNvbmZpZy50ZW1wbGF0ZS50cmltKCkgIT09ICcnXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSxcbiAgZ2V0U2F2ZWQoZG9jKSB7XG4gICAgY29uc3QgaXQgPSBgJHtDT09LSUV9PWBcbiAgICBcbiAgICBjb25zdCBjb29raWVzID0gZG9jLmNvb2tpZS5zcGxpdCgnOycpXG4gICAgY29va2llcy5mb3JFYWNoKGNvb2tpZSA9PiB7XG4gICAgICBjb29raWUgPSBjb29raWUudHJpbSgpO1xuICAgICAgaWYgKGNvb2tpZS5pbmRleE9mKGl0KSA9PT0gMCkge1xuICAgICAgICBjb25zdCBzYXZlZENvbmYgPSBKU09OLnBhcnNlKGNvb2tpZS5zdWJzdHIoaXQubGVuZ3RoLCBjb29raWUubGVuZ3RoKSlcbiAgICAgICAgT2JqZWN0LmtleXMoc2F2ZWRDb25mKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgY29uZmlnW2tleV0gPSBzYXZlZENvbmZba2V5XVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9LFxuICBzYXZlVG9Db29raWUoZG9jKSB7XG4gICAgaWYgKGNvbmYudmFsaWQoKSkge1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpXG4gICAgICBjb25zdCBleHBpcmUgPSBuZXcgRGF0ZSgpXG4gICAgICBleHBpcmUuc2V0RGF0ZSh0b2RheS5nZXREYXRlKCkgKyAzNjUpXG4gICAgICBkb2MuY29va2llID0gYCR7Q09PS0lFfT0ke0pTT04uc3RyaW5naWZ5KGNvbmZpZyl9OyBleHBpcmVzPSR7ZXhwaXJlLnRvR01UU3RyaW5nKCl9YFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb25mXG4iLCJpbXBvcnQgQ3ZBZGRyIGZyb20gJ255Yy1saWIvbnljL29sL2Zvcm1hdC9Dc3ZBZGRyJ1xuaW1wb3J0IEdlb2NsaWVudCBmcm9tICdueWMtbGliL255Yy9HZW9jbGllbnQnXG5pbXBvcnQgQ2Vuc3VzR2VvY29kZXIgZnJvbSAnbnljLWxpYi9ueWMvQ2Vuc3VzR2VvY29kZXInXG5cbmNvbnN0IGZvcm1hdCA9IG5ldyBDdkFkZHIoe30pXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0Rm9ybWF0KGNvbmYpIHtcbiAgICBmb3JtYXQubG9jYXRpb25UZW1wbGF0ZSA9IGNvbmYudGVtcGxhdGVcbiAgICBpZiAoY29uZi5ueWMpIHtcbiAgICAgIGNvbnN0IHVybCA9IGAke2NvbmYudXJsfS9zZWFyY2guanNvbj9hcHBfaWQ9JHtjb25mLmlkfSZhcHBfa2V5PSR7Y29uZi5rZXl9YFxuICAgICAgZm9ybWF0Lmdlb2NvZGVyID0gbmV3IEdlb2NsaWVudCh7dXJsfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0Lmdlb2NvZGVyID0gbmV3IENlbnN1c0dlb2NvZGVyKClcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdFxuICB9XG59IiwiaW1wb3J0IEV2ZW50SGFuZGxpbmcgZnJvbSAnbnljLWxpYi9ueWMvRXZlbnRIYW5kbGluZydcbmltcG9ydCBwcm9qNCBmcm9tICdwcm9qNCdcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICdvbC9leHRlbnQnXG5pbXBvcnQgRm9ybWF0IGZyb20gJy4vRm9ybWF0J1xuaW1wb3J0IEZlYXR1cmUgZnJvbSAnb2wvRmVhdHVyZSdcblxuY2xhc3MgU2hlZXRHZW9jb2RlciBleHRlbmRzIEV2ZW50SGFuZGxpbmcge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuc291cmNlID0gb3B0aW9ucy5zb3VyY2VcbiAgICB0aGlzLnByb2plY3Rpb24gPSBvcHRpb25zLnByb2plY3Rpb25cbiAgICB0aGlzLmNsZWFyKClcbiAgfVxuICBjb25mKGNvbmYpIHtcbiAgICB0aGlzLmZvcm1hdCA9IEZvcm1hdC5nZXRGb3JtYXQoY29uZilcbiAgICB0aGlzLnJlcXVlc3RlZEZpZWxkcyA9IGNvbmYucmVxdWVzdGVkRmllbGRzXG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgaWYgKHRoaXMuc291cmNlKSB0aGlzLnNvdXJjZS5jbGVhcigpXG4gICAgdGhpcy5nZW9jb2RlQWxsID0gZmFsc2VcbiAgICB0aGlzLmNvdW50RG93biA9IDBcbiAgICB0aGlzLmdlb2NvZGVkQm91bmRzID0gbnVsbFxuICB9XG4gIGRvR2VvY29kZShmZWF0dXJlU291cmNlLCBmZWF0dXJlKSB7XG4gICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgIGNvbnN0IG9sZElucHV0ID0gZmVhdHVyZS5nZXQoJ19pbnB1dCcpXG4gICAgICBjb25zdCBuZXdJbnB1dCA9IHRoaXMuZm9ybWF0LnJlcGxhY2UodGhpcy5mb3JtYXQubG9jYXRpb25UZW1wbGF0ZSwgZmVhdHVyZVNvdXJjZSlcbiAgICAgIHJldHVybiBvbGRJbnB1dC50cmltKCkgIT09IG5ld0lucHV0LnRyaW0oKVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGdldERhdGEoYWxsKSB7XG4gICAgdGhpcy5nZW9jb2RlQWxsID0gYWxsID09PSB0cnVlXG4gICAgZ29vZ2xlLnNjcmlwdC5ydW4ud2l0aFN1Y2Nlc3NIYW5kbGVyKCQucHJveHkodGhpcy5nb3REYXRhLCB0aGlzKSkuZ2V0RGF0YSgpXG4gIH1cbiAgZ290RGF0YShkYXRhKSB7XG4gICAgY29uc3QgY29sdW1ucyA9IGRhdGFbMF1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZVxuICAgIGlmICh0aGlzLmdlb2NvZGVBbGwpIHtcbiAgICAgIHRoaXMuY291bnREb3duID0gZGF0YS5sZW5ndGggLSAxXG4gICAgICB0aGlzLnNvdXJjZS5jbGVhcigpXG4gICAgICB0aGlzLmdlb2NvZGVkQm91bmRzID0gbnVsbFxuICAgICAgdGhpcy50cmlnZ2VyKCdiYXRjaC1zdGFydCcsIGRhdGEpXG4gICAgfVxuICAgIGRhdGEuZm9yRWFjaCgocm93LCBpKSA9PiB7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgY29uc3QgZmVhdHVyZVNvdXJjZSA9IHtfcm93X251bTogaSArIDEsIF9jb2x1bW5zOiBjb2x1bW5zLCBfY2VsbHM6IHJvd31cbiAgICAgICAgbGV0IGZlYXR1cmUgPSBzb3VyY2UuZ2V0RmVhdHVyZUJ5SWQoaSArIDEpXG4gICAgICAgIGNvbHVtbnMuZm9yRWFjaCgoY29sLCBjKSA9PiB7XG4gICAgICAgICAgZmVhdHVyZVNvdXJjZVtjb2xdID0gcm93W2NdXG4gICAgICAgIH0pXG4gICAgICAgIGlmICh0aGlzLmRvR2VvY29kZShmZWF0dXJlU291cmNlLCBmZWF0dXJlKSkge1xuICAgICAgICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICAgICAgICBzb3VyY2UucmVtb3ZlRmVhdHVyZShmZWF0dXJlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBmZWF0dXJlID0gbmV3IEZlYXR1cmUoZmVhdHVyZVNvdXJjZSlcbiAgICAgICAgICBmZWF0dXJlLnNldElkKGkgKyAxKVxuICAgICAgICAgIGZlYXR1cmUuc2V0KCdfaW50ZXJhY3RpdmUnLCAhdGhpcy5nZW9jb2RlQWxsKVxuICAgICAgICAgIHNvdXJjZS5hZGRGZWF0dXJlKGZlYXR1cmUpXG4gICAgICAgICAgZmVhdHVyZS5vbmNlKCdjaGFuZ2UnLCAkLnByb3h5KHRoaXMuZ2VvY29kZWQsIHRoaXMpKSAgICAgICAgICBcbiAgICAgICAgICB0aGlzLmZvcm1hdC5zZXRHZW9tZXRyeShmZWF0dXJlLCBmZWF0dXJlU291cmNlKVxuICAgICAgICB9ICAgICAgICBcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGdlb2NvZGVkKGV2ZW50KSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBnZW9tID0gZmVhdHVyZS5nZXRHZW9tZXRyeSgpXG4gICAgY29uc3QgaWQgPSBmZWF0dXJlLmdldElkKClcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgcHJvamVjdGVkOiB0aGlzLnByb2plY3Rpb24sXG4gICAgICByb3c6IGZlYXR1cmUuZ2V0KCdfcm93X251bScpLFxuICAgICAgY29sdW1uczogZmVhdHVyZS5nZXQoJ19jb2x1bW5zJyksXG4gICAgICBjZWxsczogZmVhdHVyZS5nZXQoJ19jZWxscycpLFxuICAgICAgZ2VvY29kZVJlc3A6IGZlYXR1cmUuZ2V0KCdfZ2VvY29kZVJlc3AnKSxcbiAgICAgIG5hbWU6IGZlYXR1cmUuZ2V0KCdfZ2VvY29kZVJlc3AnKS5uYW1lLFxuICAgICAgcmVxdWVzdGVkRmllbGRzOiB0aGlzLnJlcXVlc3RlZEZpZWxkcyxcbiAgICAgIGludGVyYWN0aXZlOiBmZWF0dXJlLmdldCgnX2ludGVyYWN0aXZlJylcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2VvY29kZUFsbCkgdGhpcy5jb3VudERvd24tLVxuICAgIGlmIChnZW9tKSB7XG4gICAgICBjb25zdCBleHQgPSBnZW9tLmdldEV4dGVudCgpXG4gICAgICBjb25zdCBjb29yZHMgPSBnZW9tLmdldENvb3JkaW5hdGVzKClcbiAgICAgIGNvbnN0IGxsID0gcHJvajQoJ0VQU0c6Mzg1NycsICdFUFNHOjQzMjYnLCBjb29yZHMpXG4gICAgICBkYXRhLmxuZyA9IGxsWzBdXG4gICAgICBkYXRhLmxhdCA9IGxsWzFdXG4gICAgICB0aGlzLnByb2plY3RlZChkYXRhLCBjb29yZHMpXG4gICAgICB0aGlzLmdlb2NvZGVkQm91bmRzID0gdGhpcy5nZW9jb2RlZEJvdW5kcyA/IGV4dGVuZCh0aGlzLmdlb2NvZGVkQm91bmRzLCBleHQpIDogZXh0O1xuICAgICAgdGhpcy50cmlnZ2VyKCdnZW9jb2RlZCcsIHtmZWF0dXJlLCBkYXRhfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmlnZ2VyKCdhbWJpZ3VvdXMnLCB7ZmVhdHVyZSwgZGF0YX0pXG4gICAgfVxuICAgIGlmICh0aGlzLmdlb2NvZGVBbGwgJiYgdGhpcy5jb3VudERvd24gPT09IDApIHtcbiAgICAgIHRoaXMuZ2VvY29kZUFsbCA9IGZhbHNlXG4gICAgICB0aGlzLnRyaWdnZXIoJ2JhdGNoLWVuZCcpXG4gICAgfVxuICAgIGdvb2dsZS5zY3JpcHQucnVuLndpdGhTdWNjZXNzSGFuZGxlcigkLnByb3h5KHRoaXMudXBkYXRlRmVhdHVyZSwgdGhpcykpLmdlb2NvZGVkKGRhdGEpXG4gIH1cbiAgcHJvamVjdGVkKGRhdGEsIGNvb3Jkcykge1xuICAgIGlmICh0aGlzLnByb2plY3Rpb24pIHtcbiAgICAgIGNvbnN0IHh5ID0gcHJvajQoJ0VQU0c6Mzg1NycsIHRoaXMucHJvamVjdGlvbiwgY29vcmRzKVxuICAgICAgZGF0YS54ID0geHlbMF1cbiAgICAgIGRhdGEueSA9IHh5WzFdXG4gICAgfVxuICB9XG4gIHVwZGF0ZUZlYXR1cmUoZGF0YSkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLnNvdXJjZS5nZXRGZWF0dXJlQnlJZChkYXRhLnJvdylcbiAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgY29uc3QgY29sdW1ucyA9IGRhdGEuY29sdW1uc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZlYXR1cmUuc2V0KGNvbHVtbnNbaV0sIGRhdGEuY2VsbHNbaV0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNoZWV0R2VvY29kZXIiLCIvKipcbiAqIEBtb2R1bGUgb2wvc3R5bGUvVGV4dFxuICovXG5pbXBvcnQgRmlsbCBmcm9tICcuL0ZpbGwuanMnO1xuaW1wb3J0IFRleHRQbGFjZW1lbnQgZnJvbSAnLi9UZXh0UGxhY2VtZW50LmpzJztcblxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZpbGwgY29sb3IgdG8gdXNlIGlmIG5vIGZpbGwgd2FzIHNldCBhdCBjb25zdHJ1Y3Rpb24gdGltZTsgYVxuICogYmxhY2tpc2ggYCMzMzNgLlxuICpcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5jb25zdCBERUZBVUxUX0ZJTExfQ09MT1IgPSAnIzMzMyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZvbnRdIEZvbnQgc3R5bGUgYXMgQ1NTICdmb250JyB2YWx1ZSwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9mb250LiBEZWZhdWx0IGlzICcxMHB4IHNhbnMtc2VyaWYnXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heEFuZ2xlXSBXaGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYCwgYWxsb3cgYSBtYXhpbXVtIGFuZ2xlIGJldHdlZW4gYWRqYWNlbnQgY2hhcmFjdGVycy5cbiAqIFRoZSBleHBlY3RlZCB2YWx1ZSBpcyBpbiByYWRpYW5zLCBhbmQgdGhlIGRlZmF1bHQgaXMgNDXCsCAoYE1hdGguUEkgLyA0YCkuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW29mZnNldFg9MF0gSG9yaXpvbnRhbCB0ZXh0IG9mZnNldCBpbiBwaXhlbHMuIEEgcG9zaXRpdmUgd2lsbCBzaGlmdCB0aGUgdGV4dCByaWdodC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb2Zmc2V0WT0wXSBWZXJ0aWNhbCB0ZXh0IG9mZnNldCBpbiBwaXhlbHMuIEEgcG9zaXRpdmUgd2lsbCBzaGlmdCB0aGUgdGV4dCBkb3duLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3ZlcmZsb3c9ZmFsc2VdIEZvciBwb2x5Z29uIGxhYmVscyBvciB3aGVuIGBwbGFjZW1lbnRgIGlzIHNldCB0byBgJ2xpbmUnYCwgYWxsb3cgdGV4dCB0byBleGNlZWRcbiAqIHRoZSB3aWR0aCBvZiB0aGUgcG9seWdvbiBhdCB0aGUgbGFiZWwgcG9zaXRpb24gb3IgdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCB0aGF0IGl0IGZvbGxvd3MuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vVGV4dFBsYWNlbWVudC5qc1wiKS5kZWZhdWx0fHN0cmluZ30gW3BsYWNlbWVudF0gVGV4dCBwbGFjZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3NjYWxlXSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgdGV4dCB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZXh0XSBUZXh0IGNvbnRlbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RleHRBbGlnbl0gVGV4dCBhbGlnbm1lbnQuIFBvc3NpYmxlIHZhbHVlczogJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJywgJ2VuZCcgb3IgJ3N0YXJ0Jy5cbiAqIERlZmF1bHQgaXMgJ2NlbnRlcicgZm9yIGBwbGFjZW1lbnQ6ICdwb2ludCdgLiBGb3IgYHBsYWNlbWVudDogJ2xpbmUnYCwgdGhlIGRlZmF1bHQgaXMgdG8gbGV0IHRoZSByZW5kZXJlciBjaG9vc2UgYVxuICogcGxhY2VtZW50IHdoZXJlIGBtYXhBbmdsZWAgaXMgbm90IGV4Y2VlZGVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZXh0QmFzZWxpbmU9J21pZGRsZSddIFRleHQgYmFzZSBsaW5lLiBQb3NzaWJsZSB2YWx1ZXM6ICdib3R0b20nLCAndG9wJywgJ21pZGRsZScsICdhbHBoYWJldGljJyxcbiAqICdoYW5naW5nJywgJ2lkZW9ncmFwaGljJy5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9GaWxsLmpzXCIpLmRlZmF1bHR9IFtmaWxsXSBGaWxsIHN0eWxlLiBJZiBub25lIGlzIHByb3ZpZGVkLCB3ZSdsbCB1c2UgYSBkYXJrIGZpbGwtc3R5bGUgKCMzMzMpLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuL1N0cm9rZS5qc1wiKS5kZWZhdWx0fSBbc3Ryb2tlXSBTdHJva2Ugc3R5bGUuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBbYmFja2dyb3VuZEZpbGxdIEZpbGwgc3R5bGUgZm9yIHRoZSB0ZXh0IGJhY2tncm91bmQgd2hlbiBgcGxhY2VtZW50YCBpc1xuICogYCdwb2ludCdgLiBEZWZhdWx0IGlzIG5vIGZpbGwuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFtiYWNrZ3JvdW5kU3Ryb2tlXSBTdHJva2Ugc3R5bGUgZm9yIHRoZSB0ZXh0IGJhY2tncm91bmQgIHdoZW4gYHBsYWNlbWVudGBcbiAqIGlzIGAncG9pbnQnYC4gRGVmYXVsdCBpcyBubyBzdHJva2UuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtwYWRkaW5nPVswLCAwLCAwLCAwXV0gUGFkZGluZyBpbiBwaXhlbHMgYXJvdW5kIHRoZSB0ZXh0IGZvciBkZWNsdXR0ZXJpbmcgYW5kIGJhY2tncm91bmQuIFRoZSBvcmRlciBvZlxuICogdmFsdWVzIGluIHRoZSBhcnJheSBpcyBgW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF1gLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBTZXQgdGV4dCBzdHlsZSBmb3IgdmVjdG9yIGZlYXR1cmVzLlxuICogQGFwaVxuICovXG5jbGFzcyBUZXh0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgKi9cbiAgICB0aGlzLmZvbnRfID0gb3B0aW9ucy5mb250O1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XG4gICAgKi9cbiAgICB0aGlzLnJvdGF0aW9uXyA9IG9wdGlvbnMucm90YXRpb247XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgKi9cbiAgICB0aGlzLnJvdGF0ZVdpdGhWaWV3XyA9IG9wdGlvbnMucm90YXRlV2l0aFZpZXc7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHRoaXMuc2NhbGVfID0gb3B0aW9ucy5zY2FsZTtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICovXG4gICAgdGhpcy50ZXh0XyA9IG9wdGlvbnMudGV4dDtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICovXG4gICAgdGhpcy50ZXh0QWxpZ25fID0gb3B0aW9ucy50ZXh0QWxpZ247XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAqL1xuICAgIHRoaXMudGV4dEJhc2VsaW5lXyA9IG9wdGlvbnMudGV4dEJhc2VsaW5lO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fVxuICAgICovXG4gICAgdGhpcy5maWxsXyA9IG9wdGlvbnMuZmlsbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5maWxsIDpcbiAgICAgIG5ldyBGaWxsKHtjb2xvcjogREVGQVVMVF9GSUxMX0NPTE9SfSk7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICovXG4gICAgdGhpcy5tYXhBbmdsZV8gPSBvcHRpb25zLm1heEFuZ2xlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1heEFuZ2xlIDogTWF0aC5QSSAvIDQ7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9UZXh0UGxhY2VtZW50LmpzXCIpLmRlZmF1bHR8c3RyaW5nfVxuICAgICovXG4gICAgdGhpcy5wbGFjZW1lbnRfID0gb3B0aW9ucy5wbGFjZW1lbnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGxhY2VtZW50IDogVGV4dFBsYWNlbWVudC5QT0lOVDtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICovXG4gICAgdGhpcy5vdmVyZmxvd18gPSAhIW9wdGlvbnMub3ZlcmZsb3c7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICAqL1xuICAgIHRoaXMuc3Ryb2tlXyA9IG9wdGlvbnMuc3Ryb2tlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0cm9rZSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICovXG4gICAgdGhpcy5vZmZzZXRYXyA9IG9wdGlvbnMub2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vZmZzZXRYIDogMDtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgKi9cbiAgICB0aGlzLm9mZnNldFlfID0gb3B0aW9ucy5vZmZzZXRZICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9mZnNldFkgOiAwO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fVxuICAgICovXG4gICAgdGhpcy5iYWNrZ3JvdW5kRmlsbF8gPSBvcHRpb25zLmJhY2tncm91bmRGaWxsID8gb3B0aW9ucy5iYWNrZ3JvdW5kRmlsbCA6IG51bGw7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH1cbiAgICAqL1xuICAgIHRoaXMuYmFja2dyb3VuZFN0cm9rZV8gPSBvcHRpb25zLmJhY2tncm91bmRTdHJva2UgPyBvcHRpb25zLmJhY2tncm91bmRTdHJva2UgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgKi9cbiAgICB0aGlzLnBhZGRpbmdfID0gb3B0aW9ucy5wYWRkaW5nID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5wYWRkaW5nO1xuICB9XG5cbiAgLyoqXG4gICogQ2xvbmVzIHRoZSBzdHlsZS5cbiAgKiBAcmV0dXJuIHtUZXh0fSBUaGUgY2xvbmVkIHN0eWxlLlxuICAqIEBhcGlcbiAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0KHtcbiAgICAgIGZvbnQ6IHRoaXMuZ2V0Rm9udCgpLFxuICAgICAgcGxhY2VtZW50OiB0aGlzLmdldFBsYWNlbWVudCgpLFxuICAgICAgbWF4QW5nbGU6IHRoaXMuZ2V0TWF4QW5nbGUoKSxcbiAgICAgIG92ZXJmbG93OiB0aGlzLmdldE92ZXJmbG93KCksXG4gICAgICByb3RhdGlvbjogdGhpcy5nZXRSb3RhdGlvbigpLFxuICAgICAgcm90YXRlV2l0aFZpZXc6IHRoaXMuZ2V0Um90YXRlV2l0aFZpZXcoKSxcbiAgICAgIHNjYWxlOiB0aGlzLmdldFNjYWxlKCksXG4gICAgICB0ZXh0OiB0aGlzLmdldFRleHQoKSxcbiAgICAgIHRleHRBbGlnbjogdGhpcy5nZXRUZXh0QWxpZ24oKSxcbiAgICAgIHRleHRCYXNlbGluZTogdGhpcy5nZXRUZXh0QmFzZWxpbmUoKSxcbiAgICAgIGZpbGw6IHRoaXMuZ2V0RmlsbCgpID8gdGhpcy5nZXRGaWxsKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0cm9rZTogdGhpcy5nZXRTdHJva2UoKSA/IHRoaXMuZ2V0U3Ryb2tlKCkuY2xvbmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9mZnNldFg6IHRoaXMuZ2V0T2Zmc2V0WCgpLFxuICAgICAgb2Zmc2V0WTogdGhpcy5nZXRPZmZzZXRZKCksXG4gICAgICBiYWNrZ3JvdW5kRmlsbDogdGhpcy5nZXRCYWNrZ3JvdW5kRmlsbCgpID8gdGhpcy5nZXRCYWNrZ3JvdW5kRmlsbCgpLmNsb25lKCkgOiB1bmRlZmluZWQsXG4gICAgICBiYWNrZ3JvdW5kU3Ryb2tlOiB0aGlzLmdldEJhY2tncm91bmRTdHJva2UoKSA/IHRoaXMuZ2V0QmFja2dyb3VuZFN0cm9rZSgpLmNsb25lKCkgOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIEdldCB0aGUgYG92ZXJmbG93YCBjb25maWd1cmF0aW9uLlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IExldCB0ZXh0IG92ZXJmbG93IHRoZSBsZW5ndGggb2YgdGhlIHBhdGggdGhleSBmb2xsb3cuXG4gICogQGFwaVxuICAqL1xuICBnZXRPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gdGhpcy5vdmVyZmxvd187XG4gIH1cblxuICAvKipcbiAgKiBHZXQgdGhlIGZvbnQgbmFtZS5cbiAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBGb250LlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0Rm9udCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb250XztcbiAgfVxuXG4gIC8qKlxuICAqIEdldCB0aGUgbWF4aW11bSBhbmdsZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXG4gICogQHJldHVybiB7bnVtYmVyfSBBbmdsZSBpbiByYWRpYW5zLlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0TWF4QW5nbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4QW5nbGVfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSBsYWJlbCBwbGFjZW1lbnQuXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi9UZXh0UGxhY2VtZW50LmpzXCIpLmRlZmF1bHR8c3RyaW5nfSBUZXh0IHBsYWNlbWVudC5cbiAgKiBAYXBpXG4gICovXG4gIGdldFBsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGFjZW1lbnRfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSB4LW9mZnNldCBmb3IgdGhlIHRleHQuXG4gICogQHJldHVybiB7bnVtYmVyfSBIb3Jpem9udGFsIHRleHQgb2Zmc2V0LlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0T2Zmc2V0WCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRYXztcbiAgfVxuXG4gIC8qKlxuICAqIEdldCB0aGUgeS1vZmZzZXQgZm9yIHRoZSB0ZXh0LlxuICAqIEByZXR1cm4ge251bWJlcn0gVmVydGljYWwgdGV4dCBvZmZzZXQuXG4gICogQGFwaVxuICAqL1xuICBnZXRPZmZzZXRZKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldFlfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSBmaWxsIHN0eWxlIGZvciB0aGUgdGV4dC5cbiAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gRmlsbCBzdHlsZS5cbiAgKiBAYXBpXG4gICovXG4gIGdldEZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsbF87XG4gIH1cblxuICAvKipcbiAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgdGV4dCByb3RhdGVzIHdpdGggdGhlIG1hcC5cbiAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH0gUm90YXRlIHdpdGggbWFwLlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0Um90YXRlV2l0aFZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRlV2l0aFZpZXdfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSB0ZXh0IHJvdGF0aW9uLlxuICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFJvdGF0aW9uLlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm90YXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSB0ZXh0IHNjYWxlLlxuICAqIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFNjYWxlLlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSBzdHJva2Ugc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAqIEByZXR1cm4ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IFN0cm9rZSBzdHlsZS5cbiAgKiBAYXBpXG4gICovXG4gIGdldFN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJva2VfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRleHQuXG4gICogQGFwaVxuICAqL1xuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHRfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSB0ZXh0IGFsaWdubWVudC5cbiAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUZXh0IGFsaWduLlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0VGV4dEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLnRleHRBbGlnbl87XG4gIH1cblxuICAvKipcbiAgKiBHZXQgdGhlIHRleHQgYmFzZWxpbmUuXG4gICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gVGV4dCBiYXNlbGluZS5cbiAgKiBAYXBpXG4gICovXG4gIGdldFRleHRCYXNlbGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0QmFzZWxpbmVfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSBiYWNrZ3JvdW5kIGZpbGwgc3R5bGUgZm9yIHRoZSB0ZXh0LlxuICAqIEByZXR1cm4ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBGaWxsIHN0eWxlLlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0QmFja2dyb3VuZEZpbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2dyb3VuZEZpbGxfO1xuICB9XG5cbiAgLyoqXG4gICogR2V0IHRoZSBiYWNrZ3JvdW5kIHN0cm9rZSBzdHlsZSBmb3IgdGhlIHRleHQuXG4gICogQHJldHVybiB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gU3Ryb2tlIHN0eWxlLlxuICAqIEBhcGlcbiAgKi9cbiAgZ2V0QmFja2dyb3VuZFN0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5iYWNrZ3JvdW5kU3Ryb2tlXztcbiAgfVxuXG4gIC8qKlxuICAqIEdldCB0aGUgcGFkZGluZyBmb3IgdGhlIHRleHQuXG4gICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gUGFkZGluZy5cbiAgKiBAYXBpXG4gICovXG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFkZGluZ187XG4gIH1cblxuICAvKipcbiAgKiBTZXQgdGhlIGBvdmVyZmxvd2AgcHJvcGVydHkuXG4gICpcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJmbG93IExldCB0ZXh0IG92ZXJmbG93IHRoZSBwYXRoIHRoYXQgaXQgZm9sbG93cy5cbiAgKiBAYXBpXG4gICovXG4gIHNldE92ZXJmbG93KG92ZXJmbG93KSB7XG4gICAgdGhpcy5vdmVyZmxvd18gPSBvdmVyZmxvdztcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgZm9udC5cbiAgKlxuICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9udCBGb250LlxuICAqIEBhcGlcbiAgKi9cbiAgc2V0Rm9udChmb250KSB7XG4gICAgdGhpcy5mb250XyA9IGZvbnQ7XG4gIH1cblxuICAvKipcbiAgKiBTZXQgdGhlIG1heGltdW0gYW5nbGUgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlxuICAqXG4gICogQHBhcmFtIHtudW1iZXJ9IG1heEFuZ2xlIEFuZ2xlIGluIHJhZGlhbnMuXG4gICogQGFwaVxuICAqL1xuICBzZXRNYXhBbmdsZShtYXhBbmdsZSkge1xuICAgIHRoaXMubWF4QW5nbGVfID0gbWF4QW5nbGU7XG4gIH1cblxuICAvKipcbiAgKiBTZXQgdGhlIHggb2Zmc2V0LlxuICAqXG4gICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggSG9yaXpvbnRhbCB0ZXh0IG9mZnNldC5cbiAgKiBAYXBpXG4gICovXG4gIHNldE9mZnNldFgob2Zmc2V0WCkge1xuICAgIHRoaXMub2Zmc2V0WF8gPSBvZmZzZXRYO1xuICB9XG5cbiAgLyoqXG4gICogU2V0IHRoZSB5IG9mZnNldC5cbiAgKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIFZlcnRpY2FsIHRleHQgb2Zmc2V0LlxuICAqIEBhcGlcbiAgKi9cbiAgc2V0T2Zmc2V0WShvZmZzZXRZKSB7XG4gICAgdGhpcy5vZmZzZXRZXyA9IG9mZnNldFk7XG4gIH1cblxuICAvKipcbiAgKiBTZXQgdGhlIHRleHQgcGxhY2VtZW50LlxuICAqXG4gICogQHBhcmFtIHtpbXBvcnQoXCIuL1RleHRQbGFjZW1lbnQuanNcIikuZGVmYXVsdHxzdHJpbmd9IHBsYWNlbWVudCBQbGFjZW1lbnQuXG4gICogQGFwaVxuICAqL1xuICBzZXRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gICAgdGhpcy5wbGFjZW1lbnRfID0gcGxhY2VtZW50O1xuICB9XG5cbiAgLyoqXG4gICogU2V0IHRoZSBmaWxsLlxuICAqXG4gICogQHBhcmFtIHtpbXBvcnQoXCIuL0ZpbGwuanNcIikuZGVmYXVsdH0gZmlsbCBGaWxsIHN0eWxlLlxuICAqIEBhcGlcbiAgKi9cbiAgc2V0RmlsbChmaWxsKSB7XG4gICAgdGhpcy5maWxsXyA9IGZpbGw7XG4gIH1cblxuICAvKipcbiAgKiBTZXQgdGhlIHJvdGF0aW9uLlxuICAqXG4gICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSByb3RhdGlvbiBSb3RhdGlvbi5cbiAgKiBAYXBpXG4gICovXG4gIHNldFJvdGF0aW9uKHJvdGF0aW9uKSB7XG4gICAgdGhpcy5yb3RhdGlvbl8gPSByb3RhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgc2NhbGUuXG4gICpcbiAgKiBAcGFyYW0ge251bWJlcnx1bmRlZmluZWR9IHNjYWxlIFNjYWxlLlxuICAqIEBhcGlcbiAgKi9cbiAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLnNjYWxlXyA9IHNjYWxlO1xuICB9XG5cbiAgLyoqXG4gICogU2V0IHRoZSBzdHJva2UuXG4gICpcbiAgKiBAcGFyYW0ge2ltcG9ydChcIi4vU3Ryb2tlLmpzXCIpLmRlZmF1bHR9IHN0cm9rZSBTdHJva2Ugc3R5bGUuXG4gICogQGFwaVxuICAqL1xuICBzZXRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgdGhpcy5zdHJva2VfID0gc3Ryb2tlO1xuICB9XG5cbiAgLyoqXG4gICogU2V0IHRoZSB0ZXh0LlxuICAqXG4gICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB0ZXh0IFRleHQuXG4gICogQGFwaVxuICAqL1xuICBzZXRUZXh0KHRleHQpIHtcbiAgICB0aGlzLnRleHRfID0gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgdGV4dCBhbGlnbm1lbnQuXG4gICpcbiAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHRleHRBbGlnbiBUZXh0IGFsaWduLlxuICAqIEBhcGlcbiAgKi9cbiAgc2V0VGV4dEFsaWduKHRleHRBbGlnbikge1xuICAgIHRoaXMudGV4dEFsaWduXyA9IHRleHRBbGlnbjtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgdGV4dCBiYXNlbGluZS5cbiAgKlxuICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdGV4dEJhc2VsaW5lIFRleHQgYmFzZWxpbmUuXG4gICogQGFwaVxuICAqL1xuICBzZXRUZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKSB7XG4gICAgdGhpcy50ZXh0QmFzZWxpbmVfID0gdGV4dEJhc2VsaW5lO1xuICB9XG5cbiAgLyoqXG4gICogU2V0IHRoZSBiYWNrZ3JvdW5kIGZpbGwuXG4gICpcbiAgKiBAcGFyYW0ge2ltcG9ydChcIi4vRmlsbC5qc1wiKS5kZWZhdWx0fSBmaWxsIEZpbGwgc3R5bGUuXG4gICogQGFwaVxuICAqL1xuICBzZXRCYWNrZ3JvdW5kRmlsbChmaWxsKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kRmlsbF8gPSBmaWxsO1xuICB9XG5cbiAgLyoqXG4gICogU2V0IHRoZSBiYWNrZ3JvdW5kIHN0cm9rZS5cbiAgKlxuICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9TdHJva2UuanNcIikuZGVmYXVsdH0gc3Ryb2tlIFN0cm9rZSBzdHlsZS5cbiAgKiBAYXBpXG4gICovXG4gIHNldEJhY2tncm91bmRTdHJva2Uoc3Ryb2tlKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kU3Ryb2tlXyA9IHN0cm9rZTtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCB0aGUgcGFkZGluZyAoYFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdYCkuXG4gICpcbiAgKiBAcGFyYW0geyFBcnJheTxudW1iZXI+fSBwYWRkaW5nIFBhZGRpbmcuXG4gICogQGFwaVxuICAqL1xuICBzZXRQYWRkaW5nKHBhZGRpbmcpIHtcbiAgICB0aGlzLnBhZGRpbmdfID0gcGFkZGluZztcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0O1xuIiwiaW1wb3J0IFNvdXJjZSBmcm9tICdvbC9zb3VyY2UvVmVjdG9yJ1xuaW1wb3J0IExheWVyIGZyb20gJ29sL2xheWVyL1ZlY3RvcidcbmltcG9ydCBTdHlsZSBmcm9tICdvbC9zdHlsZS9TdHlsZSdcbmltcG9ydCBDaXJjbGUgZnJvbSAnb2wvc3R5bGUvQ2lyY2xlJ1xuaW1wb3J0IFN0cm9rZSBmcm9tICdvbC9zdHlsZS9TdHJva2UnXG5pbXBvcnQgRmlsbCBmcm9tICdvbC9zdHlsZS9GaWxsJ1xuaW1wb3J0IFRleHQgZnJvbSAnb2wvc3R5bGUvVGV4dCdcbmltcG9ydCBueWNPbCBmcm9tICdueWMtbGliL255Yy9vbCdcblxuY29uc3Qgc3R5bGUgPSAoZmVhdHVyZSwgcmVzb2x1dGlvbikgPT4ge1xuICBjb25zdCB6b29tID0gbnljT2wuVElMRV9HUklELmdldFpGb3JSZXNvbHV0aW9uKHJlc29sdXRpb24pXG4gIGNvbnN0IHRleHQgPSBgJHtmZWF0dXJlLmdldElkKCl9YFxuICBjb25zdCBmb250U2l6ZSA9IHRleHQubGVuZ3RoID4gMiA/IHpvb20gKiAuOCA6IHpvb20gKiAxLjJcbiAgY29uc3QgZm9udFdlaWdodCA9IHRleHQubGVuZ3RoIDw9IDIgPyAnYm9sZCcgOiAnJ1xuICByZXR1cm4gbmV3IFN0eWxlKHtcbiAgICBpbWFnZTogbmV3IENpcmNsZSh7XG4gICAgICByYWRpdXM6IDEwLFxuICAgICAgc3Ryb2tlOiBuZXcgU3Ryb2tlKHtjb2xvcjogJyMwMDAnLCB3aWR0aDogMn0pLFxuICAgICAgZmlsbDogbmV3IEZpbGwoe2NvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwuNSknfSlcbiAgICB9KSxcbiAgICB0ZXh0OiBuZXcgVGV4dCh7XG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgZm9udDogYCR7Zm9udFdlaWdodH0gJHtmb250U2l6ZS50b0ZpeGVkKDApfXB4IHNhbnMtc2VyaWZgLnRyaW0oKSxcbiAgICAgIGZpbGw6IG5ldyBGaWxsKHtjb2xvcjogJyMwMDAnfSlcbiAgICB9KVxuICB9KVxufVxuXG5jb25zdCBsYXllciA9IG5ldyBMYXllcih7c291cmNlOiBuZXcgU291cmNlKCksIHN0eWxlfSlcblxuZXhwb3J0IGRlZmF1bHQgbGF5ZXIiLCIvKipcbiAqIEBtb2R1bGUgb2wvc291cmNlL09TTVxuICovXG5cbmltcG9ydCBYWVogZnJvbSAnLi9YWVouanMnO1xuXG5cbi8qKlxuICogVGhlIGF0dHJpYnV0aW9uIGNvbnRhaW5pbmcgYSBsaW5rIHRvIHRoZSBPcGVuU3RyZWV0TWFwIENvcHlyaWdodCBhbmQgTGljZW5zZVxuICogcGFnZS5cbiAqIEBjb25zdFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBhcGlcbiAqL1xuZXhwb3J0IGNvbnN0IEFUVFJJQlVUSU9OID0gJyYjMTY5OyAnICtcbiAgICAgICc8YSBocmVmPVwiaHR0cHM6Ly93d3cub3BlbnN0cmVldG1hcC5vcmcvY29weXJpZ2h0XCI+T3BlblN0cmVldE1hcDwvYT4gJyArXG4gICAgICAnY29udHJpYnV0b3JzLic7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vU291cmNlLmpzXCIpLkF0dHJpYnV0aW9uTGlrZX0gW2F0dHJpYnV0aW9uc10gQXR0cmlidXRpb25zLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYWNoZVNpemU9MjA0OF0gQ2FjaGUgc2l6ZS5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiAgTm90ZSB0aGF0XG4gKiB5b3UgbXVzdCBwcm92aWRlIGEgYGNyb3NzT3JpZ2luYCB2YWx1ZSBpZiB5b3UgYXJlIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBvciBpZiB5b3Ugd2FudCB0b1xuICogYWNjZXNzIHBpeGVsIGRhdGEgd2l0aCB0aGUgQ2FudmFzIHJlbmRlcmVyLiAgU2VlXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heFpvb209MTldIE1heCB6b29tLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbb3BhcXVlPXRydWVdIFdoZXRoZXIgdGhlIGxheWVyIGlzIG9wYXF1ZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmVwcm9qZWN0aW9uRXJyb3JUaHJlc2hvbGQ9MS41XSBNYXhpbXVtIGFsbG93ZWQgcmVwcm9qZWN0aW9uIGVycm9yIChpbiBwaXhlbHMpLlxuICogSGlnaGVyIHZhbHVlcyBjYW4gaW5jcmVhc2UgcmVwcm9qZWN0aW9uIHBlcmZvcm1hbmNlLCBidXQgZGVjcmVhc2UgcHJlY2lzaW9uLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9UaWxlLmpzXCIpLkxvYWRGdW5jdGlvbn0gW3RpbGVMb2FkRnVuY3Rpb25dIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvYWQgYSB0aWxlIGdpdmVuIGEgVVJMLiBUaGUgZGVmYXVsdCBpc1xuICogYGBganNcbiAqIGZ1bmN0aW9uKGltYWdlVGlsZSwgc3JjKSB7XG4gKiAgIGltYWdlVGlsZS5nZXRJbWFnZSgpLnNyYyA9IHNyYztcbiAqIH07XG4gKiBgYGBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsPSdodHRwczovL3thLWN9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJ10gVVJMIHRlbXBsYXRlLlxuICogTXVzdCBpbmNsdWRlIGB7eH1gLCBge3l9YCBvciBgey15fWAsIGFuZCBge3p9YCBwbGFjZWhvbGRlcnMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cmFwWD10cnVlXSBXaGV0aGVyIHRvIHdyYXAgdGhlIHdvcmxkIGhvcml6b250YWxseS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogTGF5ZXIgc291cmNlIGZvciB0aGUgT3BlblN0cmVldE1hcCB0aWxlIHNlcnZlci5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgT1NNIGV4dGVuZHMgWFlaIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IFtvcHRfb3B0aW9uc10gT3BlbiBTdHJlZXQgTWFwIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgbGV0IGF0dHJpYnV0aW9ucztcbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXR0cmlidXRpb25zID0gb3B0aW9ucy5hdHRyaWJ1dGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0aW9ucyA9IFtBVFRSSUJVVElPTl07XG4gICAgfVxuXG4gICAgY29uc3QgY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5jcm9zc09yaWdpbiA6ICdhbm9ueW1vdXMnO1xuXG4gICAgY29uc3QgdXJsID0gb3B0aW9ucy51cmwgIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLnVybCA6ICdodHRwczovL3thLWN9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJztcblxuICAgIHN1cGVyKHtcbiAgICAgIGF0dHJpYnV0aW9uczogYXR0cmlidXRpb25zLFxuICAgICAgY2FjaGVTaXplOiBvcHRpb25zLmNhY2hlU2l6ZSxcbiAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgIG9wYXF1ZTogb3B0aW9ucy5vcGFxdWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub3BhcXVlIDogdHJ1ZSxcbiAgICAgIG1heFpvb206IG9wdGlvbnMubWF4Wm9vbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXhab29tIDogMTksXG4gICAgICByZXByb2plY3Rpb25FcnJvclRocmVzaG9sZDogb3B0aW9ucy5yZXByb2plY3Rpb25FcnJvclRocmVzaG9sZCxcbiAgICAgIHRpbGVMb2FkRnVuY3Rpb246IG9wdGlvbnMudGlsZUxvYWRGdW5jdGlvbixcbiAgICAgIHVybDogdXJsLFxuICAgICAgd3JhcFg6IG9wdGlvbnMud3JhcFgsXG4gICAgICBhdHRyaWJ1dGlvbnNDb2xsYXBzaWJsZTogZmFsc2VcbiAgICB9KTtcblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgT1NNO1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IENvbmYgZnJvbSAnLi9Db25mJ1xuaW1wb3J0IFNoZWV0R2VvY29kZXIgZnJvbSAnLi9TaGVldEdlb2NvZGVyJ1xuaW1wb3J0IGxheWVyIGZyb20gJy4vbGF5ZXInXG5pbXBvcnQgQmFzZW1hcCBmcm9tICdueWMtbGliL255Yy9vbC9CYXNlbWFwJ1xuaW1wb3J0IExvY2F0aW9uTWdyIGZyb20gJ255Yy1saWIvbnljL29sL0xvY2F0aW9uTWdyJ1xuaW1wb3J0IFBvcHVwIGZyb20gJ255Yy1saWIvbnljL29sL1BvcHVwJ1xuaW1wb3J0IFRhYnMgZnJvbSAnbnljLWxpYi9ueWMvVGFicydcbmltcG9ydCBDaG9pY2UgZnJvbSAnbnljLWxpYi9ueWMvQ2hvaWNlJ1xuaW1wb3J0IE9TTSBmcm9tICdvbC9zb3VyY2UvT1NNJ1xuaW1wb3J0IEdlb0pTT04gZnJvbSAnb2wvZm9ybWF0L0dlb0pTT04nXG5pbXBvcnQgVGlsZUxheWVyIGZyb20gJ29sL2xheWVyL1RpbGUnXG5pbXBvcnQgQ2Vuc3VzR2VvY29kZXIgZnJvbSAnbnljLWxpYi9ueWMvQ2Vuc3VzR2VvY29kZXInXG5pbXBvcnQgR2VvY2xpZW50IGZyb20gJ255Yy1saWIvbnljL0dlb2NsaWVudCdcbmltcG9ydCBMb2NhbFN0b3JhZ2UgZnJvbSAnbnljLWxpYi9ueWMvTG9jYWxTdG9yYWdlJ1xuaW1wb3J0IEZlYXR1cmUgZnJvbSAnb2wvRmVhdHVyZSdcblxuY2xhc3MgQXBwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgY29uZiA9IENvbmYuZ2V0U2F2ZWQoZG9jdW1lbnQpXG4gICAgJCgnYm9keScpLmh0bWwoSFRNTClcbiAgICB0aGlzLmdlb2NsaWVudCA9IG5ldyBHZW9jbGllbnQoe3VybDogdGhpcy5nZW9jbGllbnRVcmwoKX0pXG4gICAgdGhpcy5jZW5zdXMgPSBuZXcgQ2Vuc3VzR2VvY29kZXIoKVxuICAgIHRoaXMubWFwID0gbmV3IEJhc2VtYXAoe3RhcmdldDogJ21hcCd9KVxuICAgIHRoaXMuYmFzZSA9IHRoaXMubWFwLmdldEJhc2VMYXllcnMoKS5iYXNlXG4gICAgdGhpcy5sYWJlbCA9IHRoaXMubWFwLmdldEJhc2VMYXllcnMoKS5sYWJlbHMuYmFzZVxuICAgIHRoaXMub3NtID0gbmV3IFRpbGVMYXllcih7c291cmNlOiBuZXcgT1NNKCksIHZpc2libGU6IGZhbHNlfSlcbiAgICB0aGlzLm1hcC5hZGRMYXllcih0aGlzLm9zbSlcbiAgICB0aGlzLm1hcC5hZGRMYXllcihsYXllcilcbiAgICB0aGlzLnBvcHVwID0gbmV3IFBvcHVwKHttYXA6IHRoaXMubWFwfSlcbiAgICB0aGlzLnNoZWV0R2VvY29kZXIgPSBuZXcgU2hlZXRHZW9jb2Rlcih7c291cmNlOiBsYXllci5nZXRTb3VyY2UoKX0pXG4gICAgdGhpcy5sb2NhdGlvbk1nckNlbnN1cyA9IG5ldyBMb2NhdGlvbk1ncih7bWFwOiB0aGlzLm1hcCwgZ2VvY29kZXI6IHRoaXMuY2Vuc3VzfSlcbiAgICB0aGlzLmxvY2F0aW9uTWdyR2VvY2xpZW50ID0gbmV3IExvY2F0aW9uTWdyKHttYXA6IHRoaXMubWFwLCBnZW9jb2RlcjogdGhpcy5nZW9jbGllbnR9KVxuICAgIHRoaXMuc2VhcmNoQ3RybHMgPSAkKCcuc3JjaC1jdGwnKVxuICAgICQoJCgnLnpvb20nKS5nZXQoMCkpLmhpZGUoKVxuICAgIHRoaXMuZ2VvQXBpID0gbmV3IENob2ljZSh7XG4gICAgICB0YXJnZXQ6ICcjZ2VvLWFwaScsXG4gICAgICByYWRpbzogdHJ1ZSxcbiAgICAgIGNob2ljZXM6IEFQSV9DSE9JQ0VTXG4gICAgfSlcbiAgICB0aGlzLm9uSW50ZXJ2YWwgPSBuZXcgQ2hvaWNlKHtcbiAgICAgIHRhcmdldDogJyNvbi1pbnRlcnYnLFxuICAgICAgY2hvaWNlczogW3tuYW1lOiAnb24taW50ZXJ2JywgbGFiZWw6ICdHZW9jb2RlIG9uIGludGVydmFsJywgdmFsdWVzOiBbMV19XVxuICAgIH0pXG4gICAgY29uc3QgY2hvaWNlcyA9IFtdXG4gICAgUE9TU0lCTEVfRklFTERTLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgY2hvaWNlcy5wdXNoKHtuYW1lOiBmaWVsZCwgbGFiZWw6IGZpZWxkLCB2YWx1ZXM6IFtmaWVsZF19KVxuICAgIH0pXG4gICAgdGhpcy5nZW9GaWVsZHMgPSBuZXcgQ2hvaWNlKHtcbiAgICAgIHRhcmdldDogJyNnZW8tZmllbGRzJyxcbiAgICAgIGNob2ljZXM6IGNob2ljZXNcbiAgICB9KVxuICAgICQoJyNnZW8tZmllbGRzIGxhYmVsJykuZWFjaCgoaSwgbGFiZWwpID0+IHtcbiAgICAgIGxhYmVsLnRpdGxlID0gbGFiZWwuaW5uZXJIVE1MXG4gICAgfSlcbiAgICB0aGlzLnRhYnMgPSBuZXcgVGFicyh7XG4gICAgICB0YXJnZXQ6ICcjdGFicycsXG4gICAgICB0YWJzOiBbXG4gICAgICAgIHt0YWI6ICcjdGFiLWNvbmYnLCB0aXRsZTogJ0NvbmZpZ3VyYXRpb24nLCBhY3RpdmU6IHRydWV9LFxuICAgICAgICB7dGFiOiAnI3RhYi1tYXAnLCB0aXRsZTogJ01hcCd9XG4gICAgICBdXG4gICAgfSlcbiAgICB0aGlzLnNldENvbmZpZ1ZhbHVlcyhjb25mKVxuICAgIHRoaXMuaG9va3VwKClcbiAgfVxuICBzZXRDb25maWdWYWx1ZXMoY29uZikge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdXG4gICAgY29uZi5yZXF1ZXN0ZWRGaWVsZHMuZm9yRWFjaChmID0+IHtcbiAgICAgIGZpZWxkcy5wdXNoKHtuYW1lOiBmLCBsYWJlbDogZiwgdmFsdWVzOiBbZl19KVxuICAgIH0pXG4gICAgdGhpcy5nZW9GaWVsZHMudmFsKGZpZWxkcylcbiAgICBPYmplY3Qua2V5cyhjb25mKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAkKGAjJHtrZXl9YCkudmFsKGNvbmZba2V5XSlcbiAgICB9KVxuICAgIHRoaXMuZ2VvQXBpLnZhbChjb25mLm55YyA/IFtBUElfQ0hPSUNFU1swXV0gOiBbQVBJX0NIT0lDRVNbMV1dKVxuICB9XG4gIGhvb2t1cCgpIHtcbiAgICBjb25zdCBtZSA9IHRoaXNcbiAgICBtZS5nZW9GaWVsZHMub24oJ2NoYW5nZScsIHRoaXMudXBkYXRlLCB0aGlzKVxuICAgIG1lLmdlb0FwaS5vbignY2hhbmdlJywgdGhpcy51cGRhdGUsIHRoaXMpXG4gICAgJCgnI2dlb2NvZGUnKS5jbGljaygoKSA9PiB7XG4gICAgICBtZS5zaGVldEdlb2NvZGVyLmdldERhdGEodHJ1ZSlcbiAgICB9KVxuICAgICQoJyNyZXNldCcpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgbWUuc2hlZXRHZW9jb2Rlci5jbGVhcigpXG4gICAgfSlcbiAgICAkKCcjcmV2aWV3JykuY2hhbmdlKCQucHJveHkodGhpcy5yZXZpZXcsIHRoaXMpKVxuICAgICQoJy5wb3AgLmJ0bi14JykuY2xpY2soKCkgPT4geyQoJyNyZXZpZXcnKS50cmlnZ2VyKCdjaGFuZ2UnKX0pXG4gICAgdGhpcy5zaGVldEdlb2NvZGVyLm9uKCdnZW9jb2RlZCcsIGV2ZW50ID0+IHtcbiAgICAgICQoYCNyZXZpZXcgb3B0aW9uW3ZhbHVlPVwiJHtldmVudC5mZWF0dXJlLmdldElkKCl9XCJdYCkucmVtb3ZlKClcbiAgICB9KVxuICAgICQoJyNkb3dubG9hZCcpLmNsaWNrKCQucHJveHkodGhpcy5kb3dubG9hZCwgdGhpcykpXG4gICAgJCgnI3RhYi1jb25mIGlucHV0Jykua2V5dXAoJC5wcm94eSh0aGlzLnVwZGF0ZSwgdGhpcykpXG4gICAgJCh3aW5kb3cpLnJlc2l6ZSgkLnByb3h5KHRoaXMuc2V0TWFwU2l6ZSwgdGhpcykpXG4gICAgdGhpcy50YWJzLm9uKCdjaGFuZ2UnLCB0aGlzLnNldE1hcFNpemUsIHRoaXMpXG4gICAgdGhpcy5sb2NhdGlvbk1nckNlbnN1cy5vbignZ2VvY29kZWQnLCB0aGlzLnNob3dQb3B1cCwgdGhpcylcbiAgICB0aGlzLmxvY2F0aW9uTWdyR2VvY2xpZW50Lm9uKCdnZW9jb2RlZCcsIHRoaXMuc2hvd1BvcHVwLCB0aGlzKVxuICAgIHRoaXMuc2hlZXRHZW9jb2Rlci5vbignYmF0Y2gtZW5kJywgdGhpcy56b29tLCB0aGlzKVxuICAgIHRoaXMuc2hlZXRHZW9jb2Rlci5vbignZ2VvY29kZWQnLCB0aGlzLnN5bmNGZWF0dXJlLCB0aGlzKVxuICAgIHRoaXMuc2hlZXRHZW9jb2Rlci5vbignYW1iaWd1b3VzJywgdGhpcy5hbWJpZ3VvdXMsIHRoaXMpXG4gICAgdGhpcy5vbkludGVydmFsLm9uKCdjaGFuZ2UnLCB0aGlzLnVwZGF0ZSwgdGhpcylcbiAgICB0aGlzLnVwZGF0ZSgpXG4gICAgaWYgKENvbmYudmFsaWQoKSkge1xuICAgICAgdGhpcy50YWJzLm9wZW4oJyN0YWItbWFwJylcbiAgICB9XG4gIH1cbiAgYW1iaWd1b3VzKGV2ZW50KSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IGV2ZW50LmZlYXR1cmVcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YVxuICAgIGlmIChkYXRhLmdlb2NvZGVSZXNwICYmIGRhdGEuZ2VvY29kZVJlc3AucG9zc2libGUpIHtcbiAgICAgIGNvbnN0IGlkID0gZmVhdHVyZS5nZXRJZCgpXG4gICAgICBjb25zdCByZXN1bHQgPSBkYXRhLmdlb2NvZGVSZXNwXG4gICAgICBjb25zdCBvcHQgPSAkKGAjcmV2aWV3IG9wdGlvblt2YWx1ZT1cIiR7aWR9XCJdYClcbiAgICAgIGNvbnN0IHJvdyA9IGlkICsgMVxuICAgICAgY29uc3Qgb3B0SHRtbCA9IGAoJHtyb3d9KSAke3Jlc3VsdC5pbnB1dH1gXG4gICAgICBpZiAoIW9wdC5sZW5ndGgpIHtcbiAgICAgICAgJCgnI3JldmlldycpLmFwcGVuZChcbiAgICAgICAgICAkKCc8b3B0aW9uPjwvb3B0aW9uPicpLmRhdGEoJ2ZlYXR1cmUnLCBmZWF0dXJlKVxuICAgICAgICAgICAgLmh0bWwob3B0SHRtbClcbiAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsIGBSb3cgJHtyb3d9YCkudmFsKGlkKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHQuaHRtbChvcHRIdG1sKVxuICAgICAgfVxuICAgICAgdGhpcy5yZXZpZXdNc2coKVxuICAgIH1cbiAgfVxuICBzeW5jRmVhdHVyZShldmVudCkge1xuICAgICQoYCNyZXZpZXcgb3B0aW9uW3ZhbHVlPVwiJHtldmVudC5mZWF0dXJlLmdldElkKCl9XCJdYCkucmVtb3ZlKClcbiAgICB0aGlzLnJldmlld01zZygpXG4gIH1cbiAgcmV2aWV3TXNnKCkge1xuICAgICQoJCgnI3JldmlldyBvcHRpb24nKS5nZXQoMCkpLmh0bWwoYFJldmlldyAkeyQoJyNyZXZpZXcgb3B0aW9uJykubGVuZ3RoIC0gMX0gRmFpbHVyZXNgKVxuICB9XG4gIHpvb20oKSB7XG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXBcbiAgICBtYXAuZ2V0VmlldygpLmZpdCh0aGlzLnNoZWV0R2VvY29kZXIuZ2VvY29kZWRCb3VuZHMsIHtzaXplOiBtYXAuZ2V0U2l6ZSgpLCBkdXJhdGlvbjogNTAwfSk7XG4gIH1cbiAgcmV2aWV3KCkge1xuICAgIGNvbnN0IGlkID0gJCgnI3JldmlldycpLnZhbCgpXG4gICAgY29uc3QgZmVhdHVyZSA9ICQoYCNyZXZpZXcgb3B0aW9uW3ZhbHVlPVwiJHtpZH1cIl1gKS5kYXRhKCdmZWF0dXJlJylcbiAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgY29uc3QgaW5wdXQgPSBmZWF0dXJlLmdldCgnX2lucHV0JylcbiAgICAgIGNvbnN0IGxvY2F0aW9uTWdyID0gQ29uZi5nZXQoJ255YycpID8gdGhpcy5sb2NhdGlvbk1nckdlb2NsaWVudCA6IHRoaXMubG9jYXRpb25NZ3JDZW5zdXNcbiAgICAgIGxvY2F0aW9uTWdyLnNlYXJjaC5pbnB1dC52YWwoaW5wdXQpLmRhdGEoJ2xhc3Qtc2VhcmNoJywgaW5wdXQpXG4gICAgICBsb2NhdGlvbk1nci5zZWFyY2gudHJpZ2dlcignc2VhcmNoJywgaW5wdXQpXG4gICAgfVxuICB9XG4gIGRvd25sb2FkKCkge1xuICAgIGNvbnN0IGRvd25sb2FkID0gW11cbiAgICBjb25zdCBmZWF0dXJlcyA9IGxheWVyLmdldFNvdXJjZSgpLmdldEZlYXR1cmVzKClcbiAgICBmZWF0dXJlcy5mb3JFYWNoKGYgPT4ge1xuICAgICAgY29uc3QgcHJvcHMgPSBmLmdldFByb3BlcnRpZXMoKVxuICAgICAgcHJvcHMuU0hFRVRfUk9XX05VTSA9IHByb3BzLl9yb3dfbnVtICsgMVxuICAgICAgZGVsZXRlIHByb3BzLlhcbiAgICAgIGRlbGV0ZSBwcm9wcy5ZXG4gICAgICBkZWxldGUgcHJvcHMuTE5HXG4gICAgICBkZWxldGUgcHJvcHMuTEFUXG4gICAgICBkZWxldGUgcHJvcHMuX2lucHV0XG4gICAgICBkZWxldGUgcHJvcHMuX2dlb2NvZGVSZXNwXG4gICAgICBkZWxldGUgcHJvcHMuX3Jvd19udW1cbiAgICAgIGRlbGV0ZSBwcm9wcy5fY29sdW1uc1xuICAgICAgZGVsZXRlIHByb3BzLl9jZWxsc1xuICAgICAgZGVsZXRlIHByb3BzLl9zb3VyY2VcbiAgICAgIGNvbnN0IGZlYXR1cmUgPSBuZXcgRmVhdHVyZShwcm9wcylcbiAgICAgIGZlYXR1cmUuc2V0R2VvbWV0cnkoZmVhdHVyZS5nZXRHZW9tZXRyeSgpKVxuICAgICAgZG93bmxvYWQucHVzaChmZWF0dXJlKVxuICAgIH0pXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtkYXRhUHJvamVjdGlvbjogJ0VQU0c6NDMyNicsIGZlYXR1cmVQcm9qZWN0aW9uOiAnRVBTRzozODU3J31cbiAgICBuZXcgTG9jYWxTdG9yYWdlKCkuc2F2ZUdlb0pzb24oJ2dlb2NvZGVkLmpzb24nLCBuZXcgR2VvSlNPTigpLndyaXRlRmVhdHVyZXMoZG93bmxvYWQsIG9wdGlvbnMpKVxuICB9XG4gIGNvcnJlY3RTaGVldChmZWF0dXJlLCBkYXRhKSB7XG4gICAgY29uc3QgZ2VvY29kZXIgPSB0aGlzLnNoZWV0R2VvY29kZXJcbiAgICBmZWF0dXJlLnNldCgnX2ludGVyYWN0aXZlJywgdHJ1ZSlcbiAgICBmZWF0dXJlLm9uY2UoJ2NoYW5nZScsICQucHJveHkoZ2VvY29kZXIuZ2VvY29kZWQsIGdlb2NvZGVyKSlcbiAgICBnZW9jb2Rlci5mb3JtYXQuc2V0R2VvY29kZShmZWF0dXJlLCBkYXRhKVxuICB9XG4gIHNldE1hcFNpemUoKSB7XG4gICAgY29uc3QgZGl2ID0gJCgnI21hcCcpXG4gICAgY29uc3QgbWFwID0gdGhpcy5tYXBcbiAgICBpZiAobWFwKSB7XG4gICAgICBtYXAuc2V0U2l6ZShbZGl2LndpZHRoKCksIGRpdi5oZWlnaHQoKV0pXG4gICAgfVxuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBueWMgPSB0aGlzLmdlb0FwaS52YWwoKVswXS52YWx1ZXNbMF0gPT09ICdueWMnXG4gICAgQ29uZi5zZXQoJ255YycsIG55YylcbiAgICBDb25mLnNldCgndXJsJywgJCgnI3VybCcpLnZhbCgpKVxuICAgIENvbmYuc2V0KCdpZCcsICQoJyNpZCcpLnZhbCgpKVxuICAgIENvbmYuc2V0KCdrZXknLCAkKCcja2V5JykudmFsKCkpXG4gICAgQ29uZi5zZXQoJ3RlbXBsYXRlJywgJCgnI3RlbXBsYXRlJykudmFsKCkpXG4gICAgQ29uZi5zZXQoJ3JlcXVlc3RlZEZpZWxkcycsIHRoaXMucmVxdWVzdGVkRmllbGRzKCkpXG4gICAgJCgnLmdjJylbbnljID8gJ3Nob3cnIDogJ2hpZGUnXSgpXG4gICAgdGhpcy5zZXR1cCgpXG4gIH1cbiAgc2V0dXAoKSB7XG4gICAgY29uc3QgbnljID0gQ29uZi5nZXQoJ255YycpXG4gICAgdGhpcy5iYXNlLnNldFZpc2libGUobnljKVxuICAgIHRoaXMubGFiZWwuc2V0VmlzaWJsZShueWMpXG4gICAgdGhpcy5vc20uc2V0VmlzaWJsZSghbnljKVxuICAgICQodGhpcy5zZWFyY2hDdHJscy5nZXQoMCkpW255YyA/ICdoaWRlJyA6ICdzaG93J10oKVxuICAgICQodGhpcy5zZWFyY2hDdHJscy5nZXQoMSkpW255YyA/ICdzaG93JyA6ICdoaWRlJ10oKVxuICAgIGlmIChDb25mLnZhbGlkKCkpIHtcbiAgICAgIHRoaXMuc2hlZXRHZW9jb2Rlci5jbGVhcigpXG4gICAgICB0aGlzLnNoZWV0R2VvY29kZXIucHJvamVjdGlvbiA9IG55YyA/ICdFUFNHOjIyNjMnIDogJydcbiAgICAgIHRoaXMuc2hlZXRHZW9jb2Rlci5jb25mKENvbmYuZ2V0KCkpXG4gICAgICB0aGlzLmdlb2NsaWVudC51cmwgPSB0aGlzLmdlb2NsaWVudFVybCgpXG4gICAgICBpZiAodGhpcy5vbkludGVydmFsLnZhbCgpLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRhYnMub3BlbignI3RhYi1tYXAnKVxuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2hlZXRHZW9jb2Rlci5nZXREYXRhKGZhbHNlKVxuICAgICAgICB9LCA1MDAwKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZW9jbGllbnRVcmwoKSB7XG4gICAgcmV0dXJuIGAke0NvbmYuZ2V0KCd1cmwnKX0vc2VhcmNoLmpzb24/YXBwX2lkPSR7Q29uZi5nZXQoJ2lkJyl9JmFwcF9rZXk9JHtDb25mLmdldCgna2V5Jyl9JmlucHV0PWBcbiAgfVxuICBzaG93UG9wdXAoZGF0YSkge1xuICAgIGNvbnN0IG1lID0gdGhpc1xuICAgIGNvbnN0IGlkID0gJCgnI3JldmlldycpLnZhbCgpXG4gICAgY29uc3QgZmVhdHVyZSA9ICQoYCNyZXZpZXcgb3B0aW9uW3ZhbHVlPVwiJHtpZH1cIl1gKS5kYXRhKCdmZWF0dXJlJylcbiAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgY29uc3QgbG9jYXRpb25NZ3IgPSBDb25mLmdldCgnbnljJykgPyB0aGlzLmxvY2F0aW9uTWdyR2VvY2xpZW50IDogdGhpcy5sb2NhdGlvbk1nckNlbnN1c1xuICAgICAgY29uc3QgZmFpbGVkQWRkciA9IGZlYXR1cmUuZ2V0KCdfZ2VvY29kZVJlc3AnKS5pbnB1dFxuICAgICAgY29uc3QgbGFzdFNlYXJjaCA9IGxvY2F0aW9uTWdyLnNlYXJjaC5pbnB1dC5kYXRhKCdsYXN0LXNlYXJjaCcpXG4gICAgICBpZiAobGFzdFNlYXJjaC50cmltKCkgPT09IGZhaWxlZEFkZHIudHJpbSgpKSB7XG4gICAgICAgIGNvbnN0IGJ0biA9ICQoJzxidXR0b24gY2xhc3M9XCJ1cGRhdGUgYnRuIHJhZC1hbGxcIj48L2J1dHRvbj4nKVxuICAgICAgICAgIC5jbGljaygoKSA9PiB7XG4gICAgICAgICAgICBtZS5jb3JyZWN0U2hlZXQoZmVhdHVyZSwgZGF0YSlcbiAgICAgICAgICAgIG1lLnBvcHVwLmhpZGUoKVxuICAgICAgICAgIH0pLmh0bWwoYFVwZGF0ZSByb3cgJHtpZCAqIDF9YClcbiAgICAgICAgbWUucG9wdXAuc2hvdyh7XG4gICAgICAgICAgY29vcmRpbmF0ZTogZGF0YS5jb29yZGluYXRlLFxuICAgICAgICAgIGh0bWw6ICQoYDxkaXY+PGgzPiR7ZGF0YS5uYW1lfTwvaDM+PGRpdj5gKS5hcHBlbmQoYnRuKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXF1ZXN0ZWRGaWVsZHMoKSB7XG4gICAgY29uc3QgZmllbGRzID0gW11cbiAgICBpZiAoQ29uZi5nZXQoJ255YycpKSB7XG4gICAgICB0aGlzLmdlb0ZpZWxkcy52YWwoKS5mb3JFYWNoKGNob2ljZSA9PiB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGNob2ljZS52YWx1ZXNbMF0pXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzXG4gIH1cbn1cblxuY29uc3QgUE9TU0lCTEVfRklFTERTID0gWydhc3NlbWJseURpc3RyaWN0JywgJ2F0b21pY1BvbHlnb24nLCAnYmJsJywgJ2JibEJvcm91Z2hDb2RlJywgJ2JibEJvcm91Z2hDb2RlSW4nLCAnYmJsVGF4QmxvY2snLCAnYmJsVGF4QmxvY2tJbicsICdiYmxUYXhMb3QnLCAnYmJsVGF4TG90SW4nLCAnYmlrZUxhbmUnLCAnYmlrZUxhbmUyJywgJ2Jpa2VUcmFmZmljRGlyZWN0aW9uJywgJ2Jsb2NrZmFjZUlkJywgJ2JvYXJkT2ZFbGVjdGlvbnNQcmVmZXJyZWRMZ2MnLCAnYm9lUHJlZmVycmVkU3RyZWV0TmFtZScsICdib2VQcmVmZXJyZWRzdHJlZXRDb2RlJywgJ2Jvcm91Z2hDb2RlMUluJywgJ2J1aWxkaW5nSWRlbnRpZmljYXRpb25OdW1iZXInLCAnYnVpbGRpbmdJZGVudGlmaWNhdGlvbk51bWJlckluJywgJ2J1c2luZXNzSW1wcm92ZW1lbnREaXN0cmljdCcsICdjZW5zdXNCbG9jazIwMDAnLCAnY2Vuc3VzQmxvY2syMDEwJywgJ2NlbnN1c1RyYWN0MTk5MCcsICdjZW5zdXNUcmFjdDIwMDAnLCAnY2Vuc3VzVHJhY3QyMDEwJywgJ2NpdHlDb3VuY2lsRGlzdHJpY3QnLCAnY2l2aWxDb3VydERpc3RyaWN0JywgJ2NvaW5jaWRlbnRTZWdtZW50Q291bnQnLCAnY29tbXVuaXR5RGlzdHJpY3QnLCAnY29tbXVuaXR5RGlzdHJpY3RCb3JvdWdoQ29kZScsICdjb21tdW5pdHlEaXN0cmljdE51bWJlcicsICdjb21tdW5pdHlTY2hvb2xEaXN0cmljdCcsICdjb25kb21pbml1bUJpbGxpbmdCYmwnLCAnY29uZ3Jlc3Npb25hbERpc3RyaWN0JywgJ2Nvb3BlcmF0aXZlSWROdW1iZXInLCAnY29ybmVyQ29kZScsICdjcm9zc1N0cmVldE5hbWVzRmxhZ0luJywgJ2RjcENvbW1lcmNpYWxTdHVkeUFyZWEnLCAnZGNwUHJlZmVycmVkTGdjJywgJ2RjcFByZWZlcnJlZExnY0ZvclN0cmVldDEnLCAnZGNwUHJlZmVycmVkTGdjRm9yU3RyZWV0MicsICdkY3BQcmVmZXJyZWRMZ2NGb3JTdHJlZXQzJywgJ2RjcFpvbmluZ01hcCcsICdkb3RTdHJlZXRMaWdodENvbnRyYWN0b3JBcmVhJywgJ2R5bmFtaWNCbG9jaycsICdlbGVjdGlvbkRpc3RyaWN0JywgJ2ZpcmVCYXR0YWxpb24nLCAnZmlyZUNvbXBhbnlOdW1iZXInLCAnZmlyZUNvbXBhbnlUeXBlJywgJ2ZpcmVEaXZpc2lvbicsICdmaXJzdEJvcm91Z2hOYW1lJywgJ2ZpcnN0U3RyZWV0Q29kZScsICdmaXJzdFN0cmVldE5hbWVOb3JtYWxpemVkJywgJ2Zyb21BY3R1YWxTZWdtZW50Tm9kZUlkJywgJ2Zyb21MZ2MxJywgJ2Zyb21MaW9uTm9kZUlkJywgJ2Zyb21Ob2RlJywgJ2Zyb21QcmVmZXJyZWRMZ2NzRmlyc3RTZXRPZjUnLCAnZnJvbVhDb29yZGluYXRlJywgJ2Zyb21ZQ29vcmRpbmF0ZScsICdnZW5lcmF0ZWRSZWNvcmRGbGFnJywgJ2dlbmVyaWNJZCcsICdnZW9zdXBwb3J0RnVuY3Rpb25Db2RlJywgJ2dlb3N1cHBvcnRSZXR1cm5Db2RlJywgJ2dlb3N1cHBvcnRSZXR1cm5Db2RlMicsICdnaTVEaWdpdFN0cmVldENvZGUxJywgJ2dpNURpZ2l0U3RyZWV0Q29kZTInLCAnZ2k1RGlnaXRTdHJlZXRDb2RlMycsICdnaTVEaWdpdFN0cmVldENvZGU0JywgJ2dpQm9yb3VnaENvZGUxJywgJ2dpQm9yb3VnaENvZGUyJywgJ2dpQm9yb3VnaENvZGUzJywgJ2dpQm9yb3VnaENvZGU0JywgJ2dpQnVpbGRpbmdJZGVudGlmaWNhdGlvbk51bWJlcjEnLCAnZ2lCdWlsZGluZ0lkZW50aWZpY2F0aW9uTnVtYmVyMicsICdnaUJ1aWxkaW5nSWRlbnRpZmljYXRpb25OdW1iZXIzJywgJ2dpQnVpbGRpbmdJZGVudGlmaWNhdGlvbk51bWJlcjQnLCAnZ2lEY3BQcmVmZXJyZWRMZ2MxJywgJ2dpRGNwUHJlZmVycmVkTGdjMicsICdnaURjcFByZWZlcnJlZExnYzMnLCAnZ2lEY3BQcmVmZXJyZWRMZ2M0JywgJ2dpSGlnaEhvdXNlTnVtYmVyMScsICdnaUhpZ2hIb3VzZU51bWJlcjInLCAnZ2lIaWdoSG91c2VOdW1iZXIzJywgJ2dpSGlnaEhvdXNlTnVtYmVyNCcsICdnaUxvd0hvdXNlTnVtYmVyMScsICdnaUxvd0hvdXNlTnVtYmVyMicsICdnaUxvd0hvdXNlTnVtYmVyMycsICdnaUxvd0hvdXNlTnVtYmVyNCcsICdnaVNpZGVPZlN0cmVldEluZGljYXRvcjEnLCAnZ2lTaWRlT2ZTdHJlZXRJbmRpY2F0b3IyJywgJ2dpU2lkZU9mU3RyZWV0SW5kaWNhdG9yMycsICdnaVNpZGVPZlN0cmVldEluZGljYXRvcjQnLCAnZ2lTdHJlZXRDb2RlMScsICdnaVN0cmVldENvZGUyJywgJ2dpU3RyZWV0Q29kZTMnLCAnZ2lTdHJlZXRDb2RlNCcsICdnaVN0cmVldE5hbWUxJywgJ2dpU3RyZWV0TmFtZTInLCAnZ2lTdHJlZXROYW1lMycsICdnaVN0cmVldE5hbWU0JywgJ2hlYWx0aEFyZWEnLCAnaGVhbHRoQ2VudGVyRGlzdHJpY3QnLCAnaGlnaEJibE9mVGhpc0J1aWxkaW5nc0NvbmRvbWluaXVtVW5pdHMnLCAnaGlnaENyb3NzU3RyZWV0QjVTQzEnLCAnaGlnaENyb3NzU3RyZWV0QjVTQzInLCAnaGlnaENyb3NzU3RyZWV0Q29kZTEnLCAnaGlnaENyb3NzU3RyZWV0TmFtZTEnLCAnaGlnaEhvdXNlTnVtYmVyT2ZCbG9ja2ZhY2VTb3J0Rm9ybWF0JywgJ2hvdXNlTnVtYmVyJywgJ2hvdXNlTnVtYmVySW4nLCAnaG91c2VOdW1iZXJTb3J0Rm9ybWF0JywgJ2h1cnJpY2FuZUV2YWN1YXRpb25ab25lJywgJ2luc3RydWN0aW9uYWxSZWdpb24nLCAnaW50ZXJpbUFzc2lzdGFuY2VFbGlnaWJpbGl0eUluZGljYXRvcicsICdpbnRlcm5hbExhYmVsWENvb3JkaW5hdGUnLCAnaW50ZXJuYWxMYWJlbFlDb29yZGluYXRlJywgJ2ludGVyc2VjdGluZ1N0cmVldDEnLCAnaW50ZXJzZWN0aW5nU3RyZWV0MicsICdsYXRpdHVkZScsICdsYXRpdHVkZUludGVybmFsTGFiZWwnLCAnbGF0aXR1ZGVPZkZyb21JbnRlcnNlY3Rpb24nLCAnbGF0aXR1ZGVPZlRvSW50ZXJzZWN0aW9uJywgJ2xlZnRTZWdtZW50MTk5MENlbnN1c1RyYWN0JywgJ2xlZnRTZWdtZW50MjAwMENlbnN1c0Jsb2NrJywgJ2xlZnRTZWdtZW50MjAwMENlbnN1c1RyYWN0JywgJ2xlZnRTZWdtZW50MjAxMENlbnN1c0Jsb2NrJywgJ2xlZnRTZWdtZW50MjAxMENlbnN1c1RyYWN0JywgJ2xlZnRTZWdtZW50QXNzZW1ibHlEaXN0cmljdCcsICdsZWZ0U2VnbWVudEJsb2NrZmFjZUlkJywgJ2xlZnRTZWdtZW50Qm9yb3VnaENvZGUnLCAnbGVmdFNlZ21lbnRDb21tdW5pdHlEaXN0cmljdCcsICdsZWZ0U2VnbWVudENvbW11bml0eURpc3RyaWN0Qm9yb3VnaENvZGUnLCAnbGVmdFNlZ21lbnRDb21tdW5pdHlEaXN0cmljdE51bWJlcicsICdsZWZ0U2VnbWVudENvbW11bml0eVNjaG9vbERpc3RyaWN0JywgJ2xlZnRTZWdtZW50RHluYW1pY0Jsb2NrJywgJ2xlZnRTZWdtZW50RWxlY3Rpb25EaXN0cmljdCcsICdsZWZ0U2VnbWVudEZpcmVCYXR0YWxpb24nLCAnbGVmdFNlZ21lbnRGaXJlQ29tcGFueU51bWJlcicsICdsZWZ0U2VnbWVudEZpcmVDb21wYW55VHlwZScsICdsZWZ0U2VnbWVudEZpcmVEaXZpc2lvbicsICdsZWZ0U2VnbWVudEhlYWx0aEFyZWEnLCAnbGVmdFNlZ21lbnRIZWFsdGhDZW50ZXJEaXN0cmljdCcsICdsZWZ0U2VnbWVudEhpZ2hIb3VzZU51bWJlcicsICdsZWZ0U2VnbWVudEludGVyaW1Bc3Npc3RhbmNlRWxpZ2liaWxpdHlJbmRpY2F0b3InLCAnbGVmdFNlZ21lbnRMb3dIb3VzZU51bWJlcicsICdsZWZ0U2VnbWVudE50YScsICdsZWZ0U2VnbWVudE50YU5hbWUnLCAnbGVmdFNlZ21lbnRQb2xpY2VQYXRyb2xCb3JvdWdoJywgJ2xlZnRTZWdtZW50UG9saWNlUGF0cm9sQm9yb3VnaENvbW1hbmQnLCAnbGVmdFNlZ21lbnRQb2xpY2VQcmVjaW5jdCcsICdsZWZ0U2VnbWVudFBvbGljZVNlY3RvcicsICdsZWZ0U2VnbWVudFB1bWFDb2RlJywgJ2xlZnRTZWdtZW50WmlwQ29kZScsICdsZWdhY3lJZCcsICdsZWdhY3lTZWdtZW50SWQnLCAnbGVuZ3RoT2ZTZWdtZW50SW5GZWV0JywgJ2xnYzEnLCAnbGlvbkJvcm91Z2hDb2RlJywgJ2xpb25Cb3JvdWdoQ29kZUZvclZhbml0eUFkZHJlc3MnLCAnbGlvbkZhY2VDb2RlJywgJ2xpb25GYWNlQ29kZUZvclZhbml0eUFkZHJlc3MnLCAnbGlvbktleScsICdsaW9uS2V5Rm9yVmFuaXR5QWRkcmVzcycsICdsaW9uTm9kZU51bWJlcicsICdsaW9uU2VxdWVuY2VOdW1iZXInLCAnbGlvblNlcXVlbmNlTnVtYmVyRm9yVmFuaXR5QWRkcmVzcycsICdsaXN0T2Y0TGdjcycsICdsaXN0T2ZQYWlyc09mTGV2ZWxDb2RlcycsICdsb25naXR1ZGUnLCAnbG9uZ2l0dWRlSW50ZXJuYWxMYWJlbCcsICdsb25naXR1ZGVPZkZyb21JbnRlcnNlY3Rpb24nLCAnbG9uZ2l0dWRlT2ZUb0ludGVyc2VjdGlvbicsICdsb3dCYmxPZlRoaXNCdWlsZGluZ3NDb25kb21pbml1bVVuaXRzJywgJ2xvd0Nyb3NzU3RyZWV0QjVTQzEnLCAnbG93Q3Jvc3NTdHJlZXRDb2RlMScsICdsb3dDcm9zc1N0cmVldE5hbWUxJywgJ2xvd0hvdXNlTnVtYmVyT2ZCbG9ja2ZhY2VTb3J0Rm9ybWF0JywgJ2xvd0hvdXNlTnVtYmVyT2ZEZWZpbmluZ0FkZHJlc3NSYW5nZScsICdtb2RlU3dpdGNoSW4nLCAnbnRhJywgJ250YU5hbWUnLCAnbnVtYmVyT2ZDcm9zc1N0cmVldEI1U0NzSGlnaEFkZHJlc3NFbmQnLCAnbnVtYmVyT2ZDcm9zc1N0cmVldEI1U0NzTG93QWRkcmVzc0VuZCcsICdudW1iZXJPZkNyb3NzU3RyZWV0c0hpZ2hBZGRyZXNzRW5kJywgJ251bWJlck9mQ3Jvc3NTdHJlZXRzTG93QWRkcmVzc0VuZCcsICdudW1iZXJPZkVudHJpZXNJbkxpc3RPZkdlb2dyYXBoaWNJZGVudGlmaWVycycsICdudW1iZXJPZkV4aXN0aW5nU3RydWN0dXJlc09uTG90JywgJ251bWJlck9mSW50ZXJzZWN0aW5nU3RyZWV0cycsICdudW1iZXJPZlBhcmtpbmdMYW5lc09uU3RyZWV0JywgJ251bWJlck9mUGFya2luZ0xhbmVzT25UaGVTdHJlZXQnLCAnbnVtYmVyT2ZTdHJlZXRDb2Rlc0FuZE5hbWVzSW5MaXN0JywgJ251bWJlck9mU3RyZWV0RnJvbnRhZ2VzT2ZMb3QnLCAnbnVtYmVyT2ZUb3RhbExhbmVzT25TdHJlZXQnLCAnbnVtYmVyT2ZUb3RhbExhbmVzT25UaGVTdHJlZXQnLCAnbnVtYmVyT2ZUcmF2ZWxMYW5lc09uU3RyZWV0JywgJ251bWJlck9mVHJhdmVsTGFuZXNPblRoZVN0cmVldCcsICdwaHlzaWNhbElkJywgJ3BvbGljZVBhdHJvbEJvcm91Z2hDb21tYW5kJywgJ3BvbGljZVByZWNpbmN0JywgJ3BvbGljZVNlY3RvcicsICdwdW1hQ29kZScsICdyZXR1cm5Db2RlMWEnLCAncmV0dXJuQ29kZTFlJywgJ3JpZ2h0U2VnbWVudDE5OTBDZW5zdXNUcmFjdCcsICdyaWdodFNlZ21lbnQyMDAwQ2Vuc3VzQmxvY2snLCAncmlnaHRTZWdtZW50MjAwMENlbnN1c1RyYWN0JywgJ3JpZ2h0U2VnbWVudDIwMTBDZW5zdXNCbG9jaycsICdyaWdodFNlZ21lbnQyMDEwQ2Vuc3VzVHJhY3QnLCAncmlnaHRTZWdtZW50QXNzZW1ibHlEaXN0cmljdCcsICdyaWdodFNlZ21lbnRCbG9ja2ZhY2VJZCcsICdyaWdodFNlZ21lbnRCb3JvdWdoQ29kZScsICdyaWdodFNlZ21lbnRDb21tdW5pdHlEaXN0cmljdCcsICdyaWdodFNlZ21lbnRDb21tdW5pdHlEaXN0cmljdEJvcm91Z2hDb2RlJywgJ3JpZ2h0U2VnbWVudENvbW11bml0eURpc3RyaWN0TnVtYmVyJywgJ3JpZ2h0U2VnbWVudENvbW11bml0eVNjaG9vbERpc3RyaWN0JywgJ3JpZ2h0U2VnbWVudER5bmFtaWNCbG9jaycsICdyaWdodFNlZ21lbnRFbGVjdGlvbkRpc3RyaWN0JywgJ3JpZ2h0U2VnbWVudEZpcmVCYXR0YWxpb24nLCAncmlnaHRTZWdtZW50RmlyZUNvbXBhbnlOdW1iZXInLCAncmlnaHRTZWdtZW50RmlyZUNvbXBhbnlUeXBlJywgJ3JpZ2h0U2VnbWVudEZpcmVEaXZpc2lvbicsICdyaWdodFNlZ21lbnRIZWFsdGhBcmVhJywgJ3JpZ2h0U2VnbWVudEhlYWx0aENlbnRlckRpc3RyaWN0JywgJ3JpZ2h0U2VnbWVudEhpZ2hIb3VzZU51bWJlcicsICdyaWdodFNlZ21lbnRJbnRlcmltQXNzaXN0YW5jZUVsaWdpYmlsaXR5SW5kaWNhdG9yJywgJ3JpZ2h0U2VnbWVudExvd0hvdXNlTnVtYmVyJywgJ3JpZ2h0U2VnbWVudE50YScsICdyaWdodFNlZ21lbnROdGFOYW1lJywgJ3JpZ2h0U2VnbWVudFBvbGljZVBhdHJvbEJvcm91Z2gnLCAncmlnaHRTZWdtZW50UG9saWNlUGF0cm9sQm9yb3VnaENvbW1hbmQnLCAncmlnaHRTZWdtZW50UG9saWNlUHJlY2luY3QnLCAncmlnaHRTZWdtZW50UG9saWNlU2VjdG9yJywgJ3JpZ2h0U2VnbWVudFB1bWFDb2RlJywgJ3JpZ2h0U2VnbWVudFppcENvZGUnLCAncm9hZHdheVR5cGUnLCAncnBhZEJ1aWxkaW5nQ2xhc3NpZmljYXRpb25Db2RlJywgJ3JwYWRTZWxmQ2hlY2tDb2RlRm9yQmJsJywgJ3NhbmJvcm5Cb3JvdWdoQ29kZScsICdzYW5ib3JuQm9yb3VnaENvZGUxJywgJ3NhbmJvcm5Cb3JvdWdoQ29kZTInLCAnc2FuYm9yblBhZ2VOdW1iZXInLCAnc2FuYm9yblBhZ2VOdW1iZXIxJywgJ3NhbmJvcm5QYWdlTnVtYmVyMicsICdzYW5ib3JuVm9sdW1lTnVtYmVyJywgJ3NhbmJvcm5Wb2x1bWVOdW1iZXIxJywgJ3NhbmJvcm5Wb2x1bWVOdW1iZXIyJywgJ3NhbmJvcm5Wb2x1bWVOdW1iZXJTdWZmaXgnLCAnc2FuYm9yblZvbHVtZU51bWJlclN1ZmZpeDEnLCAnc2FuYm9yblZvbHVtZU51bWJlclN1ZmZpeDInLCAnc2FuaXRhdGlvbkJ1bGtQaWNrdXBTY2hlZHVsZScsICdzYW5pdGF0aW9uQ29sbGVjdGlvblNjaGVkdWxpbmdTZWN0aW9uQW5kU3Vic2VjdGlvbicsICdzYW5pdGF0aW9uRGlzdHJpY3QnLCAnc2FuaXRhdGlvblJlY3ljbGluZ0NvbGxlY3Rpb25TY2hlZHVsZScsICdzYW5pdGF0aW9uUmVndWxhckNvbGxlY3Rpb25TY2hlZHVsZScsICdzYW5pdGF0aW9uU2VjdGlvbicsICdzYW5pdGF0aW9uU25vd1ByaW9yaXR5Q29kZScsICdzZWNvbmRTdHJlZXRDb2RlJywgJ3NlY29uZFN0cmVldE5hbWVOb3JtYWxpemVkJywgJ3NlZ21lbnRBemltdXRoJywgJ3NlZ21lbnRJZGVudGlmaWVyJywgJ3NlZ21lbnRMZW5ndGhJbkZlZXQnLCAnc2VnbWVudE9yaWVudGF0aW9uJywgJ3NlZ21lbnRUeXBlQ29kZScsICdzaWRlT2ZTdHJlZXRJbmRpY2F0b3InLCAnc2lkZU9mU3RyZWV0T2ZWYW5pdHlBZGRyZXNzJywgJ3NwZWVkTGltaXQnLCAnc3BsaXRMb3dIb3VzZU51bWJlcicsICdzdGF0ZVNlbmF0b3JpYWxEaXN0cmljdCcsICdzdHJlZXRDb2RlMScsICdzdHJlZXRDb2RlMicsICdzdHJlZXRDb2RlNicsICdzdHJlZXRDb2RlNycsICdzdHJlZXROYW1lMScsICdzdHJlZXROYW1lMUluJywgJ3N0cmVldE5hbWUyJywgJ3N0cmVldE5hbWUySW4nLCAnc3RyZWV0TmFtZTNJbicsICdzdHJlZXROYW1lNicsICdzdHJlZXROYW1lNycsICdzdHJlZXRTdGF0dXMnLCAnc3RyZWV0V2lkdGgnLCAnc3RyZWV0V2lkdGhNYXhpbXVtJywgJ3N0cm9sbGluZ0tleScsICdzdHJvbGxpbmdLZXlCb3JvdWdoQ29kZScsICdzdHJvbGxpbmdLZXlIaWdoSG91c2VOdW1iZXInLCAnc3Ryb2xsaW5nS2V5T25TdHJlZXRDb2RlJywgJ3N0cm9sbGluZ0tleVNpZGVPZlN0cmVldEluZGljYXRvcicsICd0YXhNYXBOdW1iZXJTZWN0aW9uQW5kVm9sdW1lJywgJ3RoaXJkU3RyZWV0Q29kZScsICd0aGlyZFN0cmVldE5hbWVOb3JtYWxpemVkJywgJ3RvQWN0dWFsU2VnbWVudE5vZGVJZCcsICd0b0xnYzEnLCAndG9MaW9uTm9kZUlkJywgJ3RvTm9kZScsICd0b1ByZWZlcnJlZExnY3NGaXJzdFNldE9mNScsICd0b1hDb29yZGluYXRlJywgJ3RvWUNvb3JkaW5hdGUnLCAndHJhZmZpY0RpcmVjdGlvbicsICd1bmRlcmx5aW5nU3RyZWV0Q29kZScsICd1c3BzUHJlZmVycmVkQ2l0eU5hbWUnLCAnd29ya0FyZWFGb3JtYXRJbmRpY2F0b3JJbicsICd4Q29vcmRBY3R1YWxTZWdtZW50SGlnaEFkZHJlc3NFbmQnLCAneENvb3JkQWN0dWFsU2VnbWVudExvd0FkZHJlc3NFbmQnLCAneENvb3JkaW5hdGUnLCAneENvb3JkaW5hdGVIaWdoQWRkcmVzc0VuZCcsICd4Q29vcmRpbmF0ZUxvd0FkZHJlc3NFbmQnLCAneENvb3JkaW5hdGVPZkNlbnRlcm9mQ3VydmF0dXJlJywgJ3lDb29yZEFjdHVhbFNlZ21lbnRIaWdoQWRkcmVzc0VuZCcsICd5Q29vcmRBY3R1YWxTZWdtZW50TG93QWRkcmVzc0VuZCcsICd5Q29vcmRpbmF0ZScsICd5Q29vcmRpbmF0ZUhpZ2hBZGRyZXNzRW5kJywgJ3lDb29yZGluYXRlTG93QWRkcmVzc0VuZCcsICd5Q29vcmRpbmF0ZU9mQ2VudGVyb2ZDdXJ2YXR1cmUnLCAnemlwQ29kZSddXG5jb25zdCBBUElfQ0hPSUNFUyA9IFtcbiAge25hbWU6ICdnZW8tYXBpJywgbGFiZWw6ICdOWUMgR2VvY2xpZW50JywgdmFsdWVzOiBbJ255YyddLCBjaGVja2VkOiB0cnVlfSxcbiAge25hbWU6ICdnZW8tYXBpJywgbGFiZWw6ICdDZW5zdXMnLCB2YWx1ZXM6IFsnY2Vuc3VzJ119XG5dXG5jb25zdCBIVE1MID0gYDxkaXYgaWQ9XCJ0YWJzXCI+XG4gIDxkaXYgaWQ9XCJ0YWItY29uZlwiPlxuICAgIDxsYWJlbCBjbGFzcz1cImNvbmZcIiBmb3I9XCJ1cmxcIj5HZW9jb2RlcjwvbGFiZWw+XG4gICAgPGRpdiBpZD1cImdlby1hcGlcIj48L2Rpdj5cbiAgICA8bGFiZWwgY2xhc3M9XCJjb25mXCIgZm9yPVwidGVtcGxhdGVcIj5HZW9jb2RlLWFibGUgbG9jYXRpb24gZGVmaW5pdGlvbjwvbGFiZWw+XG4gICAgPGlucHV0IGlkPVwidGVtcGxhdGVcIiBjbGFzcz1cInJhZC1hbGxcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiRWcuICYjMzY7e0FkZHJDb2x9LCAmIzM2O3tDaXR5Q29sfSwgJiMzNjt7WmlwQ29sfVwiPlxuICAgIDxkaXYgaWQ9XCJvbi1pbnRlcnZcIj48L2Rpdj5cbiAgICA8bGFiZWwgY2xhc3M9XCJjb25mIGdjXCIgZm9yPVwidXJsXCI+R2VvY2xpZW50IGVuZHBvaW50PC9sYWJlbD5cbiAgICA8aW5wdXQgaWQ9XCJ1cmxcIiBjbGFzcz1cInJhZC1hbGwgZ2NcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiRWcuIGh0dHBzOi8vbWFwcy5ueWMuZ292L2dlb2NsaWVudC92MVwiPlxuICAgIDxsYWJlbCBjbGFzcz1cImNvbmYgZ2NcIiBmb3I9XCJpZFwiPkdlb2NsaWVudCBBcHAgSUQ8L2xhYmVsPlxuICAgIDxpbnB1dCBpZD1cImlkXCIgY2xhc3M9XCJyYWQtYWxsIGdjXCIgdHlwZT1cInRleHRcIj5cbiAgICA8bGFiZWwgY2xhc3M9XCJjb25mIGdjXCIgZm9yPVwia2V5XCI+R2VvY2xpZW50IEFwcCBLZXk8L2xhYmVsPlxuICAgIDxpbnB1dCBpZD1cImtleVwiIGNsYXNzPVwicmFkLWFsbCBnY1wiIHR5cGU9XCJ0ZXh0XCI+XG4gICAgPGxhYmVsIGNsYXNzPVwiY29uZiBnY1wiIGZvcj1cImdlby1maWVsZHNcIj5Qb3NzaWJsZSBHZW9jb2RlZCB2YWx1ZXMgdG8gYXBwZW5kIChpZiBhdmFpbGFibGUpPC9sYWJlbD5cbiAgICA8ZGl2IGlkPVwiZ2VvLWZpZWxkc1wiIGNsYXNzPVwiZ2NcIj48L2Rpdj5cbiAgPC9kaXY+XG4gIDxkaXYgaWQ9XCJ0YWItbWFwXCI+XG4gICAgPGJ1dHRvbiBpZD1cImdlb2NvZGVcIiBjbGFzcz1cImJ0biBidG4tc3EgcmFkLWFsbFwiIHRpdGxlPVwiR2VvY29kZSBzaGVldFwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJzY3JlZW4tcmVhZGVyLW9ubHlcIj5HZW9jb2RlIHNoZWV0PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIDxzZWxlY3QgaWQ9XCJyZXZpZXdcIiBjbGFzcz1cImJ0biByYWQtYWxsXCI+XG4gICAgICA8b3B0aW9uIHZhbHVlPVwiLTFcIj5SZXZpZXcgMCBGYWlsdXJlczwvb3B0aW9uPlxuICAgIDwvc2VsZWN0PlxuICAgIDxidXR0b24gaWQ9XCJyZXNldFwiIGNsYXNzPVwiYnRuIGJ0bi1zcSByYWQtYWxsXCIgdGl0bGU9XCJSZXNldCBtYXBcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzY3JlZW4tcmVhZGVyLW9ubHlcIj5SZXNldCBtYXA8L3NwYW4+XG4gICAgPC9idXR0b24+XG4gICAgPGRpdiBpZD1cIm1hcFwiIGNsYXNzPVwicmFkLWFsbFwiPjwvZGl2PlxuICAgIDxidXR0b24gaWQ9XCJkb3dubG9hZFwiIGNsYXNzPVwiYnRuIGJ0bi1zcSByYWQtYWxsXCIgdGl0bGU9XCJEb3dubG9hZCBHZW9KU09OXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cInNjcmVlbi1yZWFkZXItb25seVwiPkRvd25sb2FkIEdlb0pTT048L3NwYW4+XG4gICAgPC9idXR0b24+XG4gIDwvZGl2PiAgXG48L2Rpdj5gXG5cbkFwcC5QT1NTSUJMRV9GSUVMRFMgPSBQT1NTSUJMRV9GSUVMRFNcblxuZXhwb3J0IGRlZmF1bHQgQXBwIiwiaW1wb3J0IEFwcCBmcm9tIFwiLi9BcHBcIlxuXG53aW5kb3cuYXBwID0gbmV3IEFwcCgpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQ0E7QUE4Q0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFWQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTEE7QUFLQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBM0dBO0FBQ0E7QUE2R0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEhBOzs7QUFHQTtBQUNBOzs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBO0FBTUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBQ0E7QUFBQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUVBOzs7OztBQUlBO0FBRUE7Ozs7O0FBSUE7QUFFQTs7Ozs7QUFJQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FDeGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSEE7QUFOQTtBQVlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJBOzs7QUFJQTs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7Ozs7O0FBYUE7O0FBbENBO0FBQ0E7QUFxQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBaUNBO0FBRUE7O0FDcFNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///149\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/ImageState.js\nvar ImageState = __webpack_require__(22);\n\n// EXTERNAL MODULE: ./node_modules/ol/asserts.js\nvar asserts = __webpack_require__(11);\n\n// EXTERNAL MODULE: ./node_modules/ol/color.js\nvar ol_color = __webpack_require__(37);\n\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar EventType = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./node_modules/ol/style/IconAnchorUnits.js\n/**\n * @module ol/style/IconAnchorUnits\n */\n\n/**\n * Icon anchor units. One of \'fraction\', \'pixels\'.\n * @enum {string}\n */\n/* harmony default export */ var IconAnchorUnits = ({\n  FRACTION: \'fraction\',\n  PIXELS: \'pixels\'\n});\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/Target.js\nvar Target = __webpack_require__(44);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/IconImageCache.js\nvar IconImageCache = __webpack_require__(80);\n\n// CONCATENATED MODULE: ./node_modules/ol/style/IconImage.js\n/**\n * @module ol/style/IconImage\n */\n\n\n\n\n\n\n\nvar IconImage_IconImage =\n/*@__PURE__*/\nfunction (EventTarget) {\n  function IconImage(image, src, size, crossOrigin, imageState, color) {\n    EventTarget.call(this);\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n\n    this.hitDetectionImage_ = null;\n    /**\n     * @private\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n\n    this.image_ = !image ? new Image() : image;\n\n    if (crossOrigin !== null) {\n      /** @type {HTMLImageElement} */\n      this.image_.crossOrigin = crossOrigin;\n    }\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n\n    this.canvas_ = color ?\n    /** @type {HTMLCanvasElement} */\n    document.createElement(\'canvas\') : null;\n    /**\n     * @private\n     * @type {import("../color.js").Color}\n     */\n\n    this.color_ = color;\n    /**\n     * @private\n     * @type {Array<import("../events.js").EventsKey>}\n     */\n\n    this.imageListenerKeys_ = null;\n    /**\n     * @private\n     * @type {import("../ImageState.js").default}\n     */\n\n    this.imageState_ = imageState;\n    /**\n     * @private\n     * @type {import("../size.js").Size}\n     */\n\n    this.size_ = size;\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n\n    this.src_ = src;\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n\n    this.tainted_;\n  }\n\n  if (EventTarget) IconImage.__proto__ = EventTarget;\n  IconImage.prototype = Object.create(EventTarget && EventTarget.prototype);\n  IconImage.prototype.constructor = IconImage;\n  /**\n   * @private\n   * @return {boolean} The image canvas is tainted.\n   */\n\n  IconImage.prototype.isTainted_ = function isTainted_() {\n    if (this.tainted_ === undefined && this.imageState_ === ImageState["a" /* default */].LOADED) {\n      this.tainted_ = false;\n      var context = Object(dom["a" /* createCanvasContext2D */])(1, 1);\n\n      try {\n        context.drawImage(this.image_, 0, 0);\n        context.getImageData(0, 0, 1, 1);\n      } catch (e) {\n        this.tainted_ = true;\n      }\n    }\n\n    return this.tainted_ === true;\n  };\n  /**\n   * @private\n   */\n\n\n  IconImage.prototype.dispatchChangeEvent_ = function dispatchChangeEvent_() {\n    this.dispatchEvent(EventType["a" /* default */].CHANGE);\n  };\n  /**\n   * @private\n   */\n\n\n  IconImage.prototype.handleImageError_ = function handleImageError_() {\n    this.imageState_ = ImageState["a" /* default */].ERROR;\n    this.unlistenImage_();\n    this.dispatchChangeEvent_();\n  };\n  /**\n   * @private\n   */\n\n\n  IconImage.prototype.handleImageLoad_ = function handleImageLoad_() {\n    this.imageState_ = ImageState["a" /* default */].LOADED;\n\n    if (this.size_) {\n      this.image_.width = this.size_[0];\n      this.image_.height = this.size_[1];\n    }\n\n    this.size_ = [this.image_.width, this.image_.height];\n    this.unlistenImage_();\n    this.replaceColor_();\n    this.dispatchChangeEvent_();\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.\n   */\n\n\n  IconImage.prototype.getImage = function getImage(pixelRatio) {\n    return this.canvas_ ? this.canvas_ : this.image_;\n  };\n  /**\n   * @return {import("../ImageState.js").default} Image state.\n   */\n\n\n  IconImage.prototype.getImageState = function getImageState() {\n    return this.imageState_;\n  };\n  /**\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLImageElement|HTMLCanvasElement} Image element.\n   */\n\n\n  IconImage.prototype.getHitDetectionImage = function getHitDetectionImage(pixelRatio) {\n    if (!this.hitDetectionImage_) {\n      if (this.isTainted_()) {\n        var width = this.size_[0];\n        var height = this.size_[1];\n        var context = Object(dom["a" /* createCanvasContext2D */])(width, height);\n        context.fillRect(0, 0, width, height);\n        this.hitDetectionImage_ = context.canvas;\n      } else {\n        this.hitDetectionImage_ = this.image_;\n      }\n    }\n\n    return this.hitDetectionImage_;\n  };\n  /**\n   * @return {import("../size.js").Size} Image size.\n   */\n\n\n  IconImage.prototype.getSize = function getSize() {\n    return this.size_;\n  };\n  /**\n   * @return {string|undefined} Image src.\n   */\n\n\n  IconImage.prototype.getSrc = function getSrc() {\n    return this.src_;\n  };\n  /**\n   * Load not yet loaded URI.\n   */\n\n\n  IconImage.prototype.load = function load() {\n    if (this.imageState_ == ImageState["a" /* default */].IDLE) {\n      this.imageState_ = ImageState["a" /* default */].LOADING;\n      this.imageListenerKeys_ = [Object(events["b" /* listenOnce */])(this.image_, EventType["a" /* default */].ERROR, this.handleImageError_, this), Object(events["b" /* listenOnce */])(this.image_, EventType["a" /* default */].LOAD, this.handleImageLoad_, this)];\n\n      try {\n        /** @type {HTMLImageElement} */\n        this.image_.src = this.src_;\n      } catch (e) {\n        this.handleImageError_();\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  IconImage.prototype.replaceColor_ = function replaceColor_() {\n    if (!this.color_ || this.isTainted_()) {\n      return;\n    }\n\n    this.canvas_.width = this.image_.width;\n    this.canvas_.height = this.image_.height;\n    var ctx = this.canvas_.getContext(\'2d\');\n    ctx.drawImage(this.image_, 0, 0);\n    var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);\n    var data = imgData.data;\n    var r = this.color_[0] / 255.0;\n    var g = this.color_[1] / 255.0;\n    var b = this.color_[2] / 255.0;\n\n    for (var i = 0, ii = data.length; i < ii; i += 4) {\n      data[i] *= r;\n      data[i + 1] *= g;\n      data[i + 2] *= b;\n    }\n\n    ctx.putImageData(imgData, 0, 0);\n  };\n  /**\n   * Discards event handlers which listen for load completion or errors.\n   *\n   * @private\n   */\n\n\n  IconImage.prototype.unlistenImage_ = function unlistenImage_() {\n    this.imageListenerKeys_.forEach(events["e" /* unlistenByKey */]);\n    this.imageListenerKeys_ = null;\n  };\n\n  return IconImage;\n}(Target["a" /* default */]);\n/**\n * @param {HTMLImageElement|HTMLCanvasElement} image Image.\n * @param {string} src Src.\n * @param {import("../size.js").Size} size Size.\n * @param {?string} crossOrigin Cross origin.\n * @param {import("../ImageState.js").default} imageState Image state.\n * @param {import("../color.js").Color} color Color.\n * @return {IconImage} Icon image.\n */\n\n\nfunction get(image, src, size, crossOrigin, imageState, color) {\n  var iconImage = IconImageCache["a" /* shared */].get(src, crossOrigin, color);\n\n  if (!iconImage) {\n    iconImage = new IconImage_IconImage(image, src, size, crossOrigin, imageState, color);\n    IconImageCache["a" /* shared */].set(src, crossOrigin, color, iconImage);\n  }\n\n  return iconImage;\n}\n/* harmony default export */ var style_IconImage = (IconImage_IconImage);\n// CONCATENATED MODULE: ./node_modules/ol/style/IconOrigin.js\n/**\n * @module ol/style/IconOrigin\n */\n\n/**\n * Icon origin. One of \'bottom-left\', \'bottom-right\', \'top-left\', \'top-right\'.\n * @enum {string}\n */\n/* harmony default export */ var IconOrigin = ({\n  BOTTOM_LEFT: \'bottom-left\',\n  BOTTOM_RIGHT: \'bottom-right\',\n  TOP_LEFT: \'top-left\',\n  TOP_RIGHT: \'top-right\'\n});\n// EXTERNAL MODULE: ./node_modules/ol/style/Image.js\nvar style_Image = __webpack_require__(91);\n\n// CONCATENATED MODULE: ./node_modules/ol/style/Icon.js\n/**\n * @module ol/style/Icon\n */\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.\n * @property {import("./IconOrigin.js").default} [anchorOrigin] Origin of the anchor: `bottom-left`, `bottom-right`,\n * `top-left` or `top-right`. Default is `top-left`.\n * @property {import("./IconAnchorUnits.js").default} [anchorXUnits] Units in which the anchor x value is\n * specified. A value of `\'fraction\'` indicates the x value is a fraction of the icon. A value of `\'pixels\'` indicates\n * the x value in pixels. Default is `\'fraction\'`.\n * @property {import("./IconAnchorUnits.js").default} [anchorYUnits] Units in which the anchor y value is\n * specified. A value of `\'fraction\'` indicates the y value is a fraction of the icon. A value of `\'pixels\'` indicates\n * the y value in pixels. Default is `\'fraction\'`.\n * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,\n * the icon will be left as is.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `crossOrigin` value if you are using the WebGL renderer or if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the\n * provided image must already be loaded. And in that case, it is required\n * to provide the size of the image, with the `imgSize` option.\n * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the\n * sub-rectangle to use from the original icon image.\n * @property {import("./IconOrigin.js").default} [offsetOrigin] Origin of the offset: `bottom-left`, `bottom-right`,\n * `top-left` or `top-right`. Default is `top-left`.\n * @property {number} [opacity=1] Opacity of the icon.\n * @property {number} [scale=1] Scale.\n * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the\n * sub-rectangle to use from the origin (sprite) icon image.\n * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and\n * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.\n * @property {string} [src] Image source URI.\n */\n\n/**\n * @classdesc\n * Set icon style for vector features.\n * @api\n */\n\nvar Icon_Icon =\n/*@__PURE__*/\nfunction (ImageStyle) {\n  function Icon(opt_options) {\n    var options = opt_options || {};\n    /**\n     * @type {number}\n     */\n\n    var opacity = options.opacity !== undefined ? options.opacity : 1;\n    /**\n     * @type {number}\n     */\n\n    var rotation = options.rotation !== undefined ? options.rotation : 0;\n    /**\n     * @type {number}\n     */\n\n    var scale = options.scale !== undefined ? options.scale : 1;\n    /**\n     * @type {boolean}\n     */\n\n    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;\n    ImageStyle.call(this, {\n      opacity: opacity,\n      rotation: rotation,\n      scale: scale,\n      rotateWithView: rotateWithView\n    });\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.normalizedAnchor_ = null;\n    /**\n     * @private\n     * @type {import("./IconOrigin.js").default}\n     */\n\n    this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : IconOrigin.TOP_LEFT;\n    /**\n     * @private\n     * @type {import("./IconAnchorUnits.js").default}\n     */\n\n    this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : IconAnchorUnits.FRACTION;\n    /**\n     * @private\n     * @type {import("./IconAnchorUnits.js").default}\n     */\n\n    this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : IconAnchorUnits.FRACTION;\n    /**\n     * @private\n     * @type {?string}\n     */\n\n    this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;\n    /**\n     * @type {HTMLImageElement|HTMLCanvasElement}\n     */\n\n    var image = options.img !== undefined ? options.img : null;\n    /**\n     * @type {import("../size.js").Size}\n     */\n\n    var imgSize = options.imgSize !== undefined ? options.imgSize : null;\n    /**\n     * @type {string|undefined}\n     */\n\n    var src = options.src;\n    Object(asserts["a" /* assert */])(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time\n\n    Object(asserts["a" /* assert */])(!image || image && imgSize, 5); // `imgSize` must be set when `image` is provided\n\n    if ((src === undefined || src.length === 0) && image) {\n      src =\n      /** @type {HTMLImageElement} */\n      image.src || Object(util["c" /* getUid */])(image);\n    }\n\n    Object(asserts["a" /* assert */])(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided\n\n    /**\n     * @type {import("../ImageState.js").default}\n     */\n\n    var imageState = options.src !== undefined ? ImageState["a" /* default */].IDLE : ImageState["a" /* default */].LOADED;\n    /**\n     * @private\n     * @type {import("../color.js").Color}\n     */\n\n    this.color_ = options.color !== undefined ? Object(ol_color["a" /* asArray */])(options.color) : null;\n    /**\n     * @private\n     * @type {import("./IconImage.js").default}\n     */\n\n    this.iconImage_ = get(image,\n    /** @type {string} */\n    src, imgSize, this.crossOrigin_, imageState, this.color_);\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.offset_ = options.offset !== undefined ? options.offset : [0, 0];\n    /**\n     * @private\n     * @type {import("./IconOrigin.js").default}\n     */\n\n    this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : IconOrigin.TOP_LEFT;\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n\n    this.origin_ = null;\n    /**\n     * @private\n     * @type {import("../size.js").Size}\n     */\n\n    this.size_ = options.size !== undefined ? options.size : null;\n  }\n\n  if (ImageStyle) Icon.__proto__ = ImageStyle;\n  Icon.prototype = Object.create(ImageStyle && ImageStyle.prototype);\n  Icon.prototype.constructor = Icon;\n  /**\n   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.\n   * @return {Icon} The cloned style.\n   * @api\n   */\n\n  Icon.prototype.clone = function clone() {\n    return new Icon({\n      anchor: this.anchor_.slice(),\n      anchorOrigin: this.anchorOrigin_,\n      anchorXUnits: this.anchorXUnits_,\n      anchorYUnits: this.anchorYUnits_,\n      crossOrigin: this.crossOrigin_,\n      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,\n      src: this.getSrc(),\n      offset: this.offset_.slice(),\n      offsetOrigin: this.offsetOrigin_,\n      size: this.size_ !== null ? this.size_.slice() : undefined,\n      opacity: this.getOpacity(),\n      scale: this.getScale(),\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView()\n    });\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Icon.prototype.getAnchor = function getAnchor() {\n    if (this.normalizedAnchor_) {\n      return this.normalizedAnchor_;\n    }\n\n    var anchor = this.anchor_;\n    var size = this.getSize();\n\n    if (this.anchorXUnits_ == IconAnchorUnits.FRACTION || this.anchorYUnits_ == IconAnchorUnits.FRACTION) {\n      if (!size) {\n        return null;\n      }\n\n      anchor = this.anchor_.slice();\n\n      if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {\n        anchor[0] *= size[0];\n      }\n\n      if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {\n        anchor[1] *= size[1];\n      }\n    }\n\n    if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {\n      if (!size) {\n        return null;\n      }\n\n      if (anchor === this.anchor_) {\n        anchor = this.anchor_.slice();\n      }\n\n      if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {\n        anchor[0] = -anchor[0] + size[0];\n      }\n\n      if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {\n        anchor[1] = -anchor[1] + size[1];\n      }\n    }\n\n    this.normalizedAnchor_ = anchor;\n    return this.normalizedAnchor_;\n  };\n  /**\n   * Set the anchor point. The anchor determines the center point for the\n   * symbolizer.\n   *\n   * @param {Array<number>} anchor Anchor.\n   * @api\n   */\n\n\n  Icon.prototype.setAnchor = function setAnchor(anchor) {\n    this.anchor_ = anchor;\n    this.normalizedAnchor_ = null;\n  };\n  /**\n   * Get the icon color.\n   * @return {import("../color.js").Color} Color.\n   * @api\n   */\n\n\n  Icon.prototype.getColor = function getColor() {\n    return this.color_;\n  };\n  /**\n   * Get the image icon.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.\n   * @override\n   * @api\n   */\n\n\n  Icon.prototype.getImage = function getImage(pixelRatio) {\n    return this.iconImage_.getImage(pixelRatio);\n  };\n  /**\n   * @override\n   */\n\n\n  Icon.prototype.getImageSize = function getImageSize() {\n    return this.iconImage_.getSize();\n  };\n  /**\n   * @override\n   */\n\n\n  Icon.prototype.getHitDetectionImageSize = function getHitDetectionImageSize() {\n    return this.getImageSize();\n  };\n  /**\n   * @override\n   */\n\n\n  Icon.prototype.getImageState = function getImageState() {\n    return this.iconImage_.getImageState();\n  };\n  /**\n   * @override\n   */\n\n\n  Icon.prototype.getHitDetectionImage = function getHitDetectionImage(pixelRatio) {\n    return this.iconImage_.getHitDetectionImage(pixelRatio);\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Icon.prototype.getOrigin = function getOrigin() {\n    if (this.origin_) {\n      return this.origin_;\n    }\n\n    var offset = this.offset_;\n\n    if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {\n      var size = this.getSize();\n      var iconImageSize = this.iconImage_.getSize();\n\n      if (!size || !iconImageSize) {\n        return null;\n      }\n\n      offset = offset.slice();\n\n      if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {\n        offset[0] = iconImageSize[0] - size[0] - offset[0];\n      }\n\n      if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {\n        offset[1] = iconImageSize[1] - size[1] - offset[1];\n      }\n    }\n\n    this.origin_ = offset;\n    return this.origin_;\n  };\n  /**\n   * Get the image URL.\n   * @return {string|undefined} Image src.\n   * @api\n   */\n\n\n  Icon.prototype.getSrc = function getSrc() {\n    return this.iconImage_.getSrc();\n  };\n  /**\n   * @inheritDoc\n   * @api\n   */\n\n\n  Icon.prototype.getSize = function getSize() {\n    return !this.size_ ? this.iconImage_.getSize() : this.size_;\n  };\n  /**\n   * @override\n   */\n\n\n  Icon.prototype.listenImageChange = function listenImageChange(listener, thisArg) {\n    return Object(events["a" /* listen */])(this.iconImage_, EventType["a" /* default */].CHANGE, listener, thisArg);\n  };\n  /**\n   * Load not yet loaded URI.\n   * When rendering a feature with an icon style, the vector renderer will\n   * automatically call this method. However, you might want to call this\n   * method yourself for preloading or other purposes.\n   * @override\n   * @api\n   */\n\n\n  Icon.prototype.load = function load() {\n    this.iconImage_.load();\n  };\n  /**\n   * @override\n   */\n\n\n  Icon.prototype.unlistenImageChange = function unlistenImageChange(listener, thisArg) {\n    Object(events["c" /* unlisten */])(this.iconImage_, EventType["a" /* default */].CHANGE, listener, thisArg);\n  };\n\n  return Icon;\n}(style_Image["a" /* default */]);\n\n/* harmony default export */ var style_Icon = __webpack_exports__["default"] = (Icon_Icon);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9zdHlsZS9JY29uQW5jaG9yVW5pdHMuanM/NjlkOSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL29sL3N0eWxlL0ljb25JbWFnZS5qcz84MGEwIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc3R5bGUvSWNvbk9yaWdpbi5qcz9iY2E1Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvc3R5bGUvSWNvbi5qcz8xOGJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JY29uQW5jaG9yVW5pdHNcbiAqL1xuXG4vKipcbiAqIEljb24gYW5jaG9yIHVuaXRzLiBPbmUgb2YgJ2ZyYWN0aW9uJywgJ3BpeGVscycuXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIEZSQUNUSU9OOiAnZnJhY3Rpb24nLFxuICBQSVhFTFM6ICdwaXhlbHMnXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ljb25JbWFnZVxuICovXG5cbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW5PbmNlLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL2V2ZW50cy9UYXJnZXQuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBJbWFnZVN0YXRlIGZyb20gJy4uL0ltYWdlU3RhdGUuanMnO1xuaW1wb3J0IHtzaGFyZWQgYXMgaWNvbkltYWdlQ2FjaGV9IGZyb20gJy4vSWNvbkltYWdlQ2FjaGUuanMnO1xuXG5jbGFzcyBJY29uSW1hZ2UgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IGltYWdlIEltYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHNyYyBTcmMuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfSBzaXplIFNpemUuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ltYWdlU3RhdGUuanNcIikuZGVmYXVsdH0gaW1hZ2VTdGF0ZSBJbWFnZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gY29sb3IgQ29sb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihpbWFnZSwgc3JjLCBzaXplLCBjcm9zc09yaWdpbiwgaW1hZ2VTdGF0ZSwgY29sb3IpIHtcblxuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5pbWFnZV8gPSAhaW1hZ2UgPyBuZXcgSW1hZ2UoKSA6IGltYWdlO1xuXG4gICAgaWYgKGNyb3NzT3JpZ2luICE9PSBudWxsKSB7XG4gICAgICAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovICh0aGlzLmltYWdlXykuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNhbnZhc18gPSBjb2xvciA/XG4gICAgICAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpIDpcbiAgICAgIG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yXyA9IGNvbG9yO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8aW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5pbWFnZUxpc3RlbmVyS2V5c18gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBpbWFnZVN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vc2l6ZS5qc1wiKS5TaXplfVxuICAgICAqL1xuICAgIHRoaXMuc2l6ZV8gPSBzaXplO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnNyY18gPSBzcmM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaW50ZWRfO1xuXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGltYWdlIGNhbnZhcyBpcyB0YWludGVkLlxuICAgKi9cbiAgaXNUYWludGVkXygpIHtcbiAgICBpZiAodGhpcy50YWludGVkXyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuaW1hZ2VTdGF0ZV8gPT09IEltYWdlU3RhdGUuTE9BREVEKSB7XG4gICAgICB0aGlzLnRhaW50ZWRfID0gZmFsc2U7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKDEsIDEpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGhpcy5pbWFnZV8sIDAsIDApO1xuICAgICAgICBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy50YWludGVkXyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhaW50ZWRfID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaENoYW5nZUV2ZW50XygpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRUeXBlLkNIQU5HRSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlRXJyb3JfKCkge1xuICAgIHRoaXMuaW1hZ2VTdGF0ZV8gPSBJbWFnZVN0YXRlLkVSUk9SO1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLmRpc3BhdGNoQ2hhbmdlRXZlbnRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUltYWdlTG9hZF8oKSB7XG4gICAgdGhpcy5pbWFnZVN0YXRlXyA9IEltYWdlU3RhdGUuTE9BREVEO1xuICAgIGlmICh0aGlzLnNpemVfKSB7XG4gICAgICB0aGlzLmltYWdlXy53aWR0aCA9IHRoaXMuc2l6ZV9bMF07XG4gICAgICB0aGlzLmltYWdlXy5oZWlnaHQgPSB0aGlzLnNpemVfWzFdO1xuICAgIH1cbiAgICB0aGlzLnNpemVfID0gW3RoaXMuaW1hZ2VfLndpZHRoLCB0aGlzLmltYWdlXy5oZWlnaHRdO1xuICAgIHRoaXMudW5saXN0ZW5JbWFnZV8oKTtcbiAgICB0aGlzLnJlcGxhY2VDb2xvcl8oKTtcbiAgICB0aGlzLmRpc3BhdGNoQ2hhbmdlRXZlbnRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IEltYWdlIG9yIENhbnZhcyBlbGVtZW50LlxuICAgKi9cbiAgZ2V0SW1hZ2UocGl4ZWxSYXRpbykge1xuICAgIHJldHVybiB0aGlzLmNhbnZhc18gPyB0aGlzLmNhbnZhc18gOiB0aGlzLmltYWdlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IEltYWdlIHN0YXRlLlxuICAgKi9cbiAgZ2V0SW1hZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVN0YXRlXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyBQaXhlbCByYXRpby5cbiAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gSW1hZ2UgZWxlbWVudC5cbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICBpZiAoIXRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfKSB7XG4gICAgICBpZiAodGhpcy5pc1RhaW50ZWRfKCkpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemVfWzBdO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemVfWzFdO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhpdERldGVjdGlvbkltYWdlXyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaXREZXRlY3Rpb25JbWFnZV8gPSB0aGlzLmltYWdlXztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGl0RGV0ZWN0aW9uSW1hZ2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gSW1hZ2Ugc2l6ZS5cbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZV87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH0gSW1hZ2Ugc3JjLlxuICAgKi9cbiAgZ2V0U3JjKCkge1xuICAgIHJldHVybiB0aGlzLnNyY187XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqL1xuICBsb2FkKCkge1xuICAgIGlmICh0aGlzLmltYWdlU3RhdGVfID09IEltYWdlU3RhdGUuSURMRSkge1xuICAgICAgdGhpcy5pbWFnZVN0YXRlXyA9IEltYWdlU3RhdGUuTE9BRElORztcbiAgICAgIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gW1xuICAgICAgICBsaXN0ZW5PbmNlKHRoaXMuaW1hZ2VfLCBFdmVudFR5cGUuRVJST1IsXG4gICAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUVycm9yXywgdGhpcyksXG4gICAgICAgIGxpc3Rlbk9uY2UodGhpcy5pbWFnZV8sIEV2ZW50VHlwZS5MT0FELFxuICAgICAgICAgIHRoaXMuaGFuZGxlSW1hZ2VMb2FkXywgdGhpcylcbiAgICAgIF07XG4gICAgICB0cnkge1xuICAgICAgICAvKiogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR9ICovICh0aGlzLmltYWdlXykuc3JjID0gdGhpcy5zcmNfO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUltYWdlRXJyb3JfKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZXBsYWNlQ29sb3JfKCkge1xuICAgIGlmICghdGhpcy5jb2xvcl8gfHwgdGhpcy5pc1RhaW50ZWRfKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhc18ud2lkdGggPSB0aGlzLmltYWdlXy53aWR0aDtcbiAgICB0aGlzLmNhbnZhc18uaGVpZ2h0ID0gdGhpcy5pbWFnZV8uaGVpZ2h0O1xuXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXNfLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlXywgMCwgMCk7XG5cbiAgICBjb25zdCBpbWdEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLmltYWdlXy53aWR0aCwgdGhpcy5pbWFnZV8uaGVpZ2h0KTtcbiAgICBjb25zdCBkYXRhID0gaW1nRGF0YS5kYXRhO1xuICAgIGNvbnN0IHIgPSB0aGlzLmNvbG9yX1swXSAvIDI1NS4wO1xuICAgIGNvbnN0IGcgPSB0aGlzLmNvbG9yX1sxXSAvIDI1NS4wO1xuICAgIGNvbnN0IGIgPSB0aGlzLmNvbG9yX1syXSAvIDI1NS4wO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICBkYXRhW2ldICo9IHI7XG4gICAgICBkYXRhW2kgKyAxXSAqPSBnO1xuICAgICAgZGF0YVtpICsgMl0gKj0gYjtcbiAgICB9XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkcyBldmVudCBoYW5kbGVycyB3aGljaCBsaXN0ZW4gZm9yIGxvYWQgY29tcGxldGlvbiBvciBlcnJvcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bmxpc3RlbkltYWdlXygpIHtcbiAgICB0aGlzLmltYWdlTGlzdGVuZXJLZXlzXy5mb3JFYWNoKHVubGlzdGVuQnlLZXkpO1xuICAgIHRoaXMuaW1hZ2VMaXN0ZW5lcktleXNfID0gbnVsbDtcbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBpbWFnZSBJbWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU3JjLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IHNpemUgU2l6ZS5cbiAqIEBwYXJhbSB7P3N0cmluZ30gY3Jvc3NPcmlnaW4gQ3Jvc3Mgb3JpZ2luLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9JbWFnZVN0YXRlLmpzXCIpLmRlZmF1bHR9IGltYWdlU3RhdGUgSW1hZ2Ugc3RhdGUuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbG9yLmpzXCIpLkNvbG9yfSBjb2xvciBDb2xvci5cbiAqIEByZXR1cm4ge0ljb25JbWFnZX0gSWNvbiBpbWFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChpbWFnZSwgc3JjLCBzaXplLCBjcm9zc09yaWdpbiwgaW1hZ2VTdGF0ZSwgY29sb3IpIHtcbiAgbGV0IGljb25JbWFnZSA9IGljb25JbWFnZUNhY2hlLmdldChzcmMsIGNyb3NzT3JpZ2luLCBjb2xvcik7XG4gIGlmICghaWNvbkltYWdlKSB7XG4gICAgaWNvbkltYWdlID0gbmV3IEljb25JbWFnZShpbWFnZSwgc3JjLCBzaXplLCBjcm9zc09yaWdpbiwgaW1hZ2VTdGF0ZSwgY29sb3IpO1xuICAgIGljb25JbWFnZUNhY2hlLnNldChzcmMsIGNyb3NzT3JpZ2luLCBjb2xvciwgaWNvbkltYWdlKTtcbiAgfVxuICByZXR1cm4gaWNvbkltYWdlO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IEljb25JbWFnZTtcbiIsIi8qKlxuICogQG1vZHVsZSBvbC9zdHlsZS9JY29uT3JpZ2luXG4gKi9cblxuLyoqXG4gKiBJY29uIG9yaWdpbi4gT25lIG9mICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0Jy5cbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQk9UVE9NX0xFRlQ6ICdib3R0b20tbGVmdCcsXG4gIEJPVFRPTV9SSUdIVDogJ2JvdHRvbS1yaWdodCcsXG4gIFRPUF9MRUZUOiAndG9wLWxlZnQnLFxuICBUT1BfUklHSFQ6ICd0b3AtcmlnaHQnXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3N0eWxlL0ljb25cbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IEltYWdlU3RhdGUgZnJvbSAnLi4vSW1hZ2VTdGF0ZS5qcyc7XG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vYXNzZXJ0cy5qcyc7XG5pbXBvcnQge2FzQXJyYXl9IGZyb20gJy4uL2NvbG9yLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3Rlbn0gZnJvbSAnLi4vZXZlbnRzLmpzJztcbmltcG9ydCBFdmVudFR5cGUgZnJvbSAnLi4vZXZlbnRzL0V2ZW50VHlwZS5qcyc7XG5pbXBvcnQgSWNvbkFuY2hvclVuaXRzIGZyb20gJy4vSWNvbkFuY2hvclVuaXRzLmpzJztcbmltcG9ydCB7Z2V0IGFzIGdldEljb25JbWFnZX0gZnJvbSAnLi9JY29uSW1hZ2UuanMnO1xuaW1wb3J0IEljb25PcmlnaW4gZnJvbSAnLi9JY29uT3JpZ2luLmpzJztcbmltcG9ydCBJbWFnZVN0eWxlIGZyb20gJy4vSW1hZ2UuanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbYW5jaG9yPVswLjUsIDAuNV1dIEFuY2hvci4gRGVmYXVsdCB2YWx1ZSBpcyB0aGUgaWNvbiBjZW50ZXIuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vSWNvbk9yaWdpbi5qc1wiKS5kZWZhdWx0fSBbYW5jaG9yT3JpZ2luXSBPcmlnaW4gb2YgdGhlIGFuY2hvcjogYGJvdHRvbS1sZWZ0YCwgYGJvdHRvbS1yaWdodGAsXG4gKiBgdG9wLWxlZnRgIG9yIGB0b3AtcmlnaHRgLiBEZWZhdWx0IGlzIGB0b3AtbGVmdGAuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4vSWNvbkFuY2hvclVuaXRzLmpzXCIpLmRlZmF1bHR9IFthbmNob3JYVW5pdHNdIFVuaXRzIGluIHdoaWNoIHRoZSBhbmNob3IgeCB2YWx1ZSBpc1xuICogc3BlY2lmaWVkLiBBIHZhbHVlIG9mIGAnZnJhY3Rpb24nYCBpbmRpY2F0ZXMgdGhlIHggdmFsdWUgaXMgYSBmcmFjdGlvbiBvZiB0aGUgaWNvbi4gQSB2YWx1ZSBvZiBgJ3BpeGVscydgIGluZGljYXRlc1xuICogdGhlIHggdmFsdWUgaW4gcGl4ZWxzLiBEZWZhdWx0IGlzIGAnZnJhY3Rpb24nYC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9JY29uQW5jaG9yVW5pdHMuanNcIikuZGVmYXVsdH0gW2FuY2hvcllVbml0c10gVW5pdHMgaW4gd2hpY2ggdGhlIGFuY2hvciB5IHZhbHVlIGlzXG4gKiBzcGVjaWZpZWQuIEEgdmFsdWUgb2YgYCdmcmFjdGlvbidgIGluZGljYXRlcyB0aGUgeSB2YWx1ZSBpcyBhIGZyYWN0aW9uIG9mIHRoZSBpY29uLiBBIHZhbHVlIG9mIGAncGl4ZWxzJ2AgaW5kaWNhdGVzXG4gKiB0aGUgeSB2YWx1ZSBpbiBwaXhlbHMuIERlZmF1bHQgaXMgYCdmcmFjdGlvbidgLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcnxzdHJpbmd9IFtjb2xvcl0gQ29sb3IgdG8gdGludCB0aGUgaWNvbi4gSWYgbm90IHNwZWNpZmllZCxcbiAqIHRoZSBpY29uIHdpbGwgYmUgbGVmdCBhcyBpcy5cbiAqIEBwcm9wZXJ0eSB7bnVsbHxzdHJpbmd9IFtjcm9zc09yaWdpbl0gVGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIGZvciBsb2FkZWQgaW1hZ2VzLiBOb3RlIHRoYXQgeW91IG11c3QgcHJvdmlkZSBhXG4gKiBgY3Jvc3NPcmlnaW5gIHZhbHVlIGlmIHlvdSBhcmUgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyIG9yIGlmIHlvdSB3YW50IHRvIGFjY2VzcyBwaXhlbCBkYXRhIHdpdGggdGhlIENhbnZhcyByZW5kZXJlci5cbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZSBmb3IgbW9yZSBkZXRhaWwuXG4gKiBAcHJvcGVydHkge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IFtpbWddIEltYWdlIG9iamVjdCBmb3IgdGhlIGljb24uIElmIHRoZSBgc3JjYCBvcHRpb24gaXMgbm90IHByb3ZpZGVkIHRoZW4gdGhlXG4gKiBwcm92aWRlZCBpbWFnZSBtdXN0IGFscmVhZHkgYmUgbG9hZGVkLiBBbmQgaW4gdGhhdCBjYXNlLCBpdCBpcyByZXF1aXJlZFxuICogdG8gcHJvdmlkZSB0aGUgc2l6ZSBvZiB0aGUgaW1hZ2UsIHdpdGggdGhlIGBpbWdTaXplYCBvcHRpb24uXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtvZmZzZXQ9WzAsIDBdXSBPZmZzZXQsIHdoaWNoLCB0b2dldGhlciB3aXRoIHRoZSBzaXplIGFuZCB0aGUgb2Zmc2V0IG9yaWdpbiwgZGVmaW5lIHRoZVxuICogc3ViLXJlY3RhbmdsZSB0byB1c2UgZnJvbSB0aGUgb3JpZ2luYWwgaWNvbiBpbWFnZS5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi9JY29uT3JpZ2luLmpzXCIpLmRlZmF1bHR9IFtvZmZzZXRPcmlnaW5dIE9yaWdpbiBvZiB0aGUgb2Zmc2V0OiBgYm90dG9tLWxlZnRgLCBgYm90dG9tLXJpZ2h0YCxcbiAqIGB0b3AtbGVmdGAgb3IgYHRvcC1yaWdodGAuIERlZmF1bHQgaXMgYHRvcC1sZWZ0YC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbb3BhY2l0eT0xXSBPcGFjaXR5IG9mIHRoZSBpY29uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzY2FsZT0xXSBTY2FsZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JvdGF0ZVdpdGhWaWV3PWZhbHNlXSBXaGV0aGVyIHRvIHJvdGF0ZSB0aGUgaWNvbiB3aXRoIHRoZSB2aWV3LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyb3RhdGlvbj0wXSBSb3RhdGlvbiBpbiByYWRpYW5zIChwb3NpdGl2ZSByb3RhdGlvbiBjbG9ja3dpc2UpLlxuICogQHByb3BlcnR5IHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9IFtzaXplXSBJY29uIHNpemUgaW4gcGl4ZWwuIENhbiBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggYG9mZnNldGAgdG8gZGVmaW5lIHRoZVxuICogc3ViLXJlY3RhbmdsZSB0byB1c2UgZnJvbSB0aGUgb3JpZ2luIChzcHJpdGUpIGljb24gaW1hZ2UuXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX0gW2ltZ1NpemVdIEltYWdlIHNpemUgaW4gcGl4ZWxzLiBPbmx5IHJlcXVpcmVkIGlmIGBpbWdgIGlzIHNldCBhbmQgYHNyY2AgaXMgbm90LCBhbmRcbiAqIGZvciBTVkcgaW1hZ2VzIGluIEludGVybmV0IEV4cGxvcmVyIDExLiBUaGUgcHJvdmlkZWQgYGltZ1NpemVgIG5lZWRzIHRvIG1hdGNoIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgaW1hZ2UuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NyY10gSW1hZ2Ugc291cmNlIFVSSS5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogU2V0IGljb24gc3R5bGUgZm9yIHZlY3RvciBmZWF0dXJlcy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgSWNvbiBleHRlbmRzIEltYWdlU3R5bGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9vcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCBvcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm9wYWNpdHkgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucm90YXRpb24gOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc2NhbGUgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgY29uc3Qgcm90YXRlV2l0aFZpZXcgPSBvcHRpb25zLnJvdGF0ZVdpdGhWaWV3ICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5yb3RhdGVXaXRoVmlldyA6IGZhbHNlO1xuXG4gICAgc3VwZXIoe1xuICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgIHJvdGF0aW9uOiByb3RhdGlvbixcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIHJvdGF0ZVdpdGhWaWV3OiByb3RhdGVXaXRoVmlld1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcl8gPSBvcHRpb25zLmFuY2hvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmNob3IgOiBbMC41LCAwLjVdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLm5vcm1hbGl6ZWRBbmNob3JfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSWNvbk9yaWdpbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9IG9wdGlvbnMuYW5jaG9yT3JpZ2luICE9PSB1bmRlZmluZWQgP1xuICAgICAgb3B0aW9ucy5hbmNob3JPcmlnaW4gOiBJY29uT3JpZ2luLlRPUF9MRUZUO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JY29uQW5jaG9yVW5pdHMuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclhVbml0c18gPSBvcHRpb25zLmFuY2hvclhVbml0cyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuYW5jaG9yWFVuaXRzIDogSWNvbkFuY2hvclVuaXRzLkZSQUNUSU9OO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JY29uQW5jaG9yVW5pdHMuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvcllVbml0c18gPSBvcHRpb25zLmFuY2hvcllVbml0cyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuYW5jaG9yWVVuaXRzIDogSWNvbkFuY2hvclVuaXRzLkZSQUNUSU9OO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmNyb3NzT3JpZ2luXyA9XG4gICAgICAgIG9wdGlvbnMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NPcmlnaW4gOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgY29uc3QgaW1hZ2UgPSBvcHRpb25zLmltZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbWcgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL3NpemUuanNcIikuU2l6ZX1cbiAgICAgKi9cbiAgICBjb25zdCBpbWdTaXplID0gb3B0aW9ucy5pbWdTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmltZ1NpemUgOiBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgbGV0IHNyYyA9IG9wdGlvbnMuc3JjO1xuXG4gICAgYXNzZXJ0KCEoc3JjICE9PSB1bmRlZmluZWQgJiYgaW1hZ2UpLFxuICAgICAgNCk7IC8vIGBpbWFnZWAgYW5kIGBzcmNgIGNhbm5vdCBiZSBwcm92aWRlZCBhdCB0aGUgc2FtZSB0aW1lXG4gICAgYXNzZXJ0KCFpbWFnZSB8fCAoaW1hZ2UgJiYgaW1nU2l6ZSksXG4gICAgICA1KTsgLy8gYGltZ1NpemVgIG11c3QgYmUgc2V0IHdoZW4gYGltYWdlYCBpcyBwcm92aWRlZFxuXG4gICAgaWYgKChzcmMgPT09IHVuZGVmaW5lZCB8fCBzcmMubGVuZ3RoID09PSAwKSAmJiBpbWFnZSkge1xuICAgICAgc3JjID0gLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqLyAoaW1hZ2UpLnNyYyB8fCBnZXRVaWQoaW1hZ2UpO1xuICAgIH1cbiAgICBhc3NlcnQoc3JjICE9PSB1bmRlZmluZWQgJiYgc3JjLmxlbmd0aCA+IDAsXG4gICAgICA2KTsgLy8gQSBkZWZpbmVkIGFuZCBub24tZW1wdHkgYHNyY2Agb3IgYGltYWdlYCBtdXN0IGJlIHByb3ZpZGVkXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vSW1hZ2VTdGF0ZS5qc1wiKS5kZWZhdWx0fVxuICAgICAqL1xuICAgIGNvbnN0IGltYWdlU3RhdGUgPSBvcHRpb25zLnNyYyAhPT0gdW5kZWZpbmVkID9cbiAgICAgIEltYWdlU3RhdGUuSURMRSA6IEltYWdlU3RhdGUuTE9BREVEO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29sb3IuanNcIikuQ29sb3J9XG4gICAgICovXG4gICAgdGhpcy5jb2xvcl8gPSBvcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhc0FycmF5KG9wdGlvbnMuY29sb3IpIDogbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4vSWNvbkltYWdlLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5pY29uSW1hZ2VfID0gZ2V0SWNvbkltYWdlKFxuICAgICAgaW1hZ2UsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc3JjKSwgaW1nU2l6ZSwgdGhpcy5jcm9zc09yaWdpbl8sIGltYWdlU3RhdGUsIHRoaXMuY29sb3JfKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRfID0gb3B0aW9ucy5vZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMub2Zmc2V0IDogWzAsIDBdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi9JY29uT3JpZ2luLmpzXCIpLmRlZmF1bHR9XG4gICAgICovXG4gICAgdGhpcy5vZmZzZXRPcmlnaW5fID0gb3B0aW9ucy5vZmZzZXRPcmlnaW4gIT09IHVuZGVmaW5lZCA/XG4gICAgICBvcHRpb25zLm9mZnNldE9yaWdpbiA6IEljb25PcmlnaW4uVE9QX0xFRlQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheTxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9XG4gICAgICovXG4gICAgdGhpcy5zaXplXyA9IG9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaXplIDogbnVsbDtcblxuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgc3R5bGUuIFRoZSB1bmRlcmx5aW5nIEltYWdlL0hUTUxDYW52YXNFbGVtZW50IGlzIG5vdCBjbG9uZWQuXG4gICAqIEByZXR1cm4ge0ljb259IFRoZSBjbG9uZWQgc3R5bGUuXG4gICAqIEBhcGlcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgSWNvbih7XG4gICAgICBhbmNob3I6IHRoaXMuYW5jaG9yXy5zbGljZSgpLFxuICAgICAgYW5jaG9yT3JpZ2luOiB0aGlzLmFuY2hvck9yaWdpbl8sXG4gICAgICBhbmNob3JYVW5pdHM6IHRoaXMuYW5jaG9yWFVuaXRzXyxcbiAgICAgIGFuY2hvcllVbml0czogdGhpcy5hbmNob3JZVW5pdHNfLFxuICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW5fLFxuICAgICAgY29sb3I6ICh0aGlzLmNvbG9yXyAmJiB0aGlzLmNvbG9yXy5zbGljZSkgPyB0aGlzLmNvbG9yXy5zbGljZSgpIDogdGhpcy5jb2xvcl8gfHwgdW5kZWZpbmVkLFxuICAgICAgc3JjOiB0aGlzLmdldFNyYygpLFxuICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldF8uc2xpY2UoKSxcbiAgICAgIG9mZnNldE9yaWdpbjogdGhpcy5vZmZzZXRPcmlnaW5fLFxuICAgICAgc2l6ZTogdGhpcy5zaXplXyAhPT0gbnVsbCA/IHRoaXMuc2l6ZV8uc2xpY2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgIG9wYWNpdHk6IHRoaXMuZ2V0T3BhY2l0eSgpLFxuICAgICAgc2NhbGU6IHRoaXMuZ2V0U2NhbGUoKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLmdldFJvdGF0aW9uKCksXG4gICAgICByb3RhdGVXaXRoVmlldzogdGhpcy5nZXRSb3RhdGVXaXRoVmlldygpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0QW5jaG9yKCkge1xuICAgIGlmICh0aGlzLm5vcm1hbGl6ZWRBbmNob3JfKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkQW5jaG9yXztcbiAgICB9XG4gICAgbGV0IGFuY2hvciA9IHRoaXMuYW5jaG9yXztcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgaWYgKHRoaXMuYW5jaG9yWFVuaXRzXyA9PSBJY29uQW5jaG9yVW5pdHMuRlJBQ1RJT04gfHxcbiAgICAgICAgdGhpcy5hbmNob3JZVW5pdHNfID09IEljb25BbmNob3JVbml0cy5GUkFDVElPTikge1xuICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgYW5jaG9yID0gdGhpcy5hbmNob3JfLnNsaWNlKCk7XG4gICAgICBpZiAodGhpcy5hbmNob3JYVW5pdHNfID09IEljb25BbmNob3JVbml0cy5GUkFDVElPTikge1xuICAgICAgICBhbmNob3JbMF0gKj0gc2l6ZVswXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFuY2hvcllVbml0c18gPT0gSWNvbkFuY2hvclVuaXRzLkZSQUNUSU9OKSB7XG4gICAgICAgIGFuY2hvclsxXSAqPSBzaXplWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFuY2hvck9yaWdpbl8gIT0gSWNvbk9yaWdpbi5UT1BfTEVGVCkge1xuICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFuY2hvciA9PT0gdGhpcy5hbmNob3JfKSB7XG4gICAgICAgIGFuY2hvciA9IHRoaXMuYW5jaG9yXy5zbGljZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYW5jaG9yT3JpZ2luXyA9PSBJY29uT3JpZ2luLlRPUF9SSUdIVCB8fFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSBJY29uT3JpZ2luLkJPVFRPTV9SSUdIVCkge1xuICAgICAgICBhbmNob3JbMF0gPSAtYW5jaG9yWzBdICsgc2l6ZVswXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFuY2hvck9yaWdpbl8gPT0gSWNvbk9yaWdpbi5CT1RUT01fTEVGVCB8fFxuICAgICAgICAgIHRoaXMuYW5jaG9yT3JpZ2luXyA9PSBJY29uT3JpZ2luLkJPVFRPTV9SSUdIVCkge1xuICAgICAgICBhbmNob3JbMV0gPSAtYW5jaG9yWzFdICsgc2l6ZVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IGFuY2hvcjtcbiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkQW5jaG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGFuY2hvciBwb2ludC4gVGhlIGFuY2hvciBkZXRlcm1pbmVzIHRoZSBjZW50ZXIgcG9pbnQgZm9yIHRoZVxuICAgKiBzeW1ib2xpemVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGFuY2hvciBBbmNob3IuXG4gICAqIEBhcGlcbiAgICovXG4gIHNldEFuY2hvcihhbmNob3IpIHtcbiAgICB0aGlzLmFuY2hvcl8gPSBhbmNob3I7XG4gICAgdGhpcy5ub3JtYWxpemVkQW5jaG9yXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpY29uIGNvbG9yLlxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9jb2xvci5qc1wiKS5Db2xvcn0gQ29sb3IuXG4gICAqIEBhcGlcbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yXztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGltYWdlIGljb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFJhdGlvIFBpeGVsIHJhdGlvLlxuICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBJbWFnZSBvciBDYW52YXMgZWxlbWVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEBhcGlcbiAgICovXG4gIGdldEltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldEltYWdlKHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SW1hZ2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0U2l6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SGl0RGV0ZWN0aW9uSW1hZ2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmdldEltYWdlU2l6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0SW1hZ2VTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldEltYWdlU3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldEhpdERldGVjdGlvbkltYWdlKHBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm4gdGhpcy5pY29uSW1hZ2VfLmdldEhpdERldGVjdGlvbkltYWdlKHBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqIEBhcGlcbiAgICovXG4gIGdldE9yaWdpbigpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5fKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5fO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5vZmZzZXRfO1xuXG4gICAgaWYgKHRoaXMub2Zmc2V0T3JpZ2luXyAhPSBJY29uT3JpZ2luLlRPUF9MRUZUKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBjb25zdCBpY29uSW1hZ2VTaXplID0gdGhpcy5pY29uSW1hZ2VfLmdldFNpemUoKTtcbiAgICAgIGlmICghc2l6ZSB8fCAhaWNvbkltYWdlU2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IG9mZnNldC5zbGljZSgpO1xuICAgICAgaWYgKHRoaXMub2Zmc2V0T3JpZ2luXyA9PSBJY29uT3JpZ2luLlRPUF9SSUdIVCB8fFxuICAgICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSBJY29uT3JpZ2luLkJPVFRPTV9SSUdIVCkge1xuICAgICAgICBvZmZzZXRbMF0gPSBpY29uSW1hZ2VTaXplWzBdIC0gc2l6ZVswXSAtIG9mZnNldFswXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9mZnNldE9yaWdpbl8gPT0gSWNvbk9yaWdpbi5CT1RUT01fTEVGVCB8fFxuICAgICAgICAgIHRoaXMub2Zmc2V0T3JpZ2luXyA9PSBJY29uT3JpZ2luLkJPVFRPTV9SSUdIVCkge1xuICAgICAgICBvZmZzZXRbMV0gPSBpY29uSW1hZ2VTaXplWzFdIC0gc2l6ZVsxXSAtIG9mZnNldFsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vcmlnaW5fID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLm9yaWdpbl87XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpbWFnZSBVUkwuXG4gICAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IEltYWdlIHNyYy5cbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U3JjKCkge1xuICAgIHJldHVybiB0aGlzLmljb25JbWFnZV8uZ2V0U3JjKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICogQGFwaVxuICAgKi9cbiAgZ2V0U2l6ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuc2l6ZV8gPyB0aGlzLmljb25JbWFnZV8uZ2V0U2l6ZSgpIDogdGhpcy5zaXplXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGxpc3Rlbih0aGlzLmljb25JbWFnZV8sIEV2ZW50VHlwZS5DSEFOR0UsXG4gICAgICBsaXN0ZW5lciwgdGhpc0FyZyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBub3QgeWV0IGxvYWRlZCBVUkkuXG4gICAqIFdoZW4gcmVuZGVyaW5nIGEgZmVhdHVyZSB3aXRoIGFuIGljb24gc3R5bGUsIHRoZSB2ZWN0b3IgcmVuZGVyZXIgd2lsbFxuICAgKiBhdXRvbWF0aWNhbGx5IGNhbGwgdGhpcyBtZXRob2QuIEhvd2V2ZXIsIHlvdSBtaWdodCB3YW50IHRvIGNhbGwgdGhpc1xuICAgKiBtZXRob2QgeW91cnNlbGYgZm9yIHByZWxvYWRpbmcgb3Igb3RoZXIgcHVycG9zZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKiBAYXBpXG4gICAqL1xuICBsb2FkKCkge1xuICAgIHRoaXMuaWNvbkltYWdlXy5sb2FkKCk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB1bmxpc3RlbkltYWdlQ2hhbmdlKGxpc3RlbmVyLCB0aGlzQXJnKSB7XG4gICAgdW5saXN0ZW4odGhpcy5pY29uSW1hZ2VfLCBFdmVudFR5cGUuQ0hBTkdFLFxuICAgICAgbGlzdGVuZXIsIHRoaXNBcmcpO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgSWNvbjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBRkE7Ozs7Ozs7Ozs7O0FDUkE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBU0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBOzs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyT0E7Ozs7Ozs7Ozs7OztBQWlQQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBOztBQ3RRQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7Ozs7O0FDUkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDQTtBQUFBO0FBQUE7QUFJQTtBQUNBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBOzs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOzs7Ozs7QUFXQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFPQTs7Ozs7O0FBT0E7Ozs7OztBQU9BOzs7OztBQU1BOzs7OztBQUtBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUtBOzs7Ozs7QUFPQTs7Ozs7O0FBTUE7QUFDQTtBQUFBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU9BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFDQTs7QUE3VkE7QUFDQTtBQStWQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///150\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/easing.js\nvar easing = __webpack_require__(28);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/condition.js\nvar events_condition = __webpack_require__(29);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/Event.js\nvar Event = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./node_modules/ol/functions.js\nvar functions = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/ol/interaction/Pointer.js\nvar Pointer = __webpack_require__(62);\n\n// EXTERNAL MODULE: ./node_modules/ol/Disposable.js\nvar ol_Disposable = __webpack_require__(70);\n\n// EXTERNAL MODULE: ./node_modules/ol/geom/Polygon.js + 1 modules\nvar Polygon = __webpack_require__(47);\n\n// CONCATENATED MODULE: ./node_modules/ol/render/Box.js\n/**\n * @module ol/render/Box\n */\n\n\n\nvar Box_RenderBox =\n/*@__PURE__*/\nfunction (Disposable) {\n  function RenderBox(className) {\n    Disposable.call(this);\n    /**\n     * @type {import("../geom/Polygon.js").default}\n     * @private\n     */\n\n    this.geometry_ = null;\n    /**\n     * @type {HTMLDivElement}\n     * @private\n     */\n\n    this.element_ =\n    /** @type {HTMLDivElement} */\n    document.createElement(\'div\');\n    this.element_.style.position = \'absolute\';\n    this.element_.className = \'ol-box \' + className;\n    /**\n     * @private\n     * @type {import("../PluggableMap.js").default}\n     */\n\n    this.map_ = null;\n    /**\n     * @private\n     * @type {import("../pixel.js").Pixel}\n     */\n\n    this.startPixel_ = null;\n    /**\n     * @private\n     * @type {import("../pixel.js").Pixel}\n     */\n\n    this.endPixel_ = null;\n  }\n\n  if (Disposable) RenderBox.__proto__ = Disposable;\n  RenderBox.prototype = Object.create(Disposable && Disposable.prototype);\n  RenderBox.prototype.constructor = RenderBox;\n  /**\n   * @inheritDoc\n   */\n\n  RenderBox.prototype.disposeInternal = function disposeInternal() {\n    this.setMap(null);\n  };\n  /**\n   * @private\n   */\n\n\n  RenderBox.prototype.render_ = function render_() {\n    var startPixel = this.startPixel_;\n    var endPixel = this.endPixel_;\n    var px = \'px\';\n    var style = this.element_.style;\n    style.left = Math.min(startPixel[0], endPixel[0]) + px;\n    style.top = Math.min(startPixel[1], endPixel[1]) + px;\n    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;\n    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;\n  };\n  /**\n   * @param {import("../PluggableMap.js").default} map Map.\n   */\n\n\n  RenderBox.prototype.setMap = function setMap(map) {\n    if (this.map_) {\n      this.map_.getOverlayContainer().removeChild(this.element_);\n      var style = this.element_.style;\n      style.left = style.top = style.width = style.height = \'inherit\';\n    }\n\n    this.map_ = map;\n\n    if (this.map_) {\n      this.map_.getOverlayContainer().appendChild(this.element_);\n    }\n  };\n  /**\n   * @param {import("../pixel.js").Pixel} startPixel Start pixel.\n   * @param {import("../pixel.js").Pixel} endPixel End pixel.\n   */\n\n\n  RenderBox.prototype.setPixels = function setPixels(startPixel, endPixel) {\n    this.startPixel_ = startPixel;\n    this.endPixel_ = endPixel;\n    this.createOrUpdateGeometry();\n    this.render_();\n  };\n  /**\n   * Creates or updates the cached geometry.\n   */\n\n\n  RenderBox.prototype.createOrUpdateGeometry = function createOrUpdateGeometry() {\n    var startPixel = this.startPixel_;\n    var endPixel = this.endPixel_;\n    var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];\n    var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_); // close the polygon\n\n    coordinates[4] = coordinates[0].slice();\n\n    if (!this.geometry_) {\n      this.geometry_ = new Polygon["b" /* default */]([coordinates]);\n    } else {\n      this.geometry_.setCoordinates([coordinates]);\n    }\n  };\n  /**\n   * @return {import("../geom/Polygon.js").default} Geometry.\n   */\n\n\n  RenderBox.prototype.getGeometry = function getGeometry() {\n    return this.geometry_;\n  };\n\n  return RenderBox;\n}(ol_Disposable["a" /* default */]);\n\n/* harmony default export */ var Box = (Box_RenderBox);\n// CONCATENATED MODULE: ./node_modules/ol/interaction/DragBox.js\n/**\n * @module ol/interaction/DragBox\n */\n// FIXME draw drag box\n\n\n\n\n\n/**\n * A function that takes a {@link module:ol/MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\n * true should be returned.\n * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className=\'ol-dragbox\'] CSS class name for styling the box.\n * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link ol/events/condition~always}.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\n * `boxEndCondition` function.\n * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\n * Default is `true` if the area of the box is bigger than the `minArea` option.\n * @property {function(this:DragBox, import("../MapBrowserEvent.js").default)} onBoxEnd Code to execute just\n * before `boxend` is fired.\n */\n\n/**\n * @enum {string}\n */\n\nvar DragBoxEventType = {\n  /**\n   * Triggered upon drag box start.\n   * @event DragBoxEvent#boxstart\n   * @api\n   */\n  BOXSTART: \'boxstart\',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event DragBoxEvent#boxdrag\n   * @api\n   */\n  BOXDRAG: \'boxdrag\',\n\n  /**\n   * Triggered upon drag box end.\n   * @event DragBoxEvent#boxend\n   * @api\n   */\n  BOXEND: \'boxend\'\n};\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\n * this type.\n */\n\nvar DragBoxEvent =\n/*@__PURE__*/\nfunction (Event) {\n  function DragBoxEvent(type, coordinate, mapBrowserEvent) {\n    Event.call(this, type);\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import("../coordinate.js").Coordinate}\n     * @api\n     */\n\n    this.coordinate = coordinate;\n    /**\n     * @const\n     * @type {import("../MapBrowserEvent.js").default}\n     * @api\n     */\n\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n\n  if (Event) DragBoxEvent.__proto__ = Event;\n  DragBoxEvent.prototype = Object.create(Event && Event.prototype);\n  DragBoxEvent.prototype.constructor = DragBoxEvent;\n  return DragBoxEvent;\n}(Event["a" /* default */]);\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\n * {@link module:ol/interaction/DragRotateAndZoom}).\n *\n * This interaction is only supported for mouse devices.\n *\n * @fires DragBoxEvent\n * @api\n */\n\n\nvar DragBox_DragBox =\n/*@__PURE__*/\nfunction (PointerInteraction) {\n  function DragBox(opt_options) {\n    PointerInteraction.call(this);\n    var options = opt_options ? opt_options : {};\n    /**\n    * @type {import("../render/Box.js").default}\n    * @private\n    */\n\n    this.box_ = new Box(options.className || \'ol-dragbox\');\n    /**\n    * @type {number}\n    * @private\n    */\n\n    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n    /**\n     * Function to execute just before `onboxend` is fired\n     * @type {function(this:DragBox, import("../MapBrowserEvent.js").default)}\n     * @private\n     */\n\n    this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : functions["c" /* VOID */];\n    /**\n    * @type {import("../pixel.js").Pixel}\n    * @private\n    */\n\n    this.startPixel_ = null;\n    /**\n    * @private\n    * @type {import("../events/condition.js").Condition}\n    */\n\n    this.condition_ = options.condition ? options.condition : events_condition["a" /* always */];\n    /**\n    * @private\n    * @type {EndCondition}\n    */\n\n    this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;\n  }\n\n  if (PointerInteraction) DragBox.__proto__ = PointerInteraction;\n  DragBox.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  DragBox.prototype.constructor = DragBox;\n  /**\n   * The default condition for determining whether the boxend event\n   * should fire.\n   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent\n   *     leading to the box end.\n   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.\n   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.\n   * @return {boolean} Whether or not the boxend condition should be fired.\n   */\n\n  DragBox.prototype.defaultBoxEndCondition = function defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n    var width = endPixel[0] - startPixel[0];\n    var height = endPixel[1] - startPixel[1];\n    return width * width + height * height >= this.minArea_;\n  };\n  /**\n  * Returns geometry of last drawn box.\n  * @return {import("../geom/Polygon.js").default} Geometry.\n  * @api\n  */\n\n\n  DragBox.prototype.getGeometry = function getGeometry() {\n    return this.box_.getGeometry();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  DragBox.prototype.handleDragEvent = function handleDragEvent(mapBrowserEvent) {\n    if (!Object(events_condition["c" /* mouseOnly */])(mapBrowserEvent)) {\n      return;\n    }\n\n    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  DragBox.prototype.handleUpEvent = function handleUpEvent(mapBrowserEvent) {\n    if (!Object(events_condition["c" /* mouseOnly */])(mapBrowserEvent)) {\n      return true;\n    }\n\n    this.box_.setMap(null);\n\n    if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {\n      this.onBoxEnd_(mapBrowserEvent);\n      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));\n    }\n\n    return false;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  DragBox.prototype.handleDownEvent = function handleDownEvent(mapBrowserEvent) {\n    if (!Object(events_condition["c" /* mouseOnly */])(mapBrowserEvent)) {\n      return false;\n    }\n\n    if (Object(events_condition["b" /* mouseActionButton */])(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {\n      this.startPixel_ = mapBrowserEvent.pixel;\n      this.box_.setMap(mapBrowserEvent.map);\n      this.box_.setPixels(this.startPixel_, this.startPixel_);\n      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  return DragBox;\n}(Pointer["b" /* default */]);\n\n/* harmony default export */ var interaction_DragBox = (DragBox_DragBox);\n// CONCATENATED MODULE: ./node_modules/ol/interaction/DragZoom.js\n/**\n * @module ol/interaction/DragZoom\n */\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {string} [className=\'ol-dragzoom\'] CSS class name for styling the\n * box.\n * @property {import("../events/condition.js").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition~shiftKeyOnly}.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {boolean} [out=false] Use interaction for zooming out.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when a key, shift by default, is held down.\n *\n * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\n * your custom one configured with `className`.\n * @api\n */\n\nvar DragZoom_DragZoom =\n/*@__PURE__*/\nfunction (DragBox) {\n  function DragZoom(opt_options) {\n    var options = opt_options ? opt_options : {};\n    var condition = options.condition ? options.condition : events_condition["e" /* shiftKeyOnly */];\n    DragBox.call(this, {\n      condition: condition,\n      className: options.className || \'ol-dragzoom\',\n      onBoxEnd: onBoxEnd\n    });\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.out_ = options.out !== undefined ? options.out : false;\n  }\n\n  if (DragBox) DragZoom.__proto__ = DragBox;\n  DragZoom.prototype = Object.create(DragBox && DragBox.prototype);\n  DragZoom.prototype.constructor = DragZoom;\n  return DragZoom;\n}(interaction_DragBox);\n/**\n * @this {DragZoom}\n */\n\n\nfunction onBoxEnd() {\n  var map = this.getMap();\n  var view =\n  /** @type {!import("../View.js").default} */\n  map.getView();\n  var size =\n  /** @type {!import("../size.js").Size} */\n  map.getSize();\n  var extent = this.getGeometry().getExtent();\n\n  if (this.out_) {\n    var mapExtent = view.calculateExtent(size);\n    var boxPixelExtent = Object(ol_extent["createOrUpdateFromCoordinates"])([map.getPixelFromCoordinate(Object(ol_extent["getBottomLeft"])(extent)), map.getPixelFromCoordinate(Object(ol_extent["getTopRight"])(extent))]);\n    var factor = view.getResolutionForExtent(boxPixelExtent, size);\n    Object(ol_extent["scaleFromCenter"])(mapExtent, 1 / factor);\n    extent = mapExtent;\n  }\n\n  var resolution = view.constrainResolution(view.getResolutionForExtent(extent, size));\n  var center = Object(ol_extent["getCenter"])(extent);\n  center = view.constrainCenter(center);\n  view.animate({\n    resolution: resolution,\n    center: center,\n    duration: this.duration_,\n    easing: easing["easeOut"]\n  });\n}\n\n/* harmony default export */ var interaction_DragZoom = __webpack_exports__["default"] = (DragZoom_DragZoom);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXIvQm94LmpzPzI4M2UiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9pbnRlcmFjdGlvbi9EcmFnQm94LmpzPzA4NjQiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9pbnRlcmFjdGlvbi9EcmFnWm9vbS5qcz8wNDI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9yZW5kZXIvQm94XG4gKi9cblxuaW1wb3J0IERpc3Bvc2FibGUgZnJvbSAnLi4vRGlzcG9zYWJsZS5qcyc7XG5pbXBvcnQgUG9seWdvbiBmcm9tICcuLi9nZW9tL1BvbHlnb24uanMnO1xuXG5jbGFzcyBSZW5kZXJCb3ggZXh0ZW5kcyBEaXNwb3NhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgQ1NTIGNsYXNzIG5hbWUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjbGFzc05hbWUpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL2dlb20vUG9seWdvbi5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5nZW9tZXRyeV8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0hUTUxEaXZFbGVtZW50fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50XyA9IC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgdGhpcy5lbGVtZW50Xy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgdGhpcy5lbGVtZW50Xy5jbGFzc05hbWUgPSAnb2wtYm94ICcgKyBjbGFzc05hbWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFBpeGVsXyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAgKi9cbiAgICB0aGlzLmVuZFBpeGVsXyA9IG51bGw7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZGlzcG9zZUludGVybmFsKCkge1xuICAgIHRoaXMuc2V0TWFwKG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW5kZXJfKCkge1xuICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB0aGlzLnN0YXJ0UGl4ZWxfO1xuICAgIGNvbnN0IGVuZFBpeGVsID0gdGhpcy5lbmRQaXhlbF87XG4gICAgY29uc3QgcHggPSAncHgnO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5lbGVtZW50Xy5zdHlsZTtcbiAgICBzdHlsZS5sZWZ0ID0gTWF0aC5taW4oc3RhcnRQaXhlbFswXSwgZW5kUGl4ZWxbMF0pICsgcHg7XG4gICAgc3R5bGUudG9wID0gTWF0aC5taW4oc3RhcnRQaXhlbFsxXSwgZW5kUGl4ZWxbMV0pICsgcHg7XG4gICAgc3R5bGUud2lkdGggPSBNYXRoLmFicyhlbmRQaXhlbFswXSAtIHN0YXJ0UGl4ZWxbMF0pICsgcHg7XG4gICAgc3R5bGUuaGVpZ2h0ID0gTWF0aC5hYnMoZW5kUGl4ZWxbMV0gLSBzdGFydFBpeGVsWzFdKSArIHB4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gICAqL1xuICBzZXRNYXAobWFwKSB7XG4gICAgaWYgKHRoaXMubWFwXykge1xuICAgICAgdGhpcy5tYXBfLmdldE92ZXJsYXlDb250YWluZXIoKS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnRfKTtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5lbGVtZW50Xy5zdHlsZTtcbiAgICAgIHN0eWxlLmxlZnQgPSBzdHlsZS50b3AgPSBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9ICdpbmhlcml0JztcbiAgICB9XG4gICAgdGhpcy5tYXBfID0gbWFwO1xuICAgIGlmICh0aGlzLm1hcF8pIHtcbiAgICAgIHRoaXMubWFwXy5nZXRPdmVybGF5Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50Xyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IHN0YXJ0UGl4ZWwgU3RhcnQgcGl4ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWx9IGVuZFBpeGVsIEVuZCBwaXhlbC5cbiAgICovXG4gIHNldFBpeGVscyhzdGFydFBpeGVsLCBlbmRQaXhlbCkge1xuICAgIHRoaXMuc3RhcnRQaXhlbF8gPSBzdGFydFBpeGVsO1xuICAgIHRoaXMuZW5kUGl4ZWxfID0gZW5kUGl4ZWw7XG4gICAgdGhpcy5jcmVhdGVPclVwZGF0ZUdlb21ldHJ5KCk7XG4gICAgdGhpcy5yZW5kZXJfKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBvciB1cGRhdGVzIHRoZSBjYWNoZWQgZ2VvbWV0cnkuXG4gICAqL1xuICBjcmVhdGVPclVwZGF0ZUdlb21ldHJ5KCkge1xuICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB0aGlzLnN0YXJ0UGl4ZWxfO1xuICAgIGNvbnN0IGVuZFBpeGVsID0gdGhpcy5lbmRQaXhlbF87XG4gICAgY29uc3QgcGl4ZWxzID0gW1xuICAgICAgc3RhcnRQaXhlbCxcbiAgICAgIFtzdGFydFBpeGVsWzBdLCBlbmRQaXhlbFsxXV0sXG4gICAgICBlbmRQaXhlbCxcbiAgICAgIFtlbmRQaXhlbFswXSwgc3RhcnRQaXhlbFsxXV1cbiAgICBdO1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gcGl4ZWxzLm1hcCh0aGlzLm1hcF8uZ2V0Q29vcmRpbmF0ZUZyb21QaXhlbCwgdGhpcy5tYXBfKTtcbiAgICAvLyBjbG9zZSB0aGUgcG9seWdvblxuICAgIGNvb3JkaW5hdGVzWzRdID0gY29vcmRpbmF0ZXNbMF0uc2xpY2UoKTtcbiAgICBpZiAoIXRoaXMuZ2VvbWV0cnlfKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5XyA9IG5ldyBQb2x5Z29uKFtjb29yZGluYXRlc10pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdlb21ldHJ5Xy5zZXRDb29yZGluYXRlcyhbY29vcmRpbmF0ZXNdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vZ2VvbS9Qb2x5Z29uLmpzXCIpLmRlZmF1bHR9IEdlb21ldHJ5LlxuICAgKi9cbiAgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlfO1xuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVuZGVyQm94O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdCb3hcbiAqL1xuLy8gRklYTUUgZHJhdyBkcmFnIGJveFxuaW1wb3J0IEV2ZW50IGZyb20gJy4uL2V2ZW50cy9FdmVudC5qcyc7XG5pbXBvcnQge2Fsd2F5cywgbW91c2VPbmx5LCBtb3VzZUFjdGlvbkJ1dHRvbn0gZnJvbSAnLi4vZXZlbnRzL2NvbmRpdGlvbi5qcyc7XG5pbXBvcnQge1ZPSUR9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQgUG9pbnRlckludGVyYWN0aW9uIGZyb20gJy4vUG9pbnRlci5qcyc7XG5pbXBvcnQgUmVuZGVyQm94IGZyb20gJy4uL3JlbmRlci9Cb3guanMnO1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR9IGFuZCB0d29cbiAqIHtAbGluayBtb2R1bGU6b2wvcGl4ZWx+UGl4ZWx9cyBhbmQgcmV0dXJucyBhIGB7Ym9vbGVhbn1gLiBJZiB0aGUgY29uZGl0aW9uIGlzIG1ldCxcbiAqIHRydWUgc2hvdWxkIGJlIHJldHVybmVkLlxuICogQHR5cGVkZWYge2Z1bmN0aW9uKHRoaXM6ID8sIGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0LCBpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbCwgaW1wb3J0KFwiLi4vcGl4ZWwuanNcIikuUGl4ZWwpOmJvb2xlYW59IEVuZENvbmRpdGlvblxuICovXG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtZHJhZ2JveCddIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHRoZSBib3guXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhIGJvb2xlYW5cbiAqIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG9sL2V2ZW50cy9jb25kaXRpb25+YWx3YXlzfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWluQXJlYT02NF0gVGhlIG1pbmltdW0gYXJlYSBvZiB0aGUgYm94IGluIHBpeGVsLCB0aGlzIHZhbHVlIGlzIHVzZWQgYnkgdGhlIGRlZmF1bHRcbiAqIGBib3hFbmRDb25kaXRpb25gIGZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtFbmRDb25kaXRpb259IFtib3hFbmRDb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHR3b1xuICoge0BsaW5rIG1vZHVsZTpvbC9waXhlbH5QaXhlbH1zIHRvIGluZGljYXRlIHdoZXRoZXIgYSBgYm94ZW5kYCBldmVudCBzaG91bGQgYmUgZmlyZWQuXG4gKiBEZWZhdWx0IGlzIGB0cnVlYCBpZiB0aGUgYXJlYSBvZiB0aGUgYm94IGlzIGJpZ2dlciB0aGFuIHRoZSBgbWluQXJlYWAgb3B0aW9uLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbih0aGlzOkRyYWdCb3gsIGltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0KX0gb25Cb3hFbmQgQ29kZSB0byBleGVjdXRlIGp1c3RcbiAqIGJlZm9yZSBgYm94ZW5kYCBpcyBmaXJlZC5cbiAqL1xuXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgRHJhZ0JveEV2ZW50VHlwZSA9IHtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IHN0YXJ0LlxuICAgKiBAZXZlbnQgRHJhZ0JveEV2ZW50I2JveHN0YXJ0XG4gICAqIEBhcGlcbiAgICovXG4gIEJPWFNUQVJUOiAnYm94c3RhcnQnLFxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyZWQgb24gZHJhZyB3aGVuIGJveCBpcyBhY3RpdmUuXG4gICAqIEBldmVudCBEcmFnQm94RXZlbnQjYm94ZHJhZ1xuICAgKiBAYXBpXG4gICAqL1xuICBCT1hEUkFHOiAnYm94ZHJhZycsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCB1cG9uIGRyYWcgYm94IGVuZC5cbiAgICogQGV2ZW50IERyYWdCb3hFdmVudCNib3hlbmRcbiAgICogQGFwaVxuICAgKi9cbiAgQk9YRU5EOiAnYm94ZW5kJ1xufTtcblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEV2ZW50cyBlbWl0dGVkIGJ5IHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ0JveH5EcmFnQm94fSBpbnN0YW5jZXMgYXJlIGluc3RhbmNlcyBvZlxuICogdGhpcyB0eXBlLlxuICovXG5jbGFzcyBEcmFnQm94RXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBUaGUgZXZlbnQgY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE9yaWdpbmF0aW5nIGV2ZW50LlxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgY29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgZHJhZyBldmVudC5cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vY29vcmRpbmF0ZS5qc1wiKS5Db29yZGluYXRlfVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLmNvb3JkaW5hdGUgPSBjb29yZGluYXRlO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUge2ltcG9ydChcIi4uL01hcEJyb3dzZXJFdmVudC5qc1wiKS5kZWZhdWx0fVxuICAgICAqIEBhcGlcbiAgICAgKi9cbiAgICB0aGlzLm1hcEJyb3dzZXJFdmVudCA9IG1hcEJyb3dzZXJFdmVudDtcblxuICB9XG5cbn1cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIEFsbG93cyB0aGUgdXNlciB0byBkcmF3IGEgdmVjdG9yIGJveCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiB0aGUgc2hpZnQgb3Igb3RoZXIga2V5IGlzIGhlbGQgZG93bi4gVGhpcyBpcyB1c2VkLCBmb3IgZXhhbXBsZSxcbiAqIGZvciB6b29taW5nIHRvIGEgc3BlY2lmaWMgYXJlYSBvZiB0aGUgbWFwXG4gKiAoc2VlIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vRHJhZ1pvb21+RHJhZ1pvb219IGFuZFxuICoge0BsaW5rIG1vZHVsZTpvbC9pbnRlcmFjdGlvbi9EcmFnUm90YXRlQW5kWm9vbX0pLlxuICpcbiAqIFRoaXMgaW50ZXJhY3Rpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIG1vdXNlIGRldmljZXMuXG4gKlxuICogQGZpcmVzIERyYWdCb3hFdmVudFxuICogQGFwaVxuICovXG5jbGFzcyBEcmFnQm94IGV4dGVuZHMgUG9pbnRlckludGVyYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuXG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9yZW5kZXIvQm94LmpzXCIpLmRlZmF1bHR9XG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5ib3hfID0gbmV3IFJlbmRlckJveChvcHRpb25zLmNsYXNzTmFtZSB8fCAnb2wtZHJhZ2JveCcpO1xuXG4gICAgLyoqXG4gICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMubWluQXJlYV8gPSBvcHRpb25zLm1pbkFyZWEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubWluQXJlYSA6IDY0O1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gZXhlY3V0ZSBqdXN0IGJlZm9yZSBgb25ib3hlbmRgIGlzIGZpcmVkXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKHRoaXM6RHJhZ0JveCwgaW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHQpfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5vbkJveEVuZF8gPSBvcHRpb25zLm9uQm94RW5kID8gb3B0aW9ucy5vbkJveEVuZCA6IFZPSUQ7XG5cbiAgICAvKipcbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH1cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnN0YXJ0UGl4ZWxfID0gbnVsbDtcblxuICAgIC8qKlxuICAgICogQHByaXZhdGVcbiAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAqL1xuICAgIHRoaXMuY29uZGl0aW9uXyA9IG9wdGlvbnMuY29uZGl0aW9uID8gb3B0aW9ucy5jb25kaXRpb24gOiBhbHdheXM7XG5cbiAgICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAdHlwZSB7RW5kQ29uZGl0aW9ufVxuICAgICovXG4gICAgdGhpcy5ib3hFbmRDb25kaXRpb25fID0gb3B0aW9ucy5ib3hFbmRDb25kaXRpb24gP1xuICAgICAgb3B0aW9ucy5ib3hFbmRDb25kaXRpb24gOiB0aGlzLmRlZmF1bHRCb3hFbmRDb25kaXRpb247XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29uZGl0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBib3hlbmQgZXZlbnRcbiAgICogc2hvdWxkIGZpcmUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwQnJvd3NlckV2ZW50LmpzXCIpLmRlZmF1bHR9IG1hcEJyb3dzZXJFdmVudCBUaGUgb3JpZ2luYXRpbmcgTWFwQnJvd3NlckV2ZW50XG4gICAqICAgICBsZWFkaW5nIHRvIHRoZSBib3ggZW5kLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBzdGFydFBpeGVsIFRoZSBzdGFydGluZyBwaXhlbCBvZiB0aGUgYm94LlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL3BpeGVsLmpzXCIpLlBpeGVsfSBlbmRQaXhlbCBUaGUgZW5kIHBpeGVsIG9mIHRoZSBib3guXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBib3hlbmQgY29uZGl0aW9uIHNob3VsZCBiZSBmaXJlZC5cbiAgICovXG4gIGRlZmF1bHRCb3hFbmRDb25kaXRpb24obWFwQnJvd3NlckV2ZW50LCBzdGFydFBpeGVsLCBlbmRQaXhlbCkge1xuICAgIGNvbnN0IHdpZHRoID0gZW5kUGl4ZWxbMF0gLSBzdGFydFBpeGVsWzBdO1xuICAgIGNvbnN0IGhlaWdodCA9IGVuZFBpeGVsWzFdIC0gc3RhcnRQaXhlbFsxXTtcbiAgICByZXR1cm4gd2lkdGggKiB3aWR0aCArIGhlaWdodCAqIGhlaWdodCA+PSB0aGlzLm1pbkFyZWFfO1xuICB9XG5cbiAgLyoqXG4gICogUmV0dXJucyBnZW9tZXRyeSBvZiBsYXN0IGRyYXduIGJveC5cbiAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuLi9nZW9tL1BvbHlnb24uanNcIikuZGVmYXVsdH0gR2VvbWV0cnkuXG4gICogQGFwaVxuICAqL1xuICBnZXRHZW9tZXRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3hfLmdldEdlb21ldHJ5KCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGhhbmRsZURyYWdFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgICBpZiAoIW1vdXNlT25seShtYXBCcm93c2VyRXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5ib3hfLnNldFBpeGVscyh0aGlzLnN0YXJ0UGl4ZWxfLCBtYXBCcm93c2VyRXZlbnQucGl4ZWwpO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBEcmFnQm94RXZlbnQoRHJhZ0JveEV2ZW50VHlwZS5CT1hEUkFHLFxuICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsIG1hcEJyb3dzZXJFdmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBoYW5kbGVVcEV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYm94Xy5zZXRNYXAobnVsbCk7XG5cbiAgICBpZiAodGhpcy5ib3hFbmRDb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCwgdGhpcy5zdGFydFBpeGVsXywgbWFwQnJvd3NlckV2ZW50LnBpeGVsKSkge1xuICAgICAgdGhpcy5vbkJveEVuZF8obWFwQnJvd3NlckV2ZW50KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRHJhZ0JveEV2ZW50KERyYWdCb3hFdmVudFR5cGUuQk9YRU5ELFxuICAgICAgICBtYXBCcm93c2VyRXZlbnQuY29vcmRpbmF0ZSwgbWFwQnJvd3NlckV2ZW50KSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgaGFuZGxlRG93bkV2ZW50KG1hcEJyb3dzZXJFdmVudCkge1xuICAgIGlmICghbW91c2VPbmx5KG1hcEJyb3dzZXJFdmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobW91c2VBY3Rpb25CdXR0b24obWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgICB0aGlzLmNvbmRpdGlvbl8obWFwQnJvd3NlckV2ZW50KSkge1xuICAgICAgdGhpcy5zdGFydFBpeGVsXyA9IG1hcEJyb3dzZXJFdmVudC5waXhlbDtcbiAgICAgIHRoaXMuYm94Xy5zZXRNYXAobWFwQnJvd3NlckV2ZW50Lm1hcCk7XG4gICAgICB0aGlzLmJveF8uc2V0UGl4ZWxzKHRoaXMuc3RhcnRQaXhlbF8sIHRoaXMuc3RhcnRQaXhlbF8pO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBEcmFnQm94RXZlbnQoRHJhZ0JveEV2ZW50VHlwZS5CT1hTVEFSVCxcbiAgICAgICAgbWFwQnJvd3NlckV2ZW50LmNvb3JkaW5hdGUsIG1hcEJyb3dzZXJFdmVudCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBEcmFnQm94O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0RyYWdab29tXG4gKi9cbmltcG9ydCB7ZWFzZU91dH0gZnJvbSAnLi4vZWFzaW5nLmpzJztcbmltcG9ydCB7c2hpZnRLZXlPbmx5fSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCB7Y3JlYXRlT3JVcGRhdGVGcm9tQ29vcmRpbmF0ZXMsIGdldEJvdHRvbUxlZnQsIGdldENlbnRlciwgZ2V0VG9wUmlnaHQsIHNjYWxlRnJvbUNlbnRlcn0gZnJvbSAnLi4vZXh0ZW50LmpzJztcbmltcG9ydCBEcmFnQm94IGZyb20gJy4vRHJhZ0JveC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2NsYXNzTmFtZT0nb2wtZHJhZ3pvb20nXSBDU1MgY2xhc3MgbmFtZSBmb3Igc3R5bGluZyB0aGVcbiAqIGJveC5cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KFwiLi4vZXZlbnRzL2NvbmRpdGlvbi5qc1wiKS5Db25kaXRpb259IFtjb25kaXRpb25dIEEgZnVuY3Rpb24gdGhhdFxuICogdGFrZXMgYW4ge0BsaW5rIG1vZHVsZTpvbC9NYXBCcm93c2VyRXZlbnR+TWFwQnJvd3NlckV2ZW50fSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhhdCBldmVudCBzaG91bGQgYmUgaGFuZGxlZC5cbiAqIERlZmF1bHQgaXMge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufnNoaWZ0S2V5T25seX0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gQW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW291dD1mYWxzZV0gVXNlIGludGVyYWN0aW9uIGZvciB6b29taW5nIG91dC5cbiAqL1xuXG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogQWxsb3dzIHRoZSB1c2VyIHRvIHpvb20gdGhlIG1hcCBieSBjbGlja2luZyBhbmQgZHJhZ2dpbmcgb24gdGhlIG1hcCxcbiAqIG5vcm1hbGx5IGNvbWJpbmVkIHdpdGggYW4ge0BsaW5rIG1vZHVsZTpvbC9ldmVudHMvY29uZGl0aW9ufSB0aGF0IGxpbWl0c1xuICogaXQgdG8gd2hlbiBhIGtleSwgc2hpZnQgYnkgZGVmYXVsdCwgaXMgaGVsZCBkb3duLlxuICpcbiAqIFRvIGNoYW5nZSB0aGUgc3R5bGUgb2YgdGhlIGJveCwgdXNlIENTUyBhbmQgdGhlIGAub2wtZHJhZ3pvb21gIHNlbGVjdG9yLCBvclxuICogeW91ciBjdXN0b20gb25lIGNvbmZpZ3VyZWQgd2l0aCBgY2xhc3NOYW1lYC5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgRHJhZ1pvb20gZXh0ZW5kcyBEcmFnQm94IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9ucz19IG9wdF9vcHRpb25zIE9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRfb3B0aW9ucykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyA/IG9wdF9vcHRpb25zIDoge307XG5cbiAgICBjb25zdCBjb25kaXRpb24gPSBvcHRpb25zLmNvbmRpdGlvbiA/IG9wdGlvbnMuY29uZGl0aW9uIDogc2hpZnRLZXlPbmx5O1xuXG4gICAgc3VwZXIoe1xuICAgICAgY29uZGl0aW9uOiBjb25kaXRpb24sXG4gICAgICBjbGFzc05hbWU6IG9wdGlvbnMuY2xhc3NOYW1lIHx8ICdvbC1kcmFnem9vbScsXG4gICAgICBvbkJveEVuZDogb25Cb3hFbmRcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAyMDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMub3V0XyA9IG9wdGlvbnMub3V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm91dCA6IGZhbHNlO1xuICB9XG59XG5cblxuLyoqXG4gKiBAdGhpcyB7RHJhZ1pvb219XG4gKi9cbmZ1bmN0aW9uIG9uQm94RW5kKCkge1xuICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICBjb25zdCB2aWV3ID0gLyoqIEB0eXBlIHshaW1wb3J0KFwiLi4vVmlldy5qc1wiKS5kZWZhdWx0fSAqLyAobWFwLmdldFZpZXcoKSk7XG4gIGNvbnN0IHNpemUgPSAvKiogQHR5cGUgeyFpbXBvcnQoXCIuLi9zaXplLmpzXCIpLlNpemV9ICovIChtYXAuZ2V0U2l6ZSgpKTtcbiAgbGV0IGV4dGVudCA9IHRoaXMuZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKTtcblxuICBpZiAodGhpcy5vdXRfKSB7XG4gICAgY29uc3QgbWFwRXh0ZW50ID0gdmlldy5jYWxjdWxhdGVFeHRlbnQoc2l6ZSk7XG4gICAgY29uc3QgYm94UGl4ZWxFeHRlbnQgPSBjcmVhdGVPclVwZGF0ZUZyb21Db29yZGluYXRlcyhbXG4gICAgICBtYXAuZ2V0UGl4ZWxGcm9tQ29vcmRpbmF0ZShnZXRCb3R0b21MZWZ0KGV4dGVudCkpLFxuICAgICAgbWFwLmdldFBpeGVsRnJvbUNvb3JkaW5hdGUoZ2V0VG9wUmlnaHQoZXh0ZW50KSldKTtcbiAgICBjb25zdCBmYWN0b3IgPSB2aWV3LmdldFJlc29sdXRpb25Gb3JFeHRlbnQoYm94UGl4ZWxFeHRlbnQsIHNpemUpO1xuXG4gICAgc2NhbGVGcm9tQ2VudGVyKG1hcEV4dGVudCwgMSAvIGZhY3Rvcik7XG4gICAgZXh0ZW50ID0gbWFwRXh0ZW50O1xuICB9XG5cbiAgY29uc3QgcmVzb2x1dGlvbiA9IHZpZXcuY29uc3RyYWluUmVzb2x1dGlvbihcbiAgICB2aWV3LmdldFJlc29sdXRpb25Gb3JFeHRlbnQoZXh0ZW50LCBzaXplKSk7XG5cbiAgbGV0IGNlbnRlciA9IGdldENlbnRlcihleHRlbnQpO1xuICBjZW50ZXIgPSB2aWV3LmNvbnN0cmFpbkNlbnRlcihjZW50ZXIpO1xuXG4gIHZpZXcuYW5pbWF0ZSh7XG4gICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICBjZW50ZXI6IGNlbnRlcixcbiAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbl8sXG4gICAgZWFzaW5nOiBlYXNlT3V0XG4gIH0pO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IERyYWdab29tO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQXBIQTtBQUNBO0FBc0hBOztBQzlIQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7O0FBTUE7QUFwQkE7Ozs7Ozs7QUE2QkE7QUFBQTtBQUFBO0FBT0E7QUFDQTs7Ozs7Ozs7QUFRQTs7Ozs7OztBQU9BOzs7OztBQUVBOztBQXpCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Q0E7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUVBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN0hBO0FBQ0E7QUErSEE7O0FDL09BOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7Ozs7OztBQVVBOzs7Ozs7QUFNQTs7Ozs7QUFDQTs7QUExQkE7Ozs7OztBQWlDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///151\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/coordinate.js + 1 modules\nvar coordinate = __webpack_require__(41);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar EventType = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./node_modules/ol/events/KeyCode.js\n/**\n * @module ol/events/KeyCode\n */\n\n/**\n * @enum {number}\n * @const\n */\n/* harmony default export */ var KeyCode = ({\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n});\n// EXTERNAL MODULE: ./node_modules/ol/events/condition.js\nvar condition = __webpack_require__(29);\n\n// EXTERNAL MODULE: ./node_modules/ol/interaction/Interaction.js + 1 modules\nvar interaction_Interaction = __webpack_require__(30);\n\n// CONCATENATED MODULE: ./node_modules/ol/interaction/KeyboardPan.js\n/**\n * @module ol/interaction/KeyboardPan\n */\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {import("../events/condition.js").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition~noModifierKeys} and\n * {@link module:ol/events/condition~targetNotEditable}.\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {number} [pixelDelta=128] The amount of pixels to pan on each key\n * press.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map using keyboard arrows.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.\n * @api\n */\n\nvar KeyboardPan_KeyboardPan =\n/*@__PURE__*/\nfunction (Interaction) {\n  function KeyboardPan(opt_options) {\n    Interaction.call(this, {\n      handleEvent: handleEvent\n    });\n    var options = opt_options || {};\n    /**\n     * @private\n     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n\n    this.defaultCondition_ = function (mapBrowserEvent) {\n      return Object(condition["d" /* noModifierKeys */])(mapBrowserEvent) && Object(condition["f" /* targetNotEditable */])(mapBrowserEvent);\n    };\n    /**\n     * @private\n     * @type {import("../events/condition.js").Condition}\n     */\n\n\n    this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;\n  }\n\n  if (Interaction) KeyboardPan.__proto__ = Interaction;\n  KeyboardPan.prototype = Object.create(Interaction && Interaction.prototype);\n  KeyboardPan.prototype.constructor = KeyboardPan;\n  return KeyboardPan;\n}(interaction_Interaction["a" /* default */]);\n/**\n * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a\n * `KeyEvent`, and decides the direction to pan to (if an arrow key was\n * pressed).\n * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {KeyboardPan}\n */\n\n\nfunction handleEvent(mapBrowserEvent) {\n  var stopEvent = false;\n\n  if (mapBrowserEvent.type == EventType["a" /* default */].KEYDOWN) {\n    var keyEvent =\n    /** @type {KeyboardEvent} */\n    mapBrowserEvent.originalEvent;\n    var keyCode = keyEvent.keyCode;\n\n    if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {\n      var map = mapBrowserEvent.map;\n      var view = map.getView();\n      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n      var deltaX = 0,\n          deltaY = 0;\n\n      if (keyCode == KeyCode.DOWN) {\n        deltaY = -mapUnitsDelta;\n      } else if (keyCode == KeyCode.LEFT) {\n        deltaX = -mapUnitsDelta;\n      } else if (keyCode == KeyCode.RIGHT) {\n        deltaX = mapUnitsDelta;\n      } else {\n        deltaY = mapUnitsDelta;\n      }\n\n      var delta = [deltaX, deltaY];\n      Object(coordinate["rotate"])(delta, view.getRotation());\n      Object(interaction_Interaction["b" /* pan */])(view, delta, this.duration_);\n      mapBrowserEvent.preventDefault();\n      stopEvent = true;\n    }\n  }\n\n  return !stopEvent;\n}\n\n/* harmony default export */ var interaction_KeyboardPan = __webpack_exports__["default"] = (KeyboardPan_KeyboardPan);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9ldmVudHMvS2V5Q29kZS5qcz9kY2UwIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvb2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRQYW4uanM/MTZjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvZXZlbnRzL0tleUNvZGVcbiAqL1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICBMRUZUOiAzNyxcbiAgVVA6IDM4LFxuICBSSUdIVDogMzksXG4gIERPV046IDQwXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuXG4gKi9cbmltcG9ydCB7cm90YXRlIGFzIHJvdGF0ZUNvb3JkaW5hdGV9IGZyb20gJy4uL2Nvb3JkaW5hdGUuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCBLZXlDb2RlIGZyb20gJy4uL2V2ZW50cy9LZXlDb2RlLmpzJztcbmltcG9ydCB7bm9Nb2RpZmllcktleXMsIHRhcmdldE5vdEVkaXRhYmxlfSBmcm9tICcuLi9ldmVudHMvY29uZGl0aW9uLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiwge3Bhbn0gZnJvbSAnLi9JbnRlcmFjdGlvbi5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2ltcG9ydChcIi4uL2V2ZW50cy9jb25kaXRpb24uanNcIikuQ29uZGl0aW9ufSBbY29uZGl0aW9uXSBBIGZ1bmN0aW9uIHRoYXRcbiAqIHRha2VzIGFuIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50fk1hcEJyb3dzZXJFdmVudH0gYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoYXQgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQuIERlZmF1bHQgaXNcbiAqIHtAbGluayBtb2R1bGU6b2wvZXZlbnRzL2NvbmRpdGlvbn5ub01vZGlmaWVyS2V5c30gYW5kXG4gKiB7QGxpbmsgbW9kdWxlOm9sL2V2ZW50cy9jb25kaXRpb25+dGFyZ2V0Tm90RWRpdGFibGV9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkdXJhdGlvbj0xMDBdIEFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3BpeGVsRGVsdGE9MTI4XSBUaGUgYW1vdW50IG9mIHBpeGVscyB0byBwYW4gb24gZWFjaCBrZXlcbiAqIHByZXNzLlxuICovXG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBBbGxvd3MgdGhlIHVzZXIgdG8gcGFuIHRoZSBtYXAgdXNpbmcga2V5Ym9hcmQgYXJyb3dzLlxuICogTm90ZSB0aGF0LCBhbHRob3VnaCB0aGlzIGludGVyYWN0aW9uIGlzIGJ5IGRlZmF1bHQgaW5jbHVkZWQgaW4gbWFwcyxcbiAqIHRoZSBrZXlzIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBicm93c2VyIGZvY3VzIGlzIG9uIHRoZSBlbGVtZW50IHRvIHdoaWNoXG4gKiB0aGUga2V5Ym9hcmQgZXZlbnRzIGFyZSBhdHRhY2hlZC4gQnkgZGVmYXVsdCwgdGhpcyBpcyB0aGUgbWFwIGRpdixcbiAqIHRob3VnaCB5b3UgY2FuIGNoYW5nZSB0aGlzIHdpdGggdGhlIGBrZXlib2FyZEV2ZW50VGFyZ2V0YCBpblxuICoge0BsaW5rIG1vZHVsZTpvbC9NYXB+TWFwfS4gYGRvY3VtZW50YCBuZXZlciBsb3NlcyBmb2N1cyBidXQsIGZvciBhbnkgb3RoZXJcbiAqIGVsZW1lbnQsIGZvY3VzIHdpbGwgaGF2ZSB0byBiZSBvbiwgYW5kIHJldHVybmVkIHRvLCB0aGlzIGVsZW1lbnQgaWYgdGhlIGtleXNcbiAqIGFyZSB0byBmdW5jdGlvbi5cbiAqIFNlZSBhbHNvIHtAbGluayBtb2R1bGU6b2wvaW50ZXJhY3Rpb24vS2V5Ym9hcmRab29tfktleWJvYXJkWm9vbX0uXG4gKiBAYXBpXG4gKi9cbmNsYXNzIEtleWJvYXJkUGFuIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtPcHRpb25zPX0gb3B0X29wdGlvbnMgT3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdF9vcHRpb25zKSB7XG5cbiAgICBzdXBlcih7XG4gICAgICBoYW5kbGVFdmVudDogaGFuZGxlRXZlbnRcbiAgICB9KTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRfb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IEJyb3dzZXIgZXZlbnQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29tYmluZWQgY29uZGl0aW9uIHJlc3VsdC5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRDb25kaXRpb25fID0gZnVuY3Rpb24obWFwQnJvd3NlckV2ZW50KSB7XG4gICAgICByZXR1cm4gbm9Nb2RpZmllcktleXMobWFwQnJvd3NlckV2ZW50KSAmJlxuICAgICAgICB0YXJnZXROb3RFZGl0YWJsZShtYXBCcm93c2VyRXZlbnQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9ldmVudHMvY29uZGl0aW9uLmpzXCIpLkNvbmRpdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbmRpdGlvbl8gPSBvcHRpb25zLmNvbmRpdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMuY29uZGl0aW9uIDogdGhpcy5kZWZhdWx0Q29uZGl0aW9uXztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmR1cmF0aW9uXyA9IG9wdGlvbnMuZHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZHVyYXRpb24gOiAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5waXhlbERlbHRhXyA9IG9wdGlvbnMucGl4ZWxEZWx0YSAhPT0gdW5kZWZpbmVkID9cbiAgICAgIG9wdGlvbnMucGl4ZWxEZWx0YSA6IDEyODtcblxuICB9XG5cbn1cblxuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHtAbGluayBtb2R1bGU6b2wvTWFwQnJvd3NlckV2ZW50IG1hcCBicm93c2VyIGV2ZW50fSBpZiBpdCB3YXMgYVxuICogYEtleUV2ZW50YCwgYW5kIGRlY2lkZXMgdGhlIGRpcmVjdGlvbiB0byBwYW4gdG8gKGlmIGFuIGFycm93IGtleSB3YXNcbiAqIHByZXNzZWQpLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9NYXBCcm93c2VyRXZlbnQuanNcIikuZGVmYXVsdH0gbWFwQnJvd3NlckV2ZW50IE1hcCBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCB0byBzdG9wIGV2ZW50IHByb3BhZ2F0aW9uLlxuICogQHRoaXMge0tleWJvYXJkUGFufVxuICovXG5mdW5jdGlvbiBoYW5kbGVFdmVudChtYXBCcm93c2VyRXZlbnQpIHtcbiAgbGV0IHN0b3BFdmVudCA9IGZhbHNlO1xuICBpZiAobWFwQnJvd3NlckV2ZW50LnR5cGUgPT0gRXZlbnRUeXBlLktFWURPV04pIHtcbiAgICBjb25zdCBrZXlFdmVudCA9IC8qKiBAdHlwZSB7S2V5Ym9hcmRFdmVudH0gKi8gKG1hcEJyb3dzZXJFdmVudC5vcmlnaW5hbEV2ZW50KTtcbiAgICBjb25zdCBrZXlDb2RlID0ga2V5RXZlbnQua2V5Q29kZTtcbiAgICBpZiAodGhpcy5jb25kaXRpb25fKG1hcEJyb3dzZXJFdmVudCkgJiZcbiAgICAgICAgKGtleUNvZGUgPT0gS2V5Q29kZS5ET1dOIHx8XG4gICAgICAgIGtleUNvZGUgPT0gS2V5Q29kZS5MRUZUIHx8XG4gICAgICAgIGtleUNvZGUgPT0gS2V5Q29kZS5SSUdIVCB8fFxuICAgICAgICBrZXlDb2RlID09IEtleUNvZGUuVVApKSB7XG4gICAgICBjb25zdCBtYXAgPSBtYXBCcm93c2VyRXZlbnQubWFwO1xuICAgICAgY29uc3QgdmlldyA9IG1hcC5nZXRWaWV3KCk7XG4gICAgICBjb25zdCBtYXBVbml0c0RlbHRhID0gdmlldy5nZXRSZXNvbHV0aW9uKCkgKiB0aGlzLnBpeGVsRGVsdGFfO1xuICAgICAgbGV0IGRlbHRhWCA9IDAsIGRlbHRhWSA9IDA7XG4gICAgICBpZiAoa2V5Q29kZSA9PSBLZXlDb2RlLkRPV04pIHtcbiAgICAgICAgZGVsdGFZID0gLW1hcFVuaXRzRGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT0gS2V5Q29kZS5MRUZUKSB7XG4gICAgICAgIGRlbHRhWCA9IC1tYXBVbml0c0RlbHRhO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09IEtleUNvZGUuUklHSFQpIHtcbiAgICAgICAgZGVsdGFYID0gbWFwVW5pdHNEZWx0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbHRhWSA9IG1hcFVuaXRzRGVsdGE7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWx0YSA9IFtkZWx0YVgsIGRlbHRhWV07XG4gICAgICByb3RhdGVDb29yZGluYXRlKGRlbHRhLCB2aWV3LmdldFJvdGF0aW9uKCkpO1xuICAgICAgcGFuKHZpZXcsIGRlbHRhLCB0aGlzLmR1cmF0aW9uXyk7XG4gICAgICBtYXBCcm93c2VyRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHN0b3BFdmVudCA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiAhc3RvcEV2ZW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBLZXlib2FyZFBhbjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOzs7Ozs7OztBQ1JBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2QkE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBREE7QUFJQTs7Ozs7OztBQU9BO0FBQ0E7QUFFQTs7Ozs7OztBQU1BOzs7Ozs7QUFPQTs7Ozs7O0FBTUE7Ozs7O0FBR0E7O0FBMUNBOzs7Ozs7Ozs7OztBQXVEQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///152\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/LayerType.js\nvar LayerType = __webpack_require__(53);\n\n// EXTERNAL MODULE: ./node_modules/ol/TileState.js\nvar TileState = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./node_modules/ol/ViewHint.js\nvar ViewHint = __webpack_require__(18);\n\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar EventType = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/rbush/index.js\nvar rbush = __webpack_require__(74);\nvar rbush_default = /*#__PURE__*/__webpack_require__.n(rbush);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar extent = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/ol/layer/VectorTileRenderType.js\n/**\n * @module ol/layer/VectorTileRenderType\n */\n\n/**\n * @enum {string}\n * Render mode for vector tiles:\n *  * `\'image\'`: Vector tiles are rendered as images. Great performance, but\n *    point symbols and texts are always rotated with the view and pixels are\n *    scaled during zoom animations.\n *  * `\'hybrid\'`: Polygon and line elements are rendered as images, so pixels\n *    are scaled during zoom animations. Point symbols and texts are accurately\n *    rendered as vectors and can stay upright on rotated views.\n *  * `\'vector\'`: Vector tiles are rendered as vectors. Most accurate rendering\n *    even during animations, but slower performance than the other options.\n * @api\n */\n/* harmony default export */ var VectorTileRenderType = ({\n  IMAGE: \'image\',\n  HYBRID: \'hybrid\',\n  VECTOR: \'vector\'\n});\n// EXTERNAL MODULE: ./node_modules/ol/proj.js + 3 modules\nvar proj = __webpack_require__(10);\n\n// EXTERNAL MODULE: ./node_modules/ol/proj/Units.js\nvar Units = __webpack_require__(26);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/ReplayType.js\nvar ReplayType = __webpack_require__(14);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js\nvar canvas = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/canvas/ReplayGroup.js + 9 modules\nvar ReplayGroup = __webpack_require__(81);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/replay.js\nvar replay = __webpack_require__(43);\n\n// EXTERNAL MODULE: ./node_modules/ol/renderer/canvas/TileLayer.js + 1 modules\nvar TileLayer = __webpack_require__(109);\n\n// EXTERNAL MODULE: ./node_modules/ol/renderer/vector.js\nvar vector = __webpack_require__(51);\n\n// EXTERNAL MODULE: ./node_modules/ol/transform.js\nvar ol_transform = __webpack_require__(9);\n\n// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/VectorTileLayer.js\n/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @type {!Object<string, Array<import("../../render/ReplayType.js").default>>}\n */\n\nvar IMAGE_REPLAYS = {\n  \'image\': [ReplayType["a" /* default */].POLYGON, ReplayType["a" /* default */].CIRCLE, ReplayType["a" /* default */].LINE_STRING, ReplayType["a" /* default */].IMAGE, ReplayType["a" /* default */].TEXT],\n  \'hybrid\': [ReplayType["a" /* default */].POLYGON, ReplayType["a" /* default */].LINE_STRING]\n};\n/**\n * @type {!Object<string, Array<import("../../render/ReplayType.js").default>>}\n */\n\nvar VECTOR_REPLAYS = {\n  \'image\': [ReplayType["a" /* default */].DEFAULT],\n  \'hybrid\': [ReplayType["a" /* default */].IMAGE, ReplayType["a" /* default */].TEXT, ReplayType["a" /* default */].DEFAULT],\n  \'vector\': replay["a" /* ORDER */]\n};\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\n\nvar VectorTileLayer_CanvasVectorTileLayerRenderer =\n/*@__PURE__*/\nfunction (CanvasTileLayerRenderer) {\n  function CanvasVectorTileLayerRenderer(layer) {\n    CanvasTileLayerRenderer.call(this, layer, true);\n    /**\n     * Declutter tree.\n     * @private\n     */\n\n    this.declutterTree_ = layer.getDeclutter() ? rbush_default()(9, undefined) : null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.dirty_ = false;\n    /**\n     * @private\n     * @type {number}\n     */\n\n    this.renderedLayerRevision_;\n    /**\n     * @private\n     * @type {import("../../transform.js").Transform}\n     */\n\n    this.tmpTransform_ = Object(ol_transform["c" /* create */])();\n    var renderMode = layer.getRenderMode(); // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n\n    this.zDirection = renderMode === VectorTileRenderType.VECTOR ? 1 : 0;\n\n    if (renderMode !== VectorTileRenderType.VECTOR) {\n      this.context = Object(dom["a" /* createCanvasContext2D */])();\n    }\n\n    Object(events["a" /* listen */])(canvas["o" /* labelCache */], EventType["a" /* default */].CLEAR, this.handleFontsChanged_, this);\n  }\n\n  if (CanvasTileLayerRenderer) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer;\n  CanvasVectorTileLayerRenderer.prototype = Object.create(CanvasTileLayerRenderer && CanvasTileLayerRenderer.prototype);\n  CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;\n  /**\n   * @inheritDoc\n   */\n\n  CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n    Object(events["c" /* unlisten */])(canvas["o" /* labelCache */], EventType["a" /* default */].CLEAR, this.handleFontsChanged_, this);\n    CanvasTileLayerRenderer.prototype.disposeInternal.call(this);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);\n\n    if (tile.getState() === TileState["a" /* default */].LOADED) {\n      this.createReplayGroup_(\n      /** @type {import("../../VectorImageTile.js").default} */\n      tile, pixelRatio, projection);\n\n      if (this.context) {\n        this.renderTileImage_(\n        /** @type {import("../../VectorImageTile.js").default} */\n        tile, pixelRatio, projection);\n      }\n    }\n\n    return tile;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n    var tileLayer =\n    /** @type {import("../../layer/Tile.js").default} */\n    this.getLayer();\n    return (\n      /** @type {import("../../VectorImageTile.js").default} */\n      tile.getImage(tileLayer)\n    );\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var layer =\n    /** @type {import("../../layer/Vector.js").default} */\n    this.getLayer();\n    var layerRevision = layer.getRevision();\n\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n\n    this.renderedLayerRevision_ = layerRevision;\n    return CanvasTileLayerRenderer.prototype.prepareFrame.call(this, frameState, layerState);\n  };\n  /**\n   * @param {import("../../VectorImageTile.js").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import("../../proj/Projection.js").default} projection Projection.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_(tile, pixelRatio, projection) {\n    var this$1 = this;\n    var layer =\n    /** @type {import("../../layer/Vector.js").default} */\n    this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder =\n    /** @type {import("../../render.js").OrderFunction} */\n    layer.getRenderOrder() || null;\n    var replayState = tile.getReplayState(layer);\n\n    if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n\n    var source =\n    /** @type {import("../../source/VectorTile.js").default} */\n    layer.getSource();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var resolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var tileExtent = tile.extent;\n\n    var loop = function loop(t, tt) {\n      var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n      if (sourceTile.getState() != TileState["a" /* default */].LOADED) {\n        return;\n      }\n\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = Object(extent["getIntersection"])(tileExtent, sourceTileExtent);\n      var bufferedExtent = Object(extent["equals"])(sourceTileExtent, sharedExtent) ? null : Object(extent["buffer"])(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);\n      var tileProjection = sourceTile.getProjection();\n      var reproject = false;\n\n      if (!Object(proj["equivalent"])(projection, tileProjection)) {\n        reproject = true;\n        sourceTile.setProjection(projection);\n      }\n\n      replayState.dirty = false;\n      var replayGroup = new ReplayGroup["a" /* default */](0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());\n      var squaredTolerance = Object(vector["b" /* getSquaredTolerance */])(resolution, pixelRatio);\n      /**\n       * @param {import("../../Feature.js").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n\n      var render = function render(feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          replayState.dirty = replayState.dirty || dirty;\n        }\n      };\n\n      var features = sourceTile.getFeatures();\n\n      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n\n        if (reproject) {\n          if (tileProjection.getUnits() == Units["b" /* default */].TILE_PIXELS) {\n            // projected tile extent\n            tileProjection.setWorldExtent(sourceTileExtent); // tile extent in tile pixel space\n\n            tileProjection.setExtent(sourceTile.getExtent());\n          }\n\n          feature.getGeometry().transform(tileProjection, projection);\n        }\n\n        if (!bufferedExtent || Object(extent["intersects"])(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this$1, feature);\n        }\n      }\n\n      replayGroup.finish();\n      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n    };\n\n    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n      loop(t, tt);\n    }\n\n    replayState.renderedRevision = revision;\n    replayState.renderedRenderOrder = renderOrder;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    /** @type {!Object<string, boolean>} */\n\n    var features = {};\n    var renderedTiles =\n    /** @type {Array<import("../../VectorImageTile.js").default>} */\n    this.renderedTiles;\n    var bufferedExtent, found;\n    var i, ii;\n\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      var tile = renderedTiles[i];\n      bufferedExtent = Object(extent["buffer"])(tile.extent, hitTolerance * resolution, bufferedExtent);\n\n      if (!Object(extent["containsCoordinate"])(bufferedExtent, coordinate)) {\n        continue;\n      }\n\n      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n        if (sourceTile.getState() != TileState["a" /* default */].LOADED) {\n          continue;\n        }\n\n        var replayGroup =\n        /** @type {CanvasReplayGroup} */\n        sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n        /**\n         * @param {import("../../Feature.js").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          var key = Object(util["c" /* getUid */])(feature);\n\n          if (!(key in features)) {\n            features[key] = true;\n            return callback.call(thisArg, feature, layer);\n          }\n        }, null);\n      }\n    }\n\n    return found;\n  };\n  /**\n   * @param {import("../../VectorTile.js").default} tile Tile.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @return {import("../../transform.js").Transform} transform Transform.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_(tile, frameState) {\n    var layer = this.getLayer();\n    var source =\n    /** @type {import("../../source/VectorTile.js").default} */\n    layer.getSource();\n    var tileGrid = source.getTileGrid();\n    var tileCoord = tile.tileCoord;\n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var viewState = frameState.viewState;\n    var pixelRatio = frameState.pixelRatio;\n    var renderResolution = viewState.resolution / pixelRatio;\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var center = viewState.center;\n    var origin = Object(extent["getTopLeft"])(tileExtent);\n    var size = frameState.size;\n    var offsetX = Math.round(pixelRatio * size[0] / 2);\n    var offsetY = Math.round(pixelRatio * size[1] / 2);\n    return Object(ol_transform["b" /* compose */])(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);\n  };\n  /**\n   * @param {import("../../events/Event.js").default} event Event.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n    var layer = this.getLayer();\n\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n  /**\n   * Handle changes in image style state.\n   * @param {import("../../events/Event.js").default} event Image style change event.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose(context, frameState, layerState) {\n    var layer =\n    /** @type {import("../../layer/Vector.js").default} */\n    this.getLayer();\n    var renderMode = layer.getRenderMode();\n\n    if (renderMode != VectorTileRenderType.IMAGE) {\n      var declutterReplays = layer.getDeclutter() ? {} : null;\n      var source =\n      /** @type {import("../../source/VectorTile.js").default} */\n      layer.getSource();\n      var replayTypes = VECTOR_REPLAYS[renderMode];\n      var pixelRatio = frameState.pixelRatio;\n      var rotation = frameState.viewState.rotation;\n      var size = frameState.size;\n      var offsetX, offsetY;\n\n      if (rotation) {\n        offsetX = Math.round(pixelRatio * size[0] / 2);\n        offsetY = Math.round(pixelRatio * size[1] / 2);\n        Object(canvas["s" /* rotateAtOffset */])(context, -rotation, offsetX, offsetY);\n      }\n\n      if (declutterReplays) {\n        this.declutterTree_.clear();\n      }\n\n      var viewHints = frameState.viewHints;\n      var snapToPixel = !(viewHints[ViewHint["a" /* default */].ANIMATING] || viewHints[ViewHint["a" /* default */].INTERACTING]);\n      var tiles = this.renderedTiles;\n      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      var clips = [];\n      var zs = [];\n\n      for (var i = tiles.length - 1; i >= 0; --i) {\n        var tile =\n        /** @type {import("../../VectorImageTile.js").default} */\n        tiles[i];\n\n        if (tile.getState() == TileState["a" /* default */].ABORT) {\n          continue;\n        }\n\n        var tileCoord = tile.tileCoord;\n        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n        var transform = undefined;\n\n        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n          var sourceTile = tile.getTile(tile.tileKeys[t]);\n\n          if (sourceTile.getState() != TileState["a" /* default */].LOADED) {\n            continue;\n          }\n\n          var replayGroup =\n          /** @type {CanvasReplayGroup} */\n          sourceTile.getReplayGroup(layer, tileCoord.toString());\n\n          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n            // sourceTile was not yet loaded when this.createReplayGroup_() was\n            // called, or it has no replays of the types we want to render\n            continue;\n          }\n\n          if (!transform) {\n            transform = this.getTransform(frameState, worldOffset);\n          }\n\n          var currentZ = sourceTile.tileCoord[0];\n          var currentClip = replayGroup.getClipCoords(transform);\n          context.save();\n          context.globalAlpha = layerState.opacity; // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            var clip = clips[j];\n\n            if (currentZ < zs[j]) {\n              context.beginPath(); // counter-clockwise (outer ring) for current tile\n\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile\n\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n\n          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);\n          context.restore();\n          clips.push(currentClip);\n          zs.push(currentZ);\n        }\n      }\n\n      if (declutterReplays) {\n        Object(ReplayGroup["b" /* replayDeclutter */])(declutterReplays, context, rotation, snapToPixel);\n      }\n\n      if (rotation) {\n        Object(canvas["s" /* rotateAtOffset */])(context, rotation,\n        /** @type {number} */\n        offsetX,\n        /** @type {number} */\n        offsetY);\n      }\n    }\n\n    CanvasTileLayerRenderer.prototype.postCompose.call(this, context, frameState, layerState);\n  };\n  /**\n   * @param {import("../../Feature.js").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.\n   * @param {import("../../render/canvas/ReplayGroup.js").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, squaredTolerance, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n\n    var loading = false;\n\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = Object(vector["d" /* renderFeature */])(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = Object(vector["d" /* renderFeature */])(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);\n    }\n\n    return loading;\n  };\n  /**\n   * @param {import("../../VectorImageTile.js").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import("../../proj/Projection.js").default} projection Projection.\n   * @private\n   */\n\n\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_(tile, pixelRatio, projection) {\n    var layer =\n    /** @type {import("../../layer/Vector.js").default} */\n    this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var replays = IMAGE_REPLAYS[layer.getRenderMode()];\n\n    if (replays && replayState.renderedTileRevision !== revision) {\n      replayState.renderedTileRevision = revision;\n      var tileCoord = tile.wrappedTileCoord;\n      var z = tileCoord[0];\n      var source =\n      /** @type {import("../../source/VectorTile.js").default} */\n      layer.getSource();\n      var tileGrid = source.getTileGridForProjection(projection);\n      var resolution = tileGrid.getResolution(z);\n      var context = tile.getContext(layer);\n      var size = source.getTilePixelSize(z, pixelRatio, projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n\n      for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n        var sourceTile = tile.getTile(tile.tileKeys[i]);\n\n        if (sourceTile.getState() != TileState["a" /* default */].LOADED) {\n          continue;\n        }\n\n        var pixelScale = pixelRatio / resolution;\n        var transform = Object(ol_transform["e" /* reset */])(this.tmpTransform_);\n        Object(ol_transform["f" /* scale */])(transform, pixelScale, -pixelScale);\n        Object(ol_transform["h" /* translate */])(transform, -tileExtent[0], -tileExtent[3]);\n        var replayGroup =\n        /** @type {CanvasReplayGroup} */\n        sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        replayGroup.replay(context, transform, 0, {}, true, replays);\n      }\n    }\n  };\n\n  return CanvasVectorTileLayerRenderer;\n}(TileLayer["default"]);\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import("../../layer/Layer.js").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\n\n\nVectorTileLayer_CanvasVectorTileLayerRenderer[\'handles\'] = function (layer) {\n  return layer.getType() === LayerType["a" /* default */].VECTOR_TILE;\n};\n/**\n * Create a layer renderer.\n * @param {import("../Map.js").default} mapRenderer The map renderer.\n * @param {import("../../layer/Layer.js").default} layer The layer to be rendererd.\n * @return {CanvasVectorTileLayerRenderer} The layer renderer.\n */\n\n\nVectorTileLayer_CanvasVectorTileLayerRenderer[\'create\'] = function (mapRenderer, layer) {\n  return new VectorTileLayer_CanvasVectorTileLayerRenderer(\n  /** @type {import("../../layer/VectorTile.js").default} */\n  layer);\n};\n\n/* harmony default export */ var VectorTileLayer = __webpack_exports__["default"] = (VectorTileLayer_CanvasVectorTileLayerRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9sYXllci9WZWN0b3JUaWxlUmVuZGVyVHlwZS5qcz80NWY5Iiwid2VicGFjazovLy8uLi8uLi8uLi8uLi9zcmMvb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvclRpbGVMYXllci5qcz80ZTgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBvbC9sYXllci9WZWN0b3JUaWxlUmVuZGVyVHlwZVxuICovXG5cbi8qKlxuICogQGVudW0ge3N0cmluZ31cbiAqIFJlbmRlciBtb2RlIGZvciB2ZWN0b3IgdGlsZXM6XG4gKiAgKiBgJ2ltYWdlJ2A6IFZlY3RvciB0aWxlcyBhcmUgcmVuZGVyZWQgYXMgaW1hZ2VzLiBHcmVhdCBwZXJmb3JtYW5jZSwgYnV0XG4gKiAgICBwb2ludCBzeW1ib2xzIGFuZCB0ZXh0cyBhcmUgYWx3YXlzIHJvdGF0ZWQgd2l0aCB0aGUgdmlldyBhbmQgcGl4ZWxzIGFyZVxuICogICAgc2NhbGVkIGR1cmluZyB6b29tIGFuaW1hdGlvbnMuXG4gKiAgKiBgJ2h5YnJpZCdgOiBQb2x5Z29uIGFuZCBsaW5lIGVsZW1lbnRzIGFyZSByZW5kZXJlZCBhcyBpbWFnZXMsIHNvIHBpeGVsc1xuICogICAgYXJlIHNjYWxlZCBkdXJpbmcgem9vbSBhbmltYXRpb25zLiBQb2ludCBzeW1ib2xzIGFuZCB0ZXh0cyBhcmUgYWNjdXJhdGVseVxuICogICAgcmVuZGVyZWQgYXMgdmVjdG9ycyBhbmQgY2FuIHN0YXkgdXByaWdodCBvbiByb3RhdGVkIHZpZXdzLlxuICogICogYCd2ZWN0b3InYDogVmVjdG9yIHRpbGVzIGFyZSByZW5kZXJlZCBhcyB2ZWN0b3JzLiBNb3N0IGFjY3VyYXRlIHJlbmRlcmluZ1xuICogICAgZXZlbiBkdXJpbmcgYW5pbWF0aW9ucywgYnV0IHNsb3dlciBwZXJmb3JtYW5jZSB0aGFuIHRoZSBvdGhlciBvcHRpb25zLlxuICogQGFwaVxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIElNQUdFOiAnaW1hZ2UnLFxuICBIWUJSSUQ6ICdoeWJyaWQnLFxuICBWRUNUT1I6ICd2ZWN0b3InXG59O1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9WZWN0b3JUaWxlTGF5ZXJcbiAqL1xuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uLy4uL3V0aWwuanMnO1xuaW1wb3J0IExheWVyVHlwZSBmcm9tICcuLi8uLi9MYXllclR5cGUuanMnO1xuaW1wb3J0IFRpbGVTdGF0ZSBmcm9tICcuLi8uLi9UaWxlU3RhdGUuanMnO1xuaW1wb3J0IFZpZXdIaW50IGZyb20gJy4uLy4uL1ZpZXdIaW50LmpzJztcbmltcG9ydCB7Y3JlYXRlQ2FudmFzQ29udGV4dDJEfSBmcm9tICcuLi8uLi9kb20uanMnO1xuaW1wb3J0IHtsaXN0ZW4sIHVubGlzdGVufSBmcm9tICcuLi8uLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi8uLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCByYnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQge2J1ZmZlciwgY29udGFpbnNDb29yZGluYXRlLCBlcXVhbHMsIGdldEludGVyc2VjdGlvbiwgZ2V0VG9wTGVmdCwgaW50ZXJzZWN0c30gZnJvbSAnLi4vLi4vZXh0ZW50LmpzJztcbmltcG9ydCBWZWN0b3JUaWxlUmVuZGVyVHlwZSBmcm9tICcuLi8uLi9sYXllci9WZWN0b3JUaWxlUmVuZGVyVHlwZS5qcyc7XG5pbXBvcnQge2VxdWl2YWxlbnQgYXMgZXF1aXZhbGVudFByb2plY3Rpb259IGZyb20gJy4uLy4uL3Byb2ouanMnO1xuaW1wb3J0IFVuaXRzIGZyb20gJy4uLy4uL3Byb2ovVW5pdHMuanMnO1xuaW1wb3J0IFJlcGxheVR5cGUgZnJvbSAnLi4vLi4vcmVuZGVyL1JlcGxheVR5cGUuanMnO1xuaW1wb3J0IHtsYWJlbENhY2hlLCByb3RhdGVBdE9mZnNldH0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzUmVwbGF5R3JvdXAsIHtyZXBsYXlEZWNsdXR0ZXJ9IGZyb20gJy4uLy4uL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanMnO1xuaW1wb3J0IHtPUkRFUn0gZnJvbSAnLi4vLi4vcmVuZGVyL3JlcGxheS5qcyc7XG5pbXBvcnQgQ2FudmFzVGlsZUxheWVyUmVuZGVyZXIgZnJvbSAnLi9UaWxlTGF5ZXIuanMnO1xuaW1wb3J0IHtnZXRTcXVhcmVkVG9sZXJhbmNlIGFzIGdldFNxdWFyZWRSZW5kZXJUb2xlcmFuY2UsIHJlbmRlckZlYXR1cmV9IGZyb20gJy4uL3ZlY3Rvci5qcyc7XG5pbXBvcnQge1xuICBjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLFxuICBjb21wb3NlIGFzIGNvbXBvc2VUcmFuc2Zvcm0sXG4gIHJlc2V0IGFzIHJlc2V0VHJhbnNmb3JtLFxuICBzY2FsZSBhcyBzY2FsZVRyYW5zZm9ybSxcbiAgdHJhbnNsYXRlIGFzIHRyYW5zbGF0ZVRyYW5zZm9ybVxufSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuXG5cbi8qKlxuICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBBcnJheTxpbXBvcnQoXCIuLi8uLi9yZW5kZXIvUmVwbGF5VHlwZS5qc1wiKS5kZWZhdWx0Pj59XG4gKi9cbmNvbnN0IElNQUdFX1JFUExBWVMgPSB7XG4gICdpbWFnZSc6IFtSZXBsYXlUeXBlLlBPTFlHT04sIFJlcGxheVR5cGUuQ0lSQ0xFLFxuICAgIFJlcGxheVR5cGUuTElORV9TVFJJTkcsIFJlcGxheVR5cGUuSU1BR0UsIFJlcGxheVR5cGUuVEVYVF0sXG4gICdoeWJyaWQnOiBbUmVwbGF5VHlwZS5QT0xZR09OLCBSZXBsYXlUeXBlLkxJTkVfU1RSSU5HXVxufTtcblxuXG4vKipcbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgQXJyYXk8aW1wb3J0KFwiLi4vLi4vcmVuZGVyL1JlcGxheVR5cGUuanNcIikuZGVmYXVsdD4+fVxuICovXG5jb25zdCBWRUNUT1JfUkVQTEFZUyA9IHtcbiAgJ2ltYWdlJzogW1JlcGxheVR5cGUuREVGQVVMVF0sXG4gICdoeWJyaWQnOiBbUmVwbGF5VHlwZS5JTUFHRSwgUmVwbGF5VHlwZS5URVhULCBSZXBsYXlUeXBlLkRFRkFVTFRdLFxuICAndmVjdG9yJzogT1JERVJcbn07XG5cblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBDYW52YXMgcmVuZGVyZXIgZm9yIHZlY3RvciB0aWxlIGxheWVycy5cbiAqIEBhcGlcbiAqL1xuY2xhc3MgQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXIgZXh0ZW5kcyBDYW52YXNUaWxlTGF5ZXJSZW5kZXJlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSBsYXllciBWZWN0b3JUaWxlIGxheWVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IobGF5ZXIpIHtcblxuICAgIHN1cGVyKGxheWVyLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIERlY2x1dHRlciB0cmVlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZWNsdXR0ZXJUcmVlXyA9IGxheWVyLmdldERlY2x1dHRlcigpID8gcmJ1c2goOSwgdW5kZWZpbmVkKSA6IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZGlydHlfID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlZExheWVyUmV2aXNpb25fO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnRtcFRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGNvbnN0IHJlbmRlck1vZGUgPSBsYXllci5nZXRSZW5kZXJNb2RlKCk7XG5cbiAgICAvLyBVc2UgbG93ZXIgcmVzb2x1dGlvbiBmb3IgcHVyZSB2ZWN0b3IgcmVuZGVyaW5nLiBDbG9zZXN0IHJlc29sdXRpb24gb3RoZXJ3aXNlLlxuICAgIHRoaXMuekRpcmVjdGlvbiA9IHJlbmRlck1vZGUgPT09IFZlY3RvclRpbGVSZW5kZXJUeXBlLlZFQ1RPUiA/IDEgOiAwO1xuXG4gICAgaWYgKHJlbmRlck1vZGUgIT09IFZlY3RvclRpbGVSZW5kZXJUeXBlLlZFQ1RPUikge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dDJEKCk7XG4gICAgfVxuXG5cbiAgICBsaXN0ZW4obGFiZWxDYWNoZSwgRXZlbnRUeXBlLkNMRUFSLCB0aGlzLmhhbmRsZUZvbnRzQ2hhbmdlZF8sIHRoaXMpO1xuXG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGRpc3Bvc2VJbnRlcm5hbCgpIHtcbiAgICB1bmxpc3RlbihsYWJlbENhY2hlLCBFdmVudFR5cGUuQ0xFQVIsIHRoaXMuaGFuZGxlRm9udHNDaGFuZ2VkXywgdGhpcyk7XG4gICAgc3VwZXIuZGlzcG9zZUludGVybmFsKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGdldFRpbGUoeiwgeCwgeSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IHRpbGUgPSBzdXBlci5nZXRUaWxlKHosIHgsIHksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgIGlmICh0aWxlLmdldFN0YXRlKCkgPT09IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgIHRoaXMuY3JlYXRlUmVwbGF5R3JvdXBfKC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vVmVjdG9ySW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlKSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbik7XG4gICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGlsZUltYWdlXygvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZSksIHBpeGVsUmF0aW8sIHByb2plY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0VGlsZUltYWdlKHRpbGUpIHtcbiAgICBjb25zdCB0aWxlTGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1RpbGUuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vVmVjdG9ySW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9ICovICh0aWxlKS5nZXRJbWFnZSh0aWxlTGF5ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBwcmVwYXJlRnJhbWUoZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSkge1xuICAgIGNvbnN0IGxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgY29uc3QgbGF5ZXJSZXZpc2lvbiA9IGxheWVyLmdldFJldmlzaW9uKCk7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRMYXllclJldmlzaW9uXyAhPSBsYXllclJldmlzaW9uKSB7XG4gICAgICB0aGlzLnJlbmRlcmVkVGlsZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlZExheWVyUmV2aXNpb25fID0gbGF5ZXJSZXZpc2lvbjtcbiAgICByZXR1cm4gc3VwZXIucHJlcGFyZUZyYW1lKGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVmVjdG9ySW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNyZWF0ZVJlcGxheUdyb3VwXyh0aWxlLCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKSB7XG4gICAgY29uc3QgbGF5ZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3Rvci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllcigpKTtcbiAgICBjb25zdCByZXZpc2lvbiA9IGxheWVyLmdldFJldmlzaW9uKCk7XG4gICAgY29uc3QgcmVuZGVyT3JkZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3JlbmRlci5qc1wiKS5PcmRlckZ1bmN0aW9ufSAqLyAobGF5ZXIuZ2V0UmVuZGVyT3JkZXIoKSkgfHwgbnVsbDtcblxuICAgIGNvbnN0IHJlcGxheVN0YXRlID0gdGlsZS5nZXRSZXBsYXlTdGF0ZShsYXllcik7XG4gICAgaWYgKCFyZXBsYXlTdGF0ZS5kaXJ0eSAmJiByZXBsYXlTdGF0ZS5yZW5kZXJlZFJldmlzaW9uID09IHJldmlzaW9uICYmXG4gICAgICAgIHJlcGxheVN0YXRlLnJlbmRlcmVkUmVuZGVyT3JkZXIgPT0gcmVuZGVyT3JkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL3NvdXJjZS9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9ICovIChsYXllci5nZXRTb3VyY2UoKSk7XG4gICAgY29uc3Qgc291cmNlVGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWQoKTtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHNvdXJjZS5nZXRUaWxlR3JpZEZvclByb2plY3Rpb24ocHJvamVjdGlvbik7XG4gICAgY29uc3QgcmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24odGlsZS50aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHRpbGVFeHRlbnQgPSB0aWxlLmV4dGVudDtcblxuICAgIGZvciAobGV0IHQgPSAwLCB0dCA9IHRpbGUudGlsZUtleXMubGVuZ3RoOyB0IDwgdHQ7ICsrdCkge1xuICAgICAgY29uc3Qgc291cmNlVGlsZSA9IHRpbGUuZ2V0VGlsZSh0aWxlLnRpbGVLZXlzW3RdKTtcbiAgICAgIGlmIChzb3VyY2VUaWxlLmdldFN0YXRlKCkgIT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc291cmNlVGlsZUNvb3JkID0gc291cmNlVGlsZS50aWxlQ29vcmQ7XG4gICAgICBjb25zdCBzb3VyY2VUaWxlRXh0ZW50ID0gc291cmNlVGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHNvdXJjZVRpbGVDb29yZCk7XG4gICAgICBjb25zdCBzaGFyZWRFeHRlbnQgPSBnZXRJbnRlcnNlY3Rpb24odGlsZUV4dGVudCwgc291cmNlVGlsZUV4dGVudCk7XG4gICAgICBjb25zdCBidWZmZXJlZEV4dGVudCA9IGVxdWFscyhzb3VyY2VUaWxlRXh0ZW50LCBzaGFyZWRFeHRlbnQpID8gbnVsbCA6XG4gICAgICAgIGJ1ZmZlcihzaGFyZWRFeHRlbnQsIGxheWVyLmdldFJlbmRlckJ1ZmZlcigpICogcmVzb2x1dGlvbiwgdGhpcy50bXBFeHRlbnQpO1xuICAgICAgY29uc3QgdGlsZVByb2plY3Rpb24gPSBzb3VyY2VUaWxlLmdldFByb2plY3Rpb24oKTtcbiAgICAgIGxldCByZXByb2plY3QgPSBmYWxzZTtcbiAgICAgIGlmICghZXF1aXZhbGVudFByb2plY3Rpb24ocHJvamVjdGlvbiwgdGlsZVByb2plY3Rpb24pKSB7XG4gICAgICAgIHJlcHJvamVjdCA9IHRydWU7XG4gICAgICAgIHNvdXJjZVRpbGUuc2V0UHJvamVjdGlvbihwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJlcGxheVN0YXRlLmRpcnR5ID0gZmFsc2U7XG4gICAgICBjb25zdCByZXBsYXlHcm91cCA9IG5ldyBDYW52YXNSZXBsYXlHcm91cCgwLCBzaGFyZWRFeHRlbnQsIHJlc29sdXRpb24sXG4gICAgICAgIHBpeGVsUmF0aW8sIHNvdXJjZS5nZXRPdmVybGFwcygpLCB0aGlzLmRlY2x1dHRlclRyZWVfLCBsYXllci5nZXRSZW5kZXJCdWZmZXIoKSk7XG4gICAgICBjb25zdCBzcXVhcmVkVG9sZXJhbmNlID0gZ2V0U3F1YXJlZFJlbmRlclRvbGVyYW5jZShyZXNvbHV0aW9uLCBwaXhlbFJhdGlvKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAqIEB0aGlzIHtDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlcn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgcmVuZGVyID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICBsZXQgc3R5bGVzO1xuICAgICAgICBjb25zdCBzdHlsZUZ1bmN0aW9uID0gZmVhdHVyZS5nZXRTdHlsZUZ1bmN0aW9uKCkgfHwgbGF5ZXIuZ2V0U3R5bGVGdW5jdGlvbigpO1xuICAgICAgICBpZiAoc3R5bGVGdW5jdGlvbikge1xuICAgICAgICAgIHN0eWxlcyA9IHN0eWxlRnVuY3Rpb24oZmVhdHVyZSwgcmVzb2x1dGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgIGNvbnN0IGRpcnR5ID0gdGhpcy5yZW5kZXJGZWF0dXJlKGZlYXR1cmUsIHNxdWFyZWRUb2xlcmFuY2UsIHN0eWxlcywgcmVwbGF5R3JvdXApO1xuICAgICAgICAgIHRoaXMuZGlydHlfID0gdGhpcy5kaXJ0eV8gfHwgZGlydHk7XG4gICAgICAgICAgcmVwbGF5U3RhdGUuZGlydHkgPSByZXBsYXlTdGF0ZS5kaXJ0eSB8fCBkaXJ0eTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgZmVhdHVyZXMgPSBzb3VyY2VUaWxlLmdldEZlYXR1cmVzKCk7XG4gICAgICBpZiAocmVuZGVyT3JkZXIgJiYgcmVuZGVyT3JkZXIgIT09IHJlcGxheVN0YXRlLnJlbmRlcmVkUmVuZGVyT3JkZXIpIHtcbiAgICAgICAgZmVhdHVyZXMuc29ydChyZW5kZXJPcmRlcik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICAgICAgaWYgKHJlcHJvamVjdCkge1xuICAgICAgICAgIGlmICh0aWxlUHJvamVjdGlvbi5nZXRVbml0cygpID09IFVuaXRzLlRJTEVfUElYRUxTKSB7XG4gICAgICAgICAgICAvLyBwcm9qZWN0ZWQgdGlsZSBleHRlbnRcbiAgICAgICAgICAgIHRpbGVQcm9qZWN0aW9uLnNldFdvcmxkRXh0ZW50KHNvdXJjZVRpbGVFeHRlbnQpO1xuICAgICAgICAgICAgLy8gdGlsZSBleHRlbnQgaW4gdGlsZSBwaXhlbCBzcGFjZVxuICAgICAgICAgICAgdGlsZVByb2plY3Rpb24uc2V0RXh0ZW50KHNvdXJjZVRpbGUuZ2V0RXh0ZW50KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZWF0dXJlLmdldEdlb21ldHJ5KCkudHJhbnNmb3JtKHRpbGVQcm9qZWN0aW9uLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJ1ZmZlcmVkRXh0ZW50IHx8IGludGVyc2VjdHMoYnVmZmVyZWRFeHRlbnQsIGZlYXR1cmUuZ2V0R2VvbWV0cnkoKS5nZXRFeHRlbnQoKSkpIHtcbiAgICAgICAgICByZW5kZXIuY2FsbCh0aGlzLCBmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVwbGF5R3JvdXAuZmluaXNoKCk7XG4gICAgICBzb3VyY2VUaWxlLnNldFJlcGxheUdyb3VwKGxheWVyLCB0aWxlLnRpbGVDb29yZC50b1N0cmluZygpLCByZXBsYXlHcm91cCk7XG4gICAgfVxuICAgIHJlcGxheVN0YXRlLnJlbmRlcmVkUmV2aXNpb24gPSByZXZpc2lvbjtcbiAgICByZXBsYXlTdGF0ZS5yZW5kZXJlZFJlbmRlck9yZGVyID0gcmVuZGVyT3JkZXI7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKGNvb3JkaW5hdGUsIGZyYW1lU3RhdGUsIGhpdFRvbGVyYW5jZSwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBjb25zdCByZXNvbHV0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBjb25zdCByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuICAgIGhpdFRvbGVyYW5jZSA9IGhpdFRvbGVyYW5jZSA9PSB1bmRlZmluZWQgPyAwIDogaGl0VG9sZXJhbmNlO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fSAqL1xuICAgIGNvbnN0IGZlYXR1cmVzID0ge307XG5cbiAgICBjb25zdCByZW5kZXJlZFRpbGVzID0gLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoXCIuLi8uLi9WZWN0b3JJbWFnZVRpbGUuanNcIikuZGVmYXVsdD59ICovICh0aGlzLnJlbmRlcmVkVGlsZXMpO1xuXG4gICAgbGV0IGJ1ZmZlcmVkRXh0ZW50LCBmb3VuZDtcbiAgICBsZXQgaSwgaWk7XG4gICAgZm9yIChpID0gMCwgaWkgPSByZW5kZXJlZFRpbGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IHRpbGUgPSByZW5kZXJlZFRpbGVzW2ldO1xuICAgICAgYnVmZmVyZWRFeHRlbnQgPSBidWZmZXIodGlsZS5leHRlbnQsIGhpdFRvbGVyYW5jZSAqIHJlc29sdXRpb24sIGJ1ZmZlcmVkRXh0ZW50KTtcbiAgICAgIGlmICghY29udGFpbnNDb29yZGluYXRlKGJ1ZmZlcmVkRXh0ZW50LCBjb29yZGluYXRlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHQgPSAwLCB0dCA9IHRpbGUudGlsZUtleXMubGVuZ3RoOyB0IDwgdHQ7ICsrdCkge1xuICAgICAgICBjb25zdCBzb3VyY2VUaWxlID0gdGlsZS5nZXRUaWxlKHRpbGUudGlsZUtleXNbdF0pO1xuICAgICAgICBpZiAoc291cmNlVGlsZS5nZXRTdGF0ZSgpICE9IFRpbGVTdGF0ZS5MT0FERUQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBsYXlHcm91cCA9IC8qKiBAdHlwZSB7Q2FudmFzUmVwbGF5R3JvdXB9ICovIChzb3VyY2VUaWxlLmdldFJlcGxheUdyb3VwKGxheWVyLFxuICAgICAgICAgIHRpbGUudGlsZUNvb3JkLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgZm91bmQgPSBmb3VuZCB8fCByZXBsYXlHcm91cC5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShjb29yZGluYXRlLCByZXNvbHV0aW9uLCByb3RhdGlvbiwgaGl0VG9sZXJhbmNlLCB7fSxcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgICAgICAgKiBAcmV0dXJuIHs/fSBDYWxsYmFjayByZXN1bHQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0VWlkKGZlYXR1cmUpO1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGZlYXR1cmVzKSkge1xuICAgICAgICAgICAgICBmZWF0dXJlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZmVhdHVyZSwgbGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9WZWN0b3JUaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHJldHVybiB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX0gdHJhbnNmb3JtIFRyYW5zZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFJlcGxheVRyYW5zZm9ybV8odGlsZSwgZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgIGNvbnN0IHNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyLmdldFNvdXJjZSgpKTtcbiAgICBjb25zdCB0aWxlR3JpZCA9IHNvdXJjZS5nZXRUaWxlR3JpZCgpO1xuICAgIGNvbnN0IHRpbGVDb29yZCA9IHRpbGUudGlsZUNvb3JkO1xuICAgIGNvbnN0IHRpbGVSZXNvbHV0aW9uID0gdGlsZUdyaWQuZ2V0UmVzb2x1dGlvbih0aWxlQ29vcmRbMF0pO1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3QgcmVuZGVyUmVzb2x1dGlvbiA9IHZpZXdTdGF0ZS5yZXNvbHV0aW9uIC8gcGl4ZWxSYXRpbztcbiAgICBjb25zdCB0aWxlRXh0ZW50ID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGhpcy50bXBFeHRlbnQpO1xuICAgIGNvbnN0IGNlbnRlciA9IHZpZXdTdGF0ZS5jZW50ZXI7XG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0VG9wTGVmdCh0aWxlRXh0ZW50KTtcbiAgICBjb25zdCBzaXplID0gZnJhbWVTdGF0ZS5zaXplO1xuICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBzaXplWzBdIC8gMik7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHNpemVbMV0gLyAyKTtcbiAgICByZXR1cm4gY29tcG9zZVRyYW5zZm9ybSh0aGlzLnRtcFRyYW5zZm9ybV8sXG4gICAgICBvZmZzZXRYLCBvZmZzZXRZLFxuICAgICAgdGlsZVJlc29sdXRpb24gLyByZW5kZXJSZXNvbHV0aW9uLCB0aWxlUmVzb2x1dGlvbiAvIHJlbmRlclJlc29sdXRpb24sXG4gICAgICB2aWV3U3RhdGUucm90YXRpb24sXG4gICAgICAob3JpZ2luWzBdIC0gY2VudGVyWzBdKSAvIHRpbGVSZXNvbHV0aW9uLFxuICAgICAgKGNlbnRlclsxXSAtIG9yaWdpblsxXSkgLyB0aWxlUmVzb2x1dGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgRXZlbnQuXG4gICAqL1xuICBoYW5kbGVGb250c0NoYW5nZWRfKGV2ZW50KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgaWYgKGxheWVyLmdldFZpc2libGUoKSAmJiB0aGlzLnJlbmRlcmVkTGF5ZXJSZXZpc2lvbl8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGF5ZXIuY2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBpbWFnZSBzdHlsZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9ldmVudHMvRXZlbnQuanNcIikuZGVmYXVsdH0gZXZlbnQgSW1hZ2Ugc3R5bGUgY2hhbmdlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlU3R5bGVJbWFnZUNoYW5nZV8oZXZlbnQpIHtcbiAgICB0aGlzLnJlbmRlcklmUmVhZHlBbmRWaXNpYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIHBvc3RDb21wb3NlKGNvbnRleHQsIGZyYW1lU3RhdGUsIGxheWVyU3RhdGUpIHtcbiAgICBjb25zdCBsYXllciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvVmVjdG9yLmpzXCIpLmRlZmF1bHR9ICovICh0aGlzLmdldExheWVyKCkpO1xuICAgIGNvbnN0IHJlbmRlck1vZGUgPSBsYXllci5nZXRSZW5kZXJNb2RlKCk7XG4gICAgaWYgKHJlbmRlck1vZGUgIT0gVmVjdG9yVGlsZVJlbmRlclR5cGUuSU1BR0UpIHtcbiAgICAgIGNvbnN0IGRlY2x1dHRlclJlcGxheXMgPSBsYXllci5nZXREZWNsdXR0ZXIoKSA/IHt9IDogbnVsbDtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vc291cmNlL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyLmdldFNvdXJjZSgpKTtcbiAgICAgIGNvbnN0IHJlcGxheVR5cGVzID0gVkVDVE9SX1JFUExBWVNbcmVuZGVyTW9kZV07XG4gICAgICBjb25zdCBwaXhlbFJhdGlvID0gZnJhbWVTdGF0ZS5waXhlbFJhdGlvO1xuICAgICAgY29uc3Qgcm90YXRpb24gPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZS5yb3RhdGlvbjtcbiAgICAgIGNvbnN0IHNpemUgPSBmcmFtZVN0YXRlLnNpemU7XG4gICAgICBsZXQgb2Zmc2V0WCwgb2Zmc2V0WTtcbiAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICBvZmZzZXRYID0gTWF0aC5yb3VuZChwaXhlbFJhdGlvICogc2l6ZVswXSAvIDIpO1xuICAgICAgICBvZmZzZXRZID0gTWF0aC5yb3VuZChwaXhlbFJhdGlvICogc2l6ZVsxXSAvIDIpO1xuICAgICAgICByb3RhdGVBdE9mZnNldChjb250ZXh0LCAtcm90YXRpb24sIG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgfVxuICAgICAgaWYgKGRlY2x1dHRlclJlcGxheXMpIHtcbiAgICAgICAgdGhpcy5kZWNsdXR0ZXJUcmVlXy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgY29uc3Qgdmlld0hpbnRzID0gZnJhbWVTdGF0ZS52aWV3SGludHM7XG4gICAgICBjb25zdCBzbmFwVG9QaXhlbCA9ICEodmlld0hpbnRzW1ZpZXdIaW50LkFOSU1BVElOR10gfHwgdmlld0hpbnRzW1ZpZXdIaW50LklOVEVSQUNUSU5HXSk7XG4gICAgICBjb25zdCB0aWxlcyA9IHRoaXMucmVuZGVyZWRUaWxlcztcbiAgICAgIGNvbnN0IHRpbGVHcmlkID0gc291cmNlLmdldFRpbGVHcmlkRm9yUHJvamVjdGlvbihmcmFtZVN0YXRlLnZpZXdTdGF0ZS5wcm9qZWN0aW9uKTtcbiAgICAgIGNvbnN0IGNsaXBzID0gW107XG4gICAgICBjb25zdCB6cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IHRpbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IHRpbGUgPSAvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL1ZlY3RvckltYWdlVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAodGlsZXNbaV0pO1xuICAgICAgICBpZiAodGlsZS5nZXRTdGF0ZSgpID09IFRpbGVTdGF0ZS5BQk9SVCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbGVDb29yZCA9IHRpbGUudGlsZUNvb3JkO1xuICAgICAgICBjb25zdCB3b3JsZE9mZnNldCA9IHRpbGVHcmlkLmdldFRpbGVDb29yZEV4dGVudCh0aWxlQ29vcmQsIHRoaXMudG1wRXh0ZW50KVswXSAtIHRpbGUuZXh0ZW50WzBdO1xuICAgICAgICBsZXQgdHJhbnNmb3JtID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCB0ID0gMCwgdHQgPSB0aWxlLnRpbGVLZXlzLmxlbmd0aDsgdCA8IHR0OyArK3QpIHtcbiAgICAgICAgICBjb25zdCBzb3VyY2VUaWxlID0gdGlsZS5nZXRUaWxlKHRpbGUudGlsZUtleXNbdF0pO1xuICAgICAgICAgIGlmIChzb3VyY2VUaWxlLmdldFN0YXRlKCkgIT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlcGxheUdyb3VwID0gLyoqIEB0eXBlIHtDYW52YXNSZXBsYXlHcm91cH0gKi8gKHNvdXJjZVRpbGUuZ2V0UmVwbGF5R3JvdXAobGF5ZXIsIHRpbGVDb29yZC50b1N0cmluZygpKSk7XG4gICAgICAgICAgaWYgKCFyZXBsYXlHcm91cCB8fCAhcmVwbGF5R3JvdXAuaGFzUmVwbGF5cyhyZXBsYXlUeXBlcykpIHtcbiAgICAgICAgICAgIC8vIHNvdXJjZVRpbGUgd2FzIG5vdCB5ZXQgbG9hZGVkIHdoZW4gdGhpcy5jcmVhdGVSZXBsYXlHcm91cF8oKSB3YXNcbiAgICAgICAgICAgIC8vIGNhbGxlZCwgb3IgaXQgaGFzIG5vIHJlcGxheXMgb2YgdGhlIHR5cGVzIHdlIHdhbnQgdG8gcmVuZGVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUsIHdvcmxkT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY3VycmVudFogPSBzb3VyY2VUaWxlLnRpbGVDb29yZFswXTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Q2xpcCA9IHJlcGxheUdyb3VwLmdldENsaXBDb29yZHModHJhbnNmb3JtKTtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gbGF5ZXJTdGF0ZS5vcGFjaXR5O1xuICAgICAgICAgIC8vIENyZWF0ZSBhIGNsaXAgbWFzayBmb3IgcmVnaW9ucyBpbiB0aGlzIGxvdyByZXNvbHV0aW9uIHRpbGUgdGhhdCBhcmVcbiAgICAgICAgICAvLyBhbHJlYWR5IGZpbGxlZCBieSBhIGhpZ2hlciByZXNvbHV0aW9uIHRpbGVcbiAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamogPSBjbGlwcy5sZW5ndGg7IGogPCBqajsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBjbGlwID0gY2xpcHNbal07XG4gICAgICAgICAgICBpZiAoY3VycmVudFogPCB6c1tqXSkge1xuICAgICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAvLyBjb3VudGVyLWNsb2Nrd2lzZSAob3V0ZXIgcmluZykgZm9yIGN1cnJlbnQgdGlsZVxuICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhjdXJyZW50Q2xpcFswXSwgY3VycmVudENsaXBbMV0pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50Q2xpcFsyXSwgY3VycmVudENsaXBbM10pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50Q2xpcFs0XSwgY3VycmVudENsaXBbNV0pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjdXJyZW50Q2xpcFs2XSwgY3VycmVudENsaXBbN10pO1xuICAgICAgICAgICAgICAvLyBjbG9ja3dpc2UgKGlubmVyIHJpbmcpIGZvciBoaWdoZXIgcmVzb2x1dGlvbiB0aWxlXG4gICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKGNsaXBbNl0sIGNsaXBbN10pO1xuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjbGlwWzRdLCBjbGlwWzVdKTtcbiAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY2xpcFsyXSwgY2xpcFszXSk7XG4gICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGNsaXBbMF0sIGNsaXBbMV0pO1xuICAgICAgICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGF5R3JvdXAucmVwbGF5KGNvbnRleHQsIHRyYW5zZm9ybSwgcm90YXRpb24sIHt9LCBzbmFwVG9QaXhlbCwgcmVwbGF5VHlwZXMsIGRlY2x1dHRlclJlcGxheXMpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgIGNsaXBzLnB1c2goY3VycmVudENsaXApO1xuICAgICAgICAgIHpzLnB1c2goY3VycmVudFopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVjbHV0dGVyUmVwbGF5cykge1xuICAgICAgICByZXBsYXlEZWNsdXR0ZXIoZGVjbHV0dGVyUmVwbGF5cywgY29udGV4dCwgcm90YXRpb24sIHNuYXBUb1BpeGVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICByb3RhdGVBdE9mZnNldChjb250ZXh0LCByb3RhdGlvbixcbiAgICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi8gKG9mZnNldFgpLCAvKiogQHR5cGUge251bWJlcn0gKi8gKG9mZnNldFkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIucG9zdENvbXBvc2UoY29udGV4dCwgZnJhbWVTdGF0ZSwgbGF5ZXJTdGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi8uLi9GZWF0dXJlLmpzXCIpLkZlYXR1cmVMaWtlfSBmZWF0dXJlIEZlYXR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzcXVhcmVkVG9sZXJhbmNlIFNxdWFyZWQgdG9sZXJhbmNlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3N0eWxlL1N0eWxlLmpzXCIpLmRlZmF1bHR8QXJyYXk8aW1wb3J0KFwiLi4vLi4vc3R5bGUvU3R5bGUuanNcIikuZGVmYXVsdD59IHN0eWxlcyBUaGUgc3R5bGUgb3IgYXJyYXkgb2Ygc3R5bGVzLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL3JlbmRlci9jYW52YXMvUmVwbGF5R3JvdXAuanNcIikuZGVmYXVsdH0gcmVwbGF5R3JvdXAgUmVwbGF5IGdyb3VwLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYW4gaW1hZ2UgaXMgbG9hZGluZy5cbiAgICovXG4gIHJlbmRlckZlYXR1cmUoZmVhdHVyZSwgc3F1YXJlZFRvbGVyYW5jZSwgc3R5bGVzLCByZXBsYXlHcm91cCkge1xuICAgIGlmICghc3R5bGVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBsb2FkaW5nID0gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3R5bGVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgbG9hZGluZyA9IHJlbmRlckZlYXR1cmUoXG4gICAgICAgICAgcmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlc1tpXSwgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgICAgICB0aGlzLmhhbmRsZVN0eWxlSW1hZ2VDaGFuZ2VfLCB0aGlzKSB8fCBsb2FkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkaW5nID0gcmVuZGVyRmVhdHVyZShcbiAgICAgICAgcmVwbGF5R3JvdXAsIGZlYXR1cmUsIHN0eWxlcywgc3F1YXJlZFRvbGVyYW5jZSxcbiAgICAgICAgdGhpcy5oYW5kbGVTdHlsZUltYWdlQ2hhbmdlXywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBsb2FkaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vVmVjdG9ySW1hZ2VUaWxlLmpzXCIpLmRlZmF1bHR9IHRpbGUgVGlsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsUmF0aW8gUGl4ZWwgcmF0aW8uXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcHJvai9Qcm9qZWN0aW9uLmpzXCIpLmRlZmF1bHR9IHByb2plY3Rpb24gUHJvamVjdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbmRlclRpbGVJbWFnZV8odGlsZSwgcGl4ZWxSYXRpbywgcHJvamVjdGlvbikge1xuICAgIGNvbnN0IGxheWVyID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9sYXllci9WZWN0b3IuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXIoKSk7XG4gICAgY29uc3QgcmVwbGF5U3RhdGUgPSB0aWxlLmdldFJlcGxheVN0YXRlKGxheWVyKTtcbiAgICBjb25zdCByZXZpc2lvbiA9IGxheWVyLmdldFJldmlzaW9uKCk7XG4gICAgY29uc3QgcmVwbGF5cyA9IElNQUdFX1JFUExBWVNbbGF5ZXIuZ2V0UmVuZGVyTW9kZSgpXTtcbiAgICBpZiAocmVwbGF5cyAmJiByZXBsYXlTdGF0ZS5yZW5kZXJlZFRpbGVSZXZpc2lvbiAhPT0gcmV2aXNpb24pIHtcbiAgICAgIHJlcGxheVN0YXRlLnJlbmRlcmVkVGlsZVJldmlzaW9uID0gcmV2aXNpb247XG4gICAgICBjb25zdCB0aWxlQ29vcmQgPSB0aWxlLndyYXBwZWRUaWxlQ29vcmQ7XG4gICAgICBjb25zdCB6ID0gdGlsZUNvb3JkWzBdO1xuICAgICAgY29uc3Qgc291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi8uLi9zb3VyY2UvVmVjdG9yVGlsZS5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIuZ2V0U291cmNlKCkpO1xuICAgICAgY29uc3QgdGlsZUdyaWQgPSBzb3VyY2UuZ2V0VGlsZUdyaWRGb3JQcm9qZWN0aW9uKHByb2plY3Rpb24pO1xuICAgICAgY29uc3QgcmVzb2x1dGlvbiA9IHRpbGVHcmlkLmdldFJlc29sdXRpb24oeik7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGlsZS5nZXRDb250ZXh0KGxheWVyKTtcbiAgICAgIGNvbnN0IHNpemUgPSBzb3VyY2UuZ2V0VGlsZVBpeGVsU2l6ZSh6LCBwaXhlbFJhdGlvLCBwcm9qZWN0aW9uKTtcbiAgICAgIGNvbnRleHQuY2FudmFzLndpZHRoID0gc2l6ZVswXTtcbiAgICAgIGNvbnRleHQuY2FudmFzLmhlaWdodCA9IHNpemVbMV07XG4gICAgICBjb25zdCB0aWxlRXh0ZW50ID0gdGlsZUdyaWQuZ2V0VGlsZUNvb3JkRXh0ZW50KHRpbGVDb29yZCwgdGhpcy50bXBFeHRlbnQpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdGlsZS50aWxlS2V5cy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVRpbGUgPSB0aWxlLmdldFRpbGUodGlsZS50aWxlS2V5c1tpXSk7XG4gICAgICAgIGlmIChzb3VyY2VUaWxlLmdldFN0YXRlKCkgIT0gVGlsZVN0YXRlLkxPQURFRCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBpeGVsU2NhbGUgPSBwaXhlbFJhdGlvIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gcmVzZXRUcmFuc2Zvcm0odGhpcy50bXBUcmFuc2Zvcm1fKTtcbiAgICAgICAgc2NhbGVUcmFuc2Zvcm0odHJhbnNmb3JtLCBwaXhlbFNjYWxlLCAtcGl4ZWxTY2FsZSk7XG4gICAgICAgIHRyYW5zbGF0ZVRyYW5zZm9ybSh0cmFuc2Zvcm0sIC10aWxlRXh0ZW50WzBdLCAtdGlsZUV4dGVudFszXSk7XG4gICAgICAgIGNvbnN0IHJlcGxheUdyb3VwID0gLyoqIEB0eXBlIHtDYW52YXNSZXBsYXlHcm91cH0gKi8gKHNvdXJjZVRpbGUuZ2V0UmVwbGF5R3JvdXAobGF5ZXIsXG4gICAgICAgICAgdGlsZS50aWxlQ29vcmQudG9TdHJpbmcoKSkpO1xuICAgICAgICByZXBsYXlHcm91cC5yZXBsYXkoY29udGV4dCwgdHJhbnNmb3JtLCAwLCB7fSwgdHJ1ZSwgcmVwbGF5cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgdGhpcyByZW5kZXJlciBoYW5kbGVzIHRoZSBwcm92aWRlZCBsYXllci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdH0gbGF5ZXIgVGhlIGNhbmRpZGF0ZSBsYXllci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSByZW5kZXJlciBjYW4gcmVuZGVyIHRoZSBsYXllci5cbiAqL1xuQ2FudmFzVmVjdG9yVGlsZUxheWVyUmVuZGVyZXJbJ2hhbmRsZXMnXSA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gIHJldHVybiBsYXllci5nZXRUeXBlKCkgPT09IExheWVyVHlwZS5WRUNUT1JfVElMRTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBsYXllciByZW5kZXJlci5cbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vTWFwLmpzXCIpLmRlZmF1bHR9IG1hcFJlbmRlcmVyIFRoZSBtYXAgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIFRoZSBsYXllciB0byBiZSByZW5kZXJlcmQuXG4gKiBAcmV0dXJuIHtDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlcn0gVGhlIGxheWVyIHJlbmRlcmVyLlxuICovXG5DYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlclsnY3JlYXRlJ10gPSBmdW5jdGlvbihtYXBSZW5kZXJlciwgbGF5ZXIpIHtcbiAgcmV0dXJuIG5ldyBDYW52YXNWZWN0b3JUaWxlTGF5ZXJSZW5kZXJlcigvKiogQHR5cGUge2ltcG9ydChcIi4uLy4uL2xheWVyL1ZlY3RvclRpbGUuanNcIikuZGVmYXVsdH0gKi8gKGxheWVyKSk7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1ZlY3RvclRpbGVMYXllclJlbmRlcmVyO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFZQTtBQUNBO0FBRUE7QUFIQTs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOzs7Ozs7O0FBWUE7QUFBQTtBQUFBO0FBS0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBM0RBO0FBQUE7QUFBQTtBQUNBO0FBNERBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF6YUE7Ozs7Ozs7O0FBaWJBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///153\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/ol/transform.js\nvar ol_transform = __webpack_require__(9);\n\n// EXTERNAL MODULE: ./node_modules/ol/array.js\nvar array = __webpack_require__(13);\n\n// EXTERNAL MODULE: ./node_modules/ol/css.js\nvar css = __webpack_require__(73);\n\n// EXTERNAL MODULE: ./node_modules/ol/dom.js\nvar dom = __webpack_require__(16);\n\n// EXTERNAL MODULE: ./node_modules/ol/layer/Layer.js\nvar Layer = __webpack_require__(55);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/Event.js\nvar Event = __webpack_require__(100);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/EventType.js\nvar EventType = __webpack_require__(38);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js\nvar canvas = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/ol/render/canvas/Immediate.js\nvar Immediate = __webpack_require__(98);\n\n// EXTERNAL MODULE: ./node_modules/ol/util.js\nvar util = __webpack_require__(2);\n\n// EXTERNAL MODULE: ./node_modules/ol/Disposable.js\nvar ol_Disposable = __webpack_require__(70);\n\n// EXTERNAL MODULE: ./node_modules/ol/events.js\nvar events = __webpack_require__(1);\n\n// EXTERNAL MODULE: ./node_modules/ol/events/EventType.js\nvar events_EventType = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/ol/extent.js\nvar ol_extent = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./node_modules/ol/functions.js\nvar functions = __webpack_require__(20);\n\n// EXTERNAL MODULE: ./node_modules/ol/style/IconImageCache.js\nvar IconImageCache = __webpack_require__(80);\n\n// CONCATENATED MODULE: ./node_modules/ol/renderer/Map.js\n/**\n * @module ol/renderer/Map\n */\n\n\n\n\n\n\n\n\n\n/**\n * @abstract\n */\n\nvar Map_MapRenderer =\n/*@__PURE__*/\nfunction (Disposable) {\n  function MapRenderer(map) {\n    Disposable.call(this);\n    /**\n     * @private\n     * @type {import("../PluggableMap.js").default}\n     */\n\n    this.map_ = map;\n    /**\n     * @private\n     * @type {!Object<string, import("./Layer.js").default>}\n     */\n\n    this.layerRenderers_ = {};\n    /**\n     * @private\n     * @type {Object<string, import("../events.js").EventsKey>}\n     */\n\n    this.layerRendererListeners_ = {};\n    /**\n     * @private\n     * @type {Array<typeof import("./Layer.js").default>}\n     */\n\n    this.layerRendererConstructors_ = [];\n  }\n\n  if (Disposable) MapRenderer.__proto__ = Disposable;\n  MapRenderer.prototype = Object.create(Disposable && Disposable.prototype);\n  MapRenderer.prototype.constructor = MapRenderer;\n  /**\n   * @abstract\n   * @param {import("../render/EventType.js").default} type Event type.\n   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n   */\n\n  MapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent(type, frameState) {\n    Object(util["b" /* abstract */])();\n  };\n  /**\n   * Register layer renderer constructors.\n   * @param {Array<typeof import("./Layer.js").default>} constructors Layer renderers.\n   */\n\n\n  MapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers(constructors) {\n    this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);\n  };\n  /**\n   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.\n   * @protected\n   */\n\n\n  MapRenderer.prototype.calculateMatrices2D = function calculateMatrices2D(frameState) {\n    var viewState = frameState.viewState;\n    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n    Object(ol_transform["b" /* compose */])(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);\n    Object(ol_transform["d" /* invert */])(Object(ol_transform["g" /* setFromArray */])(pixelToCoordinateTransform, coordinateToPixelTransform));\n  };\n  /**\n   * Removes all layer renderers.\n   */\n\n\n  MapRenderer.prototype.removeLayerRenderers = function removeLayerRenderers() {\n    for (var key in this.layerRenderers_) {\n      this.removeLayerRendererByKey_(key).dispose();\n    }\n  };\n  /**\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(this: S, import("../Feature.js").FeatureLike,\n   *     import("../layer/Layer.js").default): T} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n\n\n  MapRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n    var result;\n    var viewState = frameState.viewState;\n    var viewResolution = viewState.resolution;\n    /**\n     * @param {import("../Feature.js").FeatureLike} feature Feature.\n     * @param {import("../layer/Layer.js").default} layer Layer.\n     * @return {?} Callback result.\n     */\n\n    function forEachFeatureAtCoordinate(feature, layer) {\n      var managed = frameState.layerStates[Object(util["c" /* getUid */])(layer)].managed;\n\n      if (!(Object(util["c" /* getUid */])(feature) in frameState.skippedFeatureUids && !managed)) {\n        return callback.call(thisArg, feature, managed ? layer : null);\n      }\n    }\n\n    var projection = viewState.projection;\n    var translatedCoordinate = coordinate;\n\n    if (projection.canWrapX()) {\n      var projectionExtent = projection.getExtent();\n      var worldWidth = Object(ol_extent["getWidth"])(projectionExtent);\n      var x = coordinate[0];\n\n      if (x < projectionExtent[0] || x > projectionExtent[2]) {\n        var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);\n        translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];\n      }\n    }\n\n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var i;\n\n    for (i = numLayers - 1; i >= 0; --i) {\n      var layerState = layerStates[i];\n      var layer = layerState.layer;\n\n      if (Object(Layer["b" /* visibleAtResolution */])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {\n        var layerRenderer = this.getLayerRenderer(layer);\n        var source =\n        /** @type {import("../layer/Layer.js").default} */\n        layer.getSource();\n\n        if (source) {\n          result = layerRenderer.forEachFeatureAtCoordinate(source.getWrapX() ? translatedCoordinate : coordinate, frameState, hitTolerance, forEachFeatureAtCoordinate);\n        }\n\n        if (result) {\n          return result;\n        }\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @abstract\n   * @param {import("../pixel.js").Pixel} pixel Pixel.\n   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(this: S, import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer\n   *     callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n\n\n  MapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n    return Object(util["b" /* abstract */])();\n  };\n  /**\n   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.\n   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n\n\n  MapRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, layerFilter, thisArg) {\n    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, functions["b" /* TRUE */], this, layerFilter, thisArg);\n    return hasFeature !== undefined;\n  };\n  /**\n   * @param {import("../layer/Base.js").default} layer Layer.\n   * @protected\n   * @return {import("./Layer.js").default} Layer renderer.\n   */\n\n\n  MapRenderer.prototype.getLayerRenderer = function getLayerRenderer(layer) {\n    var layerKey = Object(util["c" /* getUid */])(layer);\n\n    if (layerKey in this.layerRenderers_) {\n      return this.layerRenderers_[layerKey];\n    } else {\n      var renderer;\n\n      for (var i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {\n        var candidate = this.layerRendererConstructors_[i];\n\n        if (candidate[\'handles\'](layer)) {\n          renderer = candidate[\'create\'](this, layer);\n          break;\n        }\n      }\n\n      if (renderer) {\n        this.layerRenderers_[layerKey] = renderer;\n        this.layerRendererListeners_[layerKey] = Object(events["a" /* listen */])(renderer, events_EventType["a" /* default */].CHANGE, this.handleLayerRendererChange_, this);\n      } else {\n        throw new Error(\'Unable to create renderer for layer: \' + layer.getType());\n      }\n\n      return renderer;\n    }\n  };\n  /**\n   * @param {string} layerKey Layer key.\n   * @protected\n   * @return {import("./Layer.js").default} Layer renderer.\n   */\n\n\n  MapRenderer.prototype.getLayerRendererByKey = function getLayerRendererByKey(layerKey) {\n    return this.layerRenderers_[layerKey];\n  };\n  /**\n   * @protected\n   * @return {Object<string, import("./Layer.js").default>} Layer renderers.\n   */\n\n\n  MapRenderer.prototype.getLayerRenderers = function getLayerRenderers() {\n    return this.layerRenderers_;\n  };\n  /**\n   * @return {import("../PluggableMap.js").default} Map.\n   */\n\n\n  MapRenderer.prototype.getMap = function getMap() {\n    return this.map_;\n  };\n  /**\n   * Handle changes in a layer renderer.\n   * @private\n   */\n\n\n  MapRenderer.prototype.handleLayerRendererChange_ = function handleLayerRendererChange_() {\n    this.map_.render();\n  };\n  /**\n   * @param {string} layerKey Layer key.\n   * @return {import("./Layer.js").default} Layer renderer.\n   * @private\n   */\n\n\n  MapRenderer.prototype.removeLayerRendererByKey_ = function removeLayerRendererByKey_(layerKey) {\n    var layerRenderer = this.layerRenderers_[layerKey];\n    delete this.layerRenderers_[layerKey];\n    Object(events["e" /* unlistenByKey */])(this.layerRendererListeners_[layerKey]);\n    delete this.layerRendererListeners_[layerKey];\n    return layerRenderer;\n  };\n  /**\n   * @param {import("../PluggableMap.js").default} map Map.\n   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n   * @private\n   */\n\n\n  MapRenderer.prototype.removeUnusedLayerRenderers_ = function removeUnusedLayerRenderers_(map, frameState) {\n    for (var layerKey in this.layerRenderers_) {\n      if (!frameState || !(layerKey in frameState.layerStates)) {\n        this.removeLayerRendererByKey_(layerKey).dispose();\n      }\n    }\n  };\n  /**\n   * Render.\n   * @abstract\n   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.\n   */\n\n\n  MapRenderer.prototype.renderFrame = function renderFrame(frameState) {\n    Object(util["b" /* abstract */])();\n  };\n  /**\n   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  MapRenderer.prototype.scheduleExpireIconCache = function scheduleExpireIconCache(frameState) {\n    frameState.postRenderFunctions.push(\n    /** @type {import("../PluggableMap.js").PostRenderFunction} */\n    expireIconCache);\n  };\n  /**\n   * @param {!import("../PluggableMap.js").FrameState} frameState Frame state.\n   * @protected\n   */\n\n\n  MapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function scheduleRemoveUnusedLayerRenderers(frameState) {\n    for (var layerKey in this.layerRenderers_) {\n      if (!(layerKey in frameState.layerStates)) {\n        frameState.postRenderFunctions.push(\n        /** @type {import("../PluggableMap.js").PostRenderFunction} */\n        this.removeUnusedLayerRenderers_.bind(this));\n        return;\n      }\n    }\n  };\n\n  return MapRenderer;\n}(ol_Disposable["a" /* default */]);\n/**\n * @param {import("../PluggableMap.js").default} map Map.\n * @param {import("../PluggableMap.js").FrameState} frameState Frame state.\n */\n\n\nfunction expireIconCache(map, frameState) {\n  IconImageCache["a" /* shared */].expire();\n}\n/**\n * @param {import("../layer/Layer.js").State} state1 First layer state.\n * @param {import("../layer/Layer.js").State} state2 Second layer state.\n * @return {number} The zIndex difference.\n */\n\n\nfunction sortByZIndex(state1, state2) {\n  return state1.zIndex - state2.zIndex;\n}\n/* harmony default export */ var Map = (Map_MapRenderer);\n// EXTERNAL MODULE: ./node_modules/ol/source/State.js\nvar State = __webpack_require__(45);\n\n// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/Map.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layerRendererConstructors", function() { return layerRendererConstructors; });\n/**\n * @module ol/renderer/canvas/Map\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @type {Array<typeof import("../Layer.js").default>}\n */\n\nvar layerRendererConstructors = [];\n/**\n * @classdesc\n * Canvas map renderer.\n * @api\n */\n\nvar Map_CanvasMapRenderer =\n/*@__PURE__*/\nfunction (MapRenderer) {\n  function CanvasMapRenderer(map) {\n    MapRenderer.call(this, map);\n    var container = map.getViewport();\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n\n    this.context_ = Object(dom["a" /* createCanvasContext2D */])();\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n\n    this.canvas_ = this.context_.canvas;\n    this.canvas_.style.width = \'100%\';\n    this.canvas_.style.height = \'100%\';\n    this.canvas_.style.display = \'block\';\n    this.canvas_.className = css["b" /* CLASS_UNSELECTABLE */];\n    container.insertBefore(this.canvas_, container.childNodes[0] || null);\n    /**\n     * @private\n     * @type {boolean}\n     */\n\n    this.renderedVisible_ = true;\n    /**\n     * @private\n     * @type {import("../../transform.js").Transform}\n     */\n\n    this.transform_ = Object(ol_transform["c" /* create */])();\n  }\n\n  if (MapRenderer) CanvasMapRenderer.__proto__ = MapRenderer;\n  CanvasMapRenderer.prototype = Object.create(MapRenderer && MapRenderer.prototype);\n  CanvasMapRenderer.prototype.constructor = CanvasMapRenderer;\n  /**\n   * @param {import("../../render/EventType.js").default} type Event type.\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   */\n\n  CanvasMapRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent(type, frameState) {\n    var map = this.getMap();\n    var context = this.context_;\n\n    if (map.hasListener(type)) {\n      var extent = frameState.extent;\n      var pixelRatio = frameState.pixelRatio;\n      var viewState = frameState.viewState;\n      var rotation = viewState.rotation;\n      var transform = this.getTransform(frameState);\n      var vectorContext = new Immediate["a" /* default */](context, pixelRatio, extent, transform, rotation);\n      var composeEvent = new Event["a" /* default */](type, vectorContext, frameState, context, null);\n      map.dispatchEvent(composeEvent);\n    }\n  };\n  /**\n   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.\n   * @protected\n   * @return {!import("../../transform.js").Transform} Transform.\n   */\n\n\n  CanvasMapRenderer.prototype.getTransform = function getTransform(frameState) {\n    var viewState = frameState.viewState;\n    var dx1 = this.canvas_.width / 2;\n    var dy1 = this.canvas_.height / 2;\n    var sx = frameState.pixelRatio / viewState.resolution;\n    var sy = -sx;\n    var angle = -viewState.rotation;\n    var dx2 = -viewState.center[0];\n    var dy2 = -viewState.center[1];\n    return Object(ol_transform["b" /* compose */])(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasMapRenderer.prototype.renderFrame = function renderFrame(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.canvas_.style.display = \'none\';\n        this.renderedVisible_ = false;\n      }\n\n      return;\n    }\n\n    var context = this.context_;\n    var pixelRatio = frameState.pixelRatio;\n    var width = Math.round(frameState.size[0] * pixelRatio);\n    var height = Math.round(frameState.size[1] * pixelRatio);\n\n    if (this.canvas_.width != width || this.canvas_.height != height) {\n      this.canvas_.width = width;\n      this.canvas_.height = height;\n    } else {\n      context.clearRect(0, 0, width, height);\n    }\n\n    var rotation = frameState.viewState.rotation;\n    this.calculateMatrices2D(frameState);\n    this.dispatchRenderEvent(EventType["a" /* default */].PRECOMPOSE, frameState);\n    var layerStatesArray = frameState.layerStatesArray;\n    Object(array["j" /* stableSort */])(layerStatesArray, sortByZIndex);\n\n    if (rotation) {\n      context.save();\n      Object(canvas["s" /* rotateAtOffset */])(context, rotation, width / 2, height / 2);\n    }\n\n    var viewResolution = frameState.viewState.resolution;\n    var i, ii;\n\n    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      var layerState = layerStatesArray[i];\n      var layer = layerState.layer;\n      var layerRenderer =\n      /** @type {import("./Layer.js").default} */\n      this.getLayerRenderer(layer);\n\n      if (!Object(Layer["b" /* visibleAtResolution */])(layerState, viewResolution) || layerState.sourceState != State["a" /* default */].READY) {\n        continue;\n      }\n\n      if (layerRenderer.prepareFrame(frameState, layerState)) {\n        layerRenderer.composeFrame(frameState, layerState, context);\n      }\n    }\n\n    if (rotation) {\n      context.restore();\n    }\n\n    this.dispatchRenderEvent(EventType["a" /* default */].POSTCOMPOSE, frameState);\n\n    if (!this.renderedVisible_) {\n      this.canvas_.style.display = \'\';\n      this.renderedVisible_ = true;\n    }\n\n    this.scheduleRemoveUnusedLayerRenderers(frameState);\n    this.scheduleExpireIconCache(frameState);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasMapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {\n    var result;\n    var viewState = frameState.viewState;\n    var viewResolution = viewState.resolution;\n    var layerStates = frameState.layerStatesArray;\n    var numLayers = layerStates.length;\n    var coordinate = Object(ol_transform["a" /* apply */])(frameState.pixelToCoordinateTransform, pixel.slice());\n    var i;\n\n    for (i = numLayers - 1; i >= 0; --i) {\n      var layerState = layerStates[i];\n      var layer = layerState.layer;\n\n      if (Object(Layer["b" /* visibleAtResolution */])(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {\n        var layerRenderer =\n        /** @type {import("./Layer.js").default} */\n        this.getLayerRenderer(layer);\n        result = layerRenderer.forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);\n\n        if (result) {\n          return result;\n        }\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  CanvasMapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers(constructors) {\n    MapRenderer.prototype.registerLayerRenderers.call(this, constructors);\n\n    for (var i = 0, ii = constructors.length; i < ii; ++i) {\n      var ctor = constructors[i];\n\n      if (!Object(array["d" /* includes */])(layerRendererConstructors, ctor)) {\n        layerRendererConstructors.push(ctor);\n      }\n    }\n  };\n\n  return CanvasMapRenderer;\n}(Map);\n\n/* harmony default export */ var canvas_Map = __webpack_exports__["default"] = (Map_CanvasMapRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy9vbC9yZW5kZXJlci9NYXAuanM/YjU5MSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vc3JjL29sL3JlbmRlcmVyL2NhbnZhcy9NYXAuanM/NGI0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgb2wvcmVuZGVyZXIvTWFwXG4gKi9cbmltcG9ydCB7YWJzdHJhY3QsIGdldFVpZH0gZnJvbSAnLi4vdXRpbC5qcyc7XG5pbXBvcnQgRGlzcG9zYWJsZSBmcm9tICcuLi9EaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7bGlzdGVuLCB1bmxpc3RlbkJ5S2V5fSBmcm9tICcuLi9ldmVudHMuanMnO1xuaW1wb3J0IEV2ZW50VHlwZSBmcm9tICcuLi9ldmVudHMvRXZlbnRUeXBlLmpzJztcbmltcG9ydCB7Z2V0V2lkdGh9IGZyb20gJy4uL2V4dGVudC5qcyc7XG5pbXBvcnQge1RSVUV9IGZyb20gJy4uL2Z1bmN0aW9ucy5qcyc7XG5pbXBvcnQge3Zpc2libGVBdFJlc29sdXRpb259IGZyb20gJy4uL2xheWVyL0xheWVyLmpzJztcbmltcG9ydCB7c2hhcmVkIGFzIGljb25JbWFnZUNhY2hlfSBmcm9tICcuLi9zdHlsZS9JY29uSW1hZ2VDYWNoZS5qcyc7XG5pbXBvcnQge2NvbXBvc2UgYXMgY29tcG9zZVRyYW5zZm9ybSwgaW52ZXJ0IGFzIGludmVydFRyYW5zZm9ybSwgc2V0RnJvbUFycmF5IGFzIHRyYW5zZm9ybVNldEZyb21BcnJheX0gZnJvbSAnLi4vdHJhbnNmb3JtLmpzJztcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTWFwUmVuZGVyZXIgZXh0ZW5kcyBEaXNwb3NhYmxlIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hcCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH1cbiAgICAgKi9cbiAgICB0aGlzLm1hcF8gPSBtYXA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn1cbiAgICAgKi9cbiAgICB0aGlzLmxheWVyUmVuZGVyZXJzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi4vZXZlbnRzLmpzXCIpLkV2ZW50c0tleT59XG4gICAgICovXG4gICAgdGhpcy5sYXllclJlbmRlcmVyTGlzdGVuZXJzXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8dHlwZW9mIGltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdD59XG4gICAgICovXG4gICAgdGhpcy5sYXllclJlbmRlcmVyQ29uc3RydWN0b3JzXyA9IFtdO1xuXG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vcmVuZGVyL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50KHR5cGUsIGZyYW1lU3RhdGUpIHtcbiAgICBhYnN0cmFjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGxheWVyIHJlbmRlcmVyIGNvbnN0cnVjdG9ycy5cbiAgICogQHBhcmFtIHtBcnJheTx0eXBlb2YgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gY29uc3RydWN0b3JzIExheWVyIHJlbmRlcmVycy5cbiAgICovXG4gIHJlZ2lzdGVyTGF5ZXJSZW5kZXJlcnMoY29uc3RydWN0b3JzKSB7XG4gICAgdGhpcy5sYXllclJlbmRlcmVyQ29uc3RydWN0b3JzXy5wdXNoLmFwcGx5KHRoaXMubGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc18sIGNvbnN0cnVjdG9ycyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBjYWxjdWxhdGVNYXRyaWNlczJEKGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCB2aWV3U3RhdGUgPSBmcmFtZVN0YXRlLnZpZXdTdGF0ZTtcbiAgICBjb25zdCBjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSA9IGZyYW1lU3RhdGUuY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm07XG4gICAgY29uc3QgcGl4ZWxUb0Nvb3JkaW5hdGVUcmFuc2Zvcm0gPSBmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtO1xuXG4gICAgY29tcG9zZVRyYW5zZm9ybShjb29yZGluYXRlVG9QaXhlbFRyYW5zZm9ybSxcbiAgICAgIGZyYW1lU3RhdGUuc2l6ZVswXSAvIDIsIGZyYW1lU3RhdGUuc2l6ZVsxXSAvIDIsXG4gICAgICAxIC8gdmlld1N0YXRlLnJlc29sdXRpb24sIC0xIC8gdmlld1N0YXRlLnJlc29sdXRpb24sXG4gICAgICAtdmlld1N0YXRlLnJvdGF0aW9uLFxuICAgICAgLXZpZXdTdGF0ZS5jZW50ZXJbMF0sIC12aWV3U3RhdGUuY2VudGVyWzFdKTtcblxuICAgIGludmVydFRyYW5zZm9ybShcbiAgICAgIHRyYW5zZm9ybVNldEZyb21BcnJheShwaXhlbFRvQ29vcmRpbmF0ZVRyYW5zZm9ybSwgY29vcmRpbmF0ZVRvUGl4ZWxUcmFuc2Zvcm0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsYXllciByZW5kZXJlcnMuXG4gICAqL1xuICByZW1vdmVMYXllclJlbmRlcmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmxheWVyUmVuZGVyZXJzXykge1xuICAgICAgdGhpcy5yZW1vdmVMYXllclJlbmRlcmVyQnlLZXlfKGtleSkuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2Nvb3JkaW5hdGUuanNcIikuQ29vcmRpbmF0ZX0gY29vcmRpbmF0ZSBDb29yZGluYXRlLlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lU3RhdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaXRUb2xlcmFuY2UgSGl0IHRvbGVyYW5jZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogUywgaW1wb3J0KFwiLi4vRmVhdHVyZS5qc1wiKS5GZWF0dXJlTGlrZSxcbiAgICogICAgIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBUfSBjYWxsYmFjayBGZWF0dXJlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge1N9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgY2FsbGJhY2tgLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFUsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBsYXllckZpbHRlciBMYXllciBmaWx0ZXJcbiAgICogICAgIGZ1bmN0aW9uLCBvbmx5IGxheWVycyB3aGljaCBhcmUgdmlzaWJsZSBhbmQgZm9yIHdoaWNoIHRoaXMgZnVuY3Rpb25cbiAgICogICAgIHJldHVybnMgYHRydWVgIHdpbGwgYmUgdGVzdGVkIGZvciBmZWF0dXJlcy4gIEJ5IGRlZmF1bHQsIGFsbCB2aXNpYmxlXG4gICAqICAgICBsYXllcnMgd2lsbCBiZSB0ZXN0ZWQuXG4gICAqIEBwYXJhbSB7VX0gdGhpc0FyZzIgVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgbGF5ZXJGaWx0ZXJgLlxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH0gQ2FsbGJhY2sgcmVzdWx0LlxuICAgKiBAdGVtcGxhdGUgUyxULFVcbiAgICovXG4gIGZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgIGNvb3JkaW5hdGUsXG4gICAgZnJhbWVTdGF0ZSxcbiAgICBoaXRUb2xlcmFuY2UsXG4gICAgY2FsbGJhY2ssXG4gICAgdGhpc0FyZyxcbiAgICBsYXllckZpbHRlcixcbiAgICB0aGlzQXJnMlxuICApIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IHZpZXdSZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL0ZlYXR1cmUuanNcIikuRmVhdHVyZUxpa2V9IGZlYXR1cmUgRmVhdHVyZS5cbiAgICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHR9IGxheWVyIExheWVyLlxuICAgICAqIEByZXR1cm4gez99IENhbGxiYWNrIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShmZWF0dXJlLCBsYXllcikge1xuICAgICAgY29uc3QgbWFuYWdlZCA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNbZ2V0VWlkKGxheWVyKV0ubWFuYWdlZDtcbiAgICAgIGlmICghKGdldFVpZChmZWF0dXJlKSBpbiBmcmFtZVN0YXRlLnNraXBwZWRGZWF0dXJlVWlkcyAmJiAhbWFuYWdlZCkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgZmVhdHVyZSwgbWFuYWdlZCA/IGxheWVyIDogbnVsbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHZpZXdTdGF0ZS5wcm9qZWN0aW9uO1xuXG4gICAgbGV0IHRyYW5zbGF0ZWRDb29yZGluYXRlID0gY29vcmRpbmF0ZTtcbiAgICBpZiAocHJvamVjdGlvbi5jYW5XcmFwWCgpKSB7XG4gICAgICBjb25zdCBwcm9qZWN0aW9uRXh0ZW50ID0gcHJvamVjdGlvbi5nZXRFeHRlbnQoKTtcbiAgICAgIGNvbnN0IHdvcmxkV2lkdGggPSBnZXRXaWR0aChwcm9qZWN0aW9uRXh0ZW50KTtcbiAgICAgIGNvbnN0IHggPSBjb29yZGluYXRlWzBdO1xuICAgICAgaWYgKHggPCBwcm9qZWN0aW9uRXh0ZW50WzBdIHx8IHggPiBwcm9qZWN0aW9uRXh0ZW50WzJdKSB7XG4gICAgICAgIGNvbnN0IHdvcmxkc0F3YXkgPSBNYXRoLmNlaWwoKHByb2plY3Rpb25FeHRlbnRbMF0gLSB4KSAvIHdvcmxkV2lkdGgpO1xuICAgICAgICB0cmFuc2xhdGVkQ29vcmRpbmF0ZSA9IFt4ICsgd29ybGRXaWR0aCAqIHdvcmxkc0F3YXksIGNvb3JkaW5hdGVbMV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxheWVyU3RhdGVzID0gZnJhbWVTdGF0ZS5sYXllclN0YXRlc0FycmF5O1xuICAgIGNvbnN0IG51bUxheWVycyA9IGxheWVyU3RhdGVzLmxlbmd0aDtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBudW1MYXllcnMgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgbGF5ZXJTdGF0ZSA9IGxheWVyU3RhdGVzW2ldO1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgaWYgKHZpc2libGVBdFJlc29sdXRpb24obGF5ZXJTdGF0ZSwgdmlld1Jlc29sdXRpb24pICYmIGxheWVyRmlsdGVyLmNhbGwodGhpc0FyZzIsIGxheWVyKSkge1xuICAgICAgICBjb25zdCBsYXllclJlbmRlcmVyID0gdGhpcy5nZXRMYXllclJlbmRlcmVyKGxheWVyKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0fSAqLyAobGF5ZXIpLmdldFNvdXJjZSgpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbGF5ZXJSZW5kZXJlci5mb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZShcbiAgICAgICAgICAgIHNvdXJjZS5nZXRXcmFwWCgpID8gdHJhbnNsYXRlZENvb3JkaW5hdGUgOiBjb29yZGluYXRlLFxuICAgICAgICAgICAgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBmb3JFYWNoRmVhdHVyZUF0Q29vcmRpbmF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9waXhlbC5qc1wiKS5QaXhlbH0gcGl4ZWwgUGl4ZWwuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWVTdGF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpdFRvbGVyYW5jZSBIaXQgdG9sZXJhbmNlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOiBTLCBpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5kZWZhdWx0LCAoVWludDhDbGFtcGVkQXJyYXl8VWludDhBcnJheSkpOiBUfSBjYWxsYmFjayBMYXllclxuICAgKiAgICAgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7U30gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBjYWxsYmFja2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczogVSwgaW1wb3J0KFwiLi4vbGF5ZXIvTGF5ZXIuanNcIikuZGVmYXVsdCk6IGJvb2xlYW59IGxheWVyRmlsdGVyIExheWVyIGZpbHRlclxuICAgKiAgICAgZnVuY3Rpb24sIG9ubHkgbGF5ZXJzIHdoaWNoIGFyZSB2aXNpYmxlIGFuZCBmb3Igd2hpY2ggdGhpcyBmdW5jdGlvblxuICAgKiAgICAgcmV0dXJucyBgdHJ1ZWAgd2lsbCBiZSB0ZXN0ZWQgZm9yIGZlYXR1cmVzLiAgQnkgZGVmYXVsdCwgYWxsIHZpc2libGVcbiAgICogICAgIGxheWVycyB3aWxsIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtVfSB0aGlzQXJnMiBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsYXllckZpbHRlcmAuXG4gICAqIEByZXR1cm4ge1R8dW5kZWZpbmVkfSBDYWxsYmFjayByZXN1bHQuXG4gICAqIEB0ZW1wbGF0ZSBTLFQsVVxuICAgKi9cbiAgZm9yRWFjaExheWVyQXRQaXhlbChwaXhlbCwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBjYWxsYmFjaywgdGhpc0FyZywgbGF5ZXJGaWx0ZXIsIHRoaXNBcmcyKSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb29yZGluYXRlLmpzXCIpLkNvb3JkaW5hdGV9IGNvb3JkaW5hdGUgQ29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZVN0YXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGl0VG9sZXJhbmNlIEhpdCB0b2xlcmFuY2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6IFUsIGltcG9ydChcIi4uL2xheWVyL0xheWVyLmpzXCIpLmRlZmF1bHQpOiBib29sZWFufSBsYXllckZpbHRlciBMYXllciBmaWx0ZXJcbiAgICogICAgIGZ1bmN0aW9uLCBvbmx5IGxheWVycyB3aGljaCBhcmUgdmlzaWJsZSBhbmQgZm9yIHdoaWNoIHRoaXMgZnVuY3Rpb25cbiAgICogICAgIHJldHVybnMgYHRydWVgIHdpbGwgYmUgdGVzdGVkIGZvciBmZWF0dXJlcy4gIEJ5IGRlZmF1bHQsIGFsbCB2aXNpYmxlXG4gICAqICAgICBsYXllcnMgd2lsbCBiZSB0ZXN0ZWQuXG4gICAqIEBwYXJhbSB7VX0gdGhpc0FyZyBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBsYXllckZpbHRlcmAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElzIHRoZXJlIGEgZmVhdHVyZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZT9cbiAgICogQHRlbXBsYXRlIFVcbiAgICovXG4gIGhhc0ZlYXR1cmVBdENvb3JkaW5hdGUoY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBsYXllckZpbHRlciwgdGhpc0FyZykge1xuICAgIGNvbnN0IGhhc0ZlYXR1cmUgPSB0aGlzLmZvckVhY2hGZWF0dXJlQXRDb29yZGluYXRlKFxuICAgICAgY29vcmRpbmF0ZSwgZnJhbWVTdGF0ZSwgaGl0VG9sZXJhbmNlLCBUUlVFLCB0aGlzLCBsYXllckZpbHRlciwgdGhpc0FyZyk7XG5cbiAgICByZXR1cm4gaGFzRmVhdHVyZSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vbGF5ZXIvQmFzZS5qc1wiKS5kZWZhdWx0fSBsYXllciBMYXllci5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtpbXBvcnQoXCIuL0xheWVyLmpzXCIpLmRlZmF1bHR9IExheWVyIHJlbmRlcmVyLlxuICAgKi9cbiAgZ2V0TGF5ZXJSZW5kZXJlcihsYXllcikge1xuICAgIGNvbnN0IGxheWVyS2V5ID0gZ2V0VWlkKGxheWVyKTtcbiAgICBpZiAobGF5ZXJLZXkgaW4gdGhpcy5sYXllclJlbmRlcmVyc18pIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVyUmVuZGVyZXJzX1tsYXllcktleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByZW5kZXJlcjtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMubGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9yc18ubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB0aGlzLmxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnNfW2ldO1xuICAgICAgICBpZiAoY2FuZGlkYXRlWydoYW5kbGVzJ10obGF5ZXIpKSB7XG4gICAgICAgICAgcmVuZGVyZXIgPSBjYW5kaWRhdGVbJ2NyZWF0ZSddKHRoaXMsIGxheWVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMubGF5ZXJSZW5kZXJlcnNfW2xheWVyS2V5XSA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmxheWVyUmVuZGVyZXJMaXN0ZW5lcnNfW2xheWVyS2V5XSA9IGxpc3RlbihyZW5kZXJlcixcbiAgICAgICAgICBFdmVudFR5cGUuQ0hBTkdFLCB0aGlzLmhhbmRsZUxheWVyUmVuZGVyZXJDaGFuZ2VfLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNyZWF0ZSByZW5kZXJlciBmb3IgbGF5ZXI6ICcgKyBsYXllci5nZXRUeXBlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJLZXkgTGF5ZXIga2V5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXIgcmVuZGVyZXIuXG4gICAqL1xuICBnZXRMYXllclJlbmRlcmVyQnlLZXkobGF5ZXJLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllclJlbmRlcmVyc19bbGF5ZXJLZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgaW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0Pn0gTGF5ZXIgcmVuZGVyZXJzLlxuICAgKi9cbiAgZ2V0TGF5ZXJSZW5kZXJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJSZW5kZXJlcnNfO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBNYXAuXG4gICAqL1xuICBnZXRNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2hhbmdlcyBpbiBhIGxheWVyIHJlbmRlcmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTGF5ZXJSZW5kZXJlckNoYW5nZV8oKSB7XG4gICAgdGhpcy5tYXBfLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllcktleSBMYXllciBrZXkuXG4gICAqIEByZXR1cm4ge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gTGF5ZXIgcmVuZGVyZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW1vdmVMYXllclJlbmRlcmVyQnlLZXlfKGxheWVyS2V5KSB7XG4gICAgY29uc3QgbGF5ZXJSZW5kZXJlciA9IHRoaXMubGF5ZXJSZW5kZXJlcnNfW2xheWVyS2V5XTtcbiAgICBkZWxldGUgdGhpcy5sYXllclJlbmRlcmVyc19bbGF5ZXJLZXldO1xuXG4gICAgdW5saXN0ZW5CeUtleSh0aGlzLmxheWVyUmVuZGVyZXJMaXN0ZW5lcnNfW2xheWVyS2V5XSk7XG4gICAgZGVsZXRlIHRoaXMubGF5ZXJSZW5kZXJlckxpc3RlbmVyc19bbGF5ZXJLZXldO1xuXG4gICAgcmV0dXJuIGxheWVyUmVuZGVyZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuZGVmYXVsdH0gbWFwIE1hcC5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuRnJhbWVTdGF0ZX0gZnJhbWVTdGF0ZSBGcmFtZSBzdGF0ZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlbW92ZVVudXNlZExheWVyUmVuZGVyZXJzXyhtYXAsIGZyYW1lU3RhdGUpIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyS2V5IGluIHRoaXMubGF5ZXJSZW5kZXJlcnNfKSB7XG4gICAgICBpZiAoIWZyYW1lU3RhdGUgfHwgIShsYXllcktleSBpbiBmcmFtZVN0YXRlLmxheWVyU3RhdGVzKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxheWVyUmVuZGVyZXJCeUtleV8obGF5ZXJLZXkpLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHs/aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICByZW5kZXJGcmFtZShmcmFtZVN0YXRlKSB7XG4gICAgYWJzdHJhY3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzY2hlZHVsZUV4cGlyZUljb25DYWNoZShmcmFtZVN0YXRlKSB7XG4gICAgZnJhbWVTdGF0ZS5wb3N0UmVuZGVyRnVuY3Rpb25zLnB1c2goLyoqIEB0eXBlIHtpbXBvcnQoXCIuLi9QbHVnZ2FibGVNYXAuanNcIikuUG9zdFJlbmRlckZ1bmN0aW9ufSAqLyAoZXhwaXJlSWNvbkNhY2hlKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshaW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHNjaGVkdWxlUmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnMoZnJhbWVTdGF0ZSkge1xuICAgIGZvciAoY29uc3QgbGF5ZXJLZXkgaW4gdGhpcy5sYXllclJlbmRlcmVyc18pIHtcbiAgICAgIGlmICghKGxheWVyS2V5IGluIGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXMpKSB7XG4gICAgICAgIGZyYW1lU3RhdGUucG9zdFJlbmRlckZ1bmN0aW9ucy5wdXNoKFxuICAgICAgICAgIC8qKiBAdHlwZSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLlBvc3RSZW5kZXJGdW5jdGlvbn0gKi8gKHRoaXMucmVtb3ZlVW51c2VkTGF5ZXJSZW5kZXJlcnNfLmJpbmQodGhpcykpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLmRlZmF1bHR9IG1hcCBNYXAuXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICovXG5mdW5jdGlvbiBleHBpcmVJY29uQ2FjaGUobWFwLCBmcmFtZVN0YXRlKSB7XG4gIGljb25JbWFnZUNhY2hlLmV4cGlyZSgpO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gc3RhdGUxIEZpcnN0IGxheWVyIHN0YXRlLlxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9sYXllci9MYXllci5qc1wiKS5TdGF0ZX0gc3RhdGUyIFNlY29uZCBsYXllciBzdGF0ZS5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHpJbmRleCBkaWZmZXJlbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydEJ5WkluZGV4KHN0YXRlMSwgc3RhdGUyKSB7XG4gIHJldHVybiBzdGF0ZTEuekluZGV4IC0gc3RhdGUyLnpJbmRleDtcbn1cbmV4cG9ydCBkZWZhdWx0IE1hcFJlbmRlcmVyO1xuIiwiLyoqXG4gKiBAbW9kdWxlIG9sL3JlbmRlcmVyL2NhbnZhcy9NYXBcbiAqL1xuaW1wb3J0IHtjcmVhdGUgYXMgY3JlYXRlVHJhbnNmb3JtLCBhcHBseSBhcyBhcHBseVRyYW5zZm9ybSwgY29tcG9zZSBhcyBjb21wb3NlVHJhbnNmb3JtfSBmcm9tICcuLi8uLi90cmFuc2Zvcm0uanMnO1xuaW1wb3J0IHtpbmNsdWRlcywgc3RhYmxlU29ydH0gZnJvbSAnLi4vLi4vYXJyYXkuanMnO1xuaW1wb3J0IHtDTEFTU19VTlNFTEVDVEFCTEV9IGZyb20gJy4uLy4uL2Nzcy5qcyc7XG5pbXBvcnQge2NyZWF0ZUNhbnZhc0NvbnRleHQyRH0gZnJvbSAnLi4vLi4vZG9tLmpzJztcbmltcG9ydCB7dmlzaWJsZUF0UmVzb2x1dGlvbn0gZnJvbSAnLi4vLi4vbGF5ZXIvTGF5ZXIuanMnO1xuaW1wb3J0IFJlbmRlckV2ZW50IGZyb20gJy4uLy4uL3JlbmRlci9FdmVudC5qcyc7XG5pbXBvcnQgUmVuZGVyRXZlbnRUeXBlIGZyb20gJy4uLy4uL3JlbmRlci9FdmVudFR5cGUuanMnO1xuaW1wb3J0IHtyb3RhdGVBdE9mZnNldH0gZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy5qcyc7XG5pbXBvcnQgQ2FudmFzSW1tZWRpYXRlUmVuZGVyZXIgZnJvbSAnLi4vLi4vcmVuZGVyL2NhbnZhcy9JbW1lZGlhdGUuanMnO1xuaW1wb3J0IE1hcFJlbmRlcmVyLCB7c29ydEJ5WkluZGV4fSBmcm9tICcuLi9NYXAuanMnO1xuaW1wb3J0IFNvdXJjZVN0YXRlIGZyb20gJy4uLy4uL3NvdXJjZS9TdGF0ZS5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8dHlwZW9mIGltcG9ydChcIi4uL0xheWVyLmpzXCIpLmRlZmF1bHQ+fVxuICovXG5leHBvcnQgY29uc3QgbGF5ZXJSZW5kZXJlckNvbnN0cnVjdG9ycyA9IFtdO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2NcbiAqIENhbnZhcyBtYXAgcmVuZGVyZXIuXG4gKiBAYXBpXG4gKi9cbmNsYXNzIENhbnZhc01hcFJlbmRlcmVyIGV4dGVuZHMgTWFwUmVuZGVyZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5kZWZhdWx0fSBtYXAgTWFwLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFwKSB7XG4gICAgc3VwZXIobWFwKTtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG1hcC5nZXRWaWV3cG9ydCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICAgIHRoaXMuY29udGV4dF8gPSBjcmVhdGVDYW52YXNDb250ZXh0MkQoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2FudmFzXyA9IHRoaXMuY29udGV4dF8uY2FudmFzO1xuXG4gICAgdGhpcy5jYW52YXNfLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuY2FudmFzXy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgdGhpcy5jYW52YXNfLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuY2FudmFzXy5jbGFzc05hbWUgPSBDTEFTU19VTlNFTEVDVEFCTEU7XG4gICAgY29udGFpbmVyLmluc2VydEJlZm9yZSh0aGlzLmNhbnZhc18sIGNvbnRhaW5lci5jaGlsZE5vZGVzWzBdIHx8IG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7aW1wb3J0KFwiLi4vLi4vdHJhbnNmb3JtLmpzXCIpLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zZm9ybV8gPSBjcmVhdGVUcmFuc2Zvcm0oKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vcmVuZGVyL0V2ZW50VHlwZS5qc1wiKS5kZWZhdWx0fSB0eXBlIEV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vLi4vUGx1Z2dhYmxlTWFwLmpzXCIpLkZyYW1lU3RhdGV9IGZyYW1lU3RhdGUgRnJhbWUgc3RhdGUuXG4gICAqL1xuICBkaXNwYXRjaFJlbmRlckV2ZW50KHR5cGUsIGZyYW1lU3RhdGUpIHtcbiAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIGlmIChtYXAuaGFzTGlzdGVuZXIodHlwZSkpIHtcbiAgICAgIGNvbnN0IGV4dGVudCA9IGZyYW1lU3RhdGUuZXh0ZW50O1xuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZyYW1lU3RhdGUucGl4ZWxSYXRpbztcbiAgICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgICAgY29uc3Qgcm90YXRpb24gPSB2aWV3U3RhdGUucm90YXRpb247XG5cbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuZ2V0VHJhbnNmb3JtKGZyYW1lU3RhdGUpO1xuXG4gICAgICBjb25zdCB2ZWN0b3JDb250ZXh0ID0gbmV3IENhbnZhc0ltbWVkaWF0ZVJlbmRlcmVyKGNvbnRleHQsIHBpeGVsUmF0aW8sXG4gICAgICAgIGV4dGVudCwgdHJhbnNmb3JtLCByb3RhdGlvbik7XG4gICAgICBjb25zdCBjb21wb3NlRXZlbnQgPSBuZXcgUmVuZGVyRXZlbnQodHlwZSwgdmVjdG9yQ29udGV4dCxcbiAgICAgICAgZnJhbWVTdGF0ZSwgY29udGV4dCwgbnVsbCk7XG4gICAgICBtYXAuZGlzcGF0Y2hFdmVudChjb21wb3NlRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4uLy4uL1BsdWdnYWJsZU1hcC5qc1wiKS5GcmFtZVN0YXRlfSBmcmFtZVN0YXRlIEZyYW1lIHN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4geyFpbXBvcnQoXCIuLi8uLi90cmFuc2Zvcm0uanNcIikuVHJhbnNmb3JtfSBUcmFuc2Zvcm0uXG4gICAqL1xuICBnZXRUcmFuc2Zvcm0oZnJhbWVTdGF0ZSkge1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IGR4MSA9IHRoaXMuY2FudmFzXy53aWR0aCAvIDI7XG4gICAgY29uc3QgZHkxID0gdGhpcy5jYW52YXNfLmhlaWdodCAvIDI7XG4gICAgY29uc3Qgc3ggPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW8gLyB2aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBjb25zdCBzeSA9IC1zeDtcbiAgICBjb25zdCBhbmdsZSA9IC12aWV3U3RhdGUucm90YXRpb247XG4gICAgY29uc3QgZHgyID0gLXZpZXdTdGF0ZS5jZW50ZXJbMF07XG4gICAgY29uc3QgZHkyID0gLXZpZXdTdGF0ZS5jZW50ZXJbMV07XG4gICAgcmV0dXJuIGNvbXBvc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1fLCBkeDEsIGR5MSwgc3gsIHN5LCBhbmdsZSwgZHgyLCBkeTIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICByZW5kZXJGcmFtZShmcmFtZVN0YXRlKSB7XG5cbiAgICBpZiAoIWZyYW1lU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgICAgdGhpcy5jYW52YXNfLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMucmVuZGVyZWRWaXNpYmxlXyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbnRleHRfO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBmcmFtZVN0YXRlLnBpeGVsUmF0aW87XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKGZyYW1lU3RhdGUuc2l6ZVswXSAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQoZnJhbWVTdGF0ZS5zaXplWzFdICogcGl4ZWxSYXRpbyk7XG4gICAgaWYgKHRoaXMuY2FudmFzXy53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmNhbnZhc18uaGVpZ2h0ICE9IGhlaWdodCkge1xuICAgICAgdGhpcy5jYW52YXNfLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc18uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBjb25zdCByb3RhdGlvbiA9IGZyYW1lU3RhdGUudmlld1N0YXRlLnJvdGF0aW9uO1xuXG4gICAgdGhpcy5jYWxjdWxhdGVNYXRyaWNlczJEKGZyYW1lU3RhdGUpO1xuXG4gICAgdGhpcy5kaXNwYXRjaFJlbmRlckV2ZW50KFJlbmRlckV2ZW50VHlwZS5QUkVDT01QT1NFLCBmcmFtZVN0YXRlKTtcblxuICAgIGNvbnN0IGxheWVyU3RhdGVzQXJyYXkgPSBmcmFtZVN0YXRlLmxheWVyU3RhdGVzQXJyYXk7XG4gICAgc3RhYmxlU29ydChsYXllclN0YXRlc0FycmF5LCBzb3J0QnlaSW5kZXgpO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIHJvdGF0ZUF0T2Zmc2V0KGNvbnRleHQsIHJvdGF0aW9uLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIH1cblxuICAgIGNvbnN0IHZpZXdSZXNvbHV0aW9uID0gZnJhbWVTdGF0ZS52aWV3U3RhdGUucmVzb2x1dGlvbjtcbiAgICBsZXQgaSwgaWk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsYXllclN0YXRlc0FycmF5Lmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxheWVyU3RhdGUgPSBsYXllclN0YXRlc0FycmF5W2ldO1xuICAgICAgY29uc3QgbGF5ZXIgPSBsYXllclN0YXRlLmxheWVyO1xuICAgICAgY29uc3QgbGF5ZXJSZW5kZXJlciA9IC8qKiBAdHlwZSB7aW1wb3J0KFwiLi9MYXllci5qc1wiKS5kZWZhdWx0fSAqLyAodGhpcy5nZXRMYXllclJlbmRlcmVyKGxheWVyKSk7XG4gICAgICBpZiAoIXZpc2libGVBdFJlc29sdXRpb24obGF5ZXJTdGF0ZSwgdmlld1Jlc29sdXRpb24pIHx8XG4gICAgICAgICAgbGF5ZXJTdGF0ZS5zb3VyY2VTdGF0ZSAhPSBTb3VyY2VTdGF0ZS5SRUFEWSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXllclJlbmRlcmVyLnByZXBhcmVGcmFtZShmcmFtZVN0YXRlLCBsYXllclN0YXRlKSkge1xuICAgICAgICBsYXllclJlbmRlcmVyLmNvbXBvc2VGcmFtZShmcmFtZVN0YXRlLCBsYXllclN0YXRlLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hSZW5kZXJFdmVudChSZW5kZXJFdmVudFR5cGUuUE9TVENPTVBPU0UsIGZyYW1lU3RhdGUpO1xuXG4gICAgaWYgKCF0aGlzLnJlbmRlcmVkVmlzaWJsZV8pIHtcbiAgICAgIHRoaXMuY2FudmFzXy5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICB0aGlzLnJlbmRlcmVkVmlzaWJsZV8gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuc2NoZWR1bGVSZW1vdmVVbnVzZWRMYXllclJlbmRlcmVycyhmcmFtZVN0YXRlKTtcbiAgICB0aGlzLnNjaGVkdWxlRXhwaXJlSWNvbkNhY2hlKGZyYW1lU3RhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBmb3JFYWNoTGF5ZXJBdFBpeGVsKHBpeGVsLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnLCBsYXllckZpbHRlciwgdGhpc0FyZzIpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGNvbnN0IHZpZXdTdGF0ZSA9IGZyYW1lU3RhdGUudmlld1N0YXRlO1xuICAgIGNvbnN0IHZpZXdSZXNvbHV0aW9uID0gdmlld1N0YXRlLnJlc29sdXRpb247XG5cbiAgICBjb25zdCBsYXllclN0YXRlcyA9IGZyYW1lU3RhdGUubGF5ZXJTdGF0ZXNBcnJheTtcbiAgICBjb25zdCBudW1MYXllcnMgPSBsYXllclN0YXRlcy5sZW5ndGg7XG5cbiAgICBjb25zdCBjb29yZGluYXRlID0gYXBwbHlUcmFuc2Zvcm0oXG4gICAgICBmcmFtZVN0YXRlLnBpeGVsVG9Db29yZGluYXRlVHJhbnNmb3JtLCBwaXhlbC5zbGljZSgpKTtcblxuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IG51bUxheWVycyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBsYXllclN0YXRlID0gbGF5ZXJTdGF0ZXNbaV07XG4gICAgICBjb25zdCBsYXllciA9IGxheWVyU3RhdGUubGF5ZXI7XG4gICAgICBpZiAodmlzaWJsZUF0UmVzb2x1dGlvbihsYXllclN0YXRlLCB2aWV3UmVzb2x1dGlvbikgJiYgbGF5ZXJGaWx0ZXIuY2FsbCh0aGlzQXJnMiwgbGF5ZXIpKSB7XG4gICAgICAgIGNvbnN0IGxheWVyUmVuZGVyZXIgPSAvKiogQHR5cGUge2ltcG9ydChcIi4vTGF5ZXIuanNcIikuZGVmYXVsdH0gKi8gKHRoaXMuZ2V0TGF5ZXJSZW5kZXJlcihsYXllcikpO1xuICAgICAgICByZXN1bHQgPSBsYXllclJlbmRlcmVyLmZvckVhY2hMYXllckF0Q29vcmRpbmF0ZShcbiAgICAgICAgICBjb29yZGluYXRlLCBmcmFtZVN0YXRlLCBoaXRUb2xlcmFuY2UsIGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgcmVnaXN0ZXJMYXllclJlbmRlcmVycyhjb25zdHJ1Y3RvcnMpIHtcbiAgICBzdXBlci5yZWdpc3RlckxheWVyUmVuZGVyZXJzKGNvbnN0cnVjdG9ycyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gY29uc3RydWN0b3JzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGN0b3IgPSBjb25zdHJ1Y3RvcnNbaV07XG4gICAgICBpZiAoIWluY2x1ZGVzKGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMsIGN0b3IpKSB7XG4gICAgICAgIGxheWVyUmVuZGVyZXJDb25zdHJ1Y3RvcnMucHVzaChjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNNYXBSZW5kZXJlcjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUFBO0FBQUE7QUFLQTtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTs7Ozs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUVBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFTQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBR0E7QUFDQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBelRBOzs7Ozs7O0FBZ1VBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM3VkE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTs7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7Ozs7OztBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7OztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoTUE7QUFDQTtBQWtNQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///154\n')}]);